[
  {
    "function_name": "virNetSocketSetQuietEOF",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "2287-2291",
    "snippet": "void\nvirNetSocketSetQuietEOF(virNetSocketPtr sock)\n{\n    sock->quietEOF = true;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nvirNetSocketSetQuietEOF(virNetSocketPtr sock)\n{\n    sock->quietEOF = true;\n}"
  },
  {
    "function_name": "virNetSocketClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "2254-2277",
    "snippet": "void virNetSocketClose(virNetSocketPtr sock)\n{\n    if (!sock)\n        return;\n\n    virObjectLock(sock);\n\n    if (sock->fd != -1) {\n        closesocket(sock->fd);\n        sock->fd = -1;\n    }\n\n#ifndef WIN32\n    /* If a server socket, then unlink UNIX path */\n    if (sock->unlinkUNIX &&\n        sock->localAddr.data.sa.sa_family == AF_UNIX &&\n        sock->localAddr.data.un.sun_path[0] != '\\0') {\n        if (unlink(sock->localAddr.data.un.sun_path) == 0)\n            sock->localAddr.data.un.sun_path[0] = '\\0';\n    }\n#endif\n\n    virObjectUnlock(sock);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "sock->localAddr.data.un.sun_path"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "sock->fd"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "vir_closesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "197-213",
          "snippet": "int\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketClose(virNetSocketPtr sock)\n{\n    if (!sock)\n        return;\n\n    virObjectLock(sock);\n\n    if (sock->fd != -1) {\n        closesocket(sock->fd);\n        sock->fd = -1;\n    }\n\n#ifndef WIN32\n    /* If a server socket, then unlink UNIX path */\n    if (sock->unlinkUNIX &&\n        sock->localAddr.data.sa.sa_family == AF_UNIX &&\n        sock->localAddr.data.un.sun_path[0] != '\\0') {\n        if (unlink(sock->localAddr.data.un.sun_path) == 0)\n            sock->localAddr.data.un.sun_path[0] = '\\0';\n    }\n#endif\n\n    virObjectUnlock(sock);\n}"
  },
  {
    "function_name": "virNetSocketRemoveIOCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "2237-2252",
    "snippet": "void virNetSocketRemoveIOCallback(virNetSocketPtr sock)\n{\n    virObjectLock(sock);\n\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventRemoveHandle(sock->watch);\n    /* Don't unref @sock, it's done via eventloop callback. */\n    sock->watch = -1;\n\n    virObjectUnlock(sock);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventRemoveHandle",
          "args": [
            "sock->watch"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRemoveHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "116-123",
          "snippet": "int\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventRemoveHandleFunc removeHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventRemoveHandleFunc removeHandleImpl;\n\nint\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Watch not registered on socket %p\"",
            "sock"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketRemoveIOCallback(virNetSocketPtr sock)\n{\n    virObjectLock(sock);\n\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventRemoveHandle(sock->watch);\n    /* Don't unref @sock, it's done via eventloop callback. */\n    sock->watch = -1;\n\n    virObjectUnlock(sock);\n}"
  },
  {
    "function_name": "virNetSocketUpdateIOCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "2222-2235",
    "snippet": "void virNetSocketUpdateIOCallback(virNetSocketPtr sock,\n                                  int events)\n{\n    virObjectLock(sock);\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventUpdateHandle(sock->watch, events);\n\n    virObjectUnlock(sock);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventUpdateHandle",
          "args": [
            "sock->watch",
            "events"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "virEventUpdateHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "98-103",
          "snippet": "void\nvirEventUpdateHandle(int watch, int events)\n{\n    if (updateHandleImpl)\n        updateHandleImpl(watch, events);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventUpdateHandleFunc updateHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventUpdateHandleFunc updateHandleImpl;\n\nvoid\nvirEventUpdateHandle(int watch, int events)\n{\n    if (updateHandleImpl)\n        updateHandleImpl(watch, events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Watch not registered on socket %p\"",
            "sock"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketUpdateIOCallback(virNetSocketPtr sock,\n                                  int events)\n{\n    virObjectLock(sock);\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventUpdateHandle(sock->watch, events);\n\n    virObjectUnlock(sock);\n}"
  },
  {
    "function_name": "virNetSocketAddIOCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "2186-2220",
    "snippet": "int virNetSocketAddIOCallback(virNetSocketPtr sock,\n                              int events,\n                              virNetSocketIOFunc func,\n                              void *opaque,\n                              virFreeCallback ff)\n{\n    int ret = -1;\n\n    virObjectRef(sock);\n    virObjectLock(sock);\n    if (sock->watch >= 0) {\n        VIR_DEBUG(\"Watch already registered on socket %p\", sock);\n        goto cleanup;\n    }\n\n    if ((sock->watch = virEventAddHandle(sock->fd,\n                                         events,\n                                         virNetSocketEventHandle,\n                                         sock,\n                                         virNetSocketEventFree)) < 0) {\n        VIR_DEBUG(\"Failed to register watch on socket %p\", sock);\n        goto cleanup;\n    }\n    sock->func = func;\n    sock->opaque = opaque;\n    sock->ff = ff;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sock);\n    if (ret != 0)\n        virObjectUnref(sock);\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sock"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to register watch on socket %p\"",
            "sock"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventAddHandle",
          "args": [
            "sock->fd",
            "events",
            "virNetSocketEventHandle",
            "sock",
            "virNetSocketEventFree"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "virEventAddHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "73-84",
          "snippet": "int\nvirEventAddHandle(int fd,\n                  int events,\n                  virEventHandleCallback cb,\n                  void *opaque,\n                  virFreeCallback ff)\n{\n    if (!addHandleImpl)\n        return -1;\n\n    return addHandleImpl(fd, events, cb, opaque, ff);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventAddHandleFunc addHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventAddHandleFunc addHandleImpl;\n\nint\nvirEventAddHandle(int fd,\n                  int events,\n                  virEventHandleCallback cb,\n                  void *opaque,\n                  virFreeCallback ff)\n{\n    if (!addHandleImpl)\n        return -1;\n\n    return addHandleImpl(fd, events, cb, opaque, ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Watch already registered on socket %p\"",
            "sock"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "sock"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketAddIOCallback(virNetSocketPtr sock,\n                              int events,\n                              virNetSocketIOFunc func,\n                              void *opaque,\n                              virFreeCallback ff)\n{\n    int ret = -1;\n\n    virObjectRef(sock);\n    virObjectLock(sock);\n    if (sock->watch >= 0) {\n        VIR_DEBUG(\"Watch already registered on socket %p\", sock);\n        goto cleanup;\n    }\n\n    if ((sock->watch = virEventAddHandle(sock->fd,\n                                         events,\n                                         virNetSocketEventHandle,\n                                         sock,\n                                         virNetSocketEventFree)) < 0) {\n        VIR_DEBUG(\"Failed to register watch on socket %p\", sock);\n        goto cleanup;\n    }\n    sock->func = func;\n    sock->opaque = opaque;\n    sock->ff = ff;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sock);\n    if (ret != 0)\n        virObjectUnref(sock);\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketEventFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "2166-2184",
    "snippet": "static void virNetSocketEventFree(void *opaque)\n{\n    virNetSocketPtr sock = opaque;\n    virFreeCallback ff;\n    void *eopaque;\n\n    virObjectLock(sock);\n    ff = sock->ff;\n    eopaque = sock->opaque;\n    sock->func = NULL;\n    sock->ff = NULL;\n    sock->opaque = NULL;\n    virObjectUnlock(sock);\n\n    if (ff)\n        ff(eopaque);\n\n    virObjectUnref(sock);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sock"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff",
          "args": [
            "eopaque"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "virRotatingFileWriterGetOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virrotatingfile.c",
          "lines": "358-362",
          "snippet": "off_t\nvirRotatingFileWriterGetOffset(virRotatingFileWriterPtr file)\n{\n    return file->entry->pos;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virrotatingfile.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virrotatingfile.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\noff_t\nvirRotatingFileWriterGetOffset(virRotatingFileWriterPtr file)\n{\n    return file->entry->pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void virNetSocketEventFree(void *opaque)\n{\n    virNetSocketPtr sock = opaque;\n    virFreeCallback ff;\n    void *eopaque;\n\n    virObjectLock(sock);\n    ff = sock->ff;\n    eopaque = sock->opaque;\n    sock->func = NULL;\n    sock->ff = NULL;\n    sock->opaque = NULL;\n    virObjectUnlock(sock);\n\n    if (ff)\n        ff(eopaque);\n\n    virObjectUnref(sock);\n}"
  },
  {
    "function_name": "virNetSocketEventHandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "2147-2163",
    "snippet": "static void virNetSocketEventHandle(int watch G_GNUC_UNUSED,\n                                    int fd G_GNUC_UNUSED,\n                                    int events,\n                                    void *opaque)\n{\n    virNetSocketPtr sock = opaque;\n    virNetSocketIOFunc func;\n    void *eopaque;\n\n    virObjectLock(sock);\n    func = sock->func;\n    eopaque = sock->opaque;\n    virObjectUnlock(sock);\n\n    if (func)\n        func(sock, events, eopaque);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "func",
          "args": [
            "sock",
            "events",
            "eopaque"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void virNetSocketEventHandle(int watch G_GNUC_UNUSED,\n                                    int fd G_GNUC_UNUSED,\n                                    int events,\n                                    void *opaque)\n{\n    virNetSocketPtr sock = opaque;\n    virNetSocketIOFunc func;\n    void *eopaque;\n\n    virObjectLock(sock);\n    func = sock->func;\n    eopaque = sock->opaque;\n    virObjectUnlock(sock);\n\n    if (func)\n        func(sock, events, eopaque);\n}"
  },
  {
    "function_name": "virNetSocketAccept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "2096-2144",
    "snippet": "int virNetSocketAccept(virNetSocketPtr sock, virNetSocketPtr *clientsock)\n{\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    int ret = -1;\n\n    virObjectLock(sock);\n\n    *clientsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    remoteAddr.len = sizeof(remoteAddr.data.stor);\n    if ((fd = accept(sock->fd, &remoteAddr.data.sa, &remoteAddr.len)) < 0) {\n        if (errno == ECONNABORTED ||\n            errno == EAGAIN) {\n            ret = 0;\n            goto cleanup;\n        }\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to accept client\"));\n        goto cleanup;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto cleanup;\n    }\n\n    if (!(*clientsock = virNetSocketNew(&localAddr,\n                                        &remoteAddr,\n                                        true,\n                                        fd, -1, 0,\n                                        false)))\n        goto cleanup;\n\n    fd = -1;\n    ret = 0;\n\n cleanup:\n    if (fd != -1)\n        closesocket(fd);\n    virObjectUnlock(sock);\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "fd"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "vir_closesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "197-213",
          "snippet": "int\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNew",
          "args": [
            "&localAddr",
            "&remoteAddr",
            "true",
            "fd",
            "-1",
            "0",
            "false"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "208-289",
          "snippet": "static virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetSocketClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virClassPtr virNetSocketClass;\n\nstatic virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to get local socket name\")"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get local socket name\""
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "fd",
            "&localAddr.data.sa",
            "&localAddr.len"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "vir_getsockname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "254-270",
          "snippet": "int\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to accept client\")"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "sock->fd",
            "&remoteAddr.data.sa",
            "&remoteAddr.len"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "vir_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "156-175",
          "snippet": "int\nvir_accept(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n    SOCKET csk;\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    csk = accept(sk, addr, addrlen);\n\n    if (csk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(csk);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_accept(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n    SOCKET csk;\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    csk = accept(sk, addr, addrlen);\n\n    if (csk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(csk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&remoteAddr",
            "0",
            "sizeof(remoteAddr)"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&localAddr",
            "0",
            "sizeof(localAddr)"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketAccept(virNetSocketPtr sock, virNetSocketPtr *clientsock)\n{\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    int ret = -1;\n\n    virObjectLock(sock);\n\n    *clientsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    remoteAddr.len = sizeof(remoteAddr.data.stor);\n    if ((fd = accept(sock->fd, &remoteAddr.data.sa, &remoteAddr.len)) < 0) {\n        if (errno == ECONNABORTED ||\n            errno == EAGAIN) {\n            ret = 0;\n            goto cleanup;\n        }\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to accept client\"));\n        goto cleanup;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto cleanup;\n    }\n\n    if (!(*clientsock = virNetSocketNew(&localAddr,\n                                        &remoteAddr,\n                                        true,\n                                        fd, -1, 0,\n                                        false)))\n        goto cleanup;\n\n    fd = -1;\n    ret = 0;\n\n cleanup:\n    if (fd != -1)\n        closesocket(fd);\n    virObjectUnlock(sock);\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketListen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "2084-2094",
    "snippet": "int virNetSocketListen(virNetSocketPtr sock, int backlog)\n{\n    virObjectLock(sock);\n    if (listen(sock->fd, backlog > 0 ? backlog : 30) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to listen on socket\"));\n        virObjectUnlock(sock);\n        return -1;\n    }\n    virObjectUnlock(sock);\n    return 0;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to listen on socket\")"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to listen on socket\""
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "sock->fd",
            "backlog > 0 ? backlog : 30"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "vir_listen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "273-289",
          "snippet": "int\nvir_listen(int fd, int backlog)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (listen(sk, backlog) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_listen(int fd, int backlog)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (listen(sk, backlog) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketListen(virNetSocketPtr sock, int backlog)\n{\n    virObjectLock(sock);\n    if (listen(sock->fd, backlog > 0 ? backlog : 30) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to listen on socket\"));\n        virObjectUnlock(sock);\n        return -1;\n    }\n    virObjectUnlock(sock);\n    return 0;\n}"
  },
  {
    "function_name": "virNetSocketRecvFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "2053-2081",
    "snippet": "int virNetSocketRecvFD(virNetSocketPtr sock, int *fd)\n{\n    int ret = -1;\n\n    *fd = -1;\n\n    if (!virNetSocketHasPassFD(sock)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Receiving file descriptors is not supported on this socket\"));\n        return -1;\n    }\n    virObjectLock(sock);\n\n    if ((*fd = virSocketRecvFD(sock->fd, O_CLOEXEC)) < 0) {\n        if (errno == EAGAIN)\n            ret = 0;\n        else\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Failed to recv file descriptor\"));\n        goto cleanup;\n    }\n    PROBE(RPC_SOCKET_RECV_FD,\n          \"sock=%p fd=%d\", sock, *fd);\n    ret = 1;\n\n cleanup:\n    virObjectUnlock(sock);\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_SOCKET_RECV_FD",
            "\"sock=%p fd=%d\"",
            "sock",
            "*fd"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Failed to recv file descriptor\")"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to recv file descriptor\""
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketRecvFD",
          "args": [
            "sock->fd",
            "O_CLOEXEC"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketRecvFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "496-501",
          "snippet": "int\nvirSocketRecvFD(int sock G_GNUC_UNUSED, int fdflags G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvirSocketRecvFD(int sock G_GNUC_UNUSED, int fdflags G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Receiving file descriptors is not supported on this socket\")"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketHasPassFD",
          "args": [
            "sock"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketHasPassFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1426-1434",
          "snippet": "bool virNetSocketHasPassFD(virNetSocketPtr sock)\n{\n    bool hasPassFD = false;\n    virObjectLock(sock);\n    if (sock->localAddr.data.sa.sa_family == AF_UNIX)\n        hasPassFD = true;\n    virObjectUnlock(sock);\n    return hasPassFD;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nbool virNetSocketHasPassFD(virNetSocketPtr sock)\n{\n    bool hasPassFD = false;\n    virObjectLock(sock);\n    if (sock->localAddr.data.sa.sa_family == AF_UNIX)\n        hasPassFD = true;\n    virObjectUnlock(sock);\n    return hasPassFD;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketRecvFD(virNetSocketPtr sock, int *fd)\n{\n    int ret = -1;\n\n    *fd = -1;\n\n    if (!virNetSocketHasPassFD(sock)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Receiving file descriptors is not supported on this socket\"));\n        return -1;\n    }\n    virObjectLock(sock);\n\n    if ((*fd = virSocketRecvFD(sock->fd, O_CLOEXEC)) < 0) {\n        if (errno == EAGAIN)\n            ret = 0;\n        else\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Failed to recv file descriptor\"));\n        goto cleanup;\n    }\n    PROBE(RPC_SOCKET_RECV_FD,\n          \"sock=%p fd=%d\", sock, *fd);\n    ret = 1;\n\n cleanup:\n    virObjectUnlock(sock);\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketSendFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "2022-2047",
    "snippet": "int virNetSocketSendFD(virNetSocketPtr sock, int fd)\n{\n    int ret = -1;\n    if (!virNetSocketHasPassFD(sock)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Sending file descriptors is not supported on this socket\"));\n        return -1;\n    }\n    virObjectLock(sock);\n    PROBE(RPC_SOCKET_SEND_FD,\n          \"sock=%p fd=%d\", sock, fd);\n    if (virSocketSendFD(sock->fd, fd) < 0) {\n        if (errno == EAGAIN)\n            ret = 0;\n        else\n            virReportSystemError(errno,\n                                 _(\"Failed to send file descriptor %d\"),\n                                 fd);\n        goto cleanup;\n    }\n    ret = 1;\n\n cleanup:\n    virObjectUnlock(sock);\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to send file descriptor %d\")",
            "fd"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to send file descriptor %d\""
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketSendFD",
          "args": [
            "sock->fd",
            "fd"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketSendFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "489-494",
          "snippet": "int\nvirSocketSendFD(int sock G_GNUC_UNUSED, int fd G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvirSocketSendFD(int sock G_GNUC_UNUSED, int fd G_GNUC_UNUSED)\n{\n    errno = ENOSYS;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_SOCKET_SEND_FD",
            "\"sock=%p fd=%d\"",
            "sock",
            "fd"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Sending file descriptors is not supported on this socket\")"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketHasPassFD",
          "args": [
            "sock"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketHasPassFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1426-1434",
          "snippet": "bool virNetSocketHasPassFD(virNetSocketPtr sock)\n{\n    bool hasPassFD = false;\n    virObjectLock(sock);\n    if (sock->localAddr.data.sa.sa_family == AF_UNIX)\n        hasPassFD = true;\n    virObjectUnlock(sock);\n    return hasPassFD;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nbool virNetSocketHasPassFD(virNetSocketPtr sock)\n{\n    bool hasPassFD = false;\n    virObjectLock(sock);\n    if (sock->localAddr.data.sa.sa_family == AF_UNIX)\n        hasPassFD = true;\n    virObjectUnlock(sock);\n    return hasPassFD;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketSendFD(virNetSocketPtr sock, int fd)\n{\n    int ret = -1;\n    if (!virNetSocketHasPassFD(sock)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Sending file descriptors is not supported on this socket\"));\n        return -1;\n    }\n    virObjectLock(sock);\n    PROBE(RPC_SOCKET_SEND_FD,\n          \"sock=%p fd=%d\", sock, fd);\n    if (virSocketSendFD(sock->fd, fd) < 0) {\n        if (errno == EAGAIN)\n            ret = 0;\n        else\n            virReportSystemError(errno,\n                                 _(\"Failed to send file descriptor %d\"),\n                                 fd);\n        goto cleanup;\n    }\n    ret = 1;\n\n cleanup:\n    virObjectUnlock(sock);\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "2003-2016",
    "snippet": "ssize_t virNetSocketWrite(virNetSocketPtr sock, const char *buf, size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sock);\n#if WITH_SASL\n    if (sock->saslSession)\n        ret = virNetSocketWriteSASL(sock, buf, len);\n    else\n#endif\n        ret = virNetSocketWriteWire(sock, buf, len);\n    virObjectUnlock(sock);\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketWriteWire",
          "args": [
            "sock",
            "buf",
            "len"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketWriteWire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1839-1879",
          "snippet": "static ssize_t virNetSocketWriteWire(virNetSocketPtr sock, const char *buf, size_t len)\n{\n    ssize_t ret;\n\n#if WITH_SSH2\n    if (sock->sshSession)\n        return virNetSocketLibSSH2Write(sock, buf, len);\n#endif\n\n#if WITH_LIBSSH\n    if (sock->libsshSession)\n        return virNetSocketLibsshWrite(sock, buf, len);\n#endif\n\n rewrite:\n    if (sock->tlsSession &&\n        virNetTLSSessionGetHandshakeStatus(sock->tlsSession) ==\n        VIR_NET_TLS_HANDSHAKE_COMPLETE) {\n        ret = virNetTLSSessionWrite(sock->tlsSession, buf, len);\n    } else {\n        ret = write(sock->fd, buf, len);\n    }\n\n    if (ret < 0) {\n        if (errno == EINTR)\n            goto rewrite;\n        if (errno == EAGAIN)\n            return 0;\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot write data\"));\n        return -1;\n    }\n    if (ret == 0) {\n        virReportSystemError(EIO, \"%s\",\n                             _(\"End of file while writing data\"));\n        return -1;\n    }\n\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketWriteWire(virNetSocketPtr sock, const char *buf, size_t len)\n{\n    ssize_t ret;\n\n#if WITH_SSH2\n    if (sock->sshSession)\n        return virNetSocketLibSSH2Write(sock, buf, len);\n#endif\n\n#if WITH_LIBSSH\n    if (sock->libsshSession)\n        return virNetSocketLibsshWrite(sock, buf, len);\n#endif\n\n rewrite:\n    if (sock->tlsSession &&\n        virNetTLSSessionGetHandshakeStatus(sock->tlsSession) ==\n        VIR_NET_TLS_HANDSHAKE_COMPLETE) {\n        ret = virNetTLSSessionWrite(sock->tlsSession, buf, len);\n    } else {\n        ret = write(sock->fd, buf, len);\n    }\n\n    if (ret < 0) {\n        if (errno == EINTR)\n            goto rewrite;\n        if (errno == EAGAIN)\n            return 0;\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot write data\"));\n        return -1;\n    }\n    if (ret == 0) {\n        virReportSystemError(EIO, \"%s\",\n                             _(\"End of file while writing data\"));\n        return -1;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketWriteSASL",
          "args": [
            "sock",
            "buf",
            "len"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketWriteSASL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1929-1986",
          "snippet": "static ssize_t virNetSocketWriteSASL(virNetSocketPtr sock, const char *buf, size_t len)\n{\n    int ret;\n    size_t tosend = virNetSASLSessionGetMaxBufSize(sock->saslSession);\n\n    /* SASL doesn't necessarily let us send the whole\n       buffer at once */\n    if (tosend > len)\n        tosend = len;\n\n    /* Not got any pending encoded data, so we need to encode raw stuff */\n    if (sock->saslEncoded == NULL) {\n        if (virNetSASLSessionEncode(sock->saslSession,\n                                    buf, tosend,\n                                    &sock->saslEncoded,\n                                    &sock->saslEncodedLength) < 0)\n            return -1;\n\n        sock->saslEncodedRawLength = tosend;\n        sock->saslEncodedOffset = 0;\n    }\n\n    /* Send some of the encoded stuff out on the wire */\n    ret = virNetSocketWriteWire(sock,\n                                sock->saslEncoded + sock->saslEncodedOffset,\n                                sock->saslEncodedLength - sock->saslEncodedOffset);\n\n    if (ret <= 0)\n        return ret; /* -1 error, 0 == egain */\n\n    /* Note how much we sent */\n    sock->saslEncodedOffset += ret;\n\n    /* Sent all encoded, so update raw buffer to indicate completion */\n    if (sock->saslEncodedOffset == sock->saslEncodedLength) {\n        ssize_t done = sock->saslEncodedRawLength;\n        sock->saslEncoded = NULL;\n        sock->saslEncodedOffset = sock->saslEncodedLength = sock->saslEncodedRawLength = 0;\n\n        /* Mark as complete, so caller detects completion.\n         *\n         * Note that 'done' is possibly less than our current\n         * 'tosend' value, since if virNetSocketWriteWire\n         * only partially sent the data, we might have been\n         * called a 2nd time to write remaining cached\n         * encoded data. This means that the caller might\n         * also have further raw data pending that's included\n         * in 'tosend' */\n        return done;\n    } else {\n        /* Still have stuff pending in saslEncoded buffer.\n         * Pretend to caller that we didn't send any yet.\n         * The caller will then retry with same buffer\n         * shortly, which lets us finish saslEncoded.\n         */\n        return 0;\n    }\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketWriteSASL(virNetSocketPtr sock, const char *buf, size_t len)\n{\n    int ret;\n    size_t tosend = virNetSASLSessionGetMaxBufSize(sock->saslSession);\n\n    /* SASL doesn't necessarily let us send the whole\n       buffer at once */\n    if (tosend > len)\n        tosend = len;\n\n    /* Not got any pending encoded data, so we need to encode raw stuff */\n    if (sock->saslEncoded == NULL) {\n        if (virNetSASLSessionEncode(sock->saslSession,\n                                    buf, tosend,\n                                    &sock->saslEncoded,\n                                    &sock->saslEncodedLength) < 0)\n            return -1;\n\n        sock->saslEncodedRawLength = tosend;\n        sock->saslEncodedOffset = 0;\n    }\n\n    /* Send some of the encoded stuff out on the wire */\n    ret = virNetSocketWriteWire(sock,\n                                sock->saslEncoded + sock->saslEncodedOffset,\n                                sock->saslEncodedLength - sock->saslEncodedOffset);\n\n    if (ret <= 0)\n        return ret; /* -1 error, 0 == egain */\n\n    /* Note how much we sent */\n    sock->saslEncodedOffset += ret;\n\n    /* Sent all encoded, so update raw buffer to indicate completion */\n    if (sock->saslEncodedOffset == sock->saslEncodedLength) {\n        ssize_t done = sock->saslEncodedRawLength;\n        sock->saslEncoded = NULL;\n        sock->saslEncodedOffset = sock->saslEncodedLength = sock->saslEncodedRawLength = 0;\n\n        /* Mark as complete, so caller detects completion.\n         *\n         * Note that 'done' is possibly less than our current\n         * 'tosend' value, since if virNetSocketWriteWire\n         * only partially sent the data, we might have been\n         * called a 2nd time to write remaining cached\n         * encoded data. This means that the caller might\n         * also have further raw data pending that's included\n         * in 'tosend' */\n        return done;\n    } else {\n        /* Still have stuff pending in saslEncoded buffer.\n         * Pretend to caller that we didn't send any yet.\n         * The caller will then retry with same buffer\n         * shortly, which lets us finish saslEncoded.\n         */\n        return 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nssize_t virNetSocketWrite(virNetSocketPtr sock, const char *buf, size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sock);\n#if WITH_SASL\n    if (sock->saslSession)\n        ret = virNetSocketWriteSASL(sock, buf, len);\n    else\n#endif\n        ret = virNetSocketWriteWire(sock, buf, len);\n    virObjectUnlock(sock);\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1989-2001",
    "snippet": "ssize_t virNetSocketRead(virNetSocketPtr sock, char *buf, size_t len)\n{\n    ssize_t ret;\n    virObjectLock(sock);\n#if WITH_SASL\n    if (sock->saslSession)\n        ret = virNetSocketReadSASL(sock, buf, len);\n    else\n#endif\n        ret = virNetSocketReadWire(sock, buf, len);\n    virObjectUnlock(sock);\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketReadWire",
          "args": [
            "sock",
            "buf",
            "len"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketReadWire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1769-1837",
          "snippet": "static ssize_t virNetSocketReadWire(virNetSocketPtr sock, char *buf, size_t len)\n{\n    char *errout = NULL;\n    ssize_t ret;\n\n#if WITH_SSH2\n    if (sock->sshSession)\n        return virNetSocketLibSSH2Read(sock, buf, len);\n#endif\n\n#if WITH_LIBSSH\n    if (sock->libsshSession)\n        return virNetSocketLibsshRead(sock, buf, len);\n#endif\n\n reread:\n    if (sock->tlsSession &&\n        virNetTLSSessionGetHandshakeStatus(sock->tlsSession) ==\n        VIR_NET_TLS_HANDSHAKE_COMPLETE) {\n        ret = virNetTLSSessionRead(sock->tlsSession, buf, len);\n    } else {\n        ret = read(sock->fd, buf, len);\n    }\n\n    if ((ret < 0) && (errno == EINTR))\n        goto reread;\n    if ((ret < 0) && (errno == EAGAIN))\n        return 0;\n\n    if (ret <= 0 &&\n        sock->errfd != -1 &&\n        virFileReadLimFD(sock->errfd, 1024, &errout) >= 0 &&\n        errout != NULL) {\n        size_t elen = strlen(errout);\n        /* remove trailing whitespace */\n        while (elen && g_ascii_isspace(errout[elen - 1]))\n            errout[--elen] = '\\0';\n    }\n\n    if (ret < 0) {\n        if (errout)\n            virReportSystemError(errno,\n                                 _(\"Cannot recv data: %s\"), errout);\n        else\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot recv data\"));\n        ret = -1;\n    } else if (ret == 0) {\n        if (sock->quietEOF) {\n            VIR_DEBUG(\"socket='%p' EOF while reading: errout='%s'\",\n                      socket, NULLSTR(errout));\n\n            ret = -2;\n        } else {\n            if (errout)\n                virReportSystemError(EIO,\n                                     _(\"End of file while reading data: %s\"),\n                                     errout);\n            else\n                virReportSystemError(EIO, \"%s\",\n                                     _(\"End of file while reading data\"));\n\n            ret = -1;\n        }\n    }\n\n    VIR_FREE(errout);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketReadWire(virNetSocketPtr sock, char *buf, size_t len)\n{\n    char *errout = NULL;\n    ssize_t ret;\n\n#if WITH_SSH2\n    if (sock->sshSession)\n        return virNetSocketLibSSH2Read(sock, buf, len);\n#endif\n\n#if WITH_LIBSSH\n    if (sock->libsshSession)\n        return virNetSocketLibsshRead(sock, buf, len);\n#endif\n\n reread:\n    if (sock->tlsSession &&\n        virNetTLSSessionGetHandshakeStatus(sock->tlsSession) ==\n        VIR_NET_TLS_HANDSHAKE_COMPLETE) {\n        ret = virNetTLSSessionRead(sock->tlsSession, buf, len);\n    } else {\n        ret = read(sock->fd, buf, len);\n    }\n\n    if ((ret < 0) && (errno == EINTR))\n        goto reread;\n    if ((ret < 0) && (errno == EAGAIN))\n        return 0;\n\n    if (ret <= 0 &&\n        sock->errfd != -1 &&\n        virFileReadLimFD(sock->errfd, 1024, &errout) >= 0 &&\n        errout != NULL) {\n        size_t elen = strlen(errout);\n        /* remove trailing whitespace */\n        while (elen && g_ascii_isspace(errout[elen - 1]))\n            errout[--elen] = '\\0';\n    }\n\n    if (ret < 0) {\n        if (errout)\n            virReportSystemError(errno,\n                                 _(\"Cannot recv data: %s\"), errout);\n        else\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot recv data\"));\n        ret = -1;\n    } else if (ret == 0) {\n        if (sock->quietEOF) {\n            VIR_DEBUG(\"socket='%p' EOF while reading: errout='%s'\",\n                      socket, NULLSTR(errout));\n\n            ret = -2;\n        } else {\n            if (errout)\n                virReportSystemError(EIO,\n                                     _(\"End of file while reading data: %s\"),\n                                     errout);\n            else\n                virReportSystemError(EIO, \"%s\",\n                                     _(\"End of file while reading data\"));\n\n            ret = -1;\n        }\n    }\n\n    VIR_FREE(errout);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketReadSASL",
          "args": [
            "sock",
            "buf",
            "len"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketReadSASL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1883-1926",
          "snippet": "static ssize_t virNetSocketReadSASL(virNetSocketPtr sock, char *buf, size_t len)\n{\n    ssize_t got;\n\n    /* Need to read some more data off the wire */\n    if (sock->saslDecoded == NULL) {\n        ssize_t encodedLen = virNetSASLSessionGetMaxBufSize(sock->saslSession);\n        char *encoded;\n        if (VIR_ALLOC_N(encoded, encodedLen) < 0)\n            return -1;\n        encodedLen = virNetSocketReadWire(sock, encoded, encodedLen);\n\n        if (encodedLen <= 0) {\n            VIR_FREE(encoded);\n            return encodedLen;\n        }\n\n        if (virNetSASLSessionDecode(sock->saslSession,\n                                    encoded, encodedLen,\n                                    &sock->saslDecoded, &sock->saslDecodedLength) < 0) {\n            VIR_FREE(encoded);\n            return -1;\n        }\n        VIR_FREE(encoded);\n\n        sock->saslDecodedOffset = 0;\n    }\n\n    /* Some buffered decoded data to return now */\n    got = sock->saslDecodedLength - sock->saslDecodedOffset;\n\n    if (len > got)\n        len = got;\n\n    memcpy(buf, sock->saslDecoded + sock->saslDecodedOffset, len);\n    sock->saslDecodedOffset += len;\n\n    if (sock->saslDecodedOffset == sock->saslDecodedLength) {\n        sock->saslDecoded = NULL;\n        sock->saslDecodedOffset = sock->saslDecodedLength = 0;\n    }\n\n    return len;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketReadSASL(virNetSocketPtr sock, char *buf, size_t len)\n{\n    ssize_t got;\n\n    /* Need to read some more data off the wire */\n    if (sock->saslDecoded == NULL) {\n        ssize_t encodedLen = virNetSASLSessionGetMaxBufSize(sock->saslSession);\n        char *encoded;\n        if (VIR_ALLOC_N(encoded, encodedLen) < 0)\n            return -1;\n        encodedLen = virNetSocketReadWire(sock, encoded, encodedLen);\n\n        if (encodedLen <= 0) {\n            VIR_FREE(encoded);\n            return encodedLen;\n        }\n\n        if (virNetSASLSessionDecode(sock->saslSession,\n                                    encoded, encodedLen,\n                                    &sock->saslDecoded, &sock->saslDecodedLength) < 0) {\n            VIR_FREE(encoded);\n            return -1;\n        }\n        VIR_FREE(encoded);\n\n        sock->saslDecodedOffset = 0;\n    }\n\n    /* Some buffered decoded data to return now */\n    got = sock->saslDecodedLength - sock->saslDecodedOffset;\n\n    if (len > got)\n        len = got;\n\n    memcpy(buf, sock->saslDecoded + sock->saslDecodedOffset, len);\n    sock->saslDecodedOffset += len;\n\n    if (sock->saslDecodedOffset == sock->saslDecodedLength) {\n        sock->saslDecoded = NULL;\n        sock->saslDecodedOffset = sock->saslDecodedLength = 0;\n    }\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nssize_t virNetSocketRead(virNetSocketPtr sock, char *buf, size_t len)\n{\n    ssize_t ret;\n    virObjectLock(sock);\n#if WITH_SASL\n    if (sock->saslSession)\n        ret = virNetSocketReadSASL(sock, buf, len);\n    else\n#endif\n        ret = virNetSocketReadWire(sock, buf, len);\n    virObjectUnlock(sock);\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketWriteSASL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1929-1986",
    "snippet": "static ssize_t virNetSocketWriteSASL(virNetSocketPtr sock, const char *buf, size_t len)\n{\n    int ret;\n    size_t tosend = virNetSASLSessionGetMaxBufSize(sock->saslSession);\n\n    /* SASL doesn't necessarily let us send the whole\n       buffer at once */\n    if (tosend > len)\n        tosend = len;\n\n    /* Not got any pending encoded data, so we need to encode raw stuff */\n    if (sock->saslEncoded == NULL) {\n        if (virNetSASLSessionEncode(sock->saslSession,\n                                    buf, tosend,\n                                    &sock->saslEncoded,\n                                    &sock->saslEncodedLength) < 0)\n            return -1;\n\n        sock->saslEncodedRawLength = tosend;\n        sock->saslEncodedOffset = 0;\n    }\n\n    /* Send some of the encoded stuff out on the wire */\n    ret = virNetSocketWriteWire(sock,\n                                sock->saslEncoded + sock->saslEncodedOffset,\n                                sock->saslEncodedLength - sock->saslEncodedOffset);\n\n    if (ret <= 0)\n        return ret; /* -1 error, 0 == egain */\n\n    /* Note how much we sent */\n    sock->saslEncodedOffset += ret;\n\n    /* Sent all encoded, so update raw buffer to indicate completion */\n    if (sock->saslEncodedOffset == sock->saslEncodedLength) {\n        ssize_t done = sock->saslEncodedRawLength;\n        sock->saslEncoded = NULL;\n        sock->saslEncodedOffset = sock->saslEncodedLength = sock->saslEncodedRawLength = 0;\n\n        /* Mark as complete, so caller detects completion.\n         *\n         * Note that 'done' is possibly less than our current\n         * 'tosend' value, since if virNetSocketWriteWire\n         * only partially sent the data, we might have been\n         * called a 2nd time to write remaining cached\n         * encoded data. This means that the caller might\n         * also have further raw data pending that's included\n         * in 'tosend' */\n        return done;\n    } else {\n        /* Still have stuff pending in saslEncoded buffer.\n         * Pretend to caller that we didn't send any yet.\n         * The caller will then retry with same buffer\n         * shortly, which lets us finish saslEncoded.\n         */\n        return 0;\n    }\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSocketWriteWire",
          "args": [
            "sock",
            "sock->saslEncoded + sock->saslEncodedOffset",
            "sock->saslEncodedLength - sock->saslEncodedOffset"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketWriteWire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1839-1879",
          "snippet": "static ssize_t virNetSocketWriteWire(virNetSocketPtr sock, const char *buf, size_t len)\n{\n    ssize_t ret;\n\n#if WITH_SSH2\n    if (sock->sshSession)\n        return virNetSocketLibSSH2Write(sock, buf, len);\n#endif\n\n#if WITH_LIBSSH\n    if (sock->libsshSession)\n        return virNetSocketLibsshWrite(sock, buf, len);\n#endif\n\n rewrite:\n    if (sock->tlsSession &&\n        virNetTLSSessionGetHandshakeStatus(sock->tlsSession) ==\n        VIR_NET_TLS_HANDSHAKE_COMPLETE) {\n        ret = virNetTLSSessionWrite(sock->tlsSession, buf, len);\n    } else {\n        ret = write(sock->fd, buf, len);\n    }\n\n    if (ret < 0) {\n        if (errno == EINTR)\n            goto rewrite;\n        if (errno == EAGAIN)\n            return 0;\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot write data\"));\n        return -1;\n    }\n    if (ret == 0) {\n        virReportSystemError(EIO, \"%s\",\n                             _(\"End of file while writing data\"));\n        return -1;\n    }\n\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketWriteWire(virNetSocketPtr sock, const char *buf, size_t len)\n{\n    ssize_t ret;\n\n#if WITH_SSH2\n    if (sock->sshSession)\n        return virNetSocketLibSSH2Write(sock, buf, len);\n#endif\n\n#if WITH_LIBSSH\n    if (sock->libsshSession)\n        return virNetSocketLibsshWrite(sock, buf, len);\n#endif\n\n rewrite:\n    if (sock->tlsSession &&\n        virNetTLSSessionGetHandshakeStatus(sock->tlsSession) ==\n        VIR_NET_TLS_HANDSHAKE_COMPLETE) {\n        ret = virNetTLSSessionWrite(sock->tlsSession, buf, len);\n    } else {\n        ret = write(sock->fd, buf, len);\n    }\n\n    if (ret < 0) {\n        if (errno == EINTR)\n            goto rewrite;\n        if (errno == EAGAIN)\n            return 0;\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot write data\"));\n        return -1;\n    }\n    if (ret == 0) {\n        virReportSystemError(EIO, \"%s\",\n                             _(\"End of file while writing data\"));\n        return -1;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSASLSessionEncode",
          "args": [
            "sock->saslSession",
            "buf",
            "tosend",
            "&sock->saslEncoded",
            "&sock->saslEncodedLength"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSASLSessionEncode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsaslcontext.c",
          "lines": "614-651",
          "snippet": "ssize_t virNetSASLSessionEncode(virNetSASLSessionPtr sasl,\n                                const char *input,\n                                size_t inputLen,\n                                const char **output,\n                                size_t *outputlen)\n{\n    unsigned inlen = inputLen;\n    unsigned outlen = 0;\n    int err;\n    ssize_t ret = -1;\n\n    virObjectLock(sasl);\n    if (inputLen > sasl->maxbufsize) {\n        virReportSystemError(EINVAL,\n                             _(\"SASL data length %zu too long, max %zu\"),\n                             inputLen, sasl->maxbufsize);\n        goto cleanup;\n    }\n\n    err = sasl_encode(sasl->conn,\n                      input,\n                      inlen,\n                      output,\n                      &outlen);\n    *outputlen = outlen;\n\n    if (err != SASL_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to encode SASL data: %d (%s)\"),\n                       err, sasl_errstring(err, NULL, NULL));\n        goto cleanup;\n    }\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sasl);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetmessage.h\"",
            "#include \"virnetsaslcontext.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetmessage.h\"\n#include \"virnetsaslcontext.h\"\n#include <config.h>\n\nssize_t virNetSASLSessionEncode(virNetSASLSessionPtr sasl,\n                                const char *input,\n                                size_t inputLen,\n                                const char **output,\n                                size_t *outputlen)\n{\n    unsigned inlen = inputLen;\n    unsigned outlen = 0;\n    int err;\n    ssize_t ret = -1;\n\n    virObjectLock(sasl);\n    if (inputLen > sasl->maxbufsize) {\n        virReportSystemError(EINVAL,\n                             _(\"SASL data length %zu too long, max %zu\"),\n                             inputLen, sasl->maxbufsize);\n        goto cleanup;\n    }\n\n    err = sasl_encode(sasl->conn,\n                      input,\n                      inlen,\n                      output,\n                      &outlen);\n    *outputlen = outlen;\n\n    if (err != SASL_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to encode SASL data: %d (%s)\"),\n                       err, sasl_errstring(err, NULL, NULL));\n        goto cleanup;\n    }\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sasl);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSASLSessionGetMaxBufSize",
          "args": [
            "sock->saslSession"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSASLSessionGetMaxBufSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsaslcontext.c",
          "lines": "605-612",
          "snippet": "size_t virNetSASLSessionGetMaxBufSize(virNetSASLSessionPtr sasl)\n{\n    size_t ret;\n    virObjectLock(sasl);\n    ret = sasl->maxbufsize;\n    virObjectUnlock(sasl);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetmessage.h\"",
            "#include \"virnetsaslcontext.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetmessage.h\"\n#include \"virnetsaslcontext.h\"\n#include <config.h>\n\nsize_t virNetSASLSessionGetMaxBufSize(virNetSASLSessionPtr sasl)\n{\n    size_t ret;\n    virObjectLock(sasl);\n    ret = sasl->maxbufsize;\n    virObjectUnlock(sasl);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketWriteSASL(virNetSocketPtr sock, const char *buf, size_t len)\n{\n    int ret;\n    size_t tosend = virNetSASLSessionGetMaxBufSize(sock->saslSession);\n\n    /* SASL doesn't necessarily let us send the whole\n       buffer at once */\n    if (tosend > len)\n        tosend = len;\n\n    /* Not got any pending encoded data, so we need to encode raw stuff */\n    if (sock->saslEncoded == NULL) {\n        if (virNetSASLSessionEncode(sock->saslSession,\n                                    buf, tosend,\n                                    &sock->saslEncoded,\n                                    &sock->saslEncodedLength) < 0)\n            return -1;\n\n        sock->saslEncodedRawLength = tosend;\n        sock->saslEncodedOffset = 0;\n    }\n\n    /* Send some of the encoded stuff out on the wire */\n    ret = virNetSocketWriteWire(sock,\n                                sock->saslEncoded + sock->saslEncodedOffset,\n                                sock->saslEncodedLength - sock->saslEncodedOffset);\n\n    if (ret <= 0)\n        return ret; /* -1 error, 0 == egain */\n\n    /* Note how much we sent */\n    sock->saslEncodedOffset += ret;\n\n    /* Sent all encoded, so update raw buffer to indicate completion */\n    if (sock->saslEncodedOffset == sock->saslEncodedLength) {\n        ssize_t done = sock->saslEncodedRawLength;\n        sock->saslEncoded = NULL;\n        sock->saslEncodedOffset = sock->saslEncodedLength = sock->saslEncodedRawLength = 0;\n\n        /* Mark as complete, so caller detects completion.\n         *\n         * Note that 'done' is possibly less than our current\n         * 'tosend' value, since if virNetSocketWriteWire\n         * only partially sent the data, we might have been\n         * called a 2nd time to write remaining cached\n         * encoded data. This means that the caller might\n         * also have further raw data pending that's included\n         * in 'tosend' */\n        return done;\n    } else {\n        /* Still have stuff pending in saslEncoded buffer.\n         * Pretend to caller that we didn't send any yet.\n         * The caller will then retry with same buffer\n         * shortly, which lets us finish saslEncoded.\n         */\n        return 0;\n    }\n}"
  },
  {
    "function_name": "virNetSocketReadSASL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1883-1926",
    "snippet": "static ssize_t virNetSocketReadSASL(virNetSocketPtr sock, char *buf, size_t len)\n{\n    ssize_t got;\n\n    /* Need to read some more data off the wire */\n    if (sock->saslDecoded == NULL) {\n        ssize_t encodedLen = virNetSASLSessionGetMaxBufSize(sock->saslSession);\n        char *encoded;\n        if (VIR_ALLOC_N(encoded, encodedLen) < 0)\n            return -1;\n        encodedLen = virNetSocketReadWire(sock, encoded, encodedLen);\n\n        if (encodedLen <= 0) {\n            VIR_FREE(encoded);\n            return encodedLen;\n        }\n\n        if (virNetSASLSessionDecode(sock->saslSession,\n                                    encoded, encodedLen,\n                                    &sock->saslDecoded, &sock->saslDecodedLength) < 0) {\n            VIR_FREE(encoded);\n            return -1;\n        }\n        VIR_FREE(encoded);\n\n        sock->saslDecodedOffset = 0;\n    }\n\n    /* Some buffered decoded data to return now */\n    got = sock->saslDecodedLength - sock->saslDecodedOffset;\n\n    if (len > got)\n        len = got;\n\n    memcpy(buf, sock->saslDecoded + sock->saslDecodedOffset, len);\n    sock->saslDecodedOffset += len;\n\n    if (sock->saslDecodedOffset == sock->saslDecodedLength) {\n        sock->saslDecoded = NULL;\n        sock->saslDecodedOffset = sock->saslDecodedLength = 0;\n    }\n\n    return len;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "sock->saslDecoded + sock->saslDecodedOffset",
            "len"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "encoded"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "encoded"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSASLSessionDecode",
          "args": [
            "sock->saslSession",
            "encoded",
            "encodedLen",
            "&sock->saslDecoded",
            "&sock->saslDecodedLength"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSASLSessionDecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsaslcontext.c",
          "lines": "653-689",
          "snippet": "ssize_t virNetSASLSessionDecode(virNetSASLSessionPtr sasl,\n                                const char *input,\n                                size_t inputLen,\n                                const char **output,\n                                size_t *outputlen)\n{\n    unsigned inlen = inputLen;\n    unsigned outlen = 0;\n    int err;\n    ssize_t ret = -1;\n\n    virObjectLock(sasl);\n    if (inputLen > sasl->maxbufsize) {\n        virReportSystemError(EINVAL,\n                             _(\"SASL data length %zu too long, max %zu\"),\n                             inputLen, sasl->maxbufsize);\n        goto cleanup;\n    }\n\n    err = sasl_decode(sasl->conn,\n                      input,\n                      inlen,\n                      output,\n                      &outlen);\n    *outputlen = outlen;\n    if (err != SASL_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to decode SASL data: %d (%s)\"),\n                       err, sasl_errstring(err, NULL, NULL));\n        goto cleanup;\n    }\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sasl);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetmessage.h\"",
            "#include \"virnetsaslcontext.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetmessage.h\"\n#include \"virnetsaslcontext.h\"\n#include <config.h>\n\nssize_t virNetSASLSessionDecode(virNetSASLSessionPtr sasl,\n                                const char *input,\n                                size_t inputLen,\n                                const char **output,\n                                size_t *outputlen)\n{\n    unsigned inlen = inputLen;\n    unsigned outlen = 0;\n    int err;\n    ssize_t ret = -1;\n\n    virObjectLock(sasl);\n    if (inputLen > sasl->maxbufsize) {\n        virReportSystemError(EINVAL,\n                             _(\"SASL data length %zu too long, max %zu\"),\n                             inputLen, sasl->maxbufsize);\n        goto cleanup;\n    }\n\n    err = sasl_decode(sasl->conn,\n                      input,\n                      inlen,\n                      output,\n                      &outlen);\n    *outputlen = outlen;\n    if (err != SASL_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to decode SASL data: %d (%s)\"),\n                       err, sasl_errstring(err, NULL, NULL));\n        goto cleanup;\n    }\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sasl);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "encoded"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketReadWire",
          "args": [
            "sock",
            "encoded",
            "encodedLen"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketReadWire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1769-1837",
          "snippet": "static ssize_t virNetSocketReadWire(virNetSocketPtr sock, char *buf, size_t len)\n{\n    char *errout = NULL;\n    ssize_t ret;\n\n#if WITH_SSH2\n    if (sock->sshSession)\n        return virNetSocketLibSSH2Read(sock, buf, len);\n#endif\n\n#if WITH_LIBSSH\n    if (sock->libsshSession)\n        return virNetSocketLibsshRead(sock, buf, len);\n#endif\n\n reread:\n    if (sock->tlsSession &&\n        virNetTLSSessionGetHandshakeStatus(sock->tlsSession) ==\n        VIR_NET_TLS_HANDSHAKE_COMPLETE) {\n        ret = virNetTLSSessionRead(sock->tlsSession, buf, len);\n    } else {\n        ret = read(sock->fd, buf, len);\n    }\n\n    if ((ret < 0) && (errno == EINTR))\n        goto reread;\n    if ((ret < 0) && (errno == EAGAIN))\n        return 0;\n\n    if (ret <= 0 &&\n        sock->errfd != -1 &&\n        virFileReadLimFD(sock->errfd, 1024, &errout) >= 0 &&\n        errout != NULL) {\n        size_t elen = strlen(errout);\n        /* remove trailing whitespace */\n        while (elen && g_ascii_isspace(errout[elen - 1]))\n            errout[--elen] = '\\0';\n    }\n\n    if (ret < 0) {\n        if (errout)\n            virReportSystemError(errno,\n                                 _(\"Cannot recv data: %s\"), errout);\n        else\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot recv data\"));\n        ret = -1;\n    } else if (ret == 0) {\n        if (sock->quietEOF) {\n            VIR_DEBUG(\"socket='%p' EOF while reading: errout='%s'\",\n                      socket, NULLSTR(errout));\n\n            ret = -2;\n        } else {\n            if (errout)\n                virReportSystemError(EIO,\n                                     _(\"End of file while reading data: %s\"),\n                                     errout);\n            else\n                virReportSystemError(EIO, \"%s\",\n                                     _(\"End of file while reading data\"));\n\n            ret = -1;\n        }\n    }\n\n    VIR_FREE(errout);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketReadWire(virNetSocketPtr sock, char *buf, size_t len)\n{\n    char *errout = NULL;\n    ssize_t ret;\n\n#if WITH_SSH2\n    if (sock->sshSession)\n        return virNetSocketLibSSH2Read(sock, buf, len);\n#endif\n\n#if WITH_LIBSSH\n    if (sock->libsshSession)\n        return virNetSocketLibsshRead(sock, buf, len);\n#endif\n\n reread:\n    if (sock->tlsSession &&\n        virNetTLSSessionGetHandshakeStatus(sock->tlsSession) ==\n        VIR_NET_TLS_HANDSHAKE_COMPLETE) {\n        ret = virNetTLSSessionRead(sock->tlsSession, buf, len);\n    } else {\n        ret = read(sock->fd, buf, len);\n    }\n\n    if ((ret < 0) && (errno == EINTR))\n        goto reread;\n    if ((ret < 0) && (errno == EAGAIN))\n        return 0;\n\n    if (ret <= 0 &&\n        sock->errfd != -1 &&\n        virFileReadLimFD(sock->errfd, 1024, &errout) >= 0 &&\n        errout != NULL) {\n        size_t elen = strlen(errout);\n        /* remove trailing whitespace */\n        while (elen && g_ascii_isspace(errout[elen - 1]))\n            errout[--elen] = '\\0';\n    }\n\n    if (ret < 0) {\n        if (errout)\n            virReportSystemError(errno,\n                                 _(\"Cannot recv data: %s\"), errout);\n        else\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot recv data\"));\n        ret = -1;\n    } else if (ret == 0) {\n        if (sock->quietEOF) {\n            VIR_DEBUG(\"socket='%p' EOF while reading: errout='%s'\",\n                      socket, NULLSTR(errout));\n\n            ret = -2;\n        } else {\n            if (errout)\n                virReportSystemError(EIO,\n                                     _(\"End of file while reading data: %s\"),\n                                     errout);\n            else\n                virReportSystemError(EIO, \"%s\",\n                                     _(\"End of file while reading data\"));\n\n            ret = -1;\n        }\n    }\n\n    VIR_FREE(errout);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "encoded",
            "encodedLen"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSASLSessionGetMaxBufSize",
          "args": [
            "sock->saslSession"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSASLSessionGetMaxBufSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsaslcontext.c",
          "lines": "605-612",
          "snippet": "size_t virNetSASLSessionGetMaxBufSize(virNetSASLSessionPtr sasl)\n{\n    size_t ret;\n    virObjectLock(sasl);\n    ret = sasl->maxbufsize;\n    virObjectUnlock(sasl);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetmessage.h\"",
            "#include \"virnetsaslcontext.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetmessage.h\"\n#include \"virnetsaslcontext.h\"\n#include <config.h>\n\nsize_t virNetSASLSessionGetMaxBufSize(virNetSASLSessionPtr sasl)\n{\n    size_t ret;\n    virObjectLock(sasl);\n    ret = sasl->maxbufsize;\n    virObjectUnlock(sasl);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketReadSASL(virNetSocketPtr sock, char *buf, size_t len)\n{\n    ssize_t got;\n\n    /* Need to read some more data off the wire */\n    if (sock->saslDecoded == NULL) {\n        ssize_t encodedLen = virNetSASLSessionGetMaxBufSize(sock->saslSession);\n        char *encoded;\n        if (VIR_ALLOC_N(encoded, encodedLen) < 0)\n            return -1;\n        encodedLen = virNetSocketReadWire(sock, encoded, encodedLen);\n\n        if (encodedLen <= 0) {\n            VIR_FREE(encoded);\n            return encodedLen;\n        }\n\n        if (virNetSASLSessionDecode(sock->saslSession,\n                                    encoded, encodedLen,\n                                    &sock->saslDecoded, &sock->saslDecodedLength) < 0) {\n            VIR_FREE(encoded);\n            return -1;\n        }\n        VIR_FREE(encoded);\n\n        sock->saslDecodedOffset = 0;\n    }\n\n    /* Some buffered decoded data to return now */\n    got = sock->saslDecodedLength - sock->saslDecodedOffset;\n\n    if (len > got)\n        len = got;\n\n    memcpy(buf, sock->saslDecoded + sock->saslDecodedOffset, len);\n    sock->saslDecodedOffset += len;\n\n    if (sock->saslDecodedOffset == sock->saslDecodedLength) {\n        sock->saslDecoded = NULL;\n        sock->saslDecodedOffset = sock->saslDecodedLength = 0;\n    }\n\n    return len;\n}"
  },
  {
    "function_name": "virNetSocketWriteWire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1839-1879",
    "snippet": "static ssize_t virNetSocketWriteWire(virNetSocketPtr sock, const char *buf, size_t len)\n{\n    ssize_t ret;\n\n#if WITH_SSH2\n    if (sock->sshSession)\n        return virNetSocketLibSSH2Write(sock, buf, len);\n#endif\n\n#if WITH_LIBSSH\n    if (sock->libsshSession)\n        return virNetSocketLibsshWrite(sock, buf, len);\n#endif\n\n rewrite:\n    if (sock->tlsSession &&\n        virNetTLSSessionGetHandshakeStatus(sock->tlsSession) ==\n        VIR_NET_TLS_HANDSHAKE_COMPLETE) {\n        ret = virNetTLSSessionWrite(sock->tlsSession, buf, len);\n    } else {\n        ret = write(sock->fd, buf, len);\n    }\n\n    if (ret < 0) {\n        if (errno == EINTR)\n            goto rewrite;\n        if (errno == EAGAIN)\n            return 0;\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot write data\"));\n        return -1;\n    }\n    if (ret == 0) {\n        virReportSystemError(EIO, \"%s\",\n                             _(\"End of file while writing data\"));\n        return -1;\n    }\n\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EIO",
            "\"%s\"",
            "_(\"End of file while writing data\")"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"End of file while writing data\""
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Cannot write data\")"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "sock->fd",
            "buf",
            "len"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSSessionWrite",
          "args": [
            "sock->tlsSession",
            "buf",
            "len"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSSessionWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "1275-1306",
          "snippet": "ssize_t virNetTLSSessionWrite(virNetTLSSessionPtr sess,\n                              const char *buf, size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n    ret = gnutls_record_send(sess->session, buf, len);\n\n    if (ret >= 0)\n        goto cleanup;\n\n    switch (ret) {\n    case GNUTLS_E_AGAIN:\n        errno = EAGAIN;\n        break;\n    case GNUTLS_E_INTERRUPTED:\n        errno = EINTR;\n        break;\n    case GNUTLS_E_UNEXPECTED_PACKET_LENGTH:\n        errno = ENOMSG;\n        break;\n    default:\n        errno = EIO;\n        break;\n    }\n\n    ret = -1;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nssize_t virNetTLSSessionWrite(virNetTLSSessionPtr sess,\n                              const char *buf, size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n    ret = gnutls_record_send(sess->session, buf, len);\n\n    if (ret >= 0)\n        goto cleanup;\n\n    switch (ret) {\n    case GNUTLS_E_AGAIN:\n        errno = EAGAIN;\n        break;\n    case GNUTLS_E_INTERRUPTED:\n        errno = EINTR;\n        break;\n    case GNUTLS_E_UNEXPECTED_PACKET_LENGTH:\n        errno = ENOMSG;\n        break;\n    default:\n        errno = EIO;\n        break;\n    }\n\n    ret = -1;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSSessionGetHandshakeStatus",
          "args": [
            "sock->tlsSession"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSSessionGetHandshakeStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "1370-1383",
          "snippet": "virNetTLSSessionHandshakeStatus\nvirNetTLSSessionGetHandshakeStatus(virNetTLSSessionPtr sess)\n{\n    virNetTLSSessionHandshakeStatus ret;\n    virObjectLock(sess);\n    if (sess->handshakeComplete)\n        ret = VIR_NET_TLS_HANDSHAKE_COMPLETE;\n    else if (gnutls_record_get_direction(sess->session) == 0)\n        ret = VIR_NET_TLS_HANDSHAKE_RECVING;\n    else\n        ret = VIR_NET_TLS_HANDSHAKE_SENDING;\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetTLSSessionHandshakeStatus\nvirNetTLSSessionGetHandshakeStatus(virNetTLSSessionPtr sess)\n{\n    virNetTLSSessionHandshakeStatus ret;\n    virObjectLock(sess);\n    if (sess->handshakeComplete)\n        ret = VIR_NET_TLS_HANDSHAKE_COMPLETE;\n    else if (gnutls_record_get_direction(sess->session) == 0)\n        ret = VIR_NET_TLS_HANDSHAKE_RECVING;\n    else\n        ret = VIR_NET_TLS_HANDSHAKE_SENDING;\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketLibsshWrite",
          "args": [
            "sock",
            "buf",
            "len"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketLibsshWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1748-1753",
          "snippet": "static ssize_t virNetSocketLibsshWrite(virNetSocketPtr sock,\n                                       const char *buf,\n                                       size_t len)\n{\n    return virNetLibsshChannelWrite(sock->libsshSession, buf, len);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketLibsshWrite(virNetSocketPtr sock,\n                                       const char *buf,\n                                       size_t len)\n{\n    return virNetLibsshChannelWrite(sock->libsshSession, buf, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketLibSSH2Write",
          "args": [
            "sock",
            "buf",
            "len"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketLibSSH2Write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1732-1737",
          "snippet": "static ssize_t virNetSocketLibSSH2Write(virNetSocketPtr sock,\n                                        const char *buf,\n                                        size_t len)\n{\n    return virNetSSHChannelWrite(sock->sshSession, buf, len);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketLibSSH2Write(virNetSocketPtr sock,\n                                        const char *buf,\n                                        size_t len)\n{\n    return virNetSSHChannelWrite(sock->sshSession, buf, len);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketWriteWire(virNetSocketPtr sock, const char *buf, size_t len)\n{\n    ssize_t ret;\n\n#if WITH_SSH2\n    if (sock->sshSession)\n        return virNetSocketLibSSH2Write(sock, buf, len);\n#endif\n\n#if WITH_LIBSSH\n    if (sock->libsshSession)\n        return virNetSocketLibsshWrite(sock, buf, len);\n#endif\n\n rewrite:\n    if (sock->tlsSession &&\n        virNetTLSSessionGetHandshakeStatus(sock->tlsSession) ==\n        VIR_NET_TLS_HANDSHAKE_COMPLETE) {\n        ret = virNetTLSSessionWrite(sock->tlsSession, buf, len);\n    } else {\n        ret = write(sock->fd, buf, len);\n    }\n\n    if (ret < 0) {\n        if (errno == EINTR)\n            goto rewrite;\n        if (errno == EAGAIN)\n            return 0;\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot write data\"));\n        return -1;\n    }\n    if (ret == 0) {\n        virReportSystemError(EIO, \"%s\",\n                             _(\"End of file while writing data\"));\n        return -1;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketReadWire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1769-1837",
    "snippet": "static ssize_t virNetSocketReadWire(virNetSocketPtr sock, char *buf, size_t len)\n{\n    char *errout = NULL;\n    ssize_t ret;\n\n#if WITH_SSH2\n    if (sock->sshSession)\n        return virNetSocketLibSSH2Read(sock, buf, len);\n#endif\n\n#if WITH_LIBSSH\n    if (sock->libsshSession)\n        return virNetSocketLibsshRead(sock, buf, len);\n#endif\n\n reread:\n    if (sock->tlsSession &&\n        virNetTLSSessionGetHandshakeStatus(sock->tlsSession) ==\n        VIR_NET_TLS_HANDSHAKE_COMPLETE) {\n        ret = virNetTLSSessionRead(sock->tlsSession, buf, len);\n    } else {\n        ret = read(sock->fd, buf, len);\n    }\n\n    if ((ret < 0) && (errno == EINTR))\n        goto reread;\n    if ((ret < 0) && (errno == EAGAIN))\n        return 0;\n\n    if (ret <= 0 &&\n        sock->errfd != -1 &&\n        virFileReadLimFD(sock->errfd, 1024, &errout) >= 0 &&\n        errout != NULL) {\n        size_t elen = strlen(errout);\n        /* remove trailing whitespace */\n        while (elen && g_ascii_isspace(errout[elen - 1]))\n            errout[--elen] = '\\0';\n    }\n\n    if (ret < 0) {\n        if (errout)\n            virReportSystemError(errno,\n                                 _(\"Cannot recv data: %s\"), errout);\n        else\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot recv data\"));\n        ret = -1;\n    } else if (ret == 0) {\n        if (sock->quietEOF) {\n            VIR_DEBUG(\"socket='%p' EOF while reading: errout='%s'\",\n                      socket, NULLSTR(errout));\n\n            ret = -2;\n        } else {\n            if (errout)\n                virReportSystemError(EIO,\n                                     _(\"End of file while reading data: %s\"),\n                                     errout);\n            else\n                virReportSystemError(EIO, \"%s\",\n                                     _(\"End of file while reading data\"));\n\n            ret = -1;\n        }\n    }\n\n    VIR_FREE(errout);\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "errout"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EIO",
            "\"%s\"",
            "_(\"End of file while reading data\")"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"End of file while reading data\""
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EIO",
            "_(\"End of file while reading data: %s\")",
            "errout"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"socket='%p' EOF while reading: errout='%s'\"",
            "socket",
            "NULLSTR(errout)"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "errout"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Cannot recv data\")"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot recv data: %s\")",
            "errout"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_isspace",
          "args": [
            "errout[elen - 1]"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "errout"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadLimFD",
          "args": [
            "sock->errfd",
            "1024",
            "&errout"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadLimFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1416-1438",
          "snippet": "int\nvirFileReadLimFD(int fd, int maxlen, char **buf)\n{\n    size_t len;\n    char *s;\n\n    if (maxlen <= 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    s = saferead_lim(fd, maxlen+1, &len);\n    if (s == NULL)\n        return -1;\n    if (len > maxlen || (int)len != len) {\n        VIR_FREE(s);\n        /* There was at least one byte more than MAXLEN.\n           Set errno accordingly. */\n        errno = EOVERFLOW;\n        return -1;\n    }\n    *buf = s;\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadLimFD(int fd, int maxlen, char **buf)\n{\n    size_t len;\n    char *s;\n\n    if (maxlen <= 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    s = saferead_lim(fd, maxlen+1, &len);\n    if (s == NULL)\n        return -1;\n    if (len > maxlen || (int)len != len) {\n        VIR_FREE(s);\n        /* There was at least one byte more than MAXLEN.\n           Set errno accordingly. */\n        errno = EOVERFLOW;\n        return -1;\n    }\n    *buf = s;\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "sock->fd",
            "buf",
            "len"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDelIOThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-domain.c",
          "lines": "7811-7841",
          "snippet": "int\nvirDomainDelIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=0x%x\", iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonZeroArgGoto(iothread_id, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainDelIOThread) {\n        int ret;\n        ret = conn->driver->domainDelIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirDomainDelIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=0x%x\", iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonZeroArgGoto(iothread_id, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainDelIOThread) {\n        int ret;\n        ret = conn->driver->domainDelIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSSessionRead",
          "args": [
            "sock->tlsSession",
            "buf",
            "len"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSSessionRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "1308-1336",
          "snippet": "ssize_t virNetTLSSessionRead(virNetTLSSessionPtr sess,\n                             char *buf, size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n    ret = gnutls_record_recv(sess->session, buf, len);\n\n    if (ret >= 0)\n        goto cleanup;\n\n    switch (ret) {\n    case GNUTLS_E_AGAIN:\n        errno = EAGAIN;\n        break;\n    case GNUTLS_E_INTERRUPTED:\n        errno = EINTR;\n        break;\n    default:\n        errno = EIO;\n        break;\n    }\n\n    ret = -1;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nssize_t virNetTLSSessionRead(virNetTLSSessionPtr sess,\n                             char *buf, size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n    ret = gnutls_record_recv(sess->session, buf, len);\n\n    if (ret >= 0)\n        goto cleanup;\n\n    switch (ret) {\n    case GNUTLS_E_AGAIN:\n        errno = EAGAIN;\n        break;\n    case GNUTLS_E_INTERRUPTED:\n        errno = EINTR;\n        break;\n    default:\n        errno = EIO;\n        break;\n    }\n\n    ret = -1;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSSessionGetHandshakeStatus",
          "args": [
            "sock->tlsSession"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSSessionGetHandshakeStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "1370-1383",
          "snippet": "virNetTLSSessionHandshakeStatus\nvirNetTLSSessionGetHandshakeStatus(virNetTLSSessionPtr sess)\n{\n    virNetTLSSessionHandshakeStatus ret;\n    virObjectLock(sess);\n    if (sess->handshakeComplete)\n        ret = VIR_NET_TLS_HANDSHAKE_COMPLETE;\n    else if (gnutls_record_get_direction(sess->session) == 0)\n        ret = VIR_NET_TLS_HANDSHAKE_RECVING;\n    else\n        ret = VIR_NET_TLS_HANDSHAKE_SENDING;\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetTLSSessionHandshakeStatus\nvirNetTLSSessionGetHandshakeStatus(virNetTLSSessionPtr sess)\n{\n    virNetTLSSessionHandshakeStatus ret;\n    virObjectLock(sess);\n    if (sess->handshakeComplete)\n        ret = VIR_NET_TLS_HANDSHAKE_COMPLETE;\n    else if (gnutls_record_get_direction(sess->session) == 0)\n        ret = VIR_NET_TLS_HANDSHAKE_RECVING;\n    else\n        ret = VIR_NET_TLS_HANDSHAKE_SENDING;\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketLibsshRead",
          "args": [
            "sock",
            "buf",
            "len"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketLibsshRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1741-1746",
          "snippet": "static ssize_t virNetSocketLibsshRead(virNetSocketPtr sock,\n                                      char *buf,\n                                      size_t len)\n{\n    return virNetLibsshChannelRead(sock->libsshSession, buf, len);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketLibsshRead(virNetSocketPtr sock,\n                                      char *buf,\n                                      size_t len)\n{\n    return virNetLibsshChannelRead(sock->libsshSession, buf, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketLibSSH2Read",
          "args": [
            "sock",
            "buf",
            "len"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketLibSSH2Read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1725-1730",
          "snippet": "static ssize_t virNetSocketLibSSH2Read(virNetSocketPtr sock,\n                                       char *buf,\n                                       size_t len)\n{\n    return virNetSSHChannelRead(sock->sshSession, buf, len);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketLibSSH2Read(virNetSocketPtr sock,\n                                       char *buf,\n                                       size_t len)\n{\n    return virNetSSHChannelRead(sock->sshSession, buf, len);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketReadWire(virNetSocketPtr sock, char *buf, size_t len)\n{\n    char *errout = NULL;\n    ssize_t ret;\n\n#if WITH_SSH2\n    if (sock->sshSession)\n        return virNetSocketLibSSH2Read(sock, buf, len);\n#endif\n\n#if WITH_LIBSSH\n    if (sock->libsshSession)\n        return virNetSocketLibsshRead(sock, buf, len);\n#endif\n\n reread:\n    if (sock->tlsSession &&\n        virNetTLSSessionGetHandshakeStatus(sock->tlsSession) ==\n        VIR_NET_TLS_HANDSHAKE_COMPLETE) {\n        ret = virNetTLSSessionRead(sock->tlsSession, buf, len);\n    } else {\n        ret = read(sock->fd, buf, len);\n    }\n\n    if ((ret < 0) && (errno == EINTR))\n        goto reread;\n    if ((ret < 0) && (errno == EAGAIN))\n        return 0;\n\n    if (ret <= 0 &&\n        sock->errfd != -1 &&\n        virFileReadLimFD(sock->errfd, 1024, &errout) >= 0 &&\n        errout != NULL) {\n        size_t elen = strlen(errout);\n        /* remove trailing whitespace */\n        while (elen && g_ascii_isspace(errout[elen - 1]))\n            errout[--elen] = '\\0';\n    }\n\n    if (ret < 0) {\n        if (errout)\n            virReportSystemError(errno,\n                                 _(\"Cannot recv data: %s\"), errout);\n        else\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Cannot recv data\"));\n        ret = -1;\n    } else if (ret == 0) {\n        if (sock->quietEOF) {\n            VIR_DEBUG(\"socket='%p' EOF while reading: errout='%s'\",\n                      socket, NULLSTR(errout));\n\n            ret = -2;\n        } else {\n            if (errout)\n                virReportSystemError(EIO,\n                                     _(\"End of file while reading data: %s\"),\n                                     errout);\n            else\n                virReportSystemError(EIO, \"%s\",\n                                     _(\"End of file while reading data\"));\n\n            ret = -1;\n        }\n    }\n\n    VIR_FREE(errout);\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketHasPendingData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1756-1766",
    "snippet": "bool virNetSocketHasPendingData(virNetSocketPtr sock G_GNUC_UNUSED)\n{\n    bool hasPending = false;\n    virObjectLock(sock);\n#if WITH_SASL\n    if (sock->saslEncoded)\n        hasPending = true;\n#endif\n    virObjectUnlock(sock);\n    return hasPending;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nbool virNetSocketHasPendingData(virNetSocketPtr sock G_GNUC_UNUSED)\n{\n    bool hasPending = false;\n    virObjectLock(sock);\n#if WITH_SASL\n    if (sock->saslEncoded)\n        hasPending = true;\n#endif\n    virObjectUnlock(sock);\n    return hasPending;\n}"
  },
  {
    "function_name": "virNetSocketLibsshWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1748-1753",
    "snippet": "static ssize_t virNetSocketLibsshWrite(virNetSocketPtr sock,\n                                       const char *buf,\n                                       size_t len)\n{\n    return virNetLibsshChannelWrite(sock->libsshSession, buf, len);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetLibsshChannelWrite",
          "args": [
            "sock->libsshSession",
            "buf",
            "len"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshChannelWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "1379-1434",
          "snippet": "ssize_t\nvirNetLibsshChannelWrite(virNetLibsshSessionPtr sess,\n                         const char *buf,\n                         size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n\n    if (sess->state != VIR_NET_LIBSSH_STATE_HANDSHAKE_COMPLETE) {\n        if (sess->state == VIR_NET_LIBSSH_STATE_ERROR_REMOTE)\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote program terminated with non-zero code: %d\"),\n                           sess->channelCommandReturnValue);\n        else\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Tried to write socket in error state\"));\n        ret = -1;\n        goto cleanup;\n    }\n\n    if (ssh_channel_is_eof(sess->channel)) {\n        if (ssh_channel_get_exit_status(sess->channel)) {\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote program terminated with non-zero code: %d\"),\n                           ssh_channel_get_exit_status(sess->channel));\n            sess->state = VIR_NET_LIBSSH_STATE_ERROR_REMOTE;\n            sess->channelCommandReturnValue = ssh_channel_get_exit_status(sess->channel);\n\n            ret = -1;\n            goto cleanup;\n        }\n\n        sess->state = VIR_NET_LIBSSH_STATE_CLOSED;\n        ret = -1;\n        goto cleanup;\n    }\n\n    ret = ssh_channel_write(sess->channel, buf, len);\n    if (ret == SSH_AGAIN) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (ret < 0) {\n        const char *msg;\n        sess->state = VIR_NET_LIBSSH_STATE_ERROR;\n        msg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"write failed: %s\"), msg);\n    }\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nssize_t\nvirNetLibsshChannelWrite(virNetLibsshSessionPtr sess,\n                         const char *buf,\n                         size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n\n    if (sess->state != VIR_NET_LIBSSH_STATE_HANDSHAKE_COMPLETE) {\n        if (sess->state == VIR_NET_LIBSSH_STATE_ERROR_REMOTE)\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote program terminated with non-zero code: %d\"),\n                           sess->channelCommandReturnValue);\n        else\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Tried to write socket in error state\"));\n        ret = -1;\n        goto cleanup;\n    }\n\n    if (ssh_channel_is_eof(sess->channel)) {\n        if (ssh_channel_get_exit_status(sess->channel)) {\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote program terminated with non-zero code: %d\"),\n                           ssh_channel_get_exit_status(sess->channel));\n            sess->state = VIR_NET_LIBSSH_STATE_ERROR_REMOTE;\n            sess->channelCommandReturnValue = ssh_channel_get_exit_status(sess->channel);\n\n            ret = -1;\n            goto cleanup;\n        }\n\n        sess->state = VIR_NET_LIBSSH_STATE_CLOSED;\n        ret = -1;\n        goto cleanup;\n    }\n\n    ret = ssh_channel_write(sess->channel, buf, len);\n    if (ret == SSH_AGAIN) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (ret < 0) {\n        const char *msg;\n        sess->state = VIR_NET_LIBSSH_STATE_ERROR;\n        msg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_LIBSSH,\n                       _(\"write failed: %s\"), msg);\n    }\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketLibsshWrite(virNetSocketPtr sock,\n                                       const char *buf,\n                                       size_t len)\n{\n    return virNetLibsshChannelWrite(sock->libsshSession, buf, len);\n}"
  },
  {
    "function_name": "virNetSocketLibsshRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1741-1746",
    "snippet": "static ssize_t virNetSocketLibsshRead(virNetSocketPtr sock,\n                                      char *buf,\n                                      size_t len)\n{\n    return virNetLibsshChannelRead(sock->libsshSession, buf, len);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetLibsshChannelRead",
          "args": [
            "sock->libsshSession",
            "buf",
            "len"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshChannelRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "1257-1377",
          "snippet": "ssize_t\nvirNetLibsshChannelRead(virNetLibsshSessionPtr sess,\n                        char *buf,\n                        size_t len)\n{\n    int ret = -1;\n    ssize_t read_n = 0;\n\n    virObjectLock(sess);\n\n    if (sess->state != VIR_NET_LIBSSH_STATE_HANDSHAKE_COMPLETE) {\n        if (sess->state == VIR_NET_LIBSSH_STATE_ERROR_REMOTE)\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote program terminated \"\n                             \"with non-zero code: %d\"),\n                           sess->channelCommandReturnValue);\n        else\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Tried to write socket in error state\"));\n\n        virObjectUnlock(sess);\n        return -1;\n    }\n\n    if (sess->bufUsed > 0) {\n        /* copy the rest (or complete) internal buffer to the output buffer */\n        memcpy(buf,\n               sess->rbuf + sess->bufStart,\n               len > sess->bufUsed ? sess->bufUsed : len);\n\n        if (len >= sess->bufUsed) {\n            read_n = sess->bufUsed;\n\n            sess->bufStart = 0;\n            sess->bufUsed = 0;\n        } else {\n            read_n = len;\n            sess->bufUsed -= len;\n            sess->bufStart += len;\n\n            goto success;\n        }\n    }\n\n    /* continue reading into the buffer supplied */\n    if (read_n < len) {\n        ret = ssh_channel_read_nonblocking(sess->channel,\n                                           buf + read_n,\n                                           len - read_n,\n                                           0);\n\n        if (ret == SSH_EOF || (ret == 0 && ssh_channel_is_eof(sess->channel)))\n            goto eof;\n\n        if (ret == SSH_AGAIN)\n            goto success;\n\n        if (ret < 0)\n            goto error;\n\n        read_n += ret;\n    }\n\n    /* try to read something into the internal buffer */\n    if (sess->bufUsed == 0) {\n        ret = ssh_channel_read_nonblocking(sess->channel,\n                                           sess->rbuf,\n                                           VIR_NET_LIBSSH_BUFFER_SIZE,\n                                           0);\n\n        if (ret == SSH_EOF || (ret == 0 && ssh_channel_is_eof(sess->channel)))\n            goto eof;\n\n        if (ret == SSH_AGAIN)\n            goto success;\n\n        if (ret < 0)\n            goto error;\n\n        sess->bufUsed = ret;\n        sess->bufStart = 0;\n    }\n\n    if (read_n == 0) {\n        /* get rid of data in stderr stream */\n        ret = ssh_channel_read_nonblocking(sess->channel,\n                                           sess->rbuf,\n                                           VIR_NET_LIBSSH_BUFFER_SIZE - 1,\n                                           1);\n        if (ret > 0) {\n            sess->rbuf[ret] = '\\0';\n            VIR_DEBUG(\"flushing stderr, data='%s'\",  sess->rbuf);\n        }\n    }\n\n    if (ssh_channel_is_eof(sess->channel)) {\n eof:\n        if (ssh_channel_get_exit_status(sess->channel)) {\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote command terminated with non-zero code: %d\"),\n                           ssh_channel_get_exit_status(sess->channel));\n            sess->channelCommandReturnValue = ssh_channel_get_exit_status(sess->channel);\n            sess->state = VIR_NET_LIBSSH_STATE_ERROR_REMOTE;\n            virObjectUnlock(sess);\n            return -1;\n        }\n\n        sess->state = VIR_NET_LIBSSH_STATE_CLOSED;\n        virObjectUnlock(sess);\n        return -1;\n    }\n\n success:\n    virObjectUnlock(sess);\n    return read_n;\n\n error:\n    sess->state = VIR_NET_LIBSSH_STATE_ERROR;\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_NET_LIBSSH_BUFFER_SIZE  1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\n#define VIR_NET_LIBSSH_BUFFER_SIZE  1024\n\nssize_t\nvirNetLibsshChannelRead(virNetLibsshSessionPtr sess,\n                        char *buf,\n                        size_t len)\n{\n    int ret = -1;\n    ssize_t read_n = 0;\n\n    virObjectLock(sess);\n\n    if (sess->state != VIR_NET_LIBSSH_STATE_HANDSHAKE_COMPLETE) {\n        if (sess->state == VIR_NET_LIBSSH_STATE_ERROR_REMOTE)\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote program terminated \"\n                             \"with non-zero code: %d\"),\n                           sess->channelCommandReturnValue);\n        else\n            virReportError(VIR_ERR_LIBSSH, \"%s\",\n                           _(\"Tried to write socket in error state\"));\n\n        virObjectUnlock(sess);\n        return -1;\n    }\n\n    if (sess->bufUsed > 0) {\n        /* copy the rest (or complete) internal buffer to the output buffer */\n        memcpy(buf,\n               sess->rbuf + sess->bufStart,\n               len > sess->bufUsed ? sess->bufUsed : len);\n\n        if (len >= sess->bufUsed) {\n            read_n = sess->bufUsed;\n\n            sess->bufStart = 0;\n            sess->bufUsed = 0;\n        } else {\n            read_n = len;\n            sess->bufUsed -= len;\n            sess->bufStart += len;\n\n            goto success;\n        }\n    }\n\n    /* continue reading into the buffer supplied */\n    if (read_n < len) {\n        ret = ssh_channel_read_nonblocking(sess->channel,\n                                           buf + read_n,\n                                           len - read_n,\n                                           0);\n\n        if (ret == SSH_EOF || (ret == 0 && ssh_channel_is_eof(sess->channel)))\n            goto eof;\n\n        if (ret == SSH_AGAIN)\n            goto success;\n\n        if (ret < 0)\n            goto error;\n\n        read_n += ret;\n    }\n\n    /* try to read something into the internal buffer */\n    if (sess->bufUsed == 0) {\n        ret = ssh_channel_read_nonblocking(sess->channel,\n                                           sess->rbuf,\n                                           VIR_NET_LIBSSH_BUFFER_SIZE,\n                                           0);\n\n        if (ret == SSH_EOF || (ret == 0 && ssh_channel_is_eof(sess->channel)))\n            goto eof;\n\n        if (ret == SSH_AGAIN)\n            goto success;\n\n        if (ret < 0)\n            goto error;\n\n        sess->bufUsed = ret;\n        sess->bufStart = 0;\n    }\n\n    if (read_n == 0) {\n        /* get rid of data in stderr stream */\n        ret = ssh_channel_read_nonblocking(sess->channel,\n                                           sess->rbuf,\n                                           VIR_NET_LIBSSH_BUFFER_SIZE - 1,\n                                           1);\n        if (ret > 0) {\n            sess->rbuf[ret] = '\\0';\n            VIR_DEBUG(\"flushing stderr, data='%s'\",  sess->rbuf);\n        }\n    }\n\n    if (ssh_channel_is_eof(sess->channel)) {\n eof:\n        if (ssh_channel_get_exit_status(sess->channel)) {\n            virReportError(VIR_ERR_LIBSSH,\n                           _(\"Remote command terminated with non-zero code: %d\"),\n                           ssh_channel_get_exit_status(sess->channel));\n            sess->channelCommandReturnValue = ssh_channel_get_exit_status(sess->channel);\n            sess->state = VIR_NET_LIBSSH_STATE_ERROR_REMOTE;\n            virObjectUnlock(sess);\n            return -1;\n        }\n\n        sess->state = VIR_NET_LIBSSH_STATE_CLOSED;\n        virObjectUnlock(sess);\n        return -1;\n    }\n\n success:\n    virObjectUnlock(sess);\n    return read_n;\n\n error:\n    sess->state = VIR_NET_LIBSSH_STATE_ERROR;\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketLibsshRead(virNetSocketPtr sock,\n                                      char *buf,\n                                      size_t len)\n{\n    return virNetLibsshChannelRead(sock->libsshSession, buf, len);\n}"
  },
  {
    "function_name": "virNetSocketLibSSH2Write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1732-1737",
    "snippet": "static ssize_t virNetSocketLibSSH2Write(virNetSocketPtr sock,\n                                        const char *buf,\n                                        size_t len)\n{\n    return virNetSSHChannelWrite(sock->sshSession, buf, len);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSSHChannelWrite",
          "args": [
            "sock->sshSession",
            "buf",
            "len"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSSHChannelWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsshsession.c",
          "lines": "1425-1480",
          "snippet": "ssize_t\nvirNetSSHChannelWrite(virNetSSHSessionPtr sess,\n                      const char *buf,\n                      size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n\n    if (sess->state != VIR_NET_SSH_STATE_HANDSHAKE_COMPLETE) {\n        if (sess->state == VIR_NET_SSH_STATE_ERROR_REMOTE)\n            virReportError(VIR_ERR_SSH,\n                           _(\"Remote program terminated with non-zero code: %d\"),\n                           sess->channelCommandReturnValue);\n        else\n            virReportError(VIR_ERR_SSH, \"%s\",\n                           _(\"Tried to write socket in error state\"));\n        ret = -1;\n        goto cleanup;\n    }\n\n    if (libssh2_channel_eof(sess->channel)) {\n        if (libssh2_channel_get_exit_status(sess->channel)) {\n            virReportError(VIR_ERR_SSH,\n                           _(\"Remote program terminated with non-zero code: %d\"),\n                           libssh2_channel_get_exit_status(sess->channel));\n            sess->state = VIR_NET_SSH_STATE_ERROR_REMOTE;\n            sess->channelCommandReturnValue = libssh2_channel_get_exit_status(sess->channel);\n\n            ret = -1;\n            goto cleanup;\n        }\n\n        sess->state = VIR_NET_SSH_STATE_CLOSED;\n        ret = -1;\n        goto cleanup;\n    }\n\n    ret = libssh2_channel_write(sess->channel, buf, len);\n    if (ret == LIBSSH2_ERROR_EAGAIN) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (ret < 0) {\n        char *msg;\n        sess->state = VIR_NET_SSH_STATE_ERROR;\n        libssh2_session_last_error(sess->session, &msg, NULL, 0);\n        virReportError(VIR_ERR_SSH,\n                       _(\"write failed: %s\"), msg);\n    }\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"virnetsshsession.h\"",
            "#include <libssh2_publickey.h>",
            "#include <libssh2.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"virnetsshsession.h\"\n#include <libssh2_publickey.h>\n#include <libssh2.h>\n#include <config.h>\n\nssize_t\nvirNetSSHChannelWrite(virNetSSHSessionPtr sess,\n                      const char *buf,\n                      size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n\n    if (sess->state != VIR_NET_SSH_STATE_HANDSHAKE_COMPLETE) {\n        if (sess->state == VIR_NET_SSH_STATE_ERROR_REMOTE)\n            virReportError(VIR_ERR_SSH,\n                           _(\"Remote program terminated with non-zero code: %d\"),\n                           sess->channelCommandReturnValue);\n        else\n            virReportError(VIR_ERR_SSH, \"%s\",\n                           _(\"Tried to write socket in error state\"));\n        ret = -1;\n        goto cleanup;\n    }\n\n    if (libssh2_channel_eof(sess->channel)) {\n        if (libssh2_channel_get_exit_status(sess->channel)) {\n            virReportError(VIR_ERR_SSH,\n                           _(\"Remote program terminated with non-zero code: %d\"),\n                           libssh2_channel_get_exit_status(sess->channel));\n            sess->state = VIR_NET_SSH_STATE_ERROR_REMOTE;\n            sess->channelCommandReturnValue = libssh2_channel_get_exit_status(sess->channel);\n\n            ret = -1;\n            goto cleanup;\n        }\n\n        sess->state = VIR_NET_SSH_STATE_CLOSED;\n        ret = -1;\n        goto cleanup;\n    }\n\n    ret = libssh2_channel_write(sess->channel, buf, len);\n    if (ret == LIBSSH2_ERROR_EAGAIN) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (ret < 0) {\n        char *msg;\n        sess->state = VIR_NET_SSH_STATE_ERROR;\n        libssh2_session_last_error(sess->session, &msg, NULL, 0);\n        virReportError(VIR_ERR_SSH,\n                       _(\"write failed: %s\"), msg);\n    }\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketLibSSH2Write(virNetSocketPtr sock,\n                                        const char *buf,\n                                        size_t len)\n{\n    return virNetSSHChannelWrite(sock->sshSession, buf, len);\n}"
  },
  {
    "function_name": "virNetSocketLibSSH2Read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1725-1730",
    "snippet": "static ssize_t virNetSocketLibSSH2Read(virNetSocketPtr sock,\n                                       char *buf,\n                                       size_t len)\n{\n    return virNetSSHChannelRead(sock->sshSession, buf, len);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSSHChannelRead",
          "args": [
            "sock->sshSession",
            "buf",
            "len"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSSHChannelRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsshsession.c",
          "lines": "1313-1423",
          "snippet": "ssize_t\nvirNetSSHChannelRead(virNetSSHSessionPtr sess,\n                     char *buf,\n                     size_t len)\n{\n    ssize_t ret = -1;\n    ssize_t read_n = 0;\n\n    virObjectLock(sess);\n\n    if (sess->state != VIR_NET_SSH_STATE_HANDSHAKE_COMPLETE) {\n        if (sess->state == VIR_NET_SSH_STATE_ERROR_REMOTE)\n            virReportError(VIR_ERR_SSH,\n                           _(\"Remote program terminated \"\n                             \"with non-zero code: %d\"),\n                           sess->channelCommandReturnValue);\n        else\n            virReportError(VIR_ERR_SSH, \"%s\",\n                           _(\"Tried to write socket in error state\"));\n\n        virObjectUnlock(sess);\n        return -1;\n    }\n\n    if (sess->bufUsed > 0) {\n        /* copy the rest (or complete) internal buffer to the output buffer */\n        memcpy(buf,\n               sess->rbuf + sess->bufStart,\n               len > sess->bufUsed ? sess->bufUsed : len);\n\n        if (len >= sess->bufUsed) {\n            read_n = sess->bufUsed;\n\n            sess->bufStart = 0;\n            sess->bufUsed = 0;\n        } else {\n            read_n = len;\n            sess->bufUsed -= len;\n            sess->bufStart += len;\n\n            goto success;\n        }\n    }\n\n    /* continue reading into the buffer supplied */\n    if (read_n < len) {\n        ret = libssh2_channel_read(sess->channel,\n                                   buf + read_n,\n                                   len - read_n);\n\n        if (ret == LIBSSH2_ERROR_EAGAIN)\n            goto success;\n\n        if (ret < 0)\n            goto error;\n\n        read_n += ret;\n    }\n\n    /* try to read something into the internal buffer */\n    if (sess->bufUsed == 0) {\n        ret = libssh2_channel_read(sess->channel,\n                                   sess->rbuf,\n                                   VIR_NET_SSH_BUFFER_SIZE);\n\n        if (ret == LIBSSH2_ERROR_EAGAIN)\n            goto success;\n\n        if (ret < 0)\n            goto error;\n\n        sess->bufUsed = ret;\n        sess->bufStart = 0;\n    }\n\n    if (read_n == 0) {\n        /* get rid of data in stderr stream */\n        ret = libssh2_channel_read_stderr(sess->channel,\n                                          sess->rbuf,\n                                          VIR_NET_SSH_BUFFER_SIZE - 1);\n        if (ret > 0) {\n            sess->rbuf[ret] = '\\0';\n            VIR_DEBUG(\"flushing stderr, data='%s'\",  sess->rbuf);\n        }\n    }\n\n    if (libssh2_channel_eof(sess->channel)) {\n        if (libssh2_channel_get_exit_status(sess->channel)) {\n            virReportError(VIR_ERR_SSH,\n                           _(\"Remote command terminated with non-zero code: %d\"),\n                           libssh2_channel_get_exit_status(sess->channel));\n            sess->channelCommandReturnValue = libssh2_channel_get_exit_status(sess->channel);\n            sess->state = VIR_NET_SSH_STATE_ERROR_REMOTE;\n            virObjectUnlock(sess);\n            return -1;\n        }\n\n        sess->state = VIR_NET_SSH_STATE_CLOSED;\n        virObjectUnlock(sess);\n        return -1;\n    }\n\n success:\n    virObjectUnlock(sess);\n    return read_n;\n\n error:\n    sess->state = VIR_NET_SSH_STATE_ERROR;\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"virnetsshsession.h\"",
            "#include <libssh2_publickey.h>",
            "#include <libssh2.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_NET_SSH_BUFFER_SIZE  1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"virnetsshsession.h\"\n#include <libssh2_publickey.h>\n#include <libssh2.h>\n#include <config.h>\n\n#define VIR_NET_SSH_BUFFER_SIZE  1024\n\nssize_t\nvirNetSSHChannelRead(virNetSSHSessionPtr sess,\n                     char *buf,\n                     size_t len)\n{\n    ssize_t ret = -1;\n    ssize_t read_n = 0;\n\n    virObjectLock(sess);\n\n    if (sess->state != VIR_NET_SSH_STATE_HANDSHAKE_COMPLETE) {\n        if (sess->state == VIR_NET_SSH_STATE_ERROR_REMOTE)\n            virReportError(VIR_ERR_SSH,\n                           _(\"Remote program terminated \"\n                             \"with non-zero code: %d\"),\n                           sess->channelCommandReturnValue);\n        else\n            virReportError(VIR_ERR_SSH, \"%s\",\n                           _(\"Tried to write socket in error state\"));\n\n        virObjectUnlock(sess);\n        return -1;\n    }\n\n    if (sess->bufUsed > 0) {\n        /* copy the rest (or complete) internal buffer to the output buffer */\n        memcpy(buf,\n               sess->rbuf + sess->bufStart,\n               len > sess->bufUsed ? sess->bufUsed : len);\n\n        if (len >= sess->bufUsed) {\n            read_n = sess->bufUsed;\n\n            sess->bufStart = 0;\n            sess->bufUsed = 0;\n        } else {\n            read_n = len;\n            sess->bufUsed -= len;\n            sess->bufStart += len;\n\n            goto success;\n        }\n    }\n\n    /* continue reading into the buffer supplied */\n    if (read_n < len) {\n        ret = libssh2_channel_read(sess->channel,\n                                   buf + read_n,\n                                   len - read_n);\n\n        if (ret == LIBSSH2_ERROR_EAGAIN)\n            goto success;\n\n        if (ret < 0)\n            goto error;\n\n        read_n += ret;\n    }\n\n    /* try to read something into the internal buffer */\n    if (sess->bufUsed == 0) {\n        ret = libssh2_channel_read(sess->channel,\n                                   sess->rbuf,\n                                   VIR_NET_SSH_BUFFER_SIZE);\n\n        if (ret == LIBSSH2_ERROR_EAGAIN)\n            goto success;\n\n        if (ret < 0)\n            goto error;\n\n        sess->bufUsed = ret;\n        sess->bufStart = 0;\n    }\n\n    if (read_n == 0) {\n        /* get rid of data in stderr stream */\n        ret = libssh2_channel_read_stderr(sess->channel,\n                                          sess->rbuf,\n                                          VIR_NET_SSH_BUFFER_SIZE - 1);\n        if (ret > 0) {\n            sess->rbuf[ret] = '\\0';\n            VIR_DEBUG(\"flushing stderr, data='%s'\",  sess->rbuf);\n        }\n    }\n\n    if (libssh2_channel_eof(sess->channel)) {\n        if (libssh2_channel_get_exit_status(sess->channel)) {\n            virReportError(VIR_ERR_SSH,\n                           _(\"Remote command terminated with non-zero code: %d\"),\n                           libssh2_channel_get_exit_status(sess->channel));\n            sess->channelCommandReturnValue = libssh2_channel_get_exit_status(sess->channel);\n            sess->state = VIR_NET_SSH_STATE_ERROR_REMOTE;\n            virObjectUnlock(sess);\n            return -1;\n        }\n\n        sess->state = VIR_NET_SSH_STATE_CLOSED;\n        virObjectUnlock(sess);\n        return -1;\n    }\n\n success:\n    virObjectUnlock(sess);\n    return read_n;\n\n error:\n    sess->state = VIR_NET_SSH_STATE_ERROR;\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketLibSSH2Read(virNetSocketPtr sock,\n                                       char *buf,\n                                       size_t len)\n{\n    return virNetSSHChannelRead(sock->sshSession, buf, len);\n}"
  },
  {
    "function_name": "virNetSocketHasCachedData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1701-1722",
    "snippet": "bool virNetSocketHasCachedData(virNetSocketPtr sock G_GNUC_UNUSED)\n{\n    bool hasCached = false;\n    virObjectLock(sock);\n\n#if WITH_SSH2\n    if (virNetSSHSessionHasCachedData(sock->sshSession))\n        hasCached = true;\n#endif\n\n#if WITH_LIBSSH\n    if (virNetLibsshSessionHasCachedData(sock->libsshSession))\n        hasCached = true;\n#endif\n\n#if WITH_SASL\n    if (sock->saslDecoded)\n        hasCached = true;\n#endif\n    virObjectUnlock(sock);\n    return hasCached;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionHasCachedData",
          "args": [
            "sock->libsshSession"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionHasCachedData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "1436-1450",
          "snippet": "bool\nvirNetLibsshSessionHasCachedData(virNetLibsshSessionPtr sess)\n{\n    bool ret;\n\n    if (!sess)\n        return false;\n\n    virObjectLock(sess);\n\n    ret = sess->bufUsed > 0;\n\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nbool\nvirNetLibsshSessionHasCachedData(virNetLibsshSessionPtr sess)\n{\n    bool ret;\n\n    if (!sess)\n        return false;\n\n    virObjectLock(sess);\n\n    ret = sess->bufUsed > 0;\n\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSSHSessionHasCachedData",
          "args": [
            "sock->sshSession"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSSHSessionHasCachedData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsshsession.c",
          "lines": "1482-1496",
          "snippet": "bool\nvirNetSSHSessionHasCachedData(virNetSSHSessionPtr sess)\n{\n    bool ret;\n\n    if (!sess)\n        return false;\n\n    virObjectLock(sess);\n\n    ret = sess->bufUsed > 0;\n\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"virnetsshsession.h\"",
            "#include <libssh2_publickey.h>",
            "#include <libssh2.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"virnetsshsession.h\"\n#include <libssh2_publickey.h>\n#include <libssh2.h>\n#include <config.h>\n\nbool\nvirNetSSHSessionHasCachedData(virNetSSHSessionPtr sess)\n{\n    bool ret;\n\n    if (!sess)\n        return false;\n\n    virObjectLock(sess);\n\n    ret = sess->bufUsed > 0;\n\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nbool virNetSocketHasCachedData(virNetSocketPtr sock G_GNUC_UNUSED)\n{\n    bool hasCached = false;\n    virObjectLock(sock);\n\n#if WITH_SSH2\n    if (virNetSSHSessionHasCachedData(sock->sshSession))\n        hasCached = true;\n#endif\n\n#if WITH_LIBSSH\n    if (virNetLibsshSessionHasCachedData(sock->libsshSession))\n        hasCached = true;\n#endif\n\n#if WITH_SASL\n    if (sock->saslDecoded)\n        hasCached = true;\n#endif\n    virObjectUnlock(sock);\n    return hasCached;\n}"
  },
  {
    "function_name": "virNetSocketSetSASLSession",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1690-1697",
    "snippet": "void virNetSocketSetSASLSession(virNetSocketPtr sock,\n                                virNetSASLSessionPtr sess)\n{\n    virObjectLock(sock);\n    virObjectUnref(sock->saslSession);\n    sock->saslSession = virObjectRef(sess);\n    virObjectUnlock(sock);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "sess"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sock->saslSession"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketSetSASLSession(virNetSocketPtr sock,\n                                virNetSASLSessionPtr sess)\n{\n    virObjectLock(sock);\n    virObjectUnref(sock->saslSession);\n    sock->saslSession = virObjectRef(sess);\n    virObjectUnlock(sock);\n}"
  },
  {
    "function_name": "virNetSocketSetTLSSession",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1676-1687",
    "snippet": "void virNetSocketSetTLSSession(virNetSocketPtr sock,\n                               virNetTLSSessionPtr sess)\n{\n    virObjectLock(sock);\n    virObjectUnref(sock->tlsSession);\n    sock->tlsSession = virObjectRef(sess);\n    virNetTLSSessionSetIOCallbacks(sess,\n                                   virNetSocketTLSSessionWrite,\n                                   virNetSocketTLSSessionRead,\n                                   sock);\n    virObjectUnlock(sock);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSSessionSetIOCallbacks",
          "args": [
            "sess",
            "virNetSocketTLSSessionWrite",
            "virNetSocketTLSSessionRead",
            "sock"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSSessionSetIOCallbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "1262-1272",
          "snippet": "void virNetTLSSessionSetIOCallbacks(virNetTLSSessionPtr sess,\n                                    virNetTLSSessionWriteFunc writeFunc,\n                                    virNetTLSSessionReadFunc readFunc,\n                                    void *opaque)\n{\n    virObjectLock(sess);\n    sess->writeFunc = writeFunc;\n    sess->readFunc = readFunc;\n    sess->opaque = opaque;\n    virObjectUnlock(sess);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetTLSSessionSetIOCallbacks(virNetTLSSessionPtr sess,\n                                    virNetTLSSessionWriteFunc writeFunc,\n                                    virNetTLSSessionReadFunc readFunc,\n                                    void *opaque)\n{\n    virObjectLock(sess);\n    sess->writeFunc = writeFunc;\n    sess->readFunc = readFunc;\n    sess->opaque = opaque;\n    virObjectUnlock(sess);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "sess"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sock->tlsSession"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketSetTLSSession(virNetSocketPtr sock,\n                               virNetTLSSessionPtr sess)\n{\n    virObjectLock(sock);\n    virObjectUnref(sock->tlsSession);\n    sock->tlsSession = virObjectRef(sess);\n    virNetTLSSessionSetIOCallbacks(sess,\n                                   virNetSocketTLSSessionWrite,\n                                   virNetSocketTLSSessionRead,\n                                   sock);\n    virObjectUnlock(sock);\n}"
  },
  {
    "function_name": "virNetSocketTLSSessionRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1667-1673",
    "snippet": "static ssize_t virNetSocketTLSSessionRead(char *buf,\n                                          size_t len,\n                                          void *opaque)\n{\n    virNetSocketPtr sock = opaque;\n    return read(sock->fd, buf, len);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read",
          "args": [
            "sock->fd",
            "buf",
            "len"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDelIOThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-domain.c",
          "lines": "7811-7841",
          "snippet": "int\nvirDomainDelIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=0x%x\", iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonZeroArgGoto(iothread_id, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainDelIOThread) {\n        int ret;\n        ret = conn->driver->domainDelIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirDomainDelIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=0x%x\", iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonZeroArgGoto(iothread_id, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainDelIOThread) {\n        int ret;\n        ret = conn->driver->domainDelIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketTLSSessionRead(char *buf,\n                                          size_t len,\n                                          void *opaque)\n{\n    virNetSocketPtr sock = opaque;\n    return read(sock->fd, buf, len);\n}"
  },
  {
    "function_name": "virNetSocketTLSSessionWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1658-1664",
    "snippet": "static ssize_t virNetSocketTLSSessionWrite(const char *buf,\n                                           size_t len,\n                                           void *opaque)\n{\n    virNetSocketPtr sock = opaque;\n    return write(sock->fd, buf, len);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "sock->fd",
            "buf",
            "len"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic ssize_t virNetSocketTLSSessionWrite(const char *buf,\n                                           size_t len,\n                                           void *opaque)\n{\n    virNetSocketPtr sock = opaque;\n    return write(sock->fd, buf, len);\n}"
  },
  {
    "function_name": "virNetSocketRemoteAddrStringURI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1653-1656",
    "snippet": "const char *virNetSocketRemoteAddrStringURI(virNetSocketPtr sock)\n{\n    return sock->remoteAddrStrURI;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nconst char *virNetSocketRemoteAddrStringURI(virNetSocketPtr sock)\n{\n    return sock->remoteAddrStrURI;\n}"
  },
  {
    "function_name": "virNetSocketRemoteAddrStringSASL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1648-1651",
    "snippet": "const char *virNetSocketRemoteAddrStringSASL(virNetSocketPtr sock)\n{\n    return sock->remoteAddrStrSASL;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nconst char *virNetSocketRemoteAddrStringSASL(virNetSocketPtr sock)\n{\n    return sock->remoteAddrStrSASL;\n}"
  },
  {
    "function_name": "virNetSocketLocalAddrStringSASL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1643-1646",
    "snippet": "const char *virNetSocketLocalAddrStringSASL(virNetSocketPtr sock)\n{\n    return sock->localAddrStrSASL;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nconst char *virNetSocketLocalAddrStringSASL(virNetSocketPtr sock)\n{\n    return sock->localAddrStrSASL;\n}"
  },
  {
    "function_name": "virNetSocketSetBlocking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1632-1640",
    "snippet": "int virNetSocketSetBlocking(virNetSocketPtr sock,\n                            bool blocking)\n{\n    int ret;\n    virObjectLock(sock);\n    ret = virSetBlocking(sock->fd, blocking);\n    virObjectUnlock(sock);\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetBlocking",
          "args": [
            "sock->fd",
            "blocking"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "virSetBlocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "113-121",
          "snippet": "int virSetBlocking(int fd, bool blocking)\n{\n    unsigned long arg = blocking ? 0 : 1;\n\n    if (ioctlsocket(fd, FIONBIO, &arg) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetBlocking(int fd, bool blocking)\n{\n    unsigned long arg = blocking ? 0 : 1;\n\n    if (ioctlsocket(fd, FIONBIO, &arg) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketSetBlocking(virNetSocketPtr sock,\n                            bool blocking)\n{\n    int ret;\n    virObjectLock(sock);\n    ret = virSetBlocking(sock->fd, blocking);\n    virObjectUnlock(sock);\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketGetSELinuxContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1623-1628",
    "snippet": "int virNetSocketGetSELinuxContext(virNetSocketPtr sock G_GNUC_UNUSED,\n                                  char **context)\n{\n    *context = NULL;\n    return 0;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketGetSELinuxContext(virNetSocketPtr sock G_GNUC_UNUSED,\n                                  char **context)\n{\n    *context = NULL;\n    return 0;\n}"
  },
  {
    "function_name": "virNetSocketGetSELinuxContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1595-1621",
    "snippet": "int virNetSocketGetSELinuxContext(virNetSocketPtr sock,\n                                  char **context)\n{\n    security_context_t seccon = NULL;\n    int ret = -1;\n\n    *context = NULL;\n\n    virObjectLock(sock);\n    if (getpeercon(sock->fd, &seccon) < 0) {\n        if (errno == ENOSYS || errno == ENOPROTOOPT) {\n            ret = 0;\n            goto cleanup;\n        }\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query peer security context\"));\n        goto cleanup;\n    }\n\n    *context = g_strdup(seccon);\n\n    ret = 0;\n cleanup:\n    freecon(seccon);\n    virObjectUnlock(sock);\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "seccon"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "seccon"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to query peer security context\")"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpeercon",
          "args": [
            "sock->fd",
            "&seccon"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketGetSELinuxContext(virNetSocketPtr sock,\n                                  char **context)\n{\n    security_context_t seccon = NULL;\n    int ret = -1;\n\n    *context = NULL;\n\n    virObjectLock(sock);\n    if (getpeercon(sock->fd, &seccon) < 0) {\n        if (errno == ENOSYS || errno == ENOPROTOOPT) {\n            ret = 0;\n            goto cleanup;\n        }\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to query peer security context\"));\n        goto cleanup;\n    }\n\n    *context = g_strdup(seccon);\n\n    ret = 0;\n cleanup:\n    freecon(seccon);\n    virObjectUnlock(sock);\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketGetUNIXIdentity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1581-1591",
    "snippet": "int virNetSocketGetUNIXIdentity(virNetSocketPtr sock G_GNUC_UNUSED,\n                                uid_t *uid G_GNUC_UNUSED,\n                                gid_t *gid G_GNUC_UNUSED,\n                                pid_t *pid G_GNUC_UNUSED,\n                                unsigned long long *timestamp G_GNUC_UNUSED)\n{\n    /* XXX Many more OS support UNIX socket credentials we could port to. See dbus ....*/\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Client socket identity not available\"));\n    return -1;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Client socket identity not available\")"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Client socket identity not available\""
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketGetUNIXIdentity(virNetSocketPtr sock G_GNUC_UNUSED,\n                                uid_t *uid G_GNUC_UNUSED,\n                                gid_t *gid G_GNUC_UNUSED,\n                                pid_t *pid G_GNUC_UNUSED,\n                                unsigned long long *timestamp G_GNUC_UNUSED)\n{\n    /* XXX Many more OS support UNIX socket credentials we could port to. See dbus ....*/\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Client socket identity not available\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetSocketGetUNIXIdentity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1513-1579",
    "snippet": "int virNetSocketGetUNIXIdentity(virNetSocketPtr sock,\n                                uid_t *uid,\n                                gid_t *gid,\n                                pid_t *pid,\n                                unsigned long long *timestamp)\n{\n    struct xucred cr;\n    socklen_t cr_len = sizeof(cr);\n    int ret = -1;\n\n    virObjectLock(sock);\n\n    cr.cr_ngroups = -1;\n    if (getsockopt(sock->fd, VIR_SOL_PEERCRED, LOCAL_PEERCRED, &cr, &cr_len) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Failed to get client socket identity\"));\n        goto cleanup;\n    }\n\n    if (cr.cr_version != XUCRED_VERSION) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Failed to get valid client socket identity\"));\n        goto cleanup;\n    }\n\n    if (cr.cr_ngroups <= 0 || cr.cr_ngroups > NGROUPS) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Failed to get valid client socket identity groups\"));\n        goto cleanup;\n    }\n\n    /* PID and process creation time are not supported on BSDs by\n     * LOCAL_PEERCRED.\n     */\n    *pid = -1;\n    *timestamp = -1;\n    *uid = cr.cr_uid;\n    *gid = cr.cr_gid;\n\n# ifdef LOCAL_PEERPID\n    /* Exists on Mac OS X 10.8 for retrieving the peer's PID */\n    cr_len = sizeof(*pid);\n\n    if (getsockopt(sock->fd, VIR_SOL_PEERCRED, LOCAL_PEERPID, pid, &cr_len) < 0) {\n        /* Ensure this is set to something sane as there are no guarantees\n         * as to what its set to now.\n         */\n        *pid = -1;\n\n        /* If this was built on a system with LOCAL_PEERPID defined but\n         * the kernel doesn't support it we'll get back EOPNOTSUPP so\n         * treat all errors but EOPNOTSUPP as fatal\n         */\n        if (errno != EOPNOTSUPP) {\n            virReportSystemError(errno, \"%s\",\n                    _(\"Failed to get client socket PID\"));\n            goto cleanup;\n        }\n    }\n# endif\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sock);\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Failed to get client socket PID\")"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to get client socket PID\""
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "sock->fd",
            "VIR_SOL_PEERCRED",
            "LOCAL_PEERPID",
            "pid",
            "&cr_len"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "vir_getsockopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "311-328",
          "snippet": "int\nvir_getsockopt(int fd, int level, int optname,\n               void *optval, socklen_t *optlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockopt(sk, level, optname, optval, optlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_getsockopt(int fd, int level, int optname,\n               void *optval, socklen_t *optlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockopt(sk, level, optname, optval, optlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "\"%s\"",
            "_(\"Failed to get valid client socket identity groups\")"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "\"%s\"",
            "_(\"Failed to get valid client socket identity\")"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Failed to get client socket identity\")"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketGetUNIXIdentity(virNetSocketPtr sock,\n                                uid_t *uid,\n                                gid_t *gid,\n                                pid_t *pid,\n                                unsigned long long *timestamp)\n{\n    struct xucred cr;\n    socklen_t cr_len = sizeof(cr);\n    int ret = -1;\n\n    virObjectLock(sock);\n\n    cr.cr_ngroups = -1;\n    if (getsockopt(sock->fd, VIR_SOL_PEERCRED, LOCAL_PEERCRED, &cr, &cr_len) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Failed to get client socket identity\"));\n        goto cleanup;\n    }\n\n    if (cr.cr_version != XUCRED_VERSION) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Failed to get valid client socket identity\"));\n        goto cleanup;\n    }\n\n    if (cr.cr_ngroups <= 0 || cr.cr_ngroups > NGROUPS) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Failed to get valid client socket identity groups\"));\n        goto cleanup;\n    }\n\n    /* PID and process creation time are not supported on BSDs by\n     * LOCAL_PEERCRED.\n     */\n    *pid = -1;\n    *timestamp = -1;\n    *uid = cr.cr_uid;\n    *gid = cr.cr_gid;\n\n# ifdef LOCAL_PEERPID\n    /* Exists on Mac OS X 10.8 for retrieving the peer's PID */\n    cr_len = sizeof(*pid);\n\n    if (getsockopt(sock->fd, VIR_SOL_PEERCRED, LOCAL_PEERPID, pid, &cr_len) < 0) {\n        /* Ensure this is set to something sane as there are no guarantees\n         * as to what its set to now.\n         */\n        *pid = -1;\n\n        /* If this was built on a system with LOCAL_PEERPID defined but\n         * the kernel doesn't support it we'll get back EOPNOTSUPP so\n         * treat all errors but EOPNOTSUPP as fatal\n         */\n        if (errno != EOPNOTSUPP) {\n            virReportSystemError(errno, \"%s\",\n                    _(\"Failed to get client socket PID\"));\n            goto cleanup;\n        }\n    }\n# endif\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sock);\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketGetUNIXIdentity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1456-1494",
    "snippet": "int virNetSocketGetUNIXIdentity(virNetSocketPtr sock,\n                                uid_t *uid,\n                                gid_t *gid,\n                                pid_t *pid,\n                                unsigned long long *timestamp)\n{\n# if defined(HAVE_STRUCT_SOCKPEERCRED)\n    struct sockpeercred cr;\n# else\n    struct ucred cr;\n# endif\n    socklen_t cr_len = sizeof(cr);\n    int ret = -1;\n\n    virObjectLock(sock);\n\n    if (getsockopt(sock->fd, SOL_SOCKET, SO_PEERCRED, &cr, &cr_len) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Failed to get client socket identity\"));\n        goto cleanup;\n    }\n\n    *timestamp = -1;\n    if (cr.pid && virProcessGetStartTime(cr.pid, timestamp) < 0)\n        goto cleanup;\n\n    if (cr.pid)\n        *pid = cr.pid;\n    else\n        *pid = -1;\n    *uid = cr.uid;\n    *gid = cr.gid;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sock);\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessGetStartTime",
          "args": [
            "cr.pid",
            "timestamp"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessGetStartTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "1046-1056",
          "snippet": "int virProcessGetStartTime(pid_t pid,\n                           unsigned long long *timestamp)\n{\n    static int warned;\n    if (g_atomic_int_add(&warned, 1) == 0) {\n        VIR_WARN(\"Process start time of pid %lld not available on this platform\",\n                 (long long) pid);\n    }\n    *timestamp = 0;\n    return 0;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virProcessGetStartTime(pid_t pid,\n                           unsigned long long *timestamp)\n{\n    static int warned;\n    if (g_atomic_int_add(&warned, 1) == 0) {\n        VIR_WARN(\"Process start time of pid %lld not available on this platform\",\n                 (long long) pid);\n    }\n    *timestamp = 0;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Failed to get client socket identity\")"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to get client socket identity\""
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "sock->fd",
            "SOL_SOCKET",
            "SO_PEERCRED",
            "&cr",
            "&cr_len"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "vir_getsockopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "311-328",
          "snippet": "int\nvir_getsockopt(int fd, int level, int optname,\n               void *optval, socklen_t *optlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockopt(sk, level, optname, optval, optlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_getsockopt(int fd, int level, int optname,\n               void *optval, socklen_t *optlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockopt(sk, level, optname, optval, optlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketGetUNIXIdentity(virNetSocketPtr sock,\n                                uid_t *uid,\n                                gid_t *gid,\n                                pid_t *pid,\n                                unsigned long long *timestamp)\n{\n# if defined(HAVE_STRUCT_SOCKPEERCRED)\n    struct sockpeercred cr;\n# else\n    struct ucred cr;\n# endif\n    socklen_t cr_len = sizeof(cr);\n    int ret = -1;\n\n    virObjectLock(sock);\n\n    if (getsockopt(sock->fd, SOL_SOCKET, SO_PEERCRED, &cr, &cr_len) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Failed to get client socket identity\"));\n        goto cleanup;\n    }\n\n    *timestamp = -1;\n    if (cr.pid && virProcessGetStartTime(cr.pid, timestamp) < 0)\n        goto cleanup;\n\n    if (cr.pid)\n        *pid = cr.pid;\n    else\n        *pid = -1;\n    *uid = cr.uid;\n    *gid = cr.gid;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sock);\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketGetPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1445-1452",
    "snippet": "int virNetSocketGetPort(virNetSocketPtr sock)\n{\n    int port;\n    virObjectLock(sock);\n    port = virSocketAddrGetPort(&sock->localAddr);\n    virObjectUnlock(sock);\n    return port;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetPort",
          "args": [
            "&sock->localAddr"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "552-565",
          "snippet": "int\nvirSocketAddrGetPort(virSocketAddrPtr addr)\n{\n    if (addr == NULL)\n        return -1;\n\n    if (addr->data.stor.ss_family == AF_INET) {\n        return ntohs(addr->data.inet4.sin_port);\n    } else if (addr->data.stor.ss_family == AF_INET6) {\n        return ntohs(addr->data.inet6.sin6_port);\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrGetPort(virSocketAddrPtr addr)\n{\n    if (addr == NULL)\n        return -1;\n\n    if (addr->data.stor.ss_family == AF_INET) {\n        return ntohs(addr->data.inet4.sin_port);\n    } else if (addr->data.stor.ss_family == AF_INET6) {\n        return ntohs(addr->data.inet6.sin6_port);\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketGetPort(virNetSocketPtr sock)\n{\n    int port;\n    virObjectLock(sock);\n    port = virSocketAddrGetPort(&sock->localAddr);\n    virObjectUnlock(sock);\n    return port;\n}"
  },
  {
    "function_name": "virNetSocketGetPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1436-1443",
    "snippet": "char *virNetSocketGetPath(virNetSocketPtr sock)\n{\n    char *path = NULL;\n    virObjectLock(sock);\n    path = virSocketAddrGetPath(&sock->localAddr);\n    virObjectUnlock(sock);\n    return path;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetPath",
          "args": [
            "&sock->localAddr"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "577-602",
          "snippet": "char *\nvirSocketAddrGetPath(virSocketAddrPtr addr G_GNUC_UNUSED)\n{\n#ifndef WIN32\n    char *path = NULL;\n    if (addr == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"No socket address provided\"));\n        return NULL;\n    }\n\n    if (addr->data.sa.sa_family != AF_UNIX) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"UNIX socket address is required\"));\n        return NULL;\n    }\n\n    path = g_strndup(addr->data.un.sun_path, sizeof(addr->data.un.sun_path));\n\n    return path;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"UNIX sockets not supported on this platform\"));\n    return NULL;\n#endif\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrGetPath(virSocketAddrPtr addr G_GNUC_UNUSED)\n{\n#ifndef WIN32\n    char *path = NULL;\n    if (addr == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"No socket address provided\"));\n        return NULL;\n    }\n\n    if (addr->data.sa.sa_family != AF_UNIX) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"UNIX socket address is required\"));\n        return NULL;\n    }\n\n    path = g_strndup(addr->data.un.sun_path, sizeof(addr->data.un.sun_path));\n\n    return path;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"UNIX sockets not supported on this platform\"));\n    return NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nchar *virNetSocketGetPath(virNetSocketPtr sock)\n{\n    char *path = NULL;\n    virObjectLock(sock);\n    path = virSocketAddrGetPath(&sock->localAddr);\n    virObjectUnlock(sock);\n    return path;\n}"
  },
  {
    "function_name": "virNetSocketHasPassFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1426-1434",
    "snippet": "bool virNetSocketHasPassFD(virNetSocketPtr sock)\n{\n    bool hasPassFD = false;\n    virObjectLock(sock);\n    if (sock->localAddr.data.sa.sa_family == AF_UNIX)\n        hasPassFD = true;\n    virObjectUnlock(sock);\n    return hasPassFD;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nbool virNetSocketHasPassFD(virNetSocketPtr sock)\n{\n    bool hasPassFD = false;\n    virObjectLock(sock);\n    if (sock->localAddr.data.sa.sa_family == AF_UNIX)\n        hasPassFD = true;\n    virObjectUnlock(sock);\n    return hasPassFD;\n}"
  },
  {
    "function_name": "virNetSocketIsLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1415-1423",
    "snippet": "bool virNetSocketIsLocal(virNetSocketPtr sock)\n{\n    bool isLocal = false;\n    virObjectLock(sock);\n    if (sock->localAddr.data.sa.sa_family == AF_UNIX)\n        isLocal = true;\n    virObjectUnlock(sock);\n    return isLocal;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nbool virNetSocketIsLocal(virNetSocketPtr sock)\n{\n    bool isLocal = false;\n    virObjectLock(sock);\n    if (sock->localAddr.data.sa.sa_family == AF_UNIX)\n        isLocal = true;\n    virObjectUnlock(sock);\n    return isLocal;\n}"
  },
  {
    "function_name": "virNetSocketDupFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1386-1412",
    "snippet": "int virNetSocketDupFD(virNetSocketPtr sock, bool cloexec)\n{\n    int fd;\n\n#ifdef F_DUPFD_CLOEXEC\n    if (cloexec)\n        fd = fcntl(sock->fd, F_DUPFD_CLOEXEC, 0);\n    else\n#endif /* F_DUPFD_CLOEXEC */\n        fd = dup(sock->fd);\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to copy socket file handle\"));\n        return -1;\n    }\n#ifndef F_DUPFD_CLOEXEC\n    if (cloexec &&\n        virSetCloseExec(fd < 0)) {\n        int saveerr = errno;\n        closesocket(fd);\n        errno = saveerr;\n        return -1;\n    }\n#endif /* F_DUPFD_CLOEXEC */\n\n    return fd;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "fd"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "vir_closesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "197-213",
          "snippet": "int\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetCloseExec",
          "args": [
            "fd < 0"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "virSetCloseExec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "131-134",
          "snippet": "int virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to copy socket file handle\")"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to copy socket file handle\""
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "sock->fd",
            "F_DUPFD_CLOEXEC",
            "0"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketDupFD(virNetSocketPtr sock, bool cloexec)\n{\n    int fd;\n\n#ifdef F_DUPFD_CLOEXEC\n    if (cloexec)\n        fd = fcntl(sock->fd, F_DUPFD_CLOEXEC, 0);\n    else\n#endif /* F_DUPFD_CLOEXEC */\n        fd = dup(sock->fd);\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to copy socket file handle\"));\n        return -1;\n    }\n#ifndef F_DUPFD_CLOEXEC\n    if (cloexec &&\n        virSetCloseExec(fd < 0)) {\n        int saveerr = errno;\n        closesocket(fd);\n        errno = saveerr;\n        return -1;\n    }\n#endif /* F_DUPFD_CLOEXEC */\n\n    return fd;\n}"
  },
  {
    "function_name": "virNetSocketGetFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1377-1384",
    "snippet": "int virNetSocketGetFD(virNetSocketPtr sock)\n{\n    int fd;\n    virObjectLock(sock);\n    fd = sock->fd;\n    virObjectUnlock(sock);\n    return fd;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketGetFD(virNetSocketPtr sock)\n{\n    int fd;\n    virObjectLock(sock);\n    fd = sock->fd;\n    virObjectUnlock(sock);\n    return fd;\n}"
  },
  {
    "function_name": "virNetSocketDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1327-1374",
    "snippet": "void virNetSocketDispose(void *obj)\n{\n    virNetSocketPtr sock = obj;\n\n    PROBE(RPC_SOCKET_DISPOSE,\n          \"sock=%p\", sock);\n\n    if (sock->watch >= 0) {\n        virEventRemoveHandle(sock->watch);\n        sock->watch = -1;\n    }\n\n#ifndef WIN32\n    /* If a server socket, then unlink UNIX path */\n    if (sock->unlinkUNIX &&\n        sock->localAddr.data.sa.sa_family == AF_UNIX &&\n        sock->localAddr.data.un.sun_path[0] != '\\0')\n        unlink(sock->localAddr.data.un.sun_path);\n#endif\n\n    /* Make sure it can't send any more I/O during shutdown */\n    if (sock->tlsSession)\n        virNetTLSSessionSetIOCallbacks(sock->tlsSession, NULL, NULL, NULL);\n    virObjectUnref(sock->tlsSession);\n#if WITH_SASL\n    virObjectUnref(sock->saslSession);\n#endif\n\n#if WITH_SSH2\n    virObjectUnref(sock->sshSession);\n#endif\n\n#if WITH_LIBSSH\n    virObjectUnref(sock->libsshSession);\n#endif\n\n    if (sock->ownsFd && sock->fd != -1) {\n        closesocket(sock->fd);\n        sock->fd = -1;\n    }\n    VIR_FORCE_CLOSE(sock->errfd);\n\n    virProcessAbort(sock->pid);\n\n    VIR_FREE(sock->localAddrStrSASL);\n    VIR_FREE(sock->remoteAddrStrSASL);\n    VIR_FREE(sock->remoteAddrStrURI);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetSocketDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sock->remoteAddrStrURI"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sock->remoteAddrStrSASL"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sock->localAddrStrSASL"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virProcessAbort",
          "args": [
            "sock->pid"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "288-293",
          "snippet": "void\nvirProcessAbort(pid_t pid)\n{\n    /* Not yet ported to mingw.  Any volunteers?  */\n    VIR_DEBUG(\"failed to reap child %lld, abandoning it\", (long long)pid);\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirProcessAbort(pid_t pid)\n{\n    /* Not yet ported to mingw.  Any volunteers?  */\n    VIR_DEBUG(\"failed to reap child %lld, abandoning it\", (long long)pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "sock->errfd"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "sock->fd"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "vir_closesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "197-213",
          "snippet": "int\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sock->libsshSession"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSSessionSetIOCallbacks",
          "args": [
            "sock->tlsSession",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSSessionSetIOCallbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "1262-1272",
          "snippet": "void virNetTLSSessionSetIOCallbacks(virNetTLSSessionPtr sess,\n                                    virNetTLSSessionWriteFunc writeFunc,\n                                    virNetTLSSessionReadFunc readFunc,\n                                    void *opaque)\n{\n    virObjectLock(sess);\n    sess->writeFunc = writeFunc;\n    sess->readFunc = readFunc;\n    sess->opaque = opaque;\n    virObjectUnlock(sess);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetTLSSessionSetIOCallbacks(virNetTLSSessionPtr sess,\n                                    virNetTLSSessionWriteFunc writeFunc,\n                                    virNetTLSSessionReadFunc readFunc,\n                                    void *opaque)\n{\n    virObjectLock(sess);\n    sess->writeFunc = writeFunc;\n    sess->readFunc = readFunc;\n    sess->opaque = opaque;\n    virObjectUnlock(sess);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "sock->localAddr.data.un.sun_path"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventRemoveHandle",
          "args": [
            "sock->watch"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRemoveHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "116-123",
          "snippet": "int\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventRemoveHandleFunc removeHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventRemoveHandleFunc removeHandleImpl;\n\nint\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_SOCKET_DISPOSE",
            "\"sock=%p\"",
            "sock"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void virNetSocketDispose(void *obj);\n\nvoid virNetSocketDispose(void *obj)\n{\n    virNetSocketPtr sock = obj;\n\n    PROBE(RPC_SOCKET_DISPOSE,\n          \"sock=%p\", sock);\n\n    if (sock->watch >= 0) {\n        virEventRemoveHandle(sock->watch);\n        sock->watch = -1;\n    }\n\n#ifndef WIN32\n    /* If a server socket, then unlink UNIX path */\n    if (sock->unlinkUNIX &&\n        sock->localAddr.data.sa.sa_family == AF_UNIX &&\n        sock->localAddr.data.un.sun_path[0] != '\\0')\n        unlink(sock->localAddr.data.un.sun_path);\n#endif\n\n    /* Make sure it can't send any more I/O during shutdown */\n    if (sock->tlsSession)\n        virNetTLSSessionSetIOCallbacks(sock->tlsSession, NULL, NULL, NULL);\n    virObjectUnref(sock->tlsSession);\n#if WITH_SASL\n    virObjectUnref(sock->saslSession);\n#endif\n\n#if WITH_SSH2\n    virObjectUnref(sock->sshSession);\n#endif\n\n#if WITH_LIBSSH\n    virObjectUnref(sock->libsshSession);\n#endif\n\n    if (sock->ownsFd && sock->fd != -1) {\n        closesocket(sock->fd);\n        sock->fd = -1;\n    }\n    VIR_FORCE_CLOSE(sock->errfd);\n\n    virProcessAbort(sock->pid);\n\n    VIR_FREE(sock->localAddrStrSASL);\n    VIR_FREE(sock->remoteAddrStrSASL);\n    VIR_FREE(sock->remoteAddrStrURI);\n}"
  },
  {
    "function_name": "virNetSocketPreExecRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1267-1324",
    "snippet": "virJSONValuePtr virNetSocketPreExecRestart(virNetSocketPtr sock)\n{\n    virJSONValuePtr object = NULL;\n\n    virObjectLock(sock);\n\n#if WITH_SASL\n    if (sock->saslSession) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Unable to save socket state when SASL session is active\"));\n        goto error;\n    }\n#endif\n    if (sock->tlsSession) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Unable to save socket state when TLS session is active\"));\n        goto error;\n    }\n\n    object = virJSONValueNewObject();\n\n    if (virJSONValueObjectAppendNumberInt(object, \"fd\", sock->fd) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendNumberInt(object, \"errfd\", sock->errfd) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendNumberInt(object, \"pid\", sock->pid) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendBoolean(object, \"isClient\", sock->isClient) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendBoolean(object, \"unlinkUNIX\", sock->unlinkUNIX) < 0)\n        goto error;\n\n    if (virSetInherit(sock->fd, true) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot disable close-on-exec flag on socket %d\"),\n                             sock->fd);\n        goto error;\n    }\n    if (sock->errfd != -1 &&\n        virSetInherit(sock->errfd, true) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot disable close-on-exec flag on pipe %d\"),\n                             sock->errfd);\n        goto error;\n    }\n\n    virObjectUnlock(sock);\n    return object;\n\n error:\n    virObjectUnlock(sock);\n    virJSONValueFree(object);\n    return NULL;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "object"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sock"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot disable close-on-exec flag on pipe %d\")",
            "sock->errfd"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot disable close-on-exec flag on pipe %d\""
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetInherit",
          "args": [
            "sock->errfd",
            "true"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "virSetInherit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "104-111",
          "snippet": "int virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot disable close-on-exec flag on socket %d\")",
            "sock->fd"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendBoolean",
          "args": [
            "object",
            "\"unlinkUNIX\"",
            "sock->unlinkUNIX"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "741-754",
          "snippet": "int\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendNumberInt",
          "args": [
            "object",
            "\"pid\"",
            "sock->pid"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendNumberInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "661-674",
          "snippet": "int\nvirJSONValueObjectAppendNumberInt(virJSONValuePtr object,\n                                  const char *key,\n                                  int number)\n{\n    virJSONValuePtr jvalue = virJSONValueNewNumberInt(number);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendNumberInt(virJSONValuePtr object,\n                                  const char *key,\n                                  int number)\n{\n    virJSONValuePtr jvalue = virJSONValueNewNumberInt(number);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewObject",
          "args": [],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "571-579",
          "snippet": "virJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Unable to save socket state when TLS session is active\")"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Unable to save socket state when SASL session is active\")"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sock"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvirJSONValuePtr virNetSocketPreExecRestart(virNetSocketPtr sock)\n{\n    virJSONValuePtr object = NULL;\n\n    virObjectLock(sock);\n\n#if WITH_SASL\n    if (sock->saslSession) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Unable to save socket state when SASL session is active\"));\n        goto error;\n    }\n#endif\n    if (sock->tlsSession) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Unable to save socket state when TLS session is active\"));\n        goto error;\n    }\n\n    object = virJSONValueNewObject();\n\n    if (virJSONValueObjectAppendNumberInt(object, \"fd\", sock->fd) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendNumberInt(object, \"errfd\", sock->errfd) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendNumberInt(object, \"pid\", sock->pid) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendBoolean(object, \"isClient\", sock->isClient) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendBoolean(object, \"unlinkUNIX\", sock->unlinkUNIX) < 0)\n        goto error;\n\n    if (virSetInherit(sock->fd, true) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot disable close-on-exec flag on socket %d\"),\n                             sock->fd);\n        goto error;\n    }\n    if (sock->errfd != -1 &&\n        virSetInherit(sock->errfd, true) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot disable close-on-exec flag on pipe %d\"),\n                             sock->errfd);\n        goto error;\n    }\n\n    virObjectUnlock(sock);\n    return object;\n\n error:\n    virObjectUnlock(sock);\n    virJSONValueFree(object);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetSocketNewPostExecRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1212-1264",
    "snippet": "virNetSocketPtr virNetSocketNewPostExecRestart(virJSONValuePtr object)\n{\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    int fd, thepid, errfd;\n    bool isClient;\n    bool unlinkUNIX;\n\n    if (virJSONValueObjectGetNumberInt(object, \"fd\", &fd) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing fd data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetNumberInt(object, \"pid\", &thepid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing pid data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetNumberInt(object, \"errfd\", &errfd) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing errfd data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetBoolean(object, \"isClient\", &isClient) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing isClient data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetBoolean(object, \"unlinkUNIX\", &unlinkUNIX) < 0)\n        unlinkUNIX = !isClient;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    remoteAddr.len = sizeof(remoteAddr.data.stor);\n    if (getsockname(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get peer socket name\"));\n        return NULL;\n    }\n\n    localAddr.len = sizeof(localAddr.data.stor);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        return NULL;\n    }\n\n    return virNetSocketNew(&localAddr, &remoteAddr, isClient,\n                           fd, errfd, thepid, unlinkUNIX);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSocketNew",
          "args": [
            "&localAddr",
            "&remoteAddr",
            "isClient",
            "fd",
            "errfd",
            "thepid",
            "unlinkUNIX"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "208-289",
          "snippet": "static virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetSocketClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virClassPtr virNetSocketClass;\n\nstatic virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to get local socket name\")"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get local socket name\""
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "fd",
            "&localAddr.data.sa",
            "&localAddr.len"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "vir_getsockname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "254-270",
          "snippet": "int\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to get peer socket name\")"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&remoteAddr",
            "0",
            "sizeof(remoteAddr)"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&localAddr",
            "0",
            "sizeof(localAddr)"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetBoolean",
          "args": [
            "object",
            "\"unlinkUNIX\"",
            "&unlinkUNIX"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1401-1412",
          "snippet": "int\nvirJSONValueObjectGetBoolean(virJSONValuePtr object,\n                             const char *key,\n                             bool *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetBoolean(val, value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectGetBoolean(virJSONValuePtr object,\n                             const char *key,\n                             bool *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetBoolean(val, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing isClient data in JSON document\")"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing errfd data in JSON document\")"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetNumberInt",
          "args": [
            "object",
            "\"errfd\"",
            "&errfd"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetNumberInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1331-1342",
          "snippet": "int\nvirJSONValueObjectGetNumberInt(virJSONValuePtr object,\n                               const char *key,\n                               int *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberInt(val, value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectGetNumberInt(virJSONValuePtr object,\n                               const char *key,\n                               int *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberInt(val, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing pid data in JSON document\")"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing fd data in JSON document\")"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvirNetSocketPtr virNetSocketNewPostExecRestart(virJSONValuePtr object)\n{\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    int fd, thepid, errfd;\n    bool isClient;\n    bool unlinkUNIX;\n\n    if (virJSONValueObjectGetNumberInt(object, \"fd\", &fd) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing fd data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetNumberInt(object, \"pid\", &thepid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing pid data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetNumberInt(object, \"errfd\", &errfd) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing errfd data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetBoolean(object, \"isClient\", &isClient) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing isClient data in JSON document\"));\n        return NULL;\n    }\n\n    if (virJSONValueObjectGetBoolean(object, \"unlinkUNIX\", &unlinkUNIX) < 0)\n        unlinkUNIX = !isClient;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    remoteAddr.len = sizeof(remoteAddr.data.stor);\n    if (getsockname(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get peer socket name\"));\n        return NULL;\n    }\n\n    localAddr.len = sizeof(localAddr.data.stor);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        return NULL;\n    }\n\n    return virNetSocketNew(&localAddr, &remoteAddr, isClient,\n                           fd, errfd, thepid, unlinkUNIX);\n}"
  },
  {
    "function_name": "virNetSocketNewConnectSockFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1194-1209",
    "snippet": "int virNetSocketNewConnectSockFD(int sockfd,\n                                 virNetSocketPtr *retsock)\n{\n    virSocketAddr localAddr;\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(sockfd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        return -1;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, NULL, true, sockfd, -1, -1, false)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSocketNew",
          "args": [
            "&localAddr",
            "NULL",
            "true",
            "sockfd",
            "-1",
            "-1",
            "false"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "208-289",
          "snippet": "static virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetSocketClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virClassPtr virNetSocketClass;\n\nstatic virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to get local socket name\")"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get local socket name\""
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "sockfd",
            "&localAddr.data.sa",
            "&localAddr.len"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "vir_getsockname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "254-270",
          "snippet": "int\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectSockFD(int sockfd,\n                                 virNetSocketPtr *retsock)\n{\n    virSocketAddr localAddr;\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(sockfd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        return -1;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, NULL, true, sockfd, -1, -1, false)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetSocketNewConnectExternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1179-1191",
    "snippet": "int virNetSocketNewConnectExternal(const char **cmdargv,\n                                   virNetSocketPtr *retsock)\n{\n    virCommandPtr cmd;\n\n    *retsock = NULL;\n\n    cmd = virCommandNewArgs(cmdargv);\n    virCommandAddEnvPassCommon(cmd);\n    virCommandClearCaps(cmd);\n\n    return virNetSocketNewConnectCommand(cmd, retsock);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSocketNewConnectCommand",
          "args": [
            "cmd",
            "retsock"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewConnectCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "830-836",
          "snippet": "int virNetSocketNewConnectCommand(virCommandPtr cmd G_GNUC_UNUSED,\n                                  virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(errno, \"%s\",\n                         _(\"Tunnelling sockets not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectCommand(virCommandPtr cmd G_GNUC_UNUSED,\n                                  virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(errno, \"%s\",\n                         _(\"Tunnelling sockets not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandClearCaps",
          "args": [
            "cmd"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandClearCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1179-1186",
          "snippet": "void\nvirCommandClearCaps(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_CLEAR_CAPS;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandClearCaps(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_CLEAR_CAPS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddEnvPassCommon",
          "args": [
            "cmd"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvPassCommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1454-1474",
          "snippet": "void\nvirCommandAddEnvPassCommon(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 9) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvPair(cmd, \"LC_ALL\", \"C\");\n\n    virCommandAddEnvPass(cmd, \"LD_PRELOAD\");\n    virCommandAddEnvPass(cmd, \"LD_LIBRARY_PATH\");\n    virCommandAddEnvPass(cmd, \"PATH\");\n    virCommandAddEnvPass(cmd, \"HOME\");\n    virCommandAddEnvPass(cmd, \"USER\");\n    virCommandAddEnvPass(cmd, \"LOGNAME\");\n    virCommandAddEnvPass(cmd, \"TMPDIR\");\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvPassCommon(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 9) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvPair(cmd, \"LC_ALL\", \"C\");\n\n    virCommandAddEnvPass(cmd, \"LD_PRELOAD\");\n    virCommandAddEnvPass(cmd, \"LD_LIBRARY_PATH\");\n    virCommandAddEnvPass(cmd, \"PATH\");\n    virCommandAddEnvPass(cmd, \"HOME\");\n    virCommandAddEnvPass(cmd, \"USER\");\n    virCommandAddEnvPass(cmd, \"LOGNAME\");\n    virCommandAddEnvPass(cmd, \"TMPDIR\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgs",
          "args": [
            "cmdargv"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "937-958",
          "snippet": "virCommandPtr\nvirCommandNewArgs(const char *const*args)\n{\n    virCommandPtr cmd;\n\n    if (VIR_ALLOC(cmd) < 0)\n        return NULL;\n\n    cmd->handshakeWait[0] = -1;\n    cmd->handshakeWait[1] = -1;\n    cmd->handshakeNotify[0] = -1;\n    cmd->handshakeNotify[1] = -1;\n\n    cmd->infd = cmd->inpipe = cmd->outfd = cmd->errfd = -1;\n    cmd->pid = -1;\n    cmd->uid = -1;\n    cmd->gid = -1;\n\n    virCommandAddArgSet(cmd, args);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgs(const char *const*args)\n{\n    virCommandPtr cmd;\n\n    if (VIR_ALLOC(cmd) < 0)\n        return NULL;\n\n    cmd->handshakeWait[0] = -1;\n    cmd->handshakeWait[1] = -1;\n    cmd->handshakeNotify[0] = -1;\n    cmd->handshakeNotify[1] = -1;\n\n    cmd->infd = cmd->inpipe = cmd->outfd = cmd->errfd = -1;\n    cmd->pid = -1;\n    cmd->uid = -1;\n    cmd->gid = -1;\n\n    virCommandAddArgSet(cmd, args);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectExternal(const char **cmdargv,\n                                   virNetSocketPtr *retsock)\n{\n    virCommandPtr cmd;\n\n    *retsock = NULL;\n\n    cmd = virCommandNewArgs(cmdargv);\n    virCommandAddEnvPassCommon(cmd);\n    virCommandClearCaps(cmd);\n\n    return virNetSocketNewConnectCommand(cmd, retsock);\n}"
  },
  {
    "function_name": "virNetSocketNewConnectLibssh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1159-1176",
    "snippet": "int\nvirNetSocketNewConnectLibssh(const char *host G_GNUC_UNUSED,\n                             const char *port G_GNUC_UNUSED,\n                             int family G_GNUC_UNUSED,\n                             const char *username G_GNUC_UNUSED,\n                             const char *privkey G_GNUC_UNUSED,\n                             const char *knownHosts G_GNUC_UNUSED,\n                             const char *knownHostsVerify G_GNUC_UNUSED,\n                             const char *authMethods G_GNUC_UNUSED,\n                             const char *command G_GNUC_UNUSED,\n                             virConnectAuthPtr auth G_GNUC_UNUSED,\n                             virURIPtr uri G_GNUC_UNUSED,\n                             virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"libssh transport support was not enabled\"));\n    return -1;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"libssh transport support was not enabled\")"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"libssh transport support was not enabled\""
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirNetSocketNewConnectLibssh(const char *host G_GNUC_UNUSED,\n                             const char *port G_GNUC_UNUSED,\n                             int family G_GNUC_UNUSED,\n                             const char *username G_GNUC_UNUSED,\n                             const char *privkey G_GNUC_UNUSED,\n                             const char *knownHosts G_GNUC_UNUSED,\n                             const char *knownHostsVerify G_GNUC_UNUSED,\n                             const char *authMethods G_GNUC_UNUSED,\n                             const char *command G_GNUC_UNUSED,\n                             virConnectAuthPtr auth G_GNUC_UNUSED,\n                             virURIPtr uri G_GNUC_UNUSED,\n                             virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"libssh transport support was not enabled\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetSocketNewConnectLibssh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1046-1157",
    "snippet": "int\nvirNetSocketNewConnectLibssh(const char *host,\n                             const char *port,\n                             int family,\n                             const char *username,\n                             const char *privkey,\n                             const char *knownHosts,\n                             const char *knownHostsVerify,\n                             const char *authMethods,\n                             const char *command,\n                             virConnectAuthPtr auth,\n                             virURIPtr uri,\n                             virNetSocketPtr *retsock)\n{\n    virNetSocketPtr sock = NULL;\n    virNetLibsshSessionPtr sess = NULL;\n    unsigned int verify;\n    int ret = -1;\n    int portN;\n\n    VIR_AUTOSTRINGLIST authMethodList = NULL;\n    char **authMethodNext;\n\n    /* port number will be verified while opening the socket */\n    if (virStrToLong_i(port, NULL, 10, &portN) < 0) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Failed to parse port number\"));\n        goto error;\n    }\n\n    /* create ssh session context */\n    if (!(sess = virNetLibsshSessionNew(username)))\n        goto error;\n\n    /* set ssh session parameters */\n    if (virNetLibsshSessionAuthSetCallback(sess, auth) != 0)\n        goto error;\n\n    if (STRCASEEQ(\"auto\", knownHostsVerify)) {\n        verify = VIR_NET_LIBSSH_HOSTKEY_VERIFY_AUTO_ADD;\n    } else if (STRCASEEQ(\"ignore\", knownHostsVerify)) {\n        verify = VIR_NET_LIBSSH_HOSTKEY_VERIFY_IGNORE;\n    } else if (STRCASEEQ(\"normal\", knownHostsVerify)) {\n        verify = VIR_NET_LIBSSH_HOSTKEY_VERIFY_NORMAL;\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid host key verification method: '%s'\"),\n                       knownHostsVerify);\n        goto error;\n    }\n\n    if (virNetLibsshSessionSetHostKeyVerification(sess,\n                                                  host,\n                                                  portN,\n                                                  knownHosts,\n                                                  verify) != 0)\n        goto error;\n\n    if (virNetLibsshSessionSetChannelCommand(sess, command) != 0)\n        goto error;\n\n    if (!(authMethodList = virStringSplit(authMethods, \",\", 0)))\n        goto error;\n\n    for (authMethodNext = authMethodList; *authMethodNext; authMethodNext++) {\n        const char *authMethod = *authMethodNext;\n\n        if (STRCASEEQ(authMethod, \"keyboard-interactive\")) {\n            ret = virNetLibsshSessionAuthAddKeyboardAuth(sess, -1);\n        } else if (STRCASEEQ(authMethod, \"password\")) {\n            ret = virNetLibsshSessionAuthAddPasswordAuth(sess, uri);\n        } else if (STRCASEEQ(authMethod, \"privkey\")) {\n            ret = virNetLibsshSessionAuthAddPrivKeyAuth(sess,\n                                                        privkey,\n                                                        NULL);\n        } else if (STRCASEEQ(authMethod, \"agent\")) {\n            ret = virNetLibsshSessionAuthAddAgentAuth(sess);\n        } else {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Invalid authentication method: '%s'\"),\n                           authMethod);\n            ret = -1;\n            goto error;\n        }\n\n        if (ret != 0)\n            goto error;\n    }\n\n    /* connect to remote server */\n    if ((ret = virNetSocketNewConnectTCP(host, port, family, &sock)) < 0)\n        goto error;\n\n    /* connect to the host using ssh */\n    if ((ret = virNetLibsshSessionConnect(sess, virNetSocketGetFD(sock))) != 0)\n        goto error;\n\n    sock->libsshSession = sess;\n    /* libssh owns the FD and closes it on its own, and thus\n     * we must not close it (otherwise there are warnings about\n     * trying to close an invalid FD).\n     */\n    sock->ownsFd = false;\n    *retsock = sock;\n\n    return 0;\n\n error:\n    virObjectUnref(sock);\n    virObjectUnref(sess);\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sess"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionConnect",
          "args": [
            "sess",
            "virNetSocketGetFD(sock)"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionConnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "1190-1254",
          "snippet": "int\nvirNetLibsshSessionConnect(virNetLibsshSessionPtr sess,\n                           int sock)\n{\n    int ret;\n    const char *errmsg;\n\n    VIR_DEBUG(\"sess=%p, sock=%d\", sess, sock);\n\n    if (!sess || sess->state != VIR_NET_LIBSSH_STATE_NEW) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Invalid virNetLibsshSessionPtr\"));\n        return -1;\n    }\n\n    virObjectLock(sess);\n\n    /* check if configuration is valid */\n    if ((ret = virNetLibsshValidateConfig(sess)) < 0)\n        goto error;\n\n    /* read ~/.ssh/config */\n    if ((ret = ssh_options_parse_config(sess->session, NULL)) < 0)\n        goto error;\n\n    /* set the socket FD for the libssh session */\n    if ((ret = ssh_options_set(sess->session, SSH_OPTIONS_FD, &sock)) < 0)\n        goto error;\n\n    /* open session */\n    ret = ssh_connect(sess->session);\n    /* libssh is in blocking mode, so EAGAIN will never happen */\n    if (ret < 0) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_NO_CONNECT,\n                       _(\"SSH session handshake failed: %s\"),\n                       errmsg);\n        goto error;\n    }\n\n    /* verify the SSH host key */\n    if ((ret = virNetLibsshCheckHostKey(sess)) != 0)\n        goto error;\n\n    /* authenticate */\n    if ((ret = virNetLibsshAuthenticate(sess)) != 0)\n        goto error;\n\n    /* open channel */\n    if ((ret = virNetLibsshOpenChannel(sess)) != 0)\n        goto error;\n\n    /* all set */\n    /* switch to nonblocking mode and return */\n    ssh_set_blocking(sess->session, 0);\n    sess->state = VIR_NET_LIBSSH_STATE_HANDSHAKE_COMPLETE;\n\n    virObjectUnlock(sess);\n    return ret;\n\n error:\n    sess->state = VIR_NET_LIBSSH_STATE_ERROR;\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionConnect(virNetLibsshSessionPtr sess,\n                           int sock)\n{\n    int ret;\n    const char *errmsg;\n\n    VIR_DEBUG(\"sess=%p, sock=%d\", sess, sock);\n\n    if (!sess || sess->state != VIR_NET_LIBSSH_STATE_NEW) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Invalid virNetLibsshSessionPtr\"));\n        return -1;\n    }\n\n    virObjectLock(sess);\n\n    /* check if configuration is valid */\n    if ((ret = virNetLibsshValidateConfig(sess)) < 0)\n        goto error;\n\n    /* read ~/.ssh/config */\n    if ((ret = ssh_options_parse_config(sess->session, NULL)) < 0)\n        goto error;\n\n    /* set the socket FD for the libssh session */\n    if ((ret = ssh_options_set(sess->session, SSH_OPTIONS_FD, &sock)) < 0)\n        goto error;\n\n    /* open session */\n    ret = ssh_connect(sess->session);\n    /* libssh is in blocking mode, so EAGAIN will never happen */\n    if (ret < 0) {\n        errmsg = ssh_get_error(sess->session);\n        virReportError(VIR_ERR_NO_CONNECT,\n                       _(\"SSH session handshake failed: %s\"),\n                       errmsg);\n        goto error;\n    }\n\n    /* verify the SSH host key */\n    if ((ret = virNetLibsshCheckHostKey(sess)) != 0)\n        goto error;\n\n    /* authenticate */\n    if ((ret = virNetLibsshAuthenticate(sess)) != 0)\n        goto error;\n\n    /* open channel */\n    if ((ret = virNetLibsshOpenChannel(sess)) != 0)\n        goto error;\n\n    /* all set */\n    /* switch to nonblocking mode and return */\n    ssh_set_blocking(sess->session, 0);\n    sess->state = VIR_NET_LIBSSH_STATE_HANDSHAKE_COMPLETE;\n\n    virObjectUnlock(sess);\n    return ret;\n\n error:\n    sess->state = VIR_NET_LIBSSH_STATE_ERROR;\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketGetFD",
          "args": [
            "sock"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketGetFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1377-1384",
          "snippet": "int virNetSocketGetFD(virNetSocketPtr sock)\n{\n    int fd;\n    virObjectLock(sock);\n    fd = sock->fd;\n    virObjectUnlock(sock);\n    return fd;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketGetFD(virNetSocketPtr sock)\n{\n    int fd;\n    virObjectLock(sock);\n    fd = sock->fd;\n    virObjectUnlock(sock);\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewConnectTCP",
          "args": [
            "host",
            "port",
            "family",
            "&sock"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewConnectTCP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "558-640",
          "snippet": "int virNetSocketNewConnectTCP(const char *nodename,\n                              const char *service,\n                              int family,\n                              virNetSocketPtr *retsock)\n{\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    struct addrinfo *runp;\n    int savedErrno = ENOENT;\n\n    *retsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG | AI_V4MAPPED;\n    hints.ai_socktype = SOCK_STREAM;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    runp = ai;\n    while (runp) {\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, false) < 0)\n            VIR_WARN(\"Unable to enable port reuse\");\n\n        if (connect(fd, runp->ai_addr, runp->ai_addrlen) >= 0)\n            break;\n\n        savedErrno = errno;\n        closesocket(fd);\n        fd = -1;\n        runp = runp->ai_next;\n    }\n\n    if (fd == -1) {\n        virReportSystemError(savedErrno,\n                             _(\"unable to connect to server at '%s:%s'\"),\n                             nodename, service);\n        goto error;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto error;\n    }\n\n    remoteAddr.len = sizeof(remoteAddr.data);\n    if (getpeername(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get remote socket name\"));\n        goto error;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, &remoteAddr, true, fd, -1, 0, false)))\n        goto error;\n\n    freeaddrinfo(ai);\n\n    return 0;\n\n error:\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectTCP(const char *nodename,\n                              const char *service,\n                              int family,\n                              virNetSocketPtr *retsock)\n{\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    struct addrinfo *runp;\n    int savedErrno = ENOENT;\n\n    *retsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG | AI_V4MAPPED;\n    hints.ai_socktype = SOCK_STREAM;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    runp = ai;\n    while (runp) {\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, false) < 0)\n            VIR_WARN(\"Unable to enable port reuse\");\n\n        if (connect(fd, runp->ai_addr, runp->ai_addrlen) >= 0)\n            break;\n\n        savedErrno = errno;\n        closesocket(fd);\n        fd = -1;\n        runp = runp->ai_next;\n    }\n\n    if (fd == -1) {\n        virReportSystemError(savedErrno,\n                             _(\"unable to connect to server at '%s:%s'\"),\n                             nodename, service);\n        goto error;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto error;\n    }\n\n    remoteAddr.len = sizeof(remoteAddr.data);\n    if (getpeername(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get remote socket name\"));\n        goto error;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, &remoteAddr, true, fd, -1, 0, false)))\n        goto error;\n\n    freeaddrinfo(ai);\n\n    return 0;\n\n error:\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Invalid authentication method: '%s'\")",
            "authMethod"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid authentication method: '%s'\""
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionAuthAddAgentAuth",
          "args": [
            "sess"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionAuthAddAgentAuth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "992-1013",
          "snippet": "int\nvirNetLibsshSessionAuthAddAgentAuth(virNetLibsshSessionPtr sess)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n\n    virObjectLock(sess);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    auth->method = VIR_NET_LIBSSH_AUTH_AGENT;\n    auth->ssh_flags = SSH_AUTH_METHOD_PUBLICKEY;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionAuthAddAgentAuth(virNetLibsshSessionPtr sess)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n\n    virObjectLock(sess);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    auth->method = VIR_NET_LIBSSH_AUTH_AGENT;\n    auth->ssh_flags = SSH_AUTH_METHOD_PUBLICKEY;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "authMethod",
            "\"agent\""
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionAuthAddPrivKeyAuth",
          "args": [
            "sess",
            "privkey",
            "NULL"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionAuthAddPrivKeyAuth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "1015-1057",
          "snippet": "int\nvirNetLibsshSessionAuthAddPrivKeyAuth(virNetLibsshSessionPtr sess,\n                                      const char *keyfile,\n                                      const char *password)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n    VIR_AUTODISPOSE_STR pass = NULL;\n    char *file = NULL;\n\n    if (!keyfile) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Key file path must be provided \"\n                         \"for private key authentication\"));\n        ret = -1;\n        goto error;\n    }\n\n    virObjectLock(sess);\n\n    file = g_strdup(keyfile);\n    pass = g_strdup(password);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto error;\n    }\n\n    auth->password = g_steal_pointer(&pass);\n    auth->filename = file;\n    auth->method = VIR_NET_LIBSSH_AUTH_PRIVKEY;\n    auth->ssh_flags = SSH_AUTH_METHOD_PUBLICKEY;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n\n error:\n    VIR_FREE(file);\n    goto cleanup;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionAuthAddPrivKeyAuth(virNetLibsshSessionPtr sess,\n                                      const char *keyfile,\n                                      const char *password)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n    VIR_AUTODISPOSE_STR pass = NULL;\n    char *file = NULL;\n\n    if (!keyfile) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Key file path must be provided \"\n                         \"for private key authentication\"));\n        ret = -1;\n        goto error;\n    }\n\n    virObjectLock(sess);\n\n    file = g_strdup(keyfile);\n    pass = g_strdup(password);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto error;\n    }\n\n    auth->password = g_steal_pointer(&pass);\n    auth->filename = file;\n    auth->method = VIR_NET_LIBSSH_AUTH_PRIVKEY;\n    auth->ssh_flags = SSH_AUTH_METHOD_PUBLICKEY;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n\n error:\n    VIR_FREE(file);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "authMethod",
            "\"privkey\""
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionAuthAddPasswordAuth",
          "args": [
            "sess",
            "uri"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionAuthAddPasswordAuth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "959-990",
          "snippet": "int\nvirNetLibsshSessionAuthAddPasswordAuth(virNetLibsshSessionPtr sess,\n                                       virURIPtr uri)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n\n    if (uri) {\n        VIR_FREE(sess->authPath);\n\n        if (virAuthGetConfigFilePathURI(uri, &sess->authPath) < 0) {\n            ret = -1;\n            goto cleanup;\n        }\n    }\n\n    virObjectLock(sess);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    auth->method = VIR_NET_LIBSSH_AUTH_PASSWORD;\n    auth->ssh_flags = SSH_AUTH_METHOD_PASSWORD;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionAuthAddPasswordAuth(virNetLibsshSessionPtr sess,\n                                       virURIPtr uri)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n\n    if (uri) {\n        VIR_FREE(sess->authPath);\n\n        if (virAuthGetConfigFilePathURI(uri, &sess->authPath) < 0) {\n            ret = -1;\n            goto cleanup;\n        }\n    }\n\n    virObjectLock(sess);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    auth->method = VIR_NET_LIBSSH_AUTH_PASSWORD;\n    auth->ssh_flags = SSH_AUTH_METHOD_PASSWORD;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "authMethod",
            "\"password\""
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionAuthAddKeyboardAuth",
          "args": [
            "sess",
            "-1"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionAuthAddKeyboardAuth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "1059-1083",
          "snippet": "int\nvirNetLibsshSessionAuthAddKeyboardAuth(virNetLibsshSessionPtr sess,\n                                       int tries)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n\n    virObjectLock(sess);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    auth->tries = tries;\n    auth->method = VIR_NET_LIBSSH_AUTH_KEYBOARD_INTERACTIVE;\n    auth->ssh_flags = SSH_AUTH_METHOD_INTERACTIVE;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionAuthAddKeyboardAuth(virNetLibsshSessionPtr sess,\n                                       int tries)\n{\n    int ret;\n    virNetLibsshAuthMethodPtr auth;\n\n    virObjectLock(sess);\n\n    if (!(auth = virNetLibsshSessionAuthMethodNew(sess))) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    auth->tries = tries;\n    auth->method = VIR_NET_LIBSSH_AUTH_KEYBOARD_INTERACTIVE;\n    auth->ssh_flags = SSH_AUTH_METHOD_INTERACTIVE;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "authMethod",
            "\"keyboard-interactive\""
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplit",
          "args": [
            "authMethods",
            "\",\"",
            "0"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "126-132",
          "snippet": "char **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionSetChannelCommand",
          "args": [
            "sess",
            "command"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionSetChannelCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "1085-1098",
          "snippet": "int\nvirNetLibsshSessionSetChannelCommand(virNetLibsshSessionPtr sess,\n                                      const char *command)\n{\n    int ret = 0;\n    virObjectLock(sess);\n\n    VIR_FREE(sess->channelCommand);\n\n    sess->channelCommand = g_strdup(command);\n\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionSetChannelCommand(virNetLibsshSessionPtr sess,\n                                      const char *command)\n{\n    int ret = 0;\n    virObjectLock(sess);\n\n    VIR_FREE(sess->channelCommand);\n\n    sess->channelCommand = g_strdup(command);\n\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionSetHostKeyVerification",
          "args": [
            "sess",
            "host",
            "portN",
            "knownHosts",
            "verify"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionSetHostKeyVerification",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "1100-1148",
          "snippet": "int\nvirNetLibsshSessionSetHostKeyVerification(virNetLibsshSessionPtr sess,\n                                          const char *hostname,\n                                          int port,\n                                          const char *hostsfile,\n                                          virNetLibsshHostkeyVerify opt)\n{\n    virObjectLock(sess);\n\n    sess->port = port;\n    sess->hostKeyVerify = opt;\n\n    VIR_FREE(sess->hostname);\n\n    sess->hostname = g_strdup(hostname);\n\n    /* set the hostname */\n    if (ssh_options_set(sess->session, SSH_OPTIONS_HOST, sess->hostname) < 0)\n        goto error;\n\n    /* set the port */\n    if (port > 0) {\n        unsigned int portU = port;\n\n        if (ssh_options_set(sess->session, SSH_OPTIONS_PORT, &portU) < 0)\n            goto error;\n    }\n\n    /* set the known hosts file, if specified */\n    if (hostsfile) {\n        if (ssh_options_set(sess->session, SSH_OPTIONS_KNOWNHOSTS, hostsfile) < 0)\n            goto error;\n\n        VIR_FREE(sess->knownHostsFile);\n        sess->knownHostsFile = g_strdup(hostsfile);\n    } else {\n        /* libssh does not support trying no known_host file at all:\n         * hence use /dev/null here, without storing it as file */\n        if (ssh_options_set(sess->session, SSH_OPTIONS_KNOWNHOSTS, \"/dev/null\") < 0)\n            goto error;\n    }\n\n    virObjectUnlock(sess);\n    return 0;\n\n error:\n    virObjectUnlock(sess);\n    return -1;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionSetHostKeyVerification(virNetLibsshSessionPtr sess,\n                                          const char *hostname,\n                                          int port,\n                                          const char *hostsfile,\n                                          virNetLibsshHostkeyVerify opt)\n{\n    virObjectLock(sess);\n\n    sess->port = port;\n    sess->hostKeyVerify = opt;\n\n    VIR_FREE(sess->hostname);\n\n    sess->hostname = g_strdup(hostname);\n\n    /* set the hostname */\n    if (ssh_options_set(sess->session, SSH_OPTIONS_HOST, sess->hostname) < 0)\n        goto error;\n\n    /* set the port */\n    if (port > 0) {\n        unsigned int portU = port;\n\n        if (ssh_options_set(sess->session, SSH_OPTIONS_PORT, &portU) < 0)\n            goto error;\n    }\n\n    /* set the known hosts file, if specified */\n    if (hostsfile) {\n        if (ssh_options_set(sess->session, SSH_OPTIONS_KNOWNHOSTS, hostsfile) < 0)\n            goto error;\n\n        VIR_FREE(sess->knownHostsFile);\n        sess->knownHostsFile = g_strdup(hostsfile);\n    } else {\n        /* libssh does not support trying no known_host file at all:\n         * hence use /dev/null here, without storing it as file */\n        if (ssh_options_set(sess->session, SSH_OPTIONS_KNOWNHOSTS, \"/dev/null\") < 0)\n            goto error;\n    }\n\n    virObjectUnlock(sess);\n    return 0;\n\n error:\n    virObjectUnlock(sess);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Invalid host key verification method: '%s'\")",
            "knownHostsVerify"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "\"normal\"",
            "knownHostsVerify"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "\"ignore\"",
            "knownHostsVerify"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "\"auto\"",
            "knownHostsVerify"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionAuthSetCallback",
          "args": [
            "sess",
            "auth"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionAuthSetCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "949-957",
          "snippet": "int\nvirNetLibsshSessionAuthSetCallback(virNetLibsshSessionPtr sess,\n                                   virConnectAuthPtr auth)\n{\n    virObjectLock(sess);\n    sess->cred = auth;\n    virObjectUnlock(sess);\n    return 0;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nint\nvirNetLibsshSessionAuthSetCallback(virNetLibsshSessionPtr sess,\n                                   virConnectAuthPtr auth)\n{\n    virObjectLock(sess);\n    sess->cred = auth;\n    virObjectUnlock(sess);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetLibsshSessionNew",
          "args": [
            "username"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "virNetLibsshSessionNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetlibsshsession.c",
          "lines": "1151-1188",
          "snippet": "virNetLibsshSessionPtr virNetLibsshSessionNew(const char *username)\n{\n    virNetLibsshSessionPtr sess = NULL;\n\n    if (virNetLibsshSessionInitialize() < 0)\n        goto error;\n\n    if (!(sess = virObjectLockableNew(virNetLibsshSessionClass)))\n        goto error;\n\n    /* initialize session data */\n    if (!(sess->session = ssh_new())) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Failed to initialize libssh session\"));\n        goto error;\n    }\n\n    sess->username = g_strdup(username);\n\n    VIR_DEBUG(\"virNetLibsshSessionPtr: %p, ssh_session: %p\",\n              sess, sess->session);\n\n    /* set blocking mode for libssh until handshake is complete */\n    ssh_set_blocking(sess->session, 1);\n\n    if (ssh_options_set(sess->session, SSH_OPTIONS_USER, sess->username) < 0)\n        goto error;\n\n    /* default states for config variables */\n    sess->state = VIR_NET_LIBSSH_STATE_NEW;\n    sess->hostKeyVerify = VIR_NET_LIBSSH_HOSTKEY_VERIFY_IGNORE;\n\n    return sess;\n\n error:\n    virObjectUnref(sess);\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"virnetlibsshsession.h\"",
            "#include <libssh/libssh.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetLibsshSessionClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"virnetlibsshsession.h\"\n#include <libssh/libssh.h>\n#include <config.h>\n\nstatic virClassPtr virNetLibsshSessionClass;\n\nvirNetLibsshSessionPtr virNetLibsshSessionNew(const char *username)\n{\n    virNetLibsshSessionPtr sess = NULL;\n\n    if (virNetLibsshSessionInitialize() < 0)\n        goto error;\n\n    if (!(sess = virObjectLockableNew(virNetLibsshSessionClass)))\n        goto error;\n\n    /* initialize session data */\n    if (!(sess->session = ssh_new())) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Failed to initialize libssh session\"));\n        goto error;\n    }\n\n    sess->username = g_strdup(username);\n\n    VIR_DEBUG(\"virNetLibsshSessionPtr: %p, ssh_session: %p\",\n              sess, sess->session);\n\n    /* set blocking mode for libssh until handshake is complete */\n    ssh_set_blocking(sess->session, 1);\n\n    if (ssh_options_set(sess->session, SSH_OPTIONS_USER, sess->username) < 0)\n        goto error;\n\n    /* default states for config variables */\n    sess->state = VIR_NET_LIBSSH_STATE_NEW;\n    sess->hostKeyVerify = VIR_NET_LIBSSH_HOSTKEY_VERIFY_IGNORE;\n\n    return sess;\n\n error:\n    virObjectUnref(sess);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_LIBSSH",
            "\"%s\"",
            "_(\"Failed to parse port number\")"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "port",
            "NULL",
            "10",
            "&portN"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirNetSocketNewConnectLibssh(const char *host,\n                             const char *port,\n                             int family,\n                             const char *username,\n                             const char *privkey,\n                             const char *knownHosts,\n                             const char *knownHostsVerify,\n                             const char *authMethods,\n                             const char *command,\n                             virConnectAuthPtr auth,\n                             virURIPtr uri,\n                             virNetSocketPtr *retsock)\n{\n    virNetSocketPtr sock = NULL;\n    virNetLibsshSessionPtr sess = NULL;\n    unsigned int verify;\n    int ret = -1;\n    int portN;\n\n    VIR_AUTOSTRINGLIST authMethodList = NULL;\n    char **authMethodNext;\n\n    /* port number will be verified while opening the socket */\n    if (virStrToLong_i(port, NULL, 10, &portN) < 0) {\n        virReportError(VIR_ERR_LIBSSH, \"%s\",\n                       _(\"Failed to parse port number\"));\n        goto error;\n    }\n\n    /* create ssh session context */\n    if (!(sess = virNetLibsshSessionNew(username)))\n        goto error;\n\n    /* set ssh session parameters */\n    if (virNetLibsshSessionAuthSetCallback(sess, auth) != 0)\n        goto error;\n\n    if (STRCASEEQ(\"auto\", knownHostsVerify)) {\n        verify = VIR_NET_LIBSSH_HOSTKEY_VERIFY_AUTO_ADD;\n    } else if (STRCASEEQ(\"ignore\", knownHostsVerify)) {\n        verify = VIR_NET_LIBSSH_HOSTKEY_VERIFY_IGNORE;\n    } else if (STRCASEEQ(\"normal\", knownHostsVerify)) {\n        verify = VIR_NET_LIBSSH_HOSTKEY_VERIFY_NORMAL;\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid host key verification method: '%s'\"),\n                       knownHostsVerify);\n        goto error;\n    }\n\n    if (virNetLibsshSessionSetHostKeyVerification(sess,\n                                                  host,\n                                                  portN,\n                                                  knownHosts,\n                                                  verify) != 0)\n        goto error;\n\n    if (virNetLibsshSessionSetChannelCommand(sess, command) != 0)\n        goto error;\n\n    if (!(authMethodList = virStringSplit(authMethods, \",\", 0)))\n        goto error;\n\n    for (authMethodNext = authMethodList; *authMethodNext; authMethodNext++) {\n        const char *authMethod = *authMethodNext;\n\n        if (STRCASEEQ(authMethod, \"keyboard-interactive\")) {\n            ret = virNetLibsshSessionAuthAddKeyboardAuth(sess, -1);\n        } else if (STRCASEEQ(authMethod, \"password\")) {\n            ret = virNetLibsshSessionAuthAddPasswordAuth(sess, uri);\n        } else if (STRCASEEQ(authMethod, \"privkey\")) {\n            ret = virNetLibsshSessionAuthAddPrivKeyAuth(sess,\n                                                        privkey,\n                                                        NULL);\n        } else if (STRCASEEQ(authMethod, \"agent\")) {\n            ret = virNetLibsshSessionAuthAddAgentAuth(sess);\n        } else {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Invalid authentication method: '%s'\"),\n                           authMethod);\n            ret = -1;\n            goto error;\n        }\n\n        if (ret != 0)\n            goto error;\n    }\n\n    /* connect to remote server */\n    if ((ret = virNetSocketNewConnectTCP(host, port, family, &sock)) < 0)\n        goto error;\n\n    /* connect to the host using ssh */\n    if ((ret = virNetLibsshSessionConnect(sess, virNetSocketGetFD(sock))) != 0)\n        goto error;\n\n    sock->libsshSession = sess;\n    /* libssh owns the FD and closes it on its own, and thus\n     * we must not close it (otherwise there are warnings about\n     * trying to close an invalid FD).\n     */\n    sock->ownsFd = false;\n    *retsock = sock;\n\n    return 0;\n\n error:\n    virObjectUnref(sock);\n    virObjectUnref(sess);\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketNewConnectLibSSH2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "1025-1042",
    "snippet": "int\nvirNetSocketNewConnectLibSSH2(const char *host G_GNUC_UNUSED,\n                              const char *port G_GNUC_UNUSED,\n                              int family G_GNUC_UNUSED,\n                              const char *username G_GNUC_UNUSED,\n                              const char *privkey G_GNUC_UNUSED,\n                              const char *knownHosts G_GNUC_UNUSED,\n                              const char *knownHostsVerify G_GNUC_UNUSED,\n                              const char *authMethods G_GNUC_UNUSED,\n                              const char *command G_GNUC_UNUSED,\n                              virConnectAuthPtr auth G_GNUC_UNUSED,\n                              virURIPtr uri G_GNUC_UNUSED,\n                              virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"libssh2 transport support was not enabled\"));\n    return -1;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"libssh2 transport support was not enabled\")"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"libssh2 transport support was not enabled\""
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirNetSocketNewConnectLibSSH2(const char *host G_GNUC_UNUSED,\n                              const char *port G_GNUC_UNUSED,\n                              int family G_GNUC_UNUSED,\n                              const char *username G_GNUC_UNUSED,\n                              const char *privkey G_GNUC_UNUSED,\n                              const char *knownHosts G_GNUC_UNUSED,\n                              const char *knownHostsVerify G_GNUC_UNUSED,\n                              const char *authMethods G_GNUC_UNUSED,\n                              const char *command G_GNUC_UNUSED,\n                              virConnectAuthPtr auth G_GNUC_UNUSED,\n                              virURIPtr uri G_GNUC_UNUSED,\n                              virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"libssh2 transport support was not enabled\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetSocketNewConnectLibSSH2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "913-1023",
    "snippet": "int\nvirNetSocketNewConnectLibSSH2(const char *host,\n                              const char *port,\n                              int family,\n                              const char *username,\n                              const char *privkey,\n                              const char *knownHosts,\n                              const char *knownHostsVerify,\n                              const char *authMethods,\n                              const char *command,\n                              virConnectAuthPtr auth,\n                              virURIPtr uri,\n                              virNetSocketPtr *retsock)\n{\n    virNetSocketPtr sock = NULL;\n    virNetSSHSessionPtr sess = NULL;\n    unsigned int verify;\n    int ret = -1;\n    int portN;\n\n    VIR_AUTOSTRINGLIST authMethodList = NULL;\n    char **authMethodNext;\n\n    /* port number will be verified while opening the socket */\n    if (virStrToLong_i(port, NULL, 10, &portN) < 0) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Failed to parse port number\"));\n        goto error;\n    }\n\n    /* create ssh session context */\n    if (!(sess = virNetSSHSessionNew()))\n        goto error;\n\n    /* set ssh session parameters */\n    if (virNetSSHSessionAuthSetCallback(sess, auth) != 0)\n        goto error;\n\n    if (STRCASEEQ(\"auto\", knownHostsVerify)) {\n        verify = VIR_NET_SSH_HOSTKEY_VERIFY_AUTO_ADD;\n    } else if (STRCASEEQ(\"ignore\", knownHostsVerify)) {\n        verify = VIR_NET_SSH_HOSTKEY_VERIFY_IGNORE;\n    } else if (STRCASEEQ(\"normal\", knownHostsVerify)) {\n        verify = VIR_NET_SSH_HOSTKEY_VERIFY_NORMAL;\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid host key verification method: '%s'\"),\n                       knownHostsVerify);\n        goto error;\n    }\n\n    if (virNetSSHSessionSetHostKeyVerification(sess,\n                                               host,\n                                               portN,\n                                               knownHosts,\n                                               verify,\n                                               VIR_NET_SSH_HOSTKEY_FILE_CREATE) != 0)\n        goto error;\n\n    if (virNetSSHSessionSetChannelCommand(sess, command) != 0)\n        goto error;\n\n    if (!(authMethodList = virStringSplit(authMethods, \",\", 0)))\n        goto error;\n\n    for (authMethodNext = authMethodList; *authMethodNext; authMethodNext++) {\n        const char *authMethod = *authMethodNext;\n\n        if (STRCASEEQ(authMethod, \"keyboard-interactive\")) {\n            ret = virNetSSHSessionAuthAddKeyboardAuth(sess, username, -1);\n        } else if (STRCASEEQ(authMethod, \"password\")) {\n            ret = virNetSSHSessionAuthAddPasswordAuth(sess,\n                                                      uri,\n                                                      username);\n        } else if (STRCASEEQ(authMethod, \"privkey\")) {\n            ret = virNetSSHSessionAuthAddPrivKeyAuth(sess,\n                                                     username,\n                                                     privkey,\n                                                     NULL);\n        } else if (STRCASEEQ(authMethod, \"agent\")) {\n            ret = virNetSSHSessionAuthAddAgentAuth(sess, username);\n        } else {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Invalid authentication method: '%s'\"),\n                           authMethod);\n            ret = -1;\n            goto error;\n        }\n\n        if (ret != 0)\n            goto error;\n    }\n\n    /* connect to remote server */\n    if ((ret = virNetSocketNewConnectTCP(host, port, family, &sock)) < 0)\n        goto error;\n\n    /* connect to the host using ssh */\n    if ((ret = virNetSSHSessionConnect(sess, virNetSocketGetFD(sock))) != 0)\n        goto error;\n\n    sock->sshSession = sess;\n    *retsock = sock;\n\n    return 0;\n\n error:\n    virObjectUnref(sock);\n    virObjectUnref(sess);\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sess"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSSHSessionConnect",
          "args": [
            "sess",
            "virNetSocketGetFD(sock)"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSSHSessionConnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsshsession.c",
          "lines": "1254-1310",
          "snippet": "int\nvirNetSSHSessionConnect(virNetSSHSessionPtr sess,\n                        int sock)\n{\n    int ret;\n    char *errmsg;\n\n    VIR_DEBUG(\"sess=%p, sock=%d\", sess, sock);\n\n    if (!sess || sess->state != VIR_NET_SSH_STATE_NEW) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Invalid virNetSSHSessionPtr\"));\n        return -1;\n    }\n\n    virObjectLock(sess);\n\n    /* check if configuration is valid */\n    if ((ret = virNetSSHValidateConfig(sess)) < 0)\n        goto error;\n\n    /* open session */\n    ret = libssh2_session_handshake(sess->session, sock);\n    /* libssh2 is in blocking mode, so EAGAIN will never happen */\n    if (ret < 0) {\n        libssh2_session_last_error(sess->session, &errmsg, NULL, 0);\n        virReportError(VIR_ERR_NO_CONNECT,\n                       _(\"SSH session handshake failed: %s\"),\n                       errmsg);\n        goto error;\n    }\n\n    /* verify the SSH host key */\n    if ((ret = virNetSSHCheckHostKey(sess)) != 0)\n        goto error;\n\n    /* authenticate */\n    if ((ret = virNetSSHAuthenticate(sess)) != 0)\n        goto error;\n\n    /* open channel */\n    if ((ret = virNetSSHOpenChannel(sess)) != 0)\n        goto error;\n\n    /* all set */\n    /* switch to nonblocking mode and return */\n    libssh2_session_set_blocking(sess->session, 0);\n    sess->state = VIR_NET_SSH_STATE_HANDSHAKE_COMPLETE;\n\n    virObjectUnlock(sess);\n    return ret;\n\n error:\n    sess->state = VIR_NET_SSH_STATE_ERROR;\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"virnetsshsession.h\"",
            "#include <libssh2_publickey.h>",
            "#include <libssh2.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"virnetsshsession.h\"\n#include <libssh2_publickey.h>\n#include <libssh2.h>\n#include <config.h>\n\nint\nvirNetSSHSessionConnect(virNetSSHSessionPtr sess,\n                        int sock)\n{\n    int ret;\n    char *errmsg;\n\n    VIR_DEBUG(\"sess=%p, sock=%d\", sess, sock);\n\n    if (!sess || sess->state != VIR_NET_SSH_STATE_NEW) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Invalid virNetSSHSessionPtr\"));\n        return -1;\n    }\n\n    virObjectLock(sess);\n\n    /* check if configuration is valid */\n    if ((ret = virNetSSHValidateConfig(sess)) < 0)\n        goto error;\n\n    /* open session */\n    ret = libssh2_session_handshake(sess->session, sock);\n    /* libssh2 is in blocking mode, so EAGAIN will never happen */\n    if (ret < 0) {\n        libssh2_session_last_error(sess->session, &errmsg, NULL, 0);\n        virReportError(VIR_ERR_NO_CONNECT,\n                       _(\"SSH session handshake failed: %s\"),\n                       errmsg);\n        goto error;\n    }\n\n    /* verify the SSH host key */\n    if ((ret = virNetSSHCheckHostKey(sess)) != 0)\n        goto error;\n\n    /* authenticate */\n    if ((ret = virNetSSHAuthenticate(sess)) != 0)\n        goto error;\n\n    /* open channel */\n    if ((ret = virNetSSHOpenChannel(sess)) != 0)\n        goto error;\n\n    /* all set */\n    /* switch to nonblocking mode and return */\n    libssh2_session_set_blocking(sess->session, 0);\n    sess->state = VIR_NET_SSH_STATE_HANDSHAKE_COMPLETE;\n\n    virObjectUnlock(sess);\n    return ret;\n\n error:\n    sess->state = VIR_NET_SSH_STATE_ERROR;\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketGetFD",
          "args": [
            "sock"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketGetFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1377-1384",
          "snippet": "int virNetSocketGetFD(virNetSocketPtr sock)\n{\n    int fd;\n    virObjectLock(sock);\n    fd = sock->fd;\n    virObjectUnlock(sock);\n    return fd;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketGetFD(virNetSocketPtr sock)\n{\n    int fd;\n    virObjectLock(sock);\n    fd = sock->fd;\n    virObjectUnlock(sock);\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewConnectTCP",
          "args": [
            "host",
            "port",
            "family",
            "&sock"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewConnectTCP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "558-640",
          "snippet": "int virNetSocketNewConnectTCP(const char *nodename,\n                              const char *service,\n                              int family,\n                              virNetSocketPtr *retsock)\n{\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    struct addrinfo *runp;\n    int savedErrno = ENOENT;\n\n    *retsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG | AI_V4MAPPED;\n    hints.ai_socktype = SOCK_STREAM;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    runp = ai;\n    while (runp) {\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, false) < 0)\n            VIR_WARN(\"Unable to enable port reuse\");\n\n        if (connect(fd, runp->ai_addr, runp->ai_addrlen) >= 0)\n            break;\n\n        savedErrno = errno;\n        closesocket(fd);\n        fd = -1;\n        runp = runp->ai_next;\n    }\n\n    if (fd == -1) {\n        virReportSystemError(savedErrno,\n                             _(\"unable to connect to server at '%s:%s'\"),\n                             nodename, service);\n        goto error;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto error;\n    }\n\n    remoteAddr.len = sizeof(remoteAddr.data);\n    if (getpeername(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get remote socket name\"));\n        goto error;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, &remoteAddr, true, fd, -1, 0, false)))\n        goto error;\n\n    freeaddrinfo(ai);\n\n    return 0;\n\n error:\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectTCP(const char *nodename,\n                              const char *service,\n                              int family,\n                              virNetSocketPtr *retsock)\n{\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    struct addrinfo *runp;\n    int savedErrno = ENOENT;\n\n    *retsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG | AI_V4MAPPED;\n    hints.ai_socktype = SOCK_STREAM;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    runp = ai;\n    while (runp) {\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, false) < 0)\n            VIR_WARN(\"Unable to enable port reuse\");\n\n        if (connect(fd, runp->ai_addr, runp->ai_addrlen) >= 0)\n            break;\n\n        savedErrno = errno;\n        closesocket(fd);\n        fd = -1;\n        runp = runp->ai_next;\n    }\n\n    if (fd == -1) {\n        virReportSystemError(savedErrno,\n                             _(\"unable to connect to server at '%s:%s'\"),\n                             nodename, service);\n        goto error;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto error;\n    }\n\n    remoteAddr.len = sizeof(remoteAddr.data);\n    if (getpeername(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get remote socket name\"));\n        goto error;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, &remoteAddr, true, fd, -1, 0, false)))\n        goto error;\n\n    freeaddrinfo(ai);\n\n    return 0;\n\n error:\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Invalid authentication method: '%s'\")",
            "authMethod"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid authentication method: '%s'\""
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSSHSessionAuthAddAgentAuth",
          "args": [
            "sess",
            "username"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSSHSessionAuthAddAgentAuth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsshsession.c",
          "lines": "1022-1053",
          "snippet": "int\nvirNetSSHSessionAuthAddAgentAuth(virNetSSHSessionPtr sess,\n                                 const char *username)\n{\n    virNetSSHAuthMethodPtr auth;\n    char *user = NULL;\n\n    if (!username) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Username must be provided \"\n                         \"for ssh agent authentication\"));\n        return -1;\n    }\n\n    virObjectLock(sess);\n\n    user = g_strdup(username);\n\n    if (!(auth = virNetSSHSessionAuthMethodNew(sess)))\n        goto error;\n\n    auth->username = user;\n    auth->method = VIR_NET_SSH_AUTH_AGENT;\n\n    virObjectUnlock(sess);\n    return 0;\n\n error:\n    VIR_FREE(user);\n    virObjectUnlock(sess);\n    return -1;\n}",
          "includes": [
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"virnetsshsession.h\"",
            "#include <libssh2_publickey.h>",
            "#include <libssh2.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"virnetsshsession.h\"\n#include <libssh2_publickey.h>\n#include <libssh2.h>\n#include <config.h>\n\nint\nvirNetSSHSessionAuthAddAgentAuth(virNetSSHSessionPtr sess,\n                                 const char *username)\n{\n    virNetSSHAuthMethodPtr auth;\n    char *user = NULL;\n\n    if (!username) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Username must be provided \"\n                         \"for ssh agent authentication\"));\n        return -1;\n    }\n\n    virObjectLock(sess);\n\n    user = g_strdup(username);\n\n    if (!(auth = virNetSSHSessionAuthMethodNew(sess)))\n        goto error;\n\n    auth->username = user;\n    auth->method = VIR_NET_SSH_AUTH_AGENT;\n\n    virObjectUnlock(sess);\n    return 0;\n\n error:\n    VIR_FREE(user);\n    virObjectUnlock(sess);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "authMethod",
            "\"agent\""
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSSHSessionAuthAddPrivKeyAuth",
          "args": [
            "sess",
            "username",
            "privkey",
            "NULL"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSSHSessionAuthAddPrivKeyAuth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsshsession.c",
          "lines": "1055-1097",
          "snippet": "int\nvirNetSSHSessionAuthAddPrivKeyAuth(virNetSSHSessionPtr sess,\n                                   const char *username,\n                                   const char *keyfile,\n                                   const char *password)\n{\n    virNetSSHAuthMethodPtr auth;\n\n    char *user = NULL;\n    char *pass = NULL;\n    char *file = NULL;\n\n    if (!username || !keyfile) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Username and key file path must be provided \"\n                         \"for private key authentication\"));\n        return -1;\n    }\n\n    virObjectLock(sess);\n\n    user = g_strdup(username);\n    file = g_strdup(keyfile);\n    pass = g_strdup(password);\n\n    if (!(auth = virNetSSHSessionAuthMethodNew(sess)))\n        goto error;\n\n    auth->username = user;\n    auth->password = pass;\n    auth->filename = file;\n    auth->method = VIR_NET_SSH_AUTH_PRIVKEY;\n\n    virObjectUnlock(sess);\n    return 0;\n\n error:\n    VIR_FREE(user);\n    VIR_FREE(pass);\n    VIR_FREE(file);\n    virObjectUnlock(sess);\n    return -1;\n}",
          "includes": [
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"virnetsshsession.h\"",
            "#include <libssh2_publickey.h>",
            "#include <libssh2.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"virnetsshsession.h\"\n#include <libssh2_publickey.h>\n#include <libssh2.h>\n#include <config.h>\n\nint\nvirNetSSHSessionAuthAddPrivKeyAuth(virNetSSHSessionPtr sess,\n                                   const char *username,\n                                   const char *keyfile,\n                                   const char *password)\n{\n    virNetSSHAuthMethodPtr auth;\n\n    char *user = NULL;\n    char *pass = NULL;\n    char *file = NULL;\n\n    if (!username || !keyfile) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Username and key file path must be provided \"\n                         \"for private key authentication\"));\n        return -1;\n    }\n\n    virObjectLock(sess);\n\n    user = g_strdup(username);\n    file = g_strdup(keyfile);\n    pass = g_strdup(password);\n\n    if (!(auth = virNetSSHSessionAuthMethodNew(sess)))\n        goto error;\n\n    auth->username = user;\n    auth->password = pass;\n    auth->filename = file;\n    auth->method = VIR_NET_SSH_AUTH_PRIVKEY;\n\n    virObjectUnlock(sess);\n    return 0;\n\n error:\n    VIR_FREE(user);\n    VIR_FREE(pass);\n    VIR_FREE(file);\n    virObjectUnlock(sess);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "authMethod",
            "\"privkey\""
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSSHSessionAuthAddPasswordAuth",
          "args": [
            "sess",
            "uri",
            "username"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSSHSessionAuthAddPasswordAuth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsshsession.c",
          "lines": "982-1020",
          "snippet": "int\nvirNetSSHSessionAuthAddPasswordAuth(virNetSSHSessionPtr sess,\n                                    virURIPtr uri,\n                                    const char *username)\n{\n    virNetSSHAuthMethodPtr auth;\n    char *user = NULL;\n\n    if (uri) {\n        VIR_FREE(sess->authPath);\n\n        if (virAuthGetConfigFilePathURI(uri, &sess->authPath) < 0)\n            goto error;\n    }\n\n    if (!username) {\n        if (!(user = virAuthGetUsernamePath(sess->authPath, sess->cred,\n                                            \"ssh\", NULL, sess->hostname)))\n            goto error;\n    } else {\n        user = g_strdup(username);\n    }\n\n    virObjectLock(sess);\n\n    if (!(auth = virNetSSHSessionAuthMethodNew(sess)))\n        goto error;\n\n    auth->username = user;\n    auth->method = VIR_NET_SSH_AUTH_PASSWORD;\n\n    virObjectUnlock(sess);\n    return 0;\n\n error:\n    VIR_FREE(user);\n    virObjectUnlock(sess);\n    return -1;\n}",
          "includes": [
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"virnetsshsession.h\"",
            "#include <libssh2_publickey.h>",
            "#include <libssh2.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"virnetsshsession.h\"\n#include <libssh2_publickey.h>\n#include <libssh2.h>\n#include <config.h>\n\nint\nvirNetSSHSessionAuthAddPasswordAuth(virNetSSHSessionPtr sess,\n                                    virURIPtr uri,\n                                    const char *username)\n{\n    virNetSSHAuthMethodPtr auth;\n    char *user = NULL;\n\n    if (uri) {\n        VIR_FREE(sess->authPath);\n\n        if (virAuthGetConfigFilePathURI(uri, &sess->authPath) < 0)\n            goto error;\n    }\n\n    if (!username) {\n        if (!(user = virAuthGetUsernamePath(sess->authPath, sess->cred,\n                                            \"ssh\", NULL, sess->hostname)))\n            goto error;\n    } else {\n        user = g_strdup(username);\n    }\n\n    virObjectLock(sess);\n\n    if (!(auth = virNetSSHSessionAuthMethodNew(sess)))\n        goto error;\n\n    auth->username = user;\n    auth->method = VIR_NET_SSH_AUTH_PASSWORD;\n\n    virObjectUnlock(sess);\n    return 0;\n\n error:\n    VIR_FREE(user);\n    virObjectUnlock(sess);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "authMethod",
            "\"password\""
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSSHSessionAuthAddKeyboardAuth",
          "args": [
            "sess",
            "username",
            "-1"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSSHSessionAuthAddKeyboardAuth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsshsession.c",
          "lines": "1099-1133",
          "snippet": "int\nvirNetSSHSessionAuthAddKeyboardAuth(virNetSSHSessionPtr sess,\n                                    const char *username,\n                                    int tries)\n{\n    virNetSSHAuthMethodPtr auth;\n    char *user = NULL;\n\n    if (!username) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Username must be provided \"\n                         \"for ssh agent authentication\"));\n        return -1;\n    }\n\n    virObjectLock(sess);\n\n    user = g_strdup(username);\n\n    if (!(auth = virNetSSHSessionAuthMethodNew(sess)))\n        goto error;\n\n    auth->username = user;\n    auth->tries = tries;\n    auth->method = VIR_NET_SSH_AUTH_KEYBOARD_INTERACTIVE;\n\n    virObjectUnlock(sess);\n    return 0;\n\n error:\n    VIR_FREE(user);\n    virObjectUnlock(sess);\n    return -1;\n\n}",
          "includes": [
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"virnetsshsession.h\"",
            "#include <libssh2_publickey.h>",
            "#include <libssh2.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"virnetsshsession.h\"\n#include <libssh2_publickey.h>\n#include <libssh2.h>\n#include <config.h>\n\nint\nvirNetSSHSessionAuthAddKeyboardAuth(virNetSSHSessionPtr sess,\n                                    const char *username,\n                                    int tries)\n{\n    virNetSSHAuthMethodPtr auth;\n    char *user = NULL;\n\n    if (!username) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Username must be provided \"\n                         \"for ssh agent authentication\"));\n        return -1;\n    }\n\n    virObjectLock(sess);\n\n    user = g_strdup(username);\n\n    if (!(auth = virNetSSHSessionAuthMethodNew(sess)))\n        goto error;\n\n    auth->username = user;\n    auth->tries = tries;\n    auth->method = VIR_NET_SSH_AUTH_KEYBOARD_INTERACTIVE;\n\n    virObjectUnlock(sess);\n    return 0;\n\n error:\n    VIR_FREE(user);\n    virObjectUnlock(sess);\n    return -1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "authMethod",
            "\"keyboard-interactive\""
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplit",
          "args": [
            "authMethods",
            "\",\"",
            "0"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "126-132",
          "snippet": "char **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSSHSessionSetChannelCommand",
          "args": [
            "sess",
            "command"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSSHSessionSetChannelCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsshsession.c",
          "lines": "1135-1148",
          "snippet": "int\nvirNetSSHSessionSetChannelCommand(virNetSSHSessionPtr sess,\n                                  const char *command)\n{\n    int ret = 0;\n    virObjectLock(sess);\n\n    VIR_FREE(sess->channelCommand);\n\n    sess->channelCommand = g_strdup(command);\n\n    virObjectUnlock(sess);\n    return ret;\n}",
          "includes": [
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"virnetsshsession.h\"",
            "#include <libssh2_publickey.h>",
            "#include <libssh2.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"virnetsshsession.h\"\n#include <libssh2_publickey.h>\n#include <libssh2.h>\n#include <config.h>\n\nint\nvirNetSSHSessionSetChannelCommand(virNetSSHSessionPtr sess,\n                                  const char *command)\n{\n    int ret = 0;\n    virObjectLock(sess);\n\n    VIR_FREE(sess->channelCommand);\n\n    sess->channelCommand = g_strdup(command);\n\n    virObjectUnlock(sess);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSSHSessionSetHostKeyVerification",
          "args": [
            "sess",
            "host",
            "portN",
            "knownHosts",
            "verify",
            "VIR_NET_SSH_HOSTKEY_FILE_CREATE"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSSHSessionSetHostKeyVerification",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsshsession.c",
          "lines": "1150-1201",
          "snippet": "int\nvirNetSSHSessionSetHostKeyVerification(virNetSSHSessionPtr sess,\n                                       const char *hostname,\n                                       int port,\n                                       const char *hostsfile,\n                                       virNetSSHHostkeyVerify opt,\n                                       unsigned int flags)\n{\n    char *errmsg;\n\n    virObjectLock(sess);\n\n    sess->port = port;\n    sess->hostKeyVerify = opt;\n\n    VIR_FREE(sess->hostname);\n\n    sess->hostname = g_strdup(hostname);\n\n    /* load the known hosts file */\n    if (hostsfile) {\n        if (virFileExists(hostsfile)) {\n            if (libssh2_knownhost_readfile(sess->knownHosts,\n                                           hostsfile,\n                                           LIBSSH2_KNOWNHOST_FILE_OPENSSH) < 0) {\n                libssh2_session_last_error(sess->session, &errmsg, NULL, 0);\n                virReportError(VIR_ERR_SSH,\n                               _(\"unable to load knownhosts file '%s': %s\"),\n                               hostsfile, errmsg);\n                goto error;\n            }\n        } else if (!(flags & VIR_NET_SSH_HOSTKEY_FILE_CREATE)) {\n            virReportError(VIR_ERR_SSH,\n                           _(\"known hosts file '%s' does not exist\"),\n                           hostsfile);\n            goto error;\n        }\n\n        /* set filename only if writing to the known hosts file is requested */\n        if (!(flags & VIR_NET_SSH_HOSTKEY_FILE_READONLY)) {\n            VIR_FREE(sess->knownHostsFile);\n            sess->knownHostsFile = g_strdup(hostsfile);\n        }\n    }\n\n    virObjectUnlock(sess);\n    return 0;\n\n error:\n    virObjectUnlock(sess);\n    return -1;\n}",
          "includes": [
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"virnetsshsession.h\"",
            "#include <libssh2_publickey.h>",
            "#include <libssh2.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"virnetsshsession.h\"\n#include <libssh2_publickey.h>\n#include <libssh2.h>\n#include <config.h>\n\nint\nvirNetSSHSessionSetHostKeyVerification(virNetSSHSessionPtr sess,\n                                       const char *hostname,\n                                       int port,\n                                       const char *hostsfile,\n                                       virNetSSHHostkeyVerify opt,\n                                       unsigned int flags)\n{\n    char *errmsg;\n\n    virObjectLock(sess);\n\n    sess->port = port;\n    sess->hostKeyVerify = opt;\n\n    VIR_FREE(sess->hostname);\n\n    sess->hostname = g_strdup(hostname);\n\n    /* load the known hosts file */\n    if (hostsfile) {\n        if (virFileExists(hostsfile)) {\n            if (libssh2_knownhost_readfile(sess->knownHosts,\n                                           hostsfile,\n                                           LIBSSH2_KNOWNHOST_FILE_OPENSSH) < 0) {\n                libssh2_session_last_error(sess->session, &errmsg, NULL, 0);\n                virReportError(VIR_ERR_SSH,\n                               _(\"unable to load knownhosts file '%s': %s\"),\n                               hostsfile, errmsg);\n                goto error;\n            }\n        } else if (!(flags & VIR_NET_SSH_HOSTKEY_FILE_CREATE)) {\n            virReportError(VIR_ERR_SSH,\n                           _(\"known hosts file '%s' does not exist\"),\n                           hostsfile);\n            goto error;\n        }\n\n        /* set filename only if writing to the known hosts file is requested */\n        if (!(flags & VIR_NET_SSH_HOSTKEY_FILE_READONLY)) {\n            VIR_FREE(sess->knownHostsFile);\n            sess->knownHostsFile = g_strdup(hostsfile);\n        }\n    }\n\n    virObjectUnlock(sess);\n    return 0;\n\n error:\n    virObjectUnlock(sess);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Invalid host key verification method: '%s'\")",
            "knownHostsVerify"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "\"normal\"",
            "knownHostsVerify"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "\"ignore\"",
            "knownHostsVerify"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "\"auto\"",
            "knownHostsVerify"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSSHSessionAuthSetCallback",
          "args": [
            "sess",
            "auth"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSSHSessionAuthSetCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsshsession.c",
          "lines": "964-972",
          "snippet": "int\nvirNetSSHSessionAuthSetCallback(virNetSSHSessionPtr sess,\n                                virConnectAuthPtr auth)\n{\n    virObjectLock(sess);\n    sess->cred = auth;\n    virObjectUnlock(sess);\n    return 0;\n}",
          "includes": [
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"virnetsshsession.h\"",
            "#include <libssh2_publickey.h>",
            "#include <libssh2.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"virnetsshsession.h\"\n#include <libssh2_publickey.h>\n#include <libssh2.h>\n#include <config.h>\n\nint\nvirNetSSHSessionAuthSetCallback(virNetSSHSessionPtr sess,\n                                virConnectAuthPtr auth)\n{\n    virObjectLock(sess);\n    sess->cred = auth;\n    virObjectUnlock(sess);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSSHSessionNew",
          "args": [],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSSHSessionNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsshsession.c",
          "lines": "1204-1252",
          "snippet": "virNetSSHSessionPtr virNetSSHSessionNew(void)\n{\n    virNetSSHSessionPtr sess = NULL;\n\n    if (virNetSSHSessionInitialize() < 0)\n        goto error;\n\n    if (!(sess = virObjectLockableNew(virNetSSHSessionClass)))\n        goto error;\n\n    /* initialize session data, use the internal data for callbacks\n     * and stick to default memory management functions */\n    if (!(sess->session = libssh2_session_init_ex(NULL,\n                                                  NULL,\n                                                  NULL,\n                                                  (void *)sess))) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Failed to initialize libssh2 session\"));\n        goto error;\n    }\n\n    if (!(sess->knownHosts = libssh2_knownhost_init(sess->session))) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Failed to initialize libssh2 known hosts table\"));\n        goto error;\n    }\n\n    if (!(sess->agent = libssh2_agent_init(sess->session))) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Failed to initialize libssh2 agent handle\"));\n        goto error;\n    }\n\n    VIR_DEBUG(\"virNetSSHSessionPtr: %p, LIBSSH2_SESSION: %p\",\n              sess, sess->session);\n\n    /* set blocking mode for libssh2 until handshake is complete */\n    libssh2_session_set_blocking(sess->session, 1);\n\n    /* default states for config variables */\n    sess->state = VIR_NET_SSH_STATE_NEW;\n    sess->hostKeyVerify = VIR_NET_SSH_HOSTKEY_VERIFY_IGNORE;\n\n    return sess;\n\n error:\n    virObjectUnref(sess);\n    return NULL;\n}",
          "includes": [
            "#include \"virauth.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"configmake.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"virnetsshsession.h\"",
            "#include <libssh2_publickey.h>",
            "#include <libssh2.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetSSHSessionClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virauth.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"configmake.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"virnetsshsession.h\"\n#include <libssh2_publickey.h>\n#include <libssh2.h>\n#include <config.h>\n\nstatic virClassPtr virNetSSHSessionClass;\n\nvirNetSSHSessionPtr virNetSSHSessionNew(void)\n{\n    virNetSSHSessionPtr sess = NULL;\n\n    if (virNetSSHSessionInitialize() < 0)\n        goto error;\n\n    if (!(sess = virObjectLockableNew(virNetSSHSessionClass)))\n        goto error;\n\n    /* initialize session data, use the internal data for callbacks\n     * and stick to default memory management functions */\n    if (!(sess->session = libssh2_session_init_ex(NULL,\n                                                  NULL,\n                                                  NULL,\n                                                  (void *)sess))) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Failed to initialize libssh2 session\"));\n        goto error;\n    }\n\n    if (!(sess->knownHosts = libssh2_knownhost_init(sess->session))) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Failed to initialize libssh2 known hosts table\"));\n        goto error;\n    }\n\n    if (!(sess->agent = libssh2_agent_init(sess->session))) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Failed to initialize libssh2 agent handle\"));\n        goto error;\n    }\n\n    VIR_DEBUG(\"virNetSSHSessionPtr: %p, LIBSSH2_SESSION: %p\",\n              sess, sess->session);\n\n    /* set blocking mode for libssh2 until handshake is complete */\n    libssh2_session_set_blocking(sess->session, 1);\n\n    /* default states for config variables */\n    sess->state = VIR_NET_SSH_STATE_NEW;\n    sess->hostKeyVerify = VIR_NET_SSH_HOSTKEY_VERIFY_IGNORE;\n\n    return sess;\n\n error:\n    virObjectUnref(sess);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SSH",
            "\"%s\"",
            "_(\"Failed to parse port number\")"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "port",
            "NULL",
            "10",
            "&portN"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirNetSocketNewConnectLibSSH2(const char *host,\n                              const char *port,\n                              int family,\n                              const char *username,\n                              const char *privkey,\n                              const char *knownHosts,\n                              const char *knownHostsVerify,\n                              const char *authMethods,\n                              const char *command,\n                              virConnectAuthPtr auth,\n                              virURIPtr uri,\n                              virNetSocketPtr *retsock)\n{\n    virNetSocketPtr sock = NULL;\n    virNetSSHSessionPtr sess = NULL;\n    unsigned int verify;\n    int ret = -1;\n    int portN;\n\n    VIR_AUTOSTRINGLIST authMethodList = NULL;\n    char **authMethodNext;\n\n    /* port number will be verified while opening the socket */\n    if (virStrToLong_i(port, NULL, 10, &portN) < 0) {\n        virReportError(VIR_ERR_SSH, \"%s\",\n                       _(\"Failed to parse port number\"));\n        goto error;\n    }\n\n    /* create ssh session context */\n    if (!(sess = virNetSSHSessionNew()))\n        goto error;\n\n    /* set ssh session parameters */\n    if (virNetSSHSessionAuthSetCallback(sess, auth) != 0)\n        goto error;\n\n    if (STRCASEEQ(\"auto\", knownHostsVerify)) {\n        verify = VIR_NET_SSH_HOSTKEY_VERIFY_AUTO_ADD;\n    } else if (STRCASEEQ(\"ignore\", knownHostsVerify)) {\n        verify = VIR_NET_SSH_HOSTKEY_VERIFY_IGNORE;\n    } else if (STRCASEEQ(\"normal\", knownHostsVerify)) {\n        verify = VIR_NET_SSH_HOSTKEY_VERIFY_NORMAL;\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid host key verification method: '%s'\"),\n                       knownHostsVerify);\n        goto error;\n    }\n\n    if (virNetSSHSessionSetHostKeyVerification(sess,\n                                               host,\n                                               portN,\n                                               knownHosts,\n                                               verify,\n                                               VIR_NET_SSH_HOSTKEY_FILE_CREATE) != 0)\n        goto error;\n\n    if (virNetSSHSessionSetChannelCommand(sess, command) != 0)\n        goto error;\n\n    if (!(authMethodList = virStringSplit(authMethods, \",\", 0)))\n        goto error;\n\n    for (authMethodNext = authMethodList; *authMethodNext; authMethodNext++) {\n        const char *authMethod = *authMethodNext;\n\n        if (STRCASEEQ(authMethod, \"keyboard-interactive\")) {\n            ret = virNetSSHSessionAuthAddKeyboardAuth(sess, username, -1);\n        } else if (STRCASEEQ(authMethod, \"password\")) {\n            ret = virNetSSHSessionAuthAddPasswordAuth(sess,\n                                                      uri,\n                                                      username);\n        } else if (STRCASEEQ(authMethod, \"privkey\")) {\n            ret = virNetSSHSessionAuthAddPrivKeyAuth(sess,\n                                                     username,\n                                                     privkey,\n                                                     NULL);\n        } else if (STRCASEEQ(authMethod, \"agent\")) {\n            ret = virNetSSHSessionAuthAddAgentAuth(sess, username);\n        } else {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Invalid authentication method: '%s'\"),\n                           authMethod);\n            ret = -1;\n            goto error;\n        }\n\n        if (ret != 0)\n            goto error;\n    }\n\n    /* connect to remote server */\n    if ((ret = virNetSocketNewConnectTCP(host, port, family, &sock)) < 0)\n        goto error;\n\n    /* connect to the host using ssh */\n    if ((ret = virNetSSHSessionConnect(sess, virNetSocketGetFD(sock))) != 0)\n        goto error;\n\n    sock->sshSession = sess;\n    *retsock = sock;\n\n    return 0;\n\n error:\n    virObjectUnref(sock);\n    virObjectUnref(sess);\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketNewConnectSSH",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "839-910",
    "snippet": "int virNetSocketNewConnectSSH(const char *nodename,\n                              const char *service,\n                              const char *binary,\n                              const char *username,\n                              bool noTTY,\n                              bool noVerify,\n                              const char *netcat,\n                              const char *keyfile,\n                              const char *path,\n                              virNetSocketPtr *retsock)\n{\n    char *quoted;\n    virCommandPtr cmd;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    *retsock = NULL;\n\n    cmd = virCommandNew(binary ? binary : \"ssh\");\n    virCommandAddEnvPassCommon(cmd);\n    virCommandAddEnvPass(cmd, \"KRB5CCNAME\");\n    virCommandAddEnvPass(cmd, \"SSH_AUTH_SOCK\");\n    virCommandAddEnvPass(cmd, \"SSH_ASKPASS\");\n    virCommandAddEnvPass(cmd, \"DISPLAY\");\n    virCommandAddEnvPass(cmd, \"XAUTHORITY\");\n    virCommandClearCaps(cmd);\n\n    if (service)\n        virCommandAddArgList(cmd, \"-p\", service, NULL);\n    if (username)\n        virCommandAddArgList(cmd, \"-l\", username, NULL);\n    if (keyfile)\n        virCommandAddArgList(cmd, \"-i\", keyfile, NULL);\n    virCommandAddArgList(cmd, \"-T\", \"-e\", \"none\", NULL);\n    if (noTTY)\n        virCommandAddArgList(cmd, \"-o\", \"BatchMode=yes\", NULL);\n    if (noVerify)\n        virCommandAddArgList(cmd, \"-o\", \"StrictHostKeyChecking=no\", NULL);\n\n    if (!netcat)\n        netcat = \"nc\";\n\n    virCommandAddArgList(cmd, \"--\", nodename, \"sh\", \"-c\", NULL);\n\n    virBufferEscapeShell(&buf, netcat);\n    quoted = virBufferContentAndReset(&buf);\n\n    virBufferEscapeShell(&buf, quoted);\n    VIR_FREE(quoted);\n    quoted = virBufferContentAndReset(&buf);\n\n    /*\n     * This ugly thing is a shell script to detect availability of\n     * the -q option for 'nc': debian and suse based distros need this\n     * flag to ensure the remote nc will exit on EOF, so it will go away\n     * when we close the connection tunnel. If it doesn't go away, subsequent\n     * connection attempts will hang.\n     *\n     * Fedora's 'nc' doesn't have this option, and defaults to the desired\n     * behavior.\n     */\n    virCommandAddArgFormat(cmd,\n         \"'if '%s' -q 2>&1 | grep \\\"requires an argument\\\" >/dev/null 2>&1; then \"\n             \"ARG=-q0;\"\n         \"else \"\n             \"ARG=;\"\n         \"fi;\"\n         \"'%s' $ARG -U %s'\",\n         quoted, quoted, path);\n\n    VIR_FREE(quoted);\n    return virNetSocketNewConnectCommand(cmd, retsock);\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSocketNewConnectCommand",
          "args": [
            "cmd",
            "retsock"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewConnectCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "830-836",
          "snippet": "int virNetSocketNewConnectCommand(virCommandPtr cmd G_GNUC_UNUSED,\n                                  virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(errno, \"%s\",\n                         _(\"Tunnelling sockets not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectCommand(virCommandPtr cmd G_GNUC_UNUSED,\n                                  virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(errno, \"%s\",\n                         _(\"Tunnelling sockets not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "quoted"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"'if '%s' -q 2>&1 | grep \\\"requires an argument\\\" >/dev/null 2>&1; then \"\n             \"ARG=-q0;\"\n         \"else \"\n             \"ARG=;\"\n         \"fi;\"\n         \"'%s' $ARG -U %s'\"",
            "quoted",
            "quoted",
            "path"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "quoted"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeShell",
          "args": [
            "&buf",
            "quoted"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeShell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "554-597",
          "snippet": "void\nvirBufferEscapeShell(virBufferPtr buf, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    /* Only quote if str includes shell metacharacters. */\n    if (*str && !strpbrk(str, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\")) {\n        virBufferAdd(buf, str, -1);\n        return;\n    }\n\n    if (*str) {\n        len = strlen(str);\n\n        escaped = g_malloc0_n(len + 1, 4);\n    } else {\n        virBufferAddLit(buf, \"''\");\n        return;\n    }\n\n    cur = str;\n    out = escaped;\n\n    *out++ = '\\'';\n    while (*cur != 0) {\n        if (*cur == '\\'') {\n            *out++ = '\\'';\n            /* Replace literal ' with a close ', a \\', and a open ' */\n            *out++ = '\\\\';\n            *out++ = '\\'';\n        }\n        *out++ = *cur++;\n    }\n    *out++ = '\\'';\n    *out = 0;\n\n    virBufferAdd(buf, escaped, -1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeShell(virBufferPtr buf, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    /* Only quote if str includes shell metacharacters. */\n    if (*str && !strpbrk(str, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\")) {\n        virBufferAdd(buf, str, -1);\n        return;\n    }\n\n    if (*str) {\n        len = strlen(str);\n\n        escaped = g_malloc0_n(len + 1, 4);\n    } else {\n        virBufferAddLit(buf, \"''\");\n        return;\n    }\n\n    cur = str;\n    out = escaped;\n\n    *out++ = '\\'';\n    while (*cur != 0) {\n        if (*cur == '\\'') {\n            *out++ = '\\'';\n            /* Replace literal ' with a close ', a \\', and a open ' */\n            *out++ = '\\\\';\n            *out++ = '\\'';\n        }\n        *out++ = *cur++;\n    }\n    *out++ = '\\'';\n    *out = 0;\n\n    virBufferAdd(buf, escaped, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"--\"",
            "nodename",
            "\"sh\"",
            "\"-c\"",
            "NULL"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandClearCaps",
          "args": [
            "cmd"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandClearCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1179-1186",
          "snippet": "void\nvirCommandClearCaps(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_CLEAR_CAPS;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandClearCaps(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_CLEAR_CAPS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddEnvPass",
          "args": [
            "cmd",
            "\"XAUTHORITY\""
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvPass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1434-1444",
          "snippet": "void\nvirCommandAddEnvPass(virCommandPtr cmd, const char *name)\n{\n    const char *value;\n    if (!cmd || cmd->has_error)\n        return;\n\n    value = getenv(name);\n    if (value)\n        virCommandAddEnvPair(cmd, name, value);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvPass(virCommandPtr cmd, const char *name)\n{\n    const char *value;\n    if (!cmd || cmd->has_error)\n        return;\n\n    value = getenv(name);\n    if (value)\n        virCommandAddEnvPair(cmd, name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddEnvPassCommon",
          "args": [
            "cmd"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvPassCommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1454-1474",
          "snippet": "void\nvirCommandAddEnvPassCommon(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 9) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvPair(cmd, \"LC_ALL\", \"C\");\n\n    virCommandAddEnvPass(cmd, \"LD_PRELOAD\");\n    virCommandAddEnvPass(cmd, \"LD_LIBRARY_PATH\");\n    virCommandAddEnvPass(cmd, \"PATH\");\n    virCommandAddEnvPass(cmd, \"HOME\");\n    virCommandAddEnvPass(cmd, \"USER\");\n    virCommandAddEnvPass(cmd, \"LOGNAME\");\n    virCommandAddEnvPass(cmd, \"TMPDIR\");\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvPassCommon(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 9) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvPair(cmd, \"LC_ALL\", \"C\");\n\n    virCommandAddEnvPass(cmd, \"LD_PRELOAD\");\n    virCommandAddEnvPass(cmd, \"LD_LIBRARY_PATH\");\n    virCommandAddEnvPass(cmd, \"PATH\");\n    virCommandAddEnvPass(cmd, \"HOME\");\n    virCommandAddEnvPass(cmd, \"USER\");\n    virCommandAddEnvPass(cmd, \"LOGNAME\");\n    virCommandAddEnvPass(cmd, \"TMPDIR\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "binary ? binary : \"ssh\""
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectSSH(const char *nodename,\n                              const char *service,\n                              const char *binary,\n                              const char *username,\n                              bool noTTY,\n                              bool noVerify,\n                              const char *netcat,\n                              const char *keyfile,\n                              const char *path,\n                              virNetSocketPtr *retsock)\n{\n    char *quoted;\n    virCommandPtr cmd;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    *retsock = NULL;\n\n    cmd = virCommandNew(binary ? binary : \"ssh\");\n    virCommandAddEnvPassCommon(cmd);\n    virCommandAddEnvPass(cmd, \"KRB5CCNAME\");\n    virCommandAddEnvPass(cmd, \"SSH_AUTH_SOCK\");\n    virCommandAddEnvPass(cmd, \"SSH_ASKPASS\");\n    virCommandAddEnvPass(cmd, \"DISPLAY\");\n    virCommandAddEnvPass(cmd, \"XAUTHORITY\");\n    virCommandClearCaps(cmd);\n\n    if (service)\n        virCommandAddArgList(cmd, \"-p\", service, NULL);\n    if (username)\n        virCommandAddArgList(cmd, \"-l\", username, NULL);\n    if (keyfile)\n        virCommandAddArgList(cmd, \"-i\", keyfile, NULL);\n    virCommandAddArgList(cmd, \"-T\", \"-e\", \"none\", NULL);\n    if (noTTY)\n        virCommandAddArgList(cmd, \"-o\", \"BatchMode=yes\", NULL);\n    if (noVerify)\n        virCommandAddArgList(cmd, \"-o\", \"StrictHostKeyChecking=no\", NULL);\n\n    if (!netcat)\n        netcat = \"nc\";\n\n    virCommandAddArgList(cmd, \"--\", nodename, \"sh\", \"-c\", NULL);\n\n    virBufferEscapeShell(&buf, netcat);\n    quoted = virBufferContentAndReset(&buf);\n\n    virBufferEscapeShell(&buf, quoted);\n    VIR_FREE(quoted);\n    quoted = virBufferContentAndReset(&buf);\n\n    /*\n     * This ugly thing is a shell script to detect availability of\n     * the -q option for 'nc': debian and suse based distros need this\n     * flag to ensure the remote nc will exit on EOF, so it will go away\n     * when we close the connection tunnel. If it doesn't go away, subsequent\n     * connection attempts will hang.\n     *\n     * Fedora's 'nc' doesn't have this option, and defaults to the desired\n     * behavior.\n     */\n    virCommandAddArgFormat(cmd,\n         \"'if '%s' -q 2>&1 | grep \\\"requires an argument\\\" >/dev/null 2>&1; then \"\n             \"ARG=-q0;\"\n         \"else \"\n             \"ARG=;\"\n         \"fi;\"\n         \"'%s' $ARG -U %s'\",\n         quoted, quoted, path);\n\n    VIR_FREE(quoted);\n    return virNetSocketNewConnectCommand(cmd, retsock);\n}"
  },
  {
    "function_name": "virNetSocketNewConnectCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "830-836",
    "snippet": "int virNetSocketNewConnectCommand(virCommandPtr cmd G_GNUC_UNUSED,\n                                  virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(errno, \"%s\",\n                         _(\"Tunnelling sockets not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Tunnelling sockets not supported on this platform\")"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Tunnelling sockets not supported on this platform\""
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectCommand(virCommandPtr cmd G_GNUC_UNUSED,\n                                  virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(errno, \"%s\",\n                         _(\"Tunnelling sockets not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetSocketNewConnectCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "778-828",
    "snippet": "int virNetSocketNewConnectCommand(virCommandPtr cmd,\n                                  virNetSocketPtr *retsock)\n{\n    pid_t pid = 0;\n    int sv[2] = { -1, -1 };\n    int errfd[2] = { -1, -1 };\n\n    *retsock = NULL;\n\n    /* Fork off the external process.  Use socketpair to create a private\n     * (unnamed) Unix domain socket to the child process so we don't have\n     * to faff around with two file descriptors (a la 'pipe(2)').\n     */\n    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sv) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"unable to create socket pair\"));\n        goto error;\n    }\n\n    if (virPipe(errfd) < 0)\n        goto error;\n\n    virCommandSetInputFD(cmd, sv[1]);\n    virCommandSetOutputFD(cmd, &sv[1]);\n    virCommandSetErrorFD(cmd, &errfd[1]);\n\n    if (virCommandRunAsync(cmd, &pid) < 0)\n        goto error;\n\n    /* Parent continues here. */\n    VIR_FORCE_CLOSE(sv[1]);\n    VIR_FORCE_CLOSE(errfd[1]);\n\n    if (!(*retsock = virNetSocketNew(NULL, NULL, true, sv[0], errfd[0], pid, false)))\n        goto error;\n\n    virCommandFree(cmd);\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(sv[0]);\n    VIR_FORCE_CLOSE(sv[1]);\n    VIR_FORCE_CLOSE(errfd[0]);\n    VIR_FORCE_CLOSE(errfd[1]);\n\n    virCommandAbort(cmd);\n    virCommandFree(cmd);\n\n    return -1;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAbort",
          "args": [
            "cmd"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2949-2955",
          "snippet": "void\nvirCommandAbort(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    /* Mingw lacks WNOHANG and kill().  But since we haven't ported\n     * virExec to mingw yet, there's no process to be killed,\n     * making this implementation trivially correct for now :)  */\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAbort(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    /* Mingw lacks WNOHANG and kill().  But since we haven't ported\n     * virExec to mingw yet, there's no process to be killed,\n     * making this implementation trivially correct for now :)  */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "errfd[1]"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "errfd[0]"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "sv[1]"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "sv[0]"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketNew",
          "args": [
            "NULL",
            "NULL",
            "true",
            "sv[0]",
            "errfd[0]",
            "pid",
            "false"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "208-289",
          "snippet": "static virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetSocketClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virClassPtr virNetSocketClass;\n\nstatic virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "errfd[1]"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "sv[1]"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRunAsync",
          "args": [
            "cmd",
            "&pid"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetErrorFD",
          "args": [
            "cmd",
            "&errfd[1]"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetErrorFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1984-1997",
          "snippet": "void\nvirCommandSetErrorFD(virCommandPtr cmd, int *errfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errfdptr = errfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetErrorFD(virCommandPtr cmd, int *errfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errfdptr = errfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputFD",
          "args": [
            "cmd",
            "&sv[1]"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1958-1971",
          "snippet": "void\nvirCommandSetOutputFD(virCommandPtr cmd, int *outfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outfdptr = outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputFD(virCommandPtr cmd, int *outfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outfdptr = outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetInputFD",
          "args": [
            "cmd",
            "sv[1]"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetInputFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1928-1946",
          "snippet": "void\nvirCommandSetInputFD(virCommandPtr cmd, int infd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->infd != -1 || cmd->inbuf) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify input twice\");\n        return;\n    }\n    if (infd < 0) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify invalid input fd\");\n        return;\n    }\n\n    cmd->infd = infd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetInputFD(virCommandPtr cmd, int infd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->infd != -1 || cmd->inbuf) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify input twice\");\n        return;\n    }\n    if (infd < 0) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify invalid input fd\");\n        return;\n    }\n\n    cmd->infd = infd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPipe",
          "args": [
            "errfd"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "virPipeNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1813-1817",
          "snippet": "int\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"unable to create socket pair\")"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to create socket pair\""
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "PF_UNIX",
            "SOCK_STREAM",
            "0",
            "sv"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectCommand(virCommandPtr cmd,\n                                  virNetSocketPtr *retsock)\n{\n    pid_t pid = 0;\n    int sv[2] = { -1, -1 };\n    int errfd[2] = { -1, -1 };\n\n    *retsock = NULL;\n\n    /* Fork off the external process.  Use socketpair to create a private\n     * (unnamed) Unix domain socket to the child process so we don't have\n     * to faff around with two file descriptors (a la 'pipe(2)').\n     */\n    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sv) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"unable to create socket pair\"));\n        goto error;\n    }\n\n    if (virPipe(errfd) < 0)\n        goto error;\n\n    virCommandSetInputFD(cmd, sv[1]);\n    virCommandSetOutputFD(cmd, &sv[1]);\n    virCommandSetErrorFD(cmd, &errfd[1]);\n\n    if (virCommandRunAsync(cmd, &pid) < 0)\n        goto error;\n\n    /* Parent continues here. */\n    VIR_FORCE_CLOSE(sv[1]);\n    VIR_FORCE_CLOSE(errfd[1]);\n\n    if (!(*retsock = virNetSocketNew(NULL, NULL, true, sv[0], errfd[0], pid, false)))\n        goto error;\n\n    virCommandFree(cmd);\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(sv[0]);\n    VIR_FORCE_CLOSE(sv[1]);\n    VIR_FORCE_CLOSE(errfd[0]);\n    VIR_FORCE_CLOSE(errfd[1]);\n\n    virCommandAbort(cmd);\n    virCommandFree(cmd);\n\n    return -1;\n}"
  },
  {
    "function_name": "virNetSocketNewConnectUNIX",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "765-773",
    "snippet": "int virNetSocketNewConnectUNIX(const char *path G_GNUC_UNUSED,\n                               bool spawnDaemon G_GNUC_UNUSED,\n                               const char *binary G_GNUC_UNUSED,\n                               virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"UNIX sockets are not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"UNIX sockets are not supported on this platform\")"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"UNIX sockets are not supported on this platform\""
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectUNIX(const char *path G_GNUC_UNUSED,\n                               bool spawnDaemon G_GNUC_UNUSED,\n                               const char *binary G_GNUC_UNUSED,\n                               virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"UNIX sockets are not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetSocketNewConnectUNIX",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "644-763",
    "snippet": "int virNetSocketNewConnectUNIX(const char *path,\n                               bool spawnDaemon,\n                               const char *binary,\n                               virNetSocketPtr *retsock)\n{\n    char *lockpath = NULL;\n    int lockfd = -1;\n    int fd = -1;\n    int retries = 500;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    char *rundir = NULL;\n    int ret = -1;\n    bool daemonLaunched = false;\n\n    VIR_DEBUG(\"path=%s spawnDaemon=%d binary=%s\", path, spawnDaemon,\n        NULLSTR(binary));\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    remoteAddr.len = sizeof(remoteAddr.data.un);\n\n    if (spawnDaemon) {\n        g_autofree char *binname = NULL;\n\n        if (spawnDaemon && !binary) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Auto-spawn of daemon requested, \"\n                             \"but no binary specified\"));\n            goto cleanup;\n        }\n\n        binname = g_path_get_basename(binary);\n        rundir = virGetUserRuntimeDirectory();\n\n        if (virFileMakePathWithMode(rundir, 0700) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot create user runtime directory '%s'\"),\n                                 rundir);\n            goto cleanup;\n        }\n\n        lockpath = g_strdup_printf(\"%s/%s.lock\", rundir, binname);\n\n        if ((lockfd = open(lockpath, O_RDWR | O_CREAT, 0600)) < 0 ||\n            virSetCloseExec(lockfd) < 0) {\n            virReportSystemError(errno, _(\"Unable to create lock '%s'\"), lockpath);\n            goto cleanup;\n        }\n\n        if (virFileLock(lockfd, false, 0, 1, true) < 0) {\n            virReportSystemError(errno, _(\"Unable to lock '%s'\"), lockpath);\n            goto cleanup;\n        }\n    }\n\n    if ((fd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Failed to create socket\"));\n        goto cleanup;\n    }\n\n    remoteAddr.data.un.sun_family = AF_UNIX;\n    if (virStrcpyStatic(remoteAddr.data.un.sun_path, path) < 0) {\n        virReportSystemError(ENOMEM, _(\"Path %s too long for unix socket\"), path);\n        goto cleanup;\n    }\n    if (remoteAddr.data.un.sun_path[0] == '@')\n        remoteAddr.data.un.sun_path[0] = '\\0';\n\n    while (retries) {\n        if (connect(fd, &remoteAddr.data.sa, remoteAddr.len) == 0) {\n            VIR_DEBUG(\"connect() succeeded\");\n            break;\n        }\n        VIR_DEBUG(\"connect() failed: retries=%d errno=%d\", retries, errno);\n\n        retries--;\n        if (!spawnDaemon ||\n            retries == 0 ||\n            (errno != ENOENT && errno != ECONNREFUSED)) {\n            virReportSystemError(errno, _(\"Failed to connect socket to '%s'\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (!daemonLaunched) {\n            if (virNetSocketForkDaemon(binary) < 0)\n                goto cleanup;\n\n            daemonLaunched = true;\n        }\n\n        g_usleep(10000);\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto cleanup;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, &remoteAddr, true, fd, -1, 0, false)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (lockfd != -1) {\n        unlink(lockpath);\n        VIR_FORCE_CLOSE(lockfd);\n    }\n    VIR_FREE(lockpath);\n    VIR_FREE(rundir);\n\n    if (ret < 0 && fd != -1)\n        closesocket(fd);\n\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "fd"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "vir_closesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "197-213",
          "snippet": "int\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "rundir"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "lockpath"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "lockfd"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "lockpath"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketNew",
          "args": [
            "&localAddr",
            "&remoteAddr",
            "true",
            "fd",
            "-1",
            "0",
            "false"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "208-289",
          "snippet": "static virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetSocketClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virClassPtr virNetSocketClass;\n\nstatic virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to get local socket name\")"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get local socket name\""
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "fd",
            "&localAddr.data.sa",
            "&localAddr.len"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "vir_getsockname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "254-270",
          "snippet": "int\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "10000"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketForkDaemon",
          "args": [
            "binary"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketForkDaemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "125-141",
          "snippet": "static int virNetSocketForkDaemon(const char *binary)\n{\n    int ret;\n    virCommandPtr cmd = virCommandNewArgList(binary,\n                                             \"--timeout=120\",\n                                             NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n    virCommandAddEnvPass(cmd, \"XDG_CACHE_HOME\");\n    virCommandAddEnvPass(cmd, \"XDG_CONFIG_HOME\");\n    virCommandAddEnvPass(cmd, \"XDG_RUNTIME_DIR\");\n    virCommandClearCaps(cmd);\n    virCommandDaemonize(cmd);\n    ret = virCommandRun(cmd, NULL);\n    virCommandFree(cmd);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int virNetSocketForkDaemon(const char *binary)\n{\n    int ret;\n    virCommandPtr cmd = virCommandNewArgList(binary,\n                                             \"--timeout=120\",\n                                             NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n    virCommandAddEnvPass(cmd, \"XDG_CACHE_HOME\");\n    virCommandAddEnvPass(cmd, \"XDG_CONFIG_HOME\");\n    virCommandAddEnvPass(cmd, \"XDG_RUNTIME_DIR\");\n    virCommandClearCaps(cmd);\n    virCommandDaemonize(cmd);\n    ret = virCommandRun(cmd, NULL);\n    virCommandFree(cmd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to connect socket to '%s'\")",
            "path"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"connect() failed: retries=%d errno=%d\"",
            "retries",
            "errno"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"connect() succeeded\""
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "fd",
            "&remoteAddr.data.sa",
            "remoteAddr.len"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "vir_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "216-232",
          "snippet": "int\nvir_connect(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (connect(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_connect(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (connect(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOMEM",
            "_(\"Path %s too long for unix socket\")",
            "path"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "remoteAddr.data.un.sun_path",
            "path"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Failed to create socket\")"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "vir_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "351-367",
          "snippet": "int\nvir_socket(int domain, int type, int protocol)\n{\n    SOCKET sk;\n\n    /* We have to use WSASocket() instead of socket(), to create\n     * non-overlapped IO sockets. Overlapped IO sockets cannot\n     * be used with read/write.\n     */\n    sk = WSASocket(domain, type, protocol, NULL, 0, 0);\n    if (sk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(sk);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_socket(int domain, int type, int protocol)\n{\n    SOCKET sk;\n\n    /* We have to use WSASocket() instead of socket(), to create\n     * non-overlapped IO sockets. Overlapped IO sockets cannot\n     * be used with read/write.\n     */\n    sk = WSASocket(domain, type, protocol, NULL, 0, 0);\n    if (sk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(sk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to lock '%s'\")",
            "lockpath"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileLock",
          "args": [
            "lockfd",
            "false",
            "0",
            "1",
            "true"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "virFileLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "489-496",
          "snippet": "int virFileLock(int fd G_GNUC_UNUSED,\n                bool shared G_GNUC_UNUSED,\n                off_t start G_GNUC_UNUSED,\n                off_t len G_GNUC_UNUSED,\n                bool waitForLock G_GNUC_UNUSED)\n{\n    return -ENOSYS;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileLock(int fd G_GNUC_UNUSED,\n                bool shared G_GNUC_UNUSED,\n                off_t start G_GNUC_UNUSED,\n                off_t len G_GNUC_UNUSED,\n                bool waitForLock G_GNUC_UNUSED)\n{\n    return -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to create lock '%s'\")",
            "lockpath"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetCloseExec",
          "args": [
            "lockfd"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "virSetCloseExec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "131-134",
          "snippet": "int virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "lockpath",
            "O_RDWR | O_CREAT",
            "0600"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3308-3323",
          "snippet": "int\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot create user runtime directory '%s'\")",
            "rundir"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileMakePathWithMode",
          "args": [
            "rundir",
            "0700"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePathWithMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3082-3091",
          "snippet": "int\nvirFileMakePathWithMode(const char *path,\n                        mode_t mode)\n{\n    g_autofree char *tmp = NULL;\n\n    tmp = g_strdup(path);\n\n    return virFileMakePathHelper(tmp, mode);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePathWithMode(const char *path,\n                        mode_t mode)\n{\n    g_autofree char *tmp = NULL;\n\n    tmp = g_strdup(path);\n\n    return virFileMakePathHelper(tmp, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_path_get_basename",
          "args": [
            "binary"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Auto-spawn of daemon requested, \"\n                             \"but no binary specified\")"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&remoteAddr",
            "0",
            "sizeof(remoteAddr)"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&localAddr",
            "0",
            "sizeof(localAddr)"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"path=%s spawnDaemon=%d binary=%s\"",
            "path",
            "spawnDaemon",
            "NULLSTR(binary)"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "binary"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectUNIX(const char *path,\n                               bool spawnDaemon,\n                               const char *binary,\n                               virNetSocketPtr *retsock)\n{\n    char *lockpath = NULL;\n    int lockfd = -1;\n    int fd = -1;\n    int retries = 500;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    char *rundir = NULL;\n    int ret = -1;\n    bool daemonLaunched = false;\n\n    VIR_DEBUG(\"path=%s spawnDaemon=%d binary=%s\", path, spawnDaemon,\n        NULLSTR(binary));\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    remoteAddr.len = sizeof(remoteAddr.data.un);\n\n    if (spawnDaemon) {\n        g_autofree char *binname = NULL;\n\n        if (spawnDaemon && !binary) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Auto-spawn of daemon requested, \"\n                             \"but no binary specified\"));\n            goto cleanup;\n        }\n\n        binname = g_path_get_basename(binary);\n        rundir = virGetUserRuntimeDirectory();\n\n        if (virFileMakePathWithMode(rundir, 0700) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot create user runtime directory '%s'\"),\n                                 rundir);\n            goto cleanup;\n        }\n\n        lockpath = g_strdup_printf(\"%s/%s.lock\", rundir, binname);\n\n        if ((lockfd = open(lockpath, O_RDWR | O_CREAT, 0600)) < 0 ||\n            virSetCloseExec(lockfd) < 0) {\n            virReportSystemError(errno, _(\"Unable to create lock '%s'\"), lockpath);\n            goto cleanup;\n        }\n\n        if (virFileLock(lockfd, false, 0, 1, true) < 0) {\n            virReportSystemError(errno, _(\"Unable to lock '%s'\"), lockpath);\n            goto cleanup;\n        }\n    }\n\n    if ((fd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Failed to create socket\"));\n        goto cleanup;\n    }\n\n    remoteAddr.data.un.sun_family = AF_UNIX;\n    if (virStrcpyStatic(remoteAddr.data.un.sun_path, path) < 0) {\n        virReportSystemError(ENOMEM, _(\"Path %s too long for unix socket\"), path);\n        goto cleanup;\n    }\n    if (remoteAddr.data.un.sun_path[0] == '@')\n        remoteAddr.data.un.sun_path[0] = '\\0';\n\n    while (retries) {\n        if (connect(fd, &remoteAddr.data.sa, remoteAddr.len) == 0) {\n            VIR_DEBUG(\"connect() succeeded\");\n            break;\n        }\n        VIR_DEBUG(\"connect() failed: retries=%d errno=%d\", retries, errno);\n\n        retries--;\n        if (!spawnDaemon ||\n            retries == 0 ||\n            (errno != ENOENT && errno != ECONNREFUSED)) {\n            virReportSystemError(errno, _(\"Failed to connect socket to '%s'\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (!daemonLaunched) {\n            if (virNetSocketForkDaemon(binary) < 0)\n                goto cleanup;\n\n            daemonLaunched = true;\n        }\n\n        g_usleep(10000);\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto cleanup;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, &remoteAddr, true, fd, -1, 0, false)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (lockfd != -1) {\n        unlink(lockpath);\n        VIR_FORCE_CLOSE(lockfd);\n    }\n    VIR_FREE(lockpath);\n    VIR_FREE(rundir);\n\n    if (ret < 0 && fd != -1)\n        closesocket(fd);\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketNewConnectTCP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "558-640",
    "snippet": "int virNetSocketNewConnectTCP(const char *nodename,\n                              const char *service,\n                              int family,\n                              virNetSocketPtr *retsock)\n{\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    struct addrinfo *runp;\n    int savedErrno = ENOENT;\n\n    *retsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG | AI_V4MAPPED;\n    hints.ai_socktype = SOCK_STREAM;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    runp = ai;\n    while (runp) {\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, false) < 0)\n            VIR_WARN(\"Unable to enable port reuse\");\n\n        if (connect(fd, runp->ai_addr, runp->ai_addrlen) >= 0)\n            break;\n\n        savedErrno = errno;\n        closesocket(fd);\n        fd = -1;\n        runp = runp->ai_next;\n    }\n\n    if (fd == -1) {\n        virReportSystemError(savedErrno,\n                             _(\"unable to connect to server at '%s:%s'\"),\n                             nodename, service);\n        goto error;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto error;\n    }\n\n    remoteAddr.len = sizeof(remoteAddr.data);\n    if (getpeername(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get remote socket name\"));\n        goto error;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, &remoteAddr, true, fd, -1, 0, false)))\n        goto error;\n\n    freeaddrinfo(ai);\n\n    return 0;\n\n error:\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "fd"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "vir_closesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "197-213",
          "snippet": "int\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "ai"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "ai"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketNew",
          "args": [
            "&localAddr",
            "&remoteAddr",
            "true",
            "fd",
            "-1",
            "0",
            "false"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "208-289",
          "snippet": "static virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetSocketClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virClassPtr virNetSocketClass;\n\nstatic virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to get remote socket name\")"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get remote socket name\""
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "fd",
            "&remoteAddr.data.sa",
            "&remoteAddr.len"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "vir_getpeername",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "235-251",
          "snippet": "int\nvir_getpeername(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getpeername(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_getpeername(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getpeername(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to get local socket name\")"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "fd",
            "&localAddr.data.sa",
            "&localAddr.len"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "vir_getsockname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "254-270",
          "snippet": "int\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "savedErrno",
            "_(\"unable to connect to server at '%s:%s'\")",
            "nodename",
            "service"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "fd",
            "runp->ai_addr",
            "runp->ai_addrlen"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "vir_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "216-232",
          "snippet": "int\nvir_connect(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (connect(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_connect(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (connect(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to enable port reuse\""
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetSockReuseAddr",
          "args": [
            "fd",
            "false"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "virSetSockReuseAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "152-163",
          "snippet": "int virSetSockReuseAddr(int fd, bool fatal)\n{\n    int opt = 1;\n    int ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n\n    if (ret < 0 && fatal) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set socket reuse addr flag\"));\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetSockReuseAddr(int fd, bool fatal)\n{\n    int opt = 1;\n    int ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n\n    if (ret < 0 && fatal) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set socket reuse addr flag\"));\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to create socket\")"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "runp->ai_family",
            "runp->ai_socktype",
            "runp->ai_protocol"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "vir_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "351-367",
          "snippet": "int\nvir_socket(int domain, int type, int protocol)\n{\n    SOCKET sk;\n\n    /* We have to use WSASocket() instead of socket(), to create\n     * non-overlapped IO sockets. Overlapped IO sockets cannot\n     * be used with read/write.\n     */\n    sk = WSASocket(domain, type, protocol, NULL, 0, 0);\n    if (sk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(sk);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_socket(int domain, int type, int protocol)\n{\n    SOCKET sk;\n\n    /* We have to use WSASocket() instead of socket(), to create\n     * non-overlapped IO sockets. Overlapped IO sockets cannot\n     * be used with read/write.\n     */\n    sk = WSASocket(domain, type, protocol, NULL, 0, 0);\n    if (sk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(sk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to resolve address '%s' service '%s': %s\")",
            "nodename",
            "service",
            "gai_strerror(e)"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "e"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "nodename",
            "service",
            "&hints",
            "&ai"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&remoteAddr",
            "0",
            "sizeof(remoteAddr)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&localAddr",
            "0",
            "sizeof(localAddr)"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectTCP(const char *nodename,\n                              const char *service,\n                              int family,\n                              virNetSocketPtr *retsock)\n{\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    struct addrinfo *runp;\n    int savedErrno = ENOENT;\n\n    *retsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG | AI_V4MAPPED;\n    hints.ai_socktype = SOCK_STREAM;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    runp = ai;\n    while (runp) {\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, false) < 0)\n            VIR_WARN(\"Unable to enable port reuse\");\n\n        if (connect(fd, runp->ai_addr, runp->ai_addrlen) >= 0)\n            break;\n\n        savedErrno = errno;\n        closesocket(fd);\n        fd = -1;\n        runp = runp->ai_next;\n    }\n\n    if (fd == -1) {\n        virReportSystemError(savedErrno,\n                             _(\"unable to connect to server at '%s:%s'\"),\n                             nodename, service);\n        goto error;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto error;\n    }\n\n    remoteAddr.len = sizeof(remoteAddr.data);\n    if (getpeername(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get remote socket name\"));\n        goto error;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, &remoteAddr, true, fd, -1, 0, false)))\n        goto error;\n\n    freeaddrinfo(ai);\n\n    return 0;\n\n error:\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}"
  },
  {
    "function_name": "virNetSocketNewListenFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "536-555",
    "snippet": "int virNetSocketNewListenFD(int fd,\n                            bool unlinkUNIX,\n                            virNetSocketPtr *retsock)\n{\n    virSocketAddr addr;\n    *retsock = NULL;\n\n    memset(&addr, 0, sizeof(addr));\n\n    addr.len = sizeof(addr.data);\n    if (getsockname(fd, &addr.data.sa, &addr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        return -1;\n    }\n\n    if (!(*retsock = virNetSocketNew(&addr, NULL, false, fd, -1, 0, unlinkUNIX)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetSocketNew",
          "args": [
            "&addr",
            "NULL",
            "false",
            "fd",
            "-1",
            "0",
            "unlinkUNIX"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "208-289",
          "snippet": "static virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetSocketClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virClassPtr virNetSocketClass;\n\nstatic virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to get local socket name\")"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get local socket name\""
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "fd",
            "&addr.data.sa",
            "&addr.len"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "vir_getsockname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "254-270",
          "snippet": "int\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewListenFD(int fd,\n                            bool unlinkUNIX,\n                            virNetSocketPtr *retsock)\n{\n    virSocketAddr addr;\n    *retsock = NULL;\n\n    memset(&addr, 0, sizeof(addr));\n\n    addr.len = sizeof(addr.data);\n    if (getsockname(fd, &addr.data.sa, &addr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        return -1;\n    }\n\n    if (!(*retsock = virNetSocketNew(&addr, NULL, false, fd, -1, 0, unlinkUNIX)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetSocketNewListenUNIX",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "524-533",
    "snippet": "int virNetSocketNewListenUNIX(const char *path G_GNUC_UNUSED,\n                              mode_t mask G_GNUC_UNUSED,\n                              uid_t user G_GNUC_UNUSED,\n                              gid_t grp G_GNUC_UNUSED,\n                              virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"UNIX sockets are not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"UNIX sockets are not supported on this platform\")"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"UNIX sockets are not supported on this platform\""
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewListenUNIX(const char *path G_GNUC_UNUSED,\n                              mode_t mask G_GNUC_UNUSED,\n                              uid_t user G_GNUC_UNUSED,\n                              gid_t grp G_GNUC_UNUSED,\n                              virNetSocketPtr *retsock G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"UNIX sockets are not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetSocketNewListenUNIX",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "458-522",
    "snippet": "int virNetSocketNewListenUNIX(const char *path,\n                              mode_t mask,\n                              uid_t user,\n                              gid_t grp,\n                              virNetSocketPtr *retsock)\n{\n    virSocketAddr addr;\n    mode_t oldmask;\n    int fd;\n\n    *retsock = NULL;\n\n    memset(&addr, 0, sizeof(addr));\n\n    addr.len = sizeof(addr.data.un);\n\n    if ((fd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Failed to create socket\"));\n        goto error;\n    }\n\n    addr.data.un.sun_family = AF_UNIX;\n    if (virStrcpyStatic(addr.data.un.sun_path, path) < 0) {\n        virReportSystemError(ENAMETOOLONG,\n                             _(\"Path %s too long for unix socket\"), path);\n        goto error;\n    }\n    if (addr.data.un.sun_path[0] == '@')\n        addr.data.un.sun_path[0] = '\\0';\n    else\n        unlink(addr.data.un.sun_path);\n\n    oldmask = umask(~mask);\n\n    if (bind(fd, &addr.data.sa, addr.len) < 0) {\n        umask(oldmask);\n        virReportSystemError(errno,\n                             _(\"Failed to bind socket to '%s'\"),\n                             path);\n        goto error;\n    }\n    umask(oldmask);\n\n    /* chown() doesn't work for abstract sockets but we use them only\n     * if libvirtd runs unprivileged\n     */\n    if (grp != 0 && chown(path, user, grp)) {\n        virReportSystemError(errno,\n                             _(\"Failed to change ownership of '%s' to %d:%d\"),\n                             path, (int)user, (int)grp);\n        goto error;\n    }\n\n    if (!(*retsock = virNetSocketNew(&addr, NULL, false, fd, -1, 0, true)))\n        goto error;\n\n    return 0;\n\n error:\n    if (path[0] != '@')\n        unlink(path);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "fd"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "vir_closesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "197-213",
          "snippet": "int\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketNew",
          "args": [
            "&addr",
            "NULL",
            "false",
            "fd",
            "-1",
            "0",
            "true"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "208-289",
          "snippet": "static virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetSocketClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virClassPtr virNetSocketClass;\n\nstatic virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to change ownership of '%s' to %d:%d\")",
            "path",
            "(int)user",
            "(int)grp"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to change ownership of '%s' to %d:%d\""
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "path",
            "user",
            "grp"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "oldmask"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to bind socket to '%s'\")",
            "path"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "oldmask"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "fd",
            "&addr.data.sa",
            "addr.len"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "vir_bind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "178-194",
          "snippet": "int\nvir_bind(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (bind(sk, addr, addrlen) < 0)  {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_bind(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (bind(sk, addr, addrlen) < 0)  {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "~mask"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "addr.data.un.sun_path"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENAMETOOLONG",
            "_(\"Path %s too long for unix socket\")",
            "path"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "addr.data.un.sun_path",
            "path"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Failed to create socket\")"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "PF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "vir_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "351-367",
          "snippet": "int\nvir_socket(int domain, int type, int protocol)\n{\n    SOCKET sk;\n\n    /* We have to use WSASocket() instead of socket(), to create\n     * non-overlapped IO sockets. Overlapped IO sockets cannot\n     * be used with read/write.\n     */\n    sk = WSASocket(domain, type, protocol, NULL, 0, 0);\n    if (sk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(sk);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_socket(int domain, int type, int protocol)\n{\n    SOCKET sk;\n\n    /* We have to use WSASocket() instead of socket(), to create\n     * non-overlapped IO sockets. Overlapped IO sockets cannot\n     * be used with read/write.\n     */\n    sk = WSASocket(domain, type, protocol, NULL, 0, 0);\n    if (sk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(sk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewListenUNIX(const char *path,\n                              mode_t mask,\n                              uid_t user,\n                              gid_t grp,\n                              virNetSocketPtr *retsock)\n{\n    virSocketAddr addr;\n    mode_t oldmask;\n    int fd;\n\n    *retsock = NULL;\n\n    memset(&addr, 0, sizeof(addr));\n\n    addr.len = sizeof(addr.data.un);\n\n    if ((fd = socket(PF_UNIX, SOCK_STREAM, 0)) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Failed to create socket\"));\n        goto error;\n    }\n\n    addr.data.un.sun_family = AF_UNIX;\n    if (virStrcpyStatic(addr.data.un.sun_path, path) < 0) {\n        virReportSystemError(ENAMETOOLONG,\n                             _(\"Path %s too long for unix socket\"), path);\n        goto error;\n    }\n    if (addr.data.un.sun_path[0] == '@')\n        addr.data.un.sun_path[0] = '\\0';\n    else\n        unlink(addr.data.un.sun_path);\n\n    oldmask = umask(~mask);\n\n    if (bind(fd, &addr.data.sa, addr.len) < 0) {\n        umask(oldmask);\n        virReportSystemError(errno,\n                             _(\"Failed to bind socket to '%s'\"),\n                             path);\n        goto error;\n    }\n    umask(oldmask);\n\n    /* chown() doesn't work for abstract sockets but we use them only\n     * if libvirtd runs unprivileged\n     */\n    if (grp != 0 && chown(path, user, grp)) {\n        virReportSystemError(errno,\n                             _(\"Failed to change ownership of '%s' to %d:%d\"),\n                             path, (int)user, (int)grp);\n        goto error;\n    }\n\n    if (!(*retsock = virNetSocketNew(&addr, NULL, false, fd, -1, 0, true)))\n        goto error;\n\n    return 0;\n\n error:\n    if (path[0] != '@')\n        unlink(path);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}"
  },
  {
    "function_name": "virNetSocketNewListenTCP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "292-454",
    "snippet": "int virNetSocketNewListenTCP(const char *nodename,\n                             const char *service,\n                             int family,\n                             virNetSocketPtr **retsocks,\n                             size_t *nretsocks)\n{\n    virNetSocketPtr *socks = NULL;\n    size_t nsocks = 0;\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    size_t i;\n    int socketErrno = 0;\n    int bindErrno = 0;\n    virSocketAddr tmp_addr;\n    int port = 0;\n\n    *retsocks = NULL;\n    *nretsocks = 0;\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE;\n    hints.ai_socktype = SOCK_STREAM;\n\n    /* Don't use ADDRCONFIG for binding to the wildcard address.\n     * Just catch the error returned by socket() if the system has\n     * no IPv6 support.\n     *\n     * This allows libvirtd to be started in parallel with the network\n     * startup in most cases.\n     */\n    if (nodename &&\n        !(virSocketAddrParseAny(&tmp_addr, nodename, AF_UNSPEC, false) > 0 &&\n          virSocketAddrIsWildcard(&tmp_addr)))\n        hints.ai_flags |= AI_ADDRCONFIG;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    struct addrinfo *runp = ai;\n    while (runp) {\n        virSocketAddr addr;\n\n        memset(&addr, 0, sizeof(addr));\n\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            if (errno == EAFNOSUPPORT) {\n                socketErrno = errno;\n                runp = runp->ai_next;\n                continue;\n            }\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, true) < 0)\n            goto error;\n\n#ifdef IPV6_V6ONLY\n        if (runp->ai_family == PF_INET6) {\n            int on = 1;\n            /*\n             * Normally on Linux an INET6 socket will bind to the INET4\n             * address too. If getaddrinfo returns results with INET4\n             * first though, this will result in INET6 binding failing.\n             * We can trivially cope with multiple server sockets, so\n             * we force it to only listen on IPv6\n             */\n            if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY,\n                           (void*)&on, sizeof(on)) < 0) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Unable to force bind to IPv6 only\"));\n                goto error;\n            }\n        }\n#endif\n\n        addr.len = runp->ai_addrlen;\n        memcpy(&addr.data.sa, runp->ai_addr, runp->ai_addrlen);\n\n        /* When service is NULL, we let the kernel auto-select the\n         * port. Once we've selected a port for one IP protocol\n         * though, we want to ensure we pick the same port for the\n         * other IP protocol\n         */\n        if (port != 0 && service == NULL) {\n            if (addr.data.sa.sa_family == AF_INET) {\n                addr.data.inet4.sin_port = port;\n            } else if (addr.data.sa.sa_family == AF_INET6) {\n                addr.data.inet6.sin6_port = port;\n            }\n            VIR_DEBUG(\"Used saved port %d\", port);\n        }\n\n        if (bind(fd, &addr.data.sa, addr.len) < 0) {\n            if (errno != EADDRINUSE && errno != EADDRNOTAVAIL) {\n                virReportSystemError(errno, \"%s\", _(\"Unable to bind to port\"));\n                goto error;\n            }\n            bindErrno = errno;\n            closesocket(fd);\n            fd = -1;\n            runp = runp->ai_next;\n            continue;\n        }\n\n        addr.len = sizeof(addr.data);\n        if (getsockname(fd, &addr.data.sa, &addr.len) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n            goto error;\n        }\n\n        if (port == 0 && service == NULL) {\n            if (addr.data.sa.sa_family == AF_INET)\n                port = addr.data.inet4.sin_port;\n            else if (addr.data.sa.sa_family == AF_INET6)\n                port = addr.data.inet6.sin6_port;\n            VIR_DEBUG(\"Saved port %d\", port);\n        }\n\n        VIR_DEBUG(\"%p f=%d f=%d\", &addr, runp->ai_family, addr.data.sa.sa_family);\n\n        if (VIR_EXPAND_N(socks, nsocks, 1) < 0)\n            goto error;\n\n        if (!(socks[nsocks-1] = virNetSocketNew(&addr, NULL, false, fd, -1, 0, false)))\n            goto error;\n        runp = runp->ai_next;\n        fd = -1;\n    }\n\n    if (nsocks == 0) {\n        if (bindErrno)\n            virReportSystemError(bindErrno, \"%s\", _(\"Unable to bind to port\"));\n        else if (socketErrno)\n            virReportSystemError(socketErrno, \"%s\", _(\"Unable to create socket\"));\n        else\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"No addresses to bind to\"));\n        goto error;\n    }\n\n    freeaddrinfo(ai);\n\n    *retsocks = socks;\n    *nretsocks = nsocks;\n    return 0;\n\n error:\n    for (i = 0; i < nsocks; i++)\n        virObjectUnref(socks[i]);\n    VIR_FREE(socks);\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "fd"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "vir_closesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "197-213",
          "snippet": "int\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_closesocket(int fd)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (closesocket(sk) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "ai"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "socks"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "socks[i]"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "ai"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"No addresses to bind to\")"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No addresses to bind to\""
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "socketErrno",
            "\"%s\"",
            "_(\"Unable to create socket\")"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "bindErrno",
            "\"%s\"",
            "_(\"Unable to bind to port\")"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketNew",
          "args": [
            "&addr",
            "NULL",
            "false",
            "fd",
            "-1",
            "0",
            "false"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "208-289",
          "snippet": "static virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetSocketClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virClassPtr virNetSocketClass;\n\nstatic virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "socks",
            "nsocks",
            "1"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%p f=%d f=%d\"",
            "&addr",
            "runp->ai_family",
            "addr.data.sa.sa_family"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Saved port %d\"",
            "port"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to get local socket name\")"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "fd",
            "&addr.data.sa",
            "&addr.len"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "vir_getsockname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "254-270",
          "snippet": "int\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_getsockname(int fd, struct sockaddr *addr, socklen_t *addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (getsockname(sk, addr, addrlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to bind to port\")"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "fd",
            "&addr.data.sa",
            "addr.len"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "vir_bind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "178-194",
          "snippet": "int\nvir_bind(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (bind(sk, addr, addrlen) < 0)  {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_bind(int fd, const struct sockaddr *addr, socklen_t addrlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (bind(sk, addr, addrlen) < 0)  {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Used saved port %d\"",
            "port"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&addr.data.sa",
            "runp->ai_addr",
            "runp->ai_addrlen"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to force bind to IPv6 only\")"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "fd",
            "IPPROTO_IPV6",
            "IPV6_V6ONLY",
            "(void*)&on",
            "sizeof(on)"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "vir_setsockopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "331-348",
          "snippet": "int\nvir_setsockopt(int fd, int level, int optname,\n               const void *optval, socklen_t optlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (setsockopt(sk, level, optname, optval, optlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_setsockopt(int fd, int level, int optname,\n               const void *optval, socklen_t optlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (setsockopt(sk, level, optname, optval, optlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetSockReuseAddr",
          "args": [
            "fd",
            "true"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "virSetSockReuseAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "152-163",
          "snippet": "int virSetSockReuseAddr(int fd, bool fatal)\n{\n    int opt = 1;\n    int ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n\n    if (ret < 0 && fatal) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set socket reuse addr flag\"));\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetSockReuseAddr(int fd, bool fatal)\n{\n    int opt = 1;\n    int ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n\n    if (ret < 0 && fatal) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set socket reuse addr flag\"));\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to create socket\")"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "runp->ai_family",
            "runp->ai_socktype",
            "runp->ai_protocol"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "vir_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "351-367",
          "snippet": "int\nvir_socket(int domain, int type, int protocol)\n{\n    SOCKET sk;\n\n    /* We have to use WSASocket() instead of socket(), to create\n     * non-overlapped IO sockets. Overlapped IO sockets cannot\n     * be used with read/write.\n     */\n    sk = WSASocket(domain, type, protocol, NULL, 0, 0);\n    if (sk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(sk);\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_socket(int domain, int type, int protocol)\n{\n    SOCKET sk;\n\n    /* We have to use WSASocket() instead of socket(), to create\n     * non-overlapped IO sockets. Overlapped IO sockets cannot\n     * be used with read/write.\n     */\n    sk = WSASocket(domain, type, protocol, NULL, 0, 0);\n    if (sk == INVALID_SOCKET) {\n        set_errno();\n        return -1;\n    }\n\n    return SK2FD(sk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to resolve address '%s' service '%s': %s\")",
            "nodename",
            "service",
            "gai_strerror(e)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "e"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "nodename",
            "service",
            "&hints",
            "&ai"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrIsWildcard",
          "args": [
            "&tmp_addr"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrIsWildcard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "419-431",
          "snippet": "bool\nvirSocketAddrIsWildcard(const virSocketAddr *addr)\n{\n    struct in_addr tmp = { .s_addr = INADDR_ANY };\n    switch (addr->data.stor.ss_family) {\n    case AF_INET:\n        return memcmp(&addr->data.inet4.sin_addr.s_addr, &tmp.s_addr,\n                      sizeof(addr->data.inet4.sin_addr.s_addr)) == 0;\n    case AF_INET6:\n        return IN6_IS_ADDR_UNSPECIFIED(&addr->data.inet6.sin6_addr);\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrIsWildcard(const virSocketAddr *addr)\n{\n    struct in_addr tmp = { .s_addr = INADDR_ANY };\n    switch (addr->data.stor.ss_family) {\n    case AF_INET:\n        return memcmp(&addr->data.inet4.sin_addr.s_addr, &tmp.s_addr,\n                      sizeof(addr->data.inet4.sin_addr.s_addr)) == 0;\n    case AF_INET6:\n        return IN6_IS_ADDR_UNSPECIFIED(&addr->data.inet6.sin6_addr);\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrParseAny",
          "args": [
            "&tmp_addr",
            "nodename",
            "AF_UNSPEC",
            "false"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParseAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "176-204",
          "snippet": "int virSocketAddrParseAny(virSocketAddrPtr addr,\n                          const char *val,\n                          int family,\n                          bool reportError)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, 0, reportError) < 0)\n        return -1;\n\n    if (res == NULL) {\n        if (reportError) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"No socket addresses found for '%s'\"),\n                           val);\n        }\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParseAny(virSocketAddrPtr addr,\n                          const char *val,\n                          int family,\n                          bool reportError)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, 0, reportError) < 0)\n        return -1;\n\n    if (res == NULL) {\n        if (reportError) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"No socket addresses found for '%s'\"),\n                           val);\n        }\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewListenTCP(const char *nodename,\n                             const char *service,\n                             int family,\n                             virNetSocketPtr **retsocks,\n                             size_t *nretsocks)\n{\n    virNetSocketPtr *socks = NULL;\n    size_t nsocks = 0;\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    size_t i;\n    int socketErrno = 0;\n    int bindErrno = 0;\n    virSocketAddr tmp_addr;\n    int port = 0;\n\n    *retsocks = NULL;\n    *nretsocks = 0;\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE;\n    hints.ai_socktype = SOCK_STREAM;\n\n    /* Don't use ADDRCONFIG for binding to the wildcard address.\n     * Just catch the error returned by socket() if the system has\n     * no IPv6 support.\n     *\n     * This allows libvirtd to be started in parallel with the network\n     * startup in most cases.\n     */\n    if (nodename &&\n        !(virSocketAddrParseAny(&tmp_addr, nodename, AF_UNSPEC, false) > 0 &&\n          virSocketAddrIsWildcard(&tmp_addr)))\n        hints.ai_flags |= AI_ADDRCONFIG;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    struct addrinfo *runp = ai;\n    while (runp) {\n        virSocketAddr addr;\n\n        memset(&addr, 0, sizeof(addr));\n\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            if (errno == EAFNOSUPPORT) {\n                socketErrno = errno;\n                runp = runp->ai_next;\n                continue;\n            }\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, true) < 0)\n            goto error;\n\n#ifdef IPV6_V6ONLY\n        if (runp->ai_family == PF_INET6) {\n            int on = 1;\n            /*\n             * Normally on Linux an INET6 socket will bind to the INET4\n             * address too. If getaddrinfo returns results with INET4\n             * first though, this will result in INET6 binding failing.\n             * We can trivially cope with multiple server sockets, so\n             * we force it to only listen on IPv6\n             */\n            if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY,\n                           (void*)&on, sizeof(on)) < 0) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Unable to force bind to IPv6 only\"));\n                goto error;\n            }\n        }\n#endif\n\n        addr.len = runp->ai_addrlen;\n        memcpy(&addr.data.sa, runp->ai_addr, runp->ai_addrlen);\n\n        /* When service is NULL, we let the kernel auto-select the\n         * port. Once we've selected a port for one IP protocol\n         * though, we want to ensure we pick the same port for the\n         * other IP protocol\n         */\n        if (port != 0 && service == NULL) {\n            if (addr.data.sa.sa_family == AF_INET) {\n                addr.data.inet4.sin_port = port;\n            } else if (addr.data.sa.sa_family == AF_INET6) {\n                addr.data.inet6.sin6_port = port;\n            }\n            VIR_DEBUG(\"Used saved port %d\", port);\n        }\n\n        if (bind(fd, &addr.data.sa, addr.len) < 0) {\n            if (errno != EADDRINUSE && errno != EADDRNOTAVAIL) {\n                virReportSystemError(errno, \"%s\", _(\"Unable to bind to port\"));\n                goto error;\n            }\n            bindErrno = errno;\n            closesocket(fd);\n            fd = -1;\n            runp = runp->ai_next;\n            continue;\n        }\n\n        addr.len = sizeof(addr.data);\n        if (getsockname(fd, &addr.data.sa, &addr.len) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n            goto error;\n        }\n\n        if (port == 0 && service == NULL) {\n            if (addr.data.sa.sa_family == AF_INET)\n                port = addr.data.inet4.sin_port;\n            else if (addr.data.sa.sa_family == AF_INET6)\n                port = addr.data.inet6.sin6_port;\n            VIR_DEBUG(\"Saved port %d\", port);\n        }\n\n        VIR_DEBUG(\"%p f=%d f=%d\", &addr, runp->ai_family, addr.data.sa.sa_family);\n\n        if (VIR_EXPAND_N(socks, nsocks, 1) < 0)\n            goto error;\n\n        if (!(socks[nsocks-1] = virNetSocketNew(&addr, NULL, false, fd, -1, 0, false)))\n            goto error;\n        runp = runp->ai_next;\n        fd = -1;\n    }\n\n    if (nsocks == 0) {\n        if (bindErrno)\n            virReportSystemError(bindErrno, \"%s\", _(\"Unable to bind to port\"));\n        else if (socketErrno)\n            virReportSystemError(socketErrno, \"%s\", _(\"Unable to create socket\"));\n        else\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"No addresses to bind to\"));\n        goto error;\n    }\n\n    freeaddrinfo(ai);\n\n    *retsocks = socks;\n    *nretsocks = nsocks;\n    return 0;\n\n error:\n    for (i = 0; i < nsocks; i++)\n        virObjectUnref(socks[i]);\n    VIR_FREE(socks);\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}"
  },
  {
    "function_name": "virNetSocketNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "208-289",
    "snippet": "static virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virNetSocketClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sock"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_SOCKET_NEW",
            "\"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\"",
            "sock",
            "fd",
            "errfd",
            "(long long)pid",
            "NULLSTR(sock->localAddrStrSASL)",
            "NULLSTR(sock->remoteAddrStrSASL)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "sock->remoteAddrStrSASL"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "sock->localAddrStrSASL"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormatFull",
          "args": [
            "remoteAddr",
            "true",
            "NULL"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormatFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "460-514",
          "snippet": "char *\nvirSocketAddrFormatFull(const virSocketAddr *addr,\n                        bool withService,\n                        const char *separator)\n{\n    char host[NI_MAXHOST], port[NI_MAXSERV];\n    char *addrstr;\n    int err;\n\n    if (addr == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Missing address\"));\n        return NULL;\n    }\n\n    /* Short-circuit since getnameinfo doesn't work\n     * nicely for UNIX sockets */\n    if (addr->data.sa.sa_family == AF_UNIX) {\n        if (withService) {\n            addrstr = g_strdup_printf(VIR_LOOPBACK_IPV4_ADDR \"%s0\",\n                                      separator ? separator : \":\");\n        } else {\n            addrstr = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n        }\n        return addrstr;\n    }\n\n    if ((err = getnameinfo(&addr->data.sa,\n                           addr->len,\n                           host, sizeof(host),\n                           port, sizeof(port),\n                           NI_NUMERICHOST | NI_NUMERICSERV)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Cannot convert socket address to string: %s\"),\n                       gai_strerror(err));\n        return NULL;\n    }\n\n    if (withService) {\n        g_autofree char *ipv6_host = NULL;\n        /* sasl_new_client demands the socket address to be in an odd format:\n         * a.b.c.d;port or e:f:g:h:i:j:k:l;port, so use square brackets for\n         * IPv6 only if no separator is passed to the function\n         */\n        if (!separator && VIR_SOCKET_ADDR_FAMILY(addr) == AF_INET6)\n            ipv6_host = g_strdup_printf(\"[%s]\", host);\n\n        addrstr = g_strdup_printf(\"%s%s%s\",\n                                  ipv6_host ? ipv6_host : host,\n                                  separator ? separator : \":\", port);\n    } else {\n        addrstr = g_strdup(host);\n    }\n\n    return addrstr;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormatFull(const virSocketAddr *addr,\n                        bool withService,\n                        const char *separator)\n{\n    char host[NI_MAXHOST], port[NI_MAXSERV];\n    char *addrstr;\n    int err;\n\n    if (addr == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Missing address\"));\n        return NULL;\n    }\n\n    /* Short-circuit since getnameinfo doesn't work\n     * nicely for UNIX sockets */\n    if (addr->data.sa.sa_family == AF_UNIX) {\n        if (withService) {\n            addrstr = g_strdup_printf(VIR_LOOPBACK_IPV4_ADDR \"%s0\",\n                                      separator ? separator : \":\");\n        } else {\n            addrstr = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n        }\n        return addrstr;\n    }\n\n    if ((err = getnameinfo(&addr->data.sa,\n                           addr->len,\n                           host, sizeof(host),\n                           port, sizeof(port),\n                           NI_NUMERICHOST | NI_NUMERICSERV)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Cannot convert socket address to string: %s\"),\n                       gai_strerror(err));\n        return NULL;\n    }\n\n    if (withService) {\n        g_autofree char *ipv6_host = NULL;\n        /* sasl_new_client demands the socket address to be in an odd format:\n         * a.b.c.d;port or e:f:g:h:i:j:k:l;port, so use square brackets for\n         * IPv6 only if no separator is passed to the function\n         */\n        if (!separator && VIR_SOCKET_ADDR_FAMILY(addr) == AF_INET6)\n            ipv6_host = g_strdup_printf(\"[%s]\", host);\n\n        addrstr = g_strdup_printf(\"%s%s%s\",\n                                  ipv6_host ? ipv6_host : host,\n                                  separator ? separator : \":\", port);\n    } else {\n        addrstr = g_strdup(host);\n    }\n\n    return addrstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to disable nagle algorithm\")"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to disable nagle algorithm\""
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "fd",
            "IPPROTO_TCP",
            "TCP_NODELAY",
            "&no_slow_start",
            "sizeof(no_slow_start)"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "vir_setsockopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocket.c",
          "lines": "331-348",
          "snippet": "int\nvir_setsockopt(int fd, int level, int optname,\n               const void *optval, socklen_t optlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (setsockopt(sk, level, optname, optval, optlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <fcntl.h>",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <fcntl.h>\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include <config.h>\n\nint\nvir_setsockopt(int fd, int level, int optname,\n               const void *optval, socklen_t optlen)\n{\n    SOCKET sk = FD2SK(fd);\n\n    if (sk == INVALID_SOCKET) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (setsockopt(sk, level, optname, optval, optlen) < 0) {\n        set_errno();\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "virNetSocketClass"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to enable non-blocking flag\")"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetNonBlock",
          "args": [
            "fd"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "virSetNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "126-129",
          "snippet": "int virSetNonBlock(int fd)\n{\n    return virSetBlocking(fd, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetNonBlock(int fd)\n{\n    return virSetBlocking(fd, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to set close-on-exec flag\")"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetCloseExec",
          "args": [
            "fd"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virSetCloseExec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "131-134",
          "snippet": "int virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\"",
            "localAddr",
            "remoteAddr",
            "fd",
            "errfd",
            "(long long)pid"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketInitialize",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic virClassPtr virNetSocketClass;\n\nstatic virNetSocketPtr\nvirNetSocketNew(virSocketAddrPtr localAddr,\n                virSocketAddrPtr remoteAddr,\n                bool isClient,\n                int fd,\n                int errfd,\n                pid_t pid,\n                bool unlinkUNIX)\n{\n    virNetSocketPtr sock;\n    int no_slow_start = 1;\n\n    if (virNetSocketInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"localAddr=%p remoteAddr=%p fd=%d errfd=%d pid=%lld\",\n              localAddr, remoteAddr,\n              fd, errfd, (long long)pid);\n\n    if (virSetCloseExec(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to set close-on-exec flag\"));\n       return NULL;\n    }\n    if (virSetNonBlock(fd) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to enable non-blocking flag\"));\n        return NULL;\n    }\n\n    if (!(sock = virObjectLockableNew(virNetSocketClass)))\n        return NULL;\n\n    if (localAddr)\n        sock->localAddr = *localAddr;\n    if (remoteAddr)\n        sock->remoteAddr = *remoteAddr;\n    sock->fd = fd;\n    sock->errfd = errfd;\n    sock->pid = pid;\n    sock->watch = -1;\n    sock->ownsFd = true;\n    sock->isClient = isClient;\n    sock->unlinkUNIX = unlinkUNIX;\n\n    /* Disable nagle for TCP sockets */\n    if (sock->localAddr.data.sa.sa_family == AF_INET ||\n        sock->localAddr.data.sa.sa_family == AF_INET6) {\n        if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n                       &no_slow_start,\n                       sizeof(no_slow_start)) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to disable nagle algorithm\"));\n            goto error;\n        }\n    }\n\n\n    if (localAddr &&\n        !(sock->localAddrStrSASL = virSocketAddrFormatFull(localAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrSASL = virSocketAddrFormatFull(remoteAddr, true, \";\")))\n        goto error;\n\n    if (remoteAddr &&\n        !(sock->remoteAddrStrURI = virSocketAddrFormatFull(remoteAddr, true, NULL)))\n        goto error;\n\n    PROBE(RPC_SOCKET_NEW,\n          \"sock=%p fd=%d errfd=%d pid=%lld localAddr=%s, remoteAddr=%s\",\n          sock, fd, errfd, (long long)pid,\n          NULLSTR(sock->localAddrStrSASL), NULLSTR(sock->remoteAddrStrSASL));\n\n    return sock;\n\n error:\n    sock->fd = sock->errfd = -1; /* Caller owns fd/errfd on failure */\n    virObjectUnref(sock);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetSocketForkDaemon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "125-141",
    "snippet": "static int virNetSocketForkDaemon(const char *binary)\n{\n    int ret;\n    virCommandPtr cmd = virCommandNewArgList(binary,\n                                             \"--timeout=120\",\n                                             NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n    virCommandAddEnvPass(cmd, \"XDG_CACHE_HOME\");\n    virCommandAddEnvPass(cmd, \"XDG_CONFIG_HOME\");\n    virCommandAddEnvPass(cmd, \"XDG_RUNTIME_DIR\");\n    virCommandClearCaps(cmd);\n    virCommandDaemonize(cmd);\n    ret = virCommandRun(cmd, NULL);\n    virCommandFree(cmd);\n    return ret;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandDaemonize",
          "args": [
            "cmd"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandDaemonize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1263-1270",
          "snippet": "void\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandClearCaps",
          "args": [
            "cmd"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandClearCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1179-1186",
          "snippet": "void\nvirCommandClearCaps(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_CLEAR_CAPS;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandClearCaps(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_CLEAR_CAPS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddEnvPass",
          "args": [
            "cmd",
            "\"XDG_RUNTIME_DIR\""
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvPass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1434-1444",
          "snippet": "void\nvirCommandAddEnvPass(virCommandPtr cmd, const char *name)\n{\n    const char *value;\n    if (!cmd || cmd->has_error)\n        return;\n\n    value = getenv(name);\n    if (value)\n        virCommandAddEnvPair(cmd, name, value);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvPass(virCommandPtr cmd, const char *name)\n{\n    const char *value;\n    if (!cmd || cmd->has_error)\n        return;\n\n    value = getenv(name);\n    if (value)\n        virCommandAddEnvPair(cmd, name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddEnvPassCommon",
          "args": [
            "cmd"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvPassCommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1454-1474",
          "snippet": "void\nvirCommandAddEnvPassCommon(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 9) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvPair(cmd, \"LC_ALL\", \"C\");\n\n    virCommandAddEnvPass(cmd, \"LD_PRELOAD\");\n    virCommandAddEnvPass(cmd, \"LD_LIBRARY_PATH\");\n    virCommandAddEnvPass(cmd, \"PATH\");\n    virCommandAddEnvPass(cmd, \"HOME\");\n    virCommandAddEnvPass(cmd, \"USER\");\n    virCommandAddEnvPass(cmd, \"LOGNAME\");\n    virCommandAddEnvPass(cmd, \"TMPDIR\");\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvPassCommon(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 9) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvPair(cmd, \"LC_ALL\", \"C\");\n\n    virCommandAddEnvPass(cmd, \"LD_PRELOAD\");\n    virCommandAddEnvPass(cmd, \"LD_LIBRARY_PATH\");\n    virCommandAddEnvPass(cmd, \"PATH\");\n    virCommandAddEnvPass(cmd, \"HOME\");\n    virCommandAddEnvPass(cmd, \"USER\");\n    virCommandAddEnvPass(cmd, \"LOGNAME\");\n    virCommandAddEnvPass(cmd, \"TMPDIR\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "binary",
            "\"--timeout=120\"",
            "NULL"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int virNetSocketForkDaemon(const char *binary)\n{\n    int ret;\n    virCommandPtr cmd = virCommandNewArgList(binary,\n                                             \"--timeout=120\",\n                                             NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n    virCommandAddEnvPass(cmd, \"XDG_CACHE_HOME\");\n    virCommandAddEnvPass(cmd, \"XDG_CONFIG_HOME\");\n    virCommandAddEnvPass(cmd, \"XDG_RUNTIME_DIR\");\n    virCommandClearCaps(cmd);\n    virCommandDaemonize(cmd);\n    ret = virCommandRun(cmd, NULL);\n    virCommandFree(cmd);\n    return ret;\n}"
  },
  {
    "function_name": "virNetSocketOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
    "lines": "113-119",
    "snippet": "static int virNetSocketOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetSocket, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "# include \"virnetlibsshsession.h\"",
      "# include \"virnetsshsession.h\"",
      "#include \"virstring.h\"",
      "#include \"virprocess.h\"",
      "#include \"virprobe.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetsocket.h\"",
      "#include \"virsocket.h\"",
      "# include <selinux/selinux.h>",
      "# include <sys/ucred.h>",
      "# include <ifaddrs.h>",
      "#include <fcntl.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virNetSocket",
            "virClassForObjectLockable()"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int virNetSocketOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetSocket, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  }
]