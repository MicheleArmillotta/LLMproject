[
  {
    "function_name": "xenFormatXL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "2172-2218",
    "snippet": "virConfPtr\nxenFormatXL(virDomainDefPtr def, virConnectPtr conn)\n{\n    g_autoptr(virConf) conf = NULL;\n\n    if (!(conf = virConfNew()))\n        return NULL;\n\n    if (xenFormatConfigCommon(conf, def, conn, XEN_CONFIG_FORMAT_XL) < 0)\n        return NULL;\n\n    if (xenFormatXLOS(conf, def) < 0)\n        return NULL;\n\n    if (xenFormatXLCPUID(conf, def) < 0)\n        return NULL;\n\n#ifdef LIBXL_HAVE_VNUMA\n    if (xenFormatXLDomainVnuma(conf, def) < 0)\n        return NULL;\n#endif\n\n#ifdef LIBXL_HAVE_BUILDINFO_GRANT_LIMITS\n    if (xenFormatXLGntLimits(conf, def) < 0)\n        return NULL;\n#endif\n\n    if (xenFormatXLDomainDisks(conf, def) < 0)\n        return NULL;\n\n    if (xenFormatXLSpice(conf, def) < 0)\n        return NULL;\n\n    if (xenFormatXLInputDevs(conf, def) < 0)\n        return NULL;\n\n    if (xenFormatXLUSB(conf, def) < 0)\n        return NULL;\n\n    if (xenFormatXLUSBController(conf, def) < 0)\n        return NULL;\n\n    if (xenFormatXLDomainChannels(conf, def) < 0)\n        return NULL;\n\n    return g_steal_pointer(&conf);\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&conf"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenFormatXLDomainChannels",
          "args": [
            "conf",
            "def"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLDomainChannels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "2135-2170",
          "snippet": "static int\nxenFormatXLDomainChannels(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr channelVal = NULL;\n    size_t i;\n\n    if (VIR_ALLOC(channelVal) < 0)\n        goto cleanup;\n\n    channelVal->type = VIR_CONF_LIST;\n    channelVal->list = NULL;\n\n    for (i = 0; i < def->nchannels; i++) {\n        virDomainChrDefPtr chr = def->channels[i];\n\n        if (chr->targetType != VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN)\n            continue;\n\n        if (xenFormatXLChannel(channelVal, def->channels[i]) < 0)\n            goto cleanup;\n    }\n\n    if (channelVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"channel\", channelVal);\n        channelVal = NULL;\n        if (ret < 0)\n            goto cleanup;\n    }\n\n    VIR_FREE(channelVal);\n    return 0;\n\n cleanup:\n    virConfFreeValue(channelVal);\n    return -1;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLDomainChannels(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr channelVal = NULL;\n    size_t i;\n\n    if (VIR_ALLOC(channelVal) < 0)\n        goto cleanup;\n\n    channelVal->type = VIR_CONF_LIST;\n    channelVal->list = NULL;\n\n    for (i = 0; i < def->nchannels; i++) {\n        virDomainChrDefPtr chr = def->channels[i];\n\n        if (chr->targetType != VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN)\n            continue;\n\n        if (xenFormatXLChannel(channelVal, def->channels[i]) < 0)\n            goto cleanup;\n    }\n\n    if (channelVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"channel\", channelVal);\n        channelVal = NULL;\n        if (ret < 0)\n            goto cleanup;\n    }\n\n    VIR_FREE(channelVal);\n    return 0;\n\n cleanup:\n    virConfFreeValue(channelVal);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatXLUSBController",
          "args": [
            "conf",
            "def"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLUSBController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "1943-2020",
          "snippet": "static int\nxenFormatXLUSBController(virConfPtr conf,\n                         virDomainDefPtr def)\n{\n    virConfValuePtr usbctrlVal = NULL;\n    int hasUSBCtrl = 0;\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) {\n            hasUSBCtrl = 1;\n            break;\n        }\n    }\n\n    if (!hasUSBCtrl)\n        return 0;\n\n    if (VIR_ALLOC(usbctrlVal) < 0)\n        return -1;\n\n    usbctrlVal->type = VIR_CONF_LIST;\n    usbctrlVal->list = NULL;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) {\n            virConfValuePtr val, tmp;\n            virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n            if (def->controllers[i]->model != -1) {\n                switch (def->controllers[i]->model) {\n                case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1:\n                    virBufferAddLit(&buf, \"type=qusb,version=1,\");\n                    break;\n\n                case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2:\n                    virBufferAddLit(&buf, \"type=qusb,version=2,\");\n                    break;\n\n                default:\n                    goto error;\n                }\n            }\n\n            if (def->controllers[i]->opts.usbopts.ports != -1)\n                virBufferAsprintf(&buf, \"ports=%x\",\n                                  def->controllers[i]->opts.usbopts.ports);\n\n            if (VIR_ALLOC(val) < 0) {\n                virBufferFreeAndReset(&buf);\n                goto error;\n            }\n            val->type = VIR_CONF_STRING;\n            val->str = virBufferContentAndReset(&buf);\n            tmp = usbctrlVal->list;\n            while (tmp && tmp->next)\n                tmp = tmp->next;\n            if (tmp)\n                tmp->next = val;\n            else\n                usbctrlVal->list = val;\n        }\n    }\n\n    if (usbctrlVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"usbctrl\", usbctrlVal);\n        usbctrlVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(usbctrlVal);\n\n    return 0;\n\n error:\n    virConfFreeValue(usbctrlVal);\n    return -1;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLUSBController(virConfPtr conf,\n                         virDomainDefPtr def)\n{\n    virConfValuePtr usbctrlVal = NULL;\n    int hasUSBCtrl = 0;\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) {\n            hasUSBCtrl = 1;\n            break;\n        }\n    }\n\n    if (!hasUSBCtrl)\n        return 0;\n\n    if (VIR_ALLOC(usbctrlVal) < 0)\n        return -1;\n\n    usbctrlVal->type = VIR_CONF_LIST;\n    usbctrlVal->list = NULL;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) {\n            virConfValuePtr val, tmp;\n            virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n            if (def->controllers[i]->model != -1) {\n                switch (def->controllers[i]->model) {\n                case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1:\n                    virBufferAddLit(&buf, \"type=qusb,version=1,\");\n                    break;\n\n                case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2:\n                    virBufferAddLit(&buf, \"type=qusb,version=2,\");\n                    break;\n\n                default:\n                    goto error;\n                }\n            }\n\n            if (def->controllers[i]->opts.usbopts.ports != -1)\n                virBufferAsprintf(&buf, \"ports=%x\",\n                                  def->controllers[i]->opts.usbopts.ports);\n\n            if (VIR_ALLOC(val) < 0) {\n                virBufferFreeAndReset(&buf);\n                goto error;\n            }\n            val->type = VIR_CONF_STRING;\n            val->str = virBufferContentAndReset(&buf);\n            tmp = usbctrlVal->list;\n            while (tmp && tmp->next)\n                tmp = tmp->next;\n            if (tmp)\n                tmp->next = val;\n            else\n                usbctrlVal->list = val;\n        }\n    }\n\n    if (usbctrlVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"usbctrl\", usbctrlVal);\n        usbctrlVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(usbctrlVal);\n\n    return 0;\n\n error:\n    virConfFreeValue(usbctrlVal);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatXLUSB",
          "args": [
            "conf",
            "def"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLUSB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "2023-2087",
          "snippet": "static int\nxenFormatXLUSB(virConfPtr conf,\n               virDomainDefPtr def)\n{\n    virConfValuePtr usbVal = NULL;\n    int hasUSB = 0;\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n            hasUSB = 1;\n            break;\n        }\n    }\n\n    if (!hasUSB)\n        return 0;\n\n    if (VIR_ALLOC(usbVal) < 0)\n        return -1;\n\n    usbVal->type = VIR_CONF_LIST;\n    usbVal->list = NULL;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n            virConfValuePtr val, tmp;\n            char *buf;\n\n            buf = g_strdup_printf(\"hostbus=%x,hostaddr=%x\",\n                                  def->hostdevs[i]->source.subsys.u.usb.bus,\n                                  def->hostdevs[i]->source.subsys.u.usb.device);\n\n            if (VIR_ALLOC(val) < 0) {\n                VIR_FREE(buf);\n                goto error;\n            }\n            val->type = VIR_CONF_STRING;\n            val->str = buf;\n            tmp = usbVal->list;\n            while (tmp && tmp->next)\n                tmp = tmp->next;\n            if (tmp)\n                tmp->next = val;\n            else\n                usbVal->list = val;\n        }\n    }\n\n    if (usbVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"usbdev\", usbVal);\n        usbVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(usbVal);\n\n    return 0;\n\n error:\n    virConfFreeValue(usbVal);\n    return -1;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLUSB(virConfPtr conf,\n               virDomainDefPtr def)\n{\n    virConfValuePtr usbVal = NULL;\n    int hasUSB = 0;\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n            hasUSB = 1;\n            break;\n        }\n    }\n\n    if (!hasUSB)\n        return 0;\n\n    if (VIR_ALLOC(usbVal) < 0)\n        return -1;\n\n    usbVal->type = VIR_CONF_LIST;\n    usbVal->list = NULL;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n            virConfValuePtr val, tmp;\n            char *buf;\n\n            buf = g_strdup_printf(\"hostbus=%x,hostaddr=%x\",\n                                  def->hostdevs[i]->source.subsys.u.usb.bus,\n                                  def->hostdevs[i]->source.subsys.u.usb.device);\n\n            if (VIR_ALLOC(val) < 0) {\n                VIR_FREE(buf);\n                goto error;\n            }\n            val->type = VIR_CONF_STRING;\n            val->str = buf;\n            tmp = usbVal->list;\n            while (tmp && tmp->next)\n                tmp = tmp->next;\n            if (tmp)\n                tmp->next = val;\n            else\n                usbVal->list = val;\n        }\n    }\n\n    if (usbVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"usbdev\", usbVal);\n        usbVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(usbVal);\n\n    return 0;\n\n error:\n    virConfFreeValue(usbVal);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatXLInputDevs",
          "args": [
            "conf",
            "def"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLInputDevs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "1876-1941",
          "snippet": "static int\nxenFormatXLInputDevs(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n    const char *devtype;\n    virConfValuePtr usbdevices = NULL, lastdev;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (VIR_ALLOC(usbdevices) < 0)\n            goto error;\n\n        usbdevices->type = VIR_CONF_LIST;\n        usbdevices->list = NULL;\n        lastdev = NULL;\n        for (i = 0; i < def->ninputs; i++) {\n            if (def->inputs[i]->bus == VIR_DOMAIN_INPUT_BUS_USB) {\n                if (xenConfigSetInt(conf, \"usb\", 1) < 0)\n                    goto error;\n\n                switch (def->inputs[i]->type) {\n                    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n                        devtype = \"mouse\";\n                        break;\n                    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n                        devtype = \"tablet\";\n                        break;\n                    case VIR_DOMAIN_INPUT_TYPE_KBD:\n                        devtype = \"keyboard\";\n                        break;\n                    default:\n                        continue;\n                }\n\n                if (lastdev == NULL) {\n                    if (VIR_ALLOC(lastdev) < 0)\n                        goto error;\n                    usbdevices->list = lastdev;\n                } else {\n                    if (VIR_ALLOC(lastdev->next) < 0)\n                        goto error;\n                    lastdev = lastdev->next;\n                }\n                lastdev->type = VIR_CONF_STRING;\n                lastdev->str = g_strdup(devtype);\n            }\n        }\n        if (usbdevices->list != NULL) {\n            if (usbdevices->list->next == NULL) {\n                /* for compatibility with Xen <= 4.2, use old syntax when\n                 * only one device present */\n                if (xenConfigSetString(conf, \"usbdevice\", usbdevices->list->str) < 0)\n                    goto error;\n                virConfFreeValue(usbdevices);\n            } else {\n                virConfSetValue(conf, \"usbdevice\", usbdevices);\n            }\n        } else {\n            VIR_FREE(usbdevices);\n        }\n    }\n\n    return 0;\n error:\n    virConfFreeValue(usbdevices);\n    return -1;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLInputDevs(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n    const char *devtype;\n    virConfValuePtr usbdevices = NULL, lastdev;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (VIR_ALLOC(usbdevices) < 0)\n            goto error;\n\n        usbdevices->type = VIR_CONF_LIST;\n        usbdevices->list = NULL;\n        lastdev = NULL;\n        for (i = 0; i < def->ninputs; i++) {\n            if (def->inputs[i]->bus == VIR_DOMAIN_INPUT_BUS_USB) {\n                if (xenConfigSetInt(conf, \"usb\", 1) < 0)\n                    goto error;\n\n                switch (def->inputs[i]->type) {\n                    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n                        devtype = \"mouse\";\n                        break;\n                    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n                        devtype = \"tablet\";\n                        break;\n                    case VIR_DOMAIN_INPUT_TYPE_KBD:\n                        devtype = \"keyboard\";\n                        break;\n                    default:\n                        continue;\n                }\n\n                if (lastdev == NULL) {\n                    if (VIR_ALLOC(lastdev) < 0)\n                        goto error;\n                    usbdevices->list = lastdev;\n                } else {\n                    if (VIR_ALLOC(lastdev->next) < 0)\n                        goto error;\n                    lastdev = lastdev->next;\n                }\n                lastdev->type = VIR_CONF_STRING;\n                lastdev->str = g_strdup(devtype);\n            }\n        }\n        if (usbdevices->list != NULL) {\n            if (usbdevices->list->next == NULL) {\n                /* for compatibility with Xen <= 4.2, use old syntax when\n                 * only one device present */\n                if (xenConfigSetString(conf, \"usbdevice\", usbdevices->list->str) < 0)\n                    goto error;\n                virConfFreeValue(usbdevices);\n            } else {\n                virConfSetValue(conf, \"usbdevice\", usbdevices);\n            }\n        } else {\n            VIR_FREE(usbdevices);\n        }\n    }\n\n    return 0;\n error:\n    virConfFreeValue(usbdevices);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatXLSpice",
          "args": [
            "conf",
            "def"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLSpice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "1789-1874",
          "snippet": "static int\nxenFormatXLSpice(virConfPtr conf, virDomainDefPtr def)\n{\n    virDomainGraphicsListenDefPtr glisten;\n    virDomainGraphicsDefPtr graphics;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM && def->graphics) {\n        graphics = def->graphics[0];\n\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            /* set others to false but may not be necessary */\n            if (xenConfigSetInt(conf, \"sdl\", 0) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"vnc\", 0) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"spice\", 1) < 0)\n                return -1;\n\n            if ((glisten = virDomainGraphicsGetListen(graphics, 0)) &&\n                glisten->address &&\n                xenConfigSetString(conf, \"spicehost\", glisten->address) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"spiceport\",\n                                graphics->data.spice.port) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"spicetls_port\",\n                                graphics->data.spice.tlsPort) < 0)\n                return -1;\n\n            if (graphics->data.spice.auth.passwd) {\n                if (xenConfigSetInt(conf, \"spicedisable_ticketing\", 0) < 0)\n                    return -1;\n\n                if (xenConfigSetString(conf, \"spicepasswd\",\n                                       graphics->data.spice.auth.passwd) < 0)\n                    return -1;\n            } else {\n                if (xenConfigSetInt(conf, \"spicedisable_ticketing\", 1) < 0)\n                    return -1;\n            }\n\n            if (graphics->data.spice.mousemode) {\n                switch (graphics->data.spice.mousemode) {\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_SERVER:\n                    if (xenConfigSetInt(conf, \"spiceagent_mouse\", 0) < 0)\n                        return -1;\n                    break;\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_CLIENT:\n                    if (xenConfigSetInt(conf, \"spiceagent_mouse\", 1) < 0)\n                        return -1;\n                    /*\n                     * spicevdagent must be enabled if using client\n                     * mode mouse\n                     */\n                    if (xenConfigSetInt(conf, \"spicevdagent\", 1) < 0)\n                        return -1;\n                    break;\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_DEFAULT:\n                    break;\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_LAST:\n                default:\n                    virReportEnumRangeError(virDomainGraphicsSpiceMouseMode,\n                                            graphics->data.spice.mousemode);\n                    return -1;\n                }\n            }\n\n            if (graphics->data.spice.copypaste == VIR_TRISTATE_BOOL_YES) {\n                if (xenConfigSetInt(conf, \"spice_clipboard_sharing\", 1) < 0)\n                    return -1;\n                /*\n                 * spicevdagent must be enabled if spice_clipboard_sharing\n                 * is enabled\n                 */\n                if (xenConfigSetInt(conf, \"spicevdagent\", 1) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLSpice(virConfPtr conf, virDomainDefPtr def)\n{\n    virDomainGraphicsListenDefPtr glisten;\n    virDomainGraphicsDefPtr graphics;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM && def->graphics) {\n        graphics = def->graphics[0];\n\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            /* set others to false but may not be necessary */\n            if (xenConfigSetInt(conf, \"sdl\", 0) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"vnc\", 0) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"spice\", 1) < 0)\n                return -1;\n\n            if ((glisten = virDomainGraphicsGetListen(graphics, 0)) &&\n                glisten->address &&\n                xenConfigSetString(conf, \"spicehost\", glisten->address) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"spiceport\",\n                                graphics->data.spice.port) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"spicetls_port\",\n                                graphics->data.spice.tlsPort) < 0)\n                return -1;\n\n            if (graphics->data.spice.auth.passwd) {\n                if (xenConfigSetInt(conf, \"spicedisable_ticketing\", 0) < 0)\n                    return -1;\n\n                if (xenConfigSetString(conf, \"spicepasswd\",\n                                       graphics->data.spice.auth.passwd) < 0)\n                    return -1;\n            } else {\n                if (xenConfigSetInt(conf, \"spicedisable_ticketing\", 1) < 0)\n                    return -1;\n            }\n\n            if (graphics->data.spice.mousemode) {\n                switch (graphics->data.spice.mousemode) {\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_SERVER:\n                    if (xenConfigSetInt(conf, \"spiceagent_mouse\", 0) < 0)\n                        return -1;\n                    break;\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_CLIENT:\n                    if (xenConfigSetInt(conf, \"spiceagent_mouse\", 1) < 0)\n                        return -1;\n                    /*\n                     * spicevdagent must be enabled if using client\n                     * mode mouse\n                     */\n                    if (xenConfigSetInt(conf, \"spicevdagent\", 1) < 0)\n                        return -1;\n                    break;\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_DEFAULT:\n                    break;\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_LAST:\n                default:\n                    virReportEnumRangeError(virDomainGraphicsSpiceMouseMode,\n                                            graphics->data.spice.mousemode);\n                    return -1;\n                }\n            }\n\n            if (graphics->data.spice.copypaste == VIR_TRISTATE_BOOL_YES) {\n                if (xenConfigSetInt(conf, \"spice_clipboard_sharing\", 1) < 0)\n                    return -1;\n                /*\n                 * spicevdagent must be enabled if spice_clipboard_sharing\n                 * is enabled\n                 */\n                if (xenConfigSetInt(conf, \"spicevdagent\", 1) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatXLDomainDisks",
          "args": [
            "conf",
            "def"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLDomainDisks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "1753-1786",
          "snippet": "static int\nxenFormatXLDomainDisks(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr diskVal;\n    size_t i;\n\n    if (VIR_ALLOC(diskVal) < 0)\n        return -1;\n\n    diskVal->type = VIR_CONF_LIST;\n    diskVal->list = NULL;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_FLOPPY)\n            continue;\n\n        if (xenFormatXLDisk(diskVal, def->disks[i]) < 0)\n            goto cleanup;\n    }\n\n    if (diskVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"disk\", diskVal);\n        diskVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(diskVal);\n\n    return 0;\n\n cleanup:\n    virConfFreeValue(diskVal);\n    return -1;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLDomainDisks(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr diskVal;\n    size_t i;\n\n    if (VIR_ALLOC(diskVal) < 0)\n        return -1;\n\n    diskVal->type = VIR_CONF_LIST;\n    diskVal->list = NULL;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_FLOPPY)\n            continue;\n\n        if (xenFormatXLDisk(diskVal, def->disks[i]) < 0)\n            goto cleanup;\n    }\n\n    if (diskVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"disk\", diskVal);\n        diskVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(diskVal);\n\n    return 0;\n\n cleanup:\n    virConfFreeValue(diskVal);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatXLGntLimits",
          "args": [
            "conf",
            "def"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLGntLimits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "1536-1550",
          "snippet": "static int\nxenFormatXLGntLimits(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_XENBUS &&\n            def->controllers[i]->opts.xenbusopts.maxGrantFrames > 0) {\n            if (xenConfigSetInt(conf, \"max_grant_frames\",\n                                def->controllers[i]->opts.xenbusopts.maxGrantFrames) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLGntLimits(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_XENBUS &&\n            def->controllers[i]->opts.xenbusopts.maxGrantFrames > 0) {\n            if (xenConfigSetInt(conf, \"max_grant_frames\",\n                                def->controllers[i]->opts.xenbusopts.maxGrantFrames) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatXLDomainVnuma",
          "args": [
            "conf",
            "def"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLDomainVnuma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "1495-1532",
          "snippet": "static int\nxenFormatXLDomainVnuma(virConfPtr conf,\n                       virDomainDefPtr def)\n{\n    virDomainNumaPtr numa = def->numa;\n    virConfValuePtr vnumaVal;\n    size_t i;\n    size_t nr_nodes;\n\n    if (numa == NULL)\n        return -1;\n\n    if (VIR_ALLOC(vnumaVal) < 0)\n        return -1;\n\n    vnumaVal->type = VIR_CONF_LIST;\n    vnumaVal->list = NULL;\n\n    nr_nodes = virDomainNumaGetNodeCount(numa);\n    for (i = 0; i < nr_nodes; i++) {\n        if (xenFormatXLVnuma(vnumaVal, numa, i, nr_nodes) < 0)\n            goto cleanup;\n    }\n\n    if (vnumaVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"vnuma\", vnumaVal);\n            vnumaVal = NULL;\n            if (ret < 0)\n                return -1;\n    }\n    VIR_FREE(vnumaVal);\n\n    return 0;\n\n cleanup:\n    virConfFreeValue(vnumaVal);\n    return -1;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLDomainVnuma(virConfPtr conf,\n                       virDomainDefPtr def)\n{\n    virDomainNumaPtr numa = def->numa;\n    virConfValuePtr vnumaVal;\n    size_t i;\n    size_t nr_nodes;\n\n    if (numa == NULL)\n        return -1;\n\n    if (VIR_ALLOC(vnumaVal) < 0)\n        return -1;\n\n    vnumaVal->type = VIR_CONF_LIST;\n    vnumaVal->list = NULL;\n\n    nr_nodes = virDomainNumaGetNodeCount(numa);\n    for (i = 0; i < nr_nodes; i++) {\n        if (xenFormatXLVnuma(vnumaVal, numa, i, nr_nodes) < 0)\n            goto cleanup;\n    }\n\n    if (vnumaVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"vnuma\", vnumaVal);\n            vnumaVal = NULL;\n            if (ret < 0)\n                return -1;\n    }\n    VIR_FREE(vnumaVal);\n\n    return 0;\n\n cleanup:\n    virConfFreeValue(vnumaVal);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatXLCPUID",
          "args": [
            "conf",
            "def"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "1340-1407",
          "snippet": "static int\nxenFormatXLCPUID(virConfPtr conf, virDomainDefPtr def)\n{\n    char **cpuid_pairs = NULL;\n    char *cpuid_string = NULL;\n    size_t i, j;\n    int ret = -1;\n\n    if (!def->cpu)\n        return 0;\n\n    if (def->cpu->mode != VIR_CPU_MODE_HOST_PASSTHROUGH) {\n        VIR_WARN(\"ignoring CPU mode '%s', only host-passthrough mode \"\n                 \"is supported\", virCPUModeTypeToString(def->cpu->mode));\n        return 0;\n    }\n\n    /* \"host\" + all features + NULL */\n    if (VIR_ALLOC_N(cpuid_pairs, def->cpu->nfeatures + 2) < 0)\n        return -1;\n\n    cpuid_pairs[0] = g_strdup(\"host\");\n\n    j = 1;\n    for (i = 0; i < def->cpu->nfeatures; i++) {\n        const char *feature_name = xenTranslateCPUFeature(\n                def->cpu->features[i].name,\n                false);\n        const char *policy = NULL;\n\n        if (STREQ(feature_name, \"vmx\") || STREQ(feature_name, \"svm\"))\n            /* ignore vmx/svm in cpuid option, translated into nestedhvm\n             * elsewhere */\n            continue;\n\n        switch (def->cpu->features[i].policy) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                policy = \"1\";\n                break;\n            case VIR_CPU_FEATURE_OPTIONAL:\n                policy = \"x\";\n                break;\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                policy = \"0\";\n                break;\n        }\n        cpuid_pairs[j++] = g_strdup_printf(\"%s=%s\", feature_name, policy);\n    }\n    cpuid_pairs[j] = NULL;\n\n    if (j > 1) {\n        cpuid_string = virStringListJoin((const char **)cpuid_pairs, \",\");\n        if (!cpuid_string)\n            goto cleanup;\n\n        if (xenConfigSetString(conf, \"cpuid\", cpuid_string) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virStringListFree(cpuid_pairs);\n    VIR_FREE(cpuid_string);\n    return ret;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLCPUID(virConfPtr conf, virDomainDefPtr def)\n{\n    char **cpuid_pairs = NULL;\n    char *cpuid_string = NULL;\n    size_t i, j;\n    int ret = -1;\n\n    if (!def->cpu)\n        return 0;\n\n    if (def->cpu->mode != VIR_CPU_MODE_HOST_PASSTHROUGH) {\n        VIR_WARN(\"ignoring CPU mode '%s', only host-passthrough mode \"\n                 \"is supported\", virCPUModeTypeToString(def->cpu->mode));\n        return 0;\n    }\n\n    /* \"host\" + all features + NULL */\n    if (VIR_ALLOC_N(cpuid_pairs, def->cpu->nfeatures + 2) < 0)\n        return -1;\n\n    cpuid_pairs[0] = g_strdup(\"host\");\n\n    j = 1;\n    for (i = 0; i < def->cpu->nfeatures; i++) {\n        const char *feature_name = xenTranslateCPUFeature(\n                def->cpu->features[i].name,\n                false);\n        const char *policy = NULL;\n\n        if (STREQ(feature_name, \"vmx\") || STREQ(feature_name, \"svm\"))\n            /* ignore vmx/svm in cpuid option, translated into nestedhvm\n             * elsewhere */\n            continue;\n\n        switch (def->cpu->features[i].policy) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                policy = \"1\";\n                break;\n            case VIR_CPU_FEATURE_OPTIONAL:\n                policy = \"x\";\n                break;\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                policy = \"0\";\n                break;\n        }\n        cpuid_pairs[j++] = g_strdup_printf(\"%s=%s\", feature_name, policy);\n    }\n    cpuid_pairs[j] = NULL;\n\n    if (j > 1) {\n        cpuid_string = virStringListJoin((const char **)cpuid_pairs, \",\");\n        if (!cpuid_string)\n            goto cleanup;\n\n        if (xenConfigSetString(conf, \"cpuid\", cpuid_string) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virStringListFree(cpuid_pairs);\n    VIR_FREE(cpuid_string);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatXLOS",
          "args": [
            "conf",
            "def"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLOS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "1221-1338",
          "snippet": "static int\nxenFormatXLOS(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        char boot[VIR_DOMAIN_BOOT_LAST+1];\n        if (xenConfigSetString(conf, \"builder\", \"hvm\") < 0)\n            return -1;\n\n        if (virDomainDefHasOldStyleUEFI(def) &&\n            xenConfigSetString(conf, \"bios\", \"ovmf\") < 0)\n            return -1;\n\n        if (def->os.slic_table &&\n            xenConfigSetString(conf, \"acpi_firmware\", def->os.slic_table) < 0)\n            return -1;\n\n#ifdef LIBXL_HAVE_BUILDINFO_KERNEL\n        if (def->os.kernel &&\n            xenConfigSetString(conf, \"kernel\", def->os.kernel) < 0)\n            return -1;\n\n        if (def->os.initrd &&\n            xenConfigSetString(conf, \"ramdisk\", def->os.initrd) < 0)\n            return -1;\n\n        if (def->os.cmdline &&\n            xenConfigSetString(conf, \"cmdline\", def->os.cmdline) < 0)\n            return -1;\n#endif\n\n        for (i = 0; i < def->os.nBootDevs; i++) {\n            switch (def->os.bootDevs[i]) {\n            case VIR_DOMAIN_BOOT_FLOPPY:\n                boot[i] = 'a';\n                break;\n            case VIR_DOMAIN_BOOT_CDROM:\n                boot[i] = 'd';\n                break;\n            case VIR_DOMAIN_BOOT_NET:\n                boot[i] = 'n';\n                break;\n            case VIR_DOMAIN_BOOT_DISK:\n            default:\n                boot[i] = 'c';\n                break;\n            }\n        }\n\n        if (!def->os.nBootDevs) {\n            boot[0] = 'c';\n            boot[1] = '\\0';\n        } else {\n            boot[def->os.nBootDevs] = '\\0';\n        }\n\n        if (xenConfigSetString(conf, \"boot\", boot) < 0)\n            return -1;\n\n        if (def->cpu &&\n            def->cpu->mode == VIR_CPU_MODE_HOST_PASSTHROUGH) {\n            bool hasHwVirt = true;\n\n            if (def->cpu->nfeatures) {\n                for (i = 0; i < def->cpu->nfeatures; i++) {\n\n                    switch (def->cpu->features[i].policy) {\n                        case VIR_CPU_FEATURE_DISABLE:\n                        case VIR_CPU_FEATURE_FORBID:\n                            if (STREQ(def->cpu->features[i].name, \"vmx\") ||\n                                STREQ(def->cpu->features[i].name, \"svm\"))\n                                hasHwVirt = false;\n                            break;\n\n                        case VIR_CPU_FEATURE_FORCE:\n                        case VIR_CPU_FEATURE_REQUIRE:\n                        case VIR_CPU_FEATURE_OPTIONAL:\n                        case VIR_CPU_FEATURE_LAST:\n                            break;\n                    }\n                }\n            }\n\n            if (xenConfigSetInt(conf, \"nestedhvm\", hasHwVirt) < 0)\n                return -1;\n        }\n\n        /* XXX floppy disks */\n    } else {\n        if (def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) {\n            if (xenConfigSetString(conf, \"type\", \"pvh\") < 0)\n                return -1;\n        }\n\n        if (def->os.bootloader &&\n             xenConfigSetString(conf, \"bootloader\", def->os.bootloader) < 0)\n            return -1;\n\n         if (def->os.bootloaderArgs &&\n             xenConfigSetString(conf, \"bootargs\", def->os.bootloaderArgs) < 0)\n            return -1;\n\n         if (def->os.kernel &&\n             xenConfigSetString(conf, \"kernel\", def->os.kernel) < 0)\n            return -1;\n\n         if (def->os.initrd &&\n             xenConfigSetString(conf, \"ramdisk\", def->os.initrd) < 0)\n            return -1;\n\n         if (def->os.cmdline &&\n             xenConfigSetString(conf, \"cmdline\", def->os.cmdline) < 0)\n            return -1;\n     } /* !hvm */\n\n    return 0;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLOS(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        char boot[VIR_DOMAIN_BOOT_LAST+1];\n        if (xenConfigSetString(conf, \"builder\", \"hvm\") < 0)\n            return -1;\n\n        if (virDomainDefHasOldStyleUEFI(def) &&\n            xenConfigSetString(conf, \"bios\", \"ovmf\") < 0)\n            return -1;\n\n        if (def->os.slic_table &&\n            xenConfigSetString(conf, \"acpi_firmware\", def->os.slic_table) < 0)\n            return -1;\n\n#ifdef LIBXL_HAVE_BUILDINFO_KERNEL\n        if (def->os.kernel &&\n            xenConfigSetString(conf, \"kernel\", def->os.kernel) < 0)\n            return -1;\n\n        if (def->os.initrd &&\n            xenConfigSetString(conf, \"ramdisk\", def->os.initrd) < 0)\n            return -1;\n\n        if (def->os.cmdline &&\n            xenConfigSetString(conf, \"cmdline\", def->os.cmdline) < 0)\n            return -1;\n#endif\n\n        for (i = 0; i < def->os.nBootDevs; i++) {\n            switch (def->os.bootDevs[i]) {\n            case VIR_DOMAIN_BOOT_FLOPPY:\n                boot[i] = 'a';\n                break;\n            case VIR_DOMAIN_BOOT_CDROM:\n                boot[i] = 'd';\n                break;\n            case VIR_DOMAIN_BOOT_NET:\n                boot[i] = 'n';\n                break;\n            case VIR_DOMAIN_BOOT_DISK:\n            default:\n                boot[i] = 'c';\n                break;\n            }\n        }\n\n        if (!def->os.nBootDevs) {\n            boot[0] = 'c';\n            boot[1] = '\\0';\n        } else {\n            boot[def->os.nBootDevs] = '\\0';\n        }\n\n        if (xenConfigSetString(conf, \"boot\", boot) < 0)\n            return -1;\n\n        if (def->cpu &&\n            def->cpu->mode == VIR_CPU_MODE_HOST_PASSTHROUGH) {\n            bool hasHwVirt = true;\n\n            if (def->cpu->nfeatures) {\n                for (i = 0; i < def->cpu->nfeatures; i++) {\n\n                    switch (def->cpu->features[i].policy) {\n                        case VIR_CPU_FEATURE_DISABLE:\n                        case VIR_CPU_FEATURE_FORBID:\n                            if (STREQ(def->cpu->features[i].name, \"vmx\") ||\n                                STREQ(def->cpu->features[i].name, \"svm\"))\n                                hasHwVirt = false;\n                            break;\n\n                        case VIR_CPU_FEATURE_FORCE:\n                        case VIR_CPU_FEATURE_REQUIRE:\n                        case VIR_CPU_FEATURE_OPTIONAL:\n                        case VIR_CPU_FEATURE_LAST:\n                            break;\n                    }\n                }\n            }\n\n            if (xenConfigSetInt(conf, \"nestedhvm\", hasHwVirt) < 0)\n                return -1;\n        }\n\n        /* XXX floppy disks */\n    } else {\n        if (def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) {\n            if (xenConfigSetString(conf, \"type\", \"pvh\") < 0)\n                return -1;\n        }\n\n        if (def->os.bootloader &&\n             xenConfigSetString(conf, \"bootloader\", def->os.bootloader) < 0)\n            return -1;\n\n         if (def->os.bootloaderArgs &&\n             xenConfigSetString(conf, \"bootargs\", def->os.bootloaderArgs) < 0)\n            return -1;\n\n         if (def->os.kernel &&\n             xenConfigSetString(conf, \"kernel\", def->os.kernel) < 0)\n            return -1;\n\n         if (def->os.initrd &&\n             xenConfigSetString(conf, \"ramdisk\", def->os.initrd) < 0)\n            return -1;\n\n         if (def->os.cmdline &&\n             xenConfigSetString(conf, \"cmdline\", def->os.cmdline) < 0)\n            return -1;\n     } /* !hvm */\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatConfigCommon",
          "args": [
            "conf",
            "def",
            "conn",
            "XEN_CONFIG_FORMAT_XL"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatConfigCommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "2398-2450",
          "snippet": "int\nxenFormatConfigCommon(virConfPtr conf,\n                      virDomainDefPtr def,\n                      virConnectPtr conn,\n                      const char *nativeFormat)\n{\n    if (xenFormatGeneralMeta(conf, def) < 0)\n        return -1;\n\n    if (xenFormatMem(conf, def) < 0)\n        return -1;\n\n    if (xenFormatCPUAllocation(conf, def) < 0)\n        return -1;\n\n    if (xenFormatCPUFeatures(conf, def) < 0)\n        return -1;\n\n    if (xenFormatTimeOffset(conf, def) < 0)\n        return -1;\n\n    if (xenFormatEventActions(conf, def) < 0)\n        return -1;\n\n    if (xenFormatEmulator(conf, def) < 0)\n        return -1;\n\n    if (xenFormatVfb(conf, def) < 0)\n        return -1;\n\n    if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XL)) {\n        if (xenFormatVif(conf, conn, def, \"vif\") < 0)\n            return -1;\n    } else if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n        if (xenFormatVif(conf, conn, def, \"netfront\") < 0)\n            return -1;\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported config type %s\"), nativeFormat);\n        return -1;\n    }\n\n    if (xenFormatPCI(conf, def) < 0)\n        return -1;\n\n    if (xenFormatCharDev(conf, def, nativeFormat) < 0)\n        return -1;\n\n    if (xenFormatSound(conf, def) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenFormatConfigCommon(virConfPtr conf,\n                      virDomainDefPtr def,\n                      virConnectPtr conn,\n                      const char *nativeFormat)\n{\n    if (xenFormatGeneralMeta(conf, def) < 0)\n        return -1;\n\n    if (xenFormatMem(conf, def) < 0)\n        return -1;\n\n    if (xenFormatCPUAllocation(conf, def) < 0)\n        return -1;\n\n    if (xenFormatCPUFeatures(conf, def) < 0)\n        return -1;\n\n    if (xenFormatTimeOffset(conf, def) < 0)\n        return -1;\n\n    if (xenFormatEventActions(conf, def) < 0)\n        return -1;\n\n    if (xenFormatEmulator(conf, def) < 0)\n        return -1;\n\n    if (xenFormatVfb(conf, def) < 0)\n        return -1;\n\n    if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XL)) {\n        if (xenFormatVif(conf, conn, def, \"vif\") < 0)\n            return -1;\n    } else if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n        if (xenFormatVif(conf, conn, def, \"netfront\") < 0)\n            return -1;\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported config type %s\"), nativeFormat);\n        return -1;\n    }\n\n    if (xenFormatPCI(conf, def) < 0)\n        return -1;\n\n    if (xenFormatCharDev(conf, def, nativeFormat) < 0)\n        return -1;\n\n    if (xenFormatSound(conf, def) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfNew",
          "args": [],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "virConfNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "161-172",
          "snippet": "virConfPtr\nvirConfNew(void)\n{\n    virConfPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n    ret->filename = NULL;\n    ret->flags = 0;\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvirConfPtr\nvirConfNew(void)\n{\n    virConfPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n    ret->filename = NULL;\n    ret->flags = 0;\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nvirConfPtr\nxenFormatXL(virDomainDefPtr def, virConnectPtr conn)\n{\n    g_autoptr(virConf) conf = NULL;\n\n    if (!(conf = virConfNew()))\n        return NULL;\n\n    if (xenFormatConfigCommon(conf, def, conn, XEN_CONFIG_FORMAT_XL) < 0)\n        return NULL;\n\n    if (xenFormatXLOS(conf, def) < 0)\n        return NULL;\n\n    if (xenFormatXLCPUID(conf, def) < 0)\n        return NULL;\n\n#ifdef LIBXL_HAVE_VNUMA\n    if (xenFormatXLDomainVnuma(conf, def) < 0)\n        return NULL;\n#endif\n\n#ifdef LIBXL_HAVE_BUILDINFO_GRANT_LIMITS\n    if (xenFormatXLGntLimits(conf, def) < 0)\n        return NULL;\n#endif\n\n    if (xenFormatXLDomainDisks(conf, def) < 0)\n        return NULL;\n\n    if (xenFormatXLSpice(conf, def) < 0)\n        return NULL;\n\n    if (xenFormatXLInputDevs(conf, def) < 0)\n        return NULL;\n\n    if (xenFormatXLUSB(conf, def) < 0)\n        return NULL;\n\n    if (xenFormatXLUSBController(conf, def) < 0)\n        return NULL;\n\n    if (xenFormatXLDomainChannels(conf, def) < 0)\n        return NULL;\n\n    return g_steal_pointer(&conf);\n}"
  },
  {
    "function_name": "xenFormatXLDomainChannels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "2135-2170",
    "snippet": "static int\nxenFormatXLDomainChannels(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr channelVal = NULL;\n    size_t i;\n\n    if (VIR_ALLOC(channelVal) < 0)\n        goto cleanup;\n\n    channelVal->type = VIR_CONF_LIST;\n    channelVal->list = NULL;\n\n    for (i = 0; i < def->nchannels; i++) {\n        virDomainChrDefPtr chr = def->channels[i];\n\n        if (chr->targetType != VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN)\n            continue;\n\n        if (xenFormatXLChannel(channelVal, def->channels[i]) < 0)\n            goto cleanup;\n    }\n\n    if (channelVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"channel\", channelVal);\n        channelVal = NULL;\n        if (ret < 0)\n            goto cleanup;\n    }\n\n    VIR_FREE(channelVal);\n    return 0;\n\n cleanup:\n    virConfFreeValue(channelVal);\n    return -1;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConfFreeValue",
          "args": [
            "channelVal"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "virConfFreeValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "147-159",
          "snippet": "void\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "channelVal"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfSetValue",
          "args": [
            "conf",
            "\"channel\"",
            "channelVal"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "virConfSetValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1338-1378",
          "snippet": "int\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatXLChannel",
          "args": [
            "channelVal",
            "def->channels[i]"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLChannel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "2089-2133",
          "snippet": "static int\nxenFormatXLChannel(virConfValuePtr list, virDomainChrDefPtr channel)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int sourceType = channel->source->type;\n    virConfValuePtr val, tmp;\n\n    /* connection */\n    virBufferAddLit(&buf, \"connection=\");\n    switch (sourceType) {\n        case VIR_DOMAIN_CHR_TYPE_PTY:\n            virBufferAddLit(&buf, \"pty,\");\n            break;\n        case VIR_DOMAIN_CHR_TYPE_UNIX:\n            virBufferAddLit(&buf, \"socket,\");\n            /* path */\n            if (channel->source->data.nix.path)\n                virBufferAsprintf(&buf, \"path=%s,\",\n                                  channel->source->data.nix.path);\n            break;\n        default:\n            goto cleanup;\n    }\n\n    /* name */\n    virBufferAsprintf(&buf, \"name=%s\", channel->target.name);\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n    return 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLChannel(virConfValuePtr list, virDomainChrDefPtr channel)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int sourceType = channel->source->type;\n    virConfValuePtr val, tmp;\n\n    /* connection */\n    virBufferAddLit(&buf, \"connection=\");\n    switch (sourceType) {\n        case VIR_DOMAIN_CHR_TYPE_PTY:\n            virBufferAddLit(&buf, \"pty,\");\n            break;\n        case VIR_DOMAIN_CHR_TYPE_UNIX:\n            virBufferAddLit(&buf, \"socket,\");\n            /* path */\n            if (channel->source->data.nix.path)\n                virBufferAsprintf(&buf, \"path=%s,\",\n                                  channel->source->data.nix.path);\n            break;\n        default:\n            goto cleanup;\n    }\n\n    /* name */\n    virBufferAsprintf(&buf, \"name=%s\", channel->target.name);\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n    return 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "channelVal"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLDomainChannels(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr channelVal = NULL;\n    size_t i;\n\n    if (VIR_ALLOC(channelVal) < 0)\n        goto cleanup;\n\n    channelVal->type = VIR_CONF_LIST;\n    channelVal->list = NULL;\n\n    for (i = 0; i < def->nchannels; i++) {\n        virDomainChrDefPtr chr = def->channels[i];\n\n        if (chr->targetType != VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN)\n            continue;\n\n        if (xenFormatXLChannel(channelVal, def->channels[i]) < 0)\n            goto cleanup;\n    }\n\n    if (channelVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"channel\", channelVal);\n        channelVal = NULL;\n        if (ret < 0)\n            goto cleanup;\n    }\n\n    VIR_FREE(channelVal);\n    return 0;\n\n cleanup:\n    virConfFreeValue(channelVal);\n    return -1;\n}"
  },
  {
    "function_name": "xenFormatXLChannel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "2089-2133",
    "snippet": "static int\nxenFormatXLChannel(virConfValuePtr list, virDomainChrDefPtr channel)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int sourceType = channel->source->type;\n    virConfValuePtr val, tmp;\n\n    /* connection */\n    virBufferAddLit(&buf, \"connection=\");\n    switch (sourceType) {\n        case VIR_DOMAIN_CHR_TYPE_PTY:\n            virBufferAddLit(&buf, \"pty,\");\n            break;\n        case VIR_DOMAIN_CHR_TYPE_UNIX:\n            virBufferAddLit(&buf, \"socket,\");\n            /* path */\n            if (channel->source->data.nix.path)\n                virBufferAsprintf(&buf, \"path=%s,\",\n                                  channel->source->data.nix.path);\n            break;\n        default:\n            goto cleanup;\n    }\n\n    /* name */\n    virBufferAsprintf(&buf, \"name=%s\", channel->target.name);\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n    return 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "val"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"name=%s\"",
            "channel->target.name"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"socket,\""
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"pty,\""
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"connection=\""
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLChannel(virConfValuePtr list, virDomainChrDefPtr channel)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int sourceType = channel->source->type;\n    virConfValuePtr val, tmp;\n\n    /* connection */\n    virBufferAddLit(&buf, \"connection=\");\n    switch (sourceType) {\n        case VIR_DOMAIN_CHR_TYPE_PTY:\n            virBufferAddLit(&buf, \"pty,\");\n            break;\n        case VIR_DOMAIN_CHR_TYPE_UNIX:\n            virBufferAddLit(&buf, \"socket,\");\n            /* path */\n            if (channel->source->data.nix.path)\n                virBufferAsprintf(&buf, \"path=%s,\",\n                                  channel->source->data.nix.path);\n            break;\n        default:\n            goto cleanup;\n    }\n\n    /* name */\n    virBufferAsprintf(&buf, \"name=%s\", channel->target.name);\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n    return 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}"
  },
  {
    "function_name": "xenFormatXLUSB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "2023-2087",
    "snippet": "static int\nxenFormatXLUSB(virConfPtr conf,\n               virDomainDefPtr def)\n{\n    virConfValuePtr usbVal = NULL;\n    int hasUSB = 0;\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n            hasUSB = 1;\n            break;\n        }\n    }\n\n    if (!hasUSB)\n        return 0;\n\n    if (VIR_ALLOC(usbVal) < 0)\n        return -1;\n\n    usbVal->type = VIR_CONF_LIST;\n    usbVal->list = NULL;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n            virConfValuePtr val, tmp;\n            char *buf;\n\n            buf = g_strdup_printf(\"hostbus=%x,hostaddr=%x\",\n                                  def->hostdevs[i]->source.subsys.u.usb.bus,\n                                  def->hostdevs[i]->source.subsys.u.usb.device);\n\n            if (VIR_ALLOC(val) < 0) {\n                VIR_FREE(buf);\n                goto error;\n            }\n            val->type = VIR_CONF_STRING;\n            val->str = buf;\n            tmp = usbVal->list;\n            while (tmp && tmp->next)\n                tmp = tmp->next;\n            if (tmp)\n                tmp->next = val;\n            else\n                usbVal->list = val;\n        }\n    }\n\n    if (usbVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"usbdev\", usbVal);\n        usbVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(usbVal);\n\n    return 0;\n\n error:\n    virConfFreeValue(usbVal);\n    return -1;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConfFreeValue",
          "args": [
            "usbVal"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "virConfFreeValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "147-159",
          "snippet": "void\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "usbVal"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfSetValue",
          "args": [
            "conf",
            "\"usbdev\"",
            "usbVal"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "virConfSetValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1338-1378",
          "snippet": "int\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buf"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "val"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"hostbus=%x,hostaddr=%x\"",
            "def->hostdevs[i]->source.subsys.u.usb.bus",
            "def->hostdevs[i]->source.subsys.u.usb.device"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "usbVal"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLUSB(virConfPtr conf,\n               virDomainDefPtr def)\n{\n    virConfValuePtr usbVal = NULL;\n    int hasUSB = 0;\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n            hasUSB = 1;\n            break;\n        }\n    }\n\n    if (!hasUSB)\n        return 0;\n\n    if (VIR_ALLOC(usbVal) < 0)\n        return -1;\n\n    usbVal->type = VIR_CONF_LIST;\n    usbVal->list = NULL;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n            virConfValuePtr val, tmp;\n            char *buf;\n\n            buf = g_strdup_printf(\"hostbus=%x,hostaddr=%x\",\n                                  def->hostdevs[i]->source.subsys.u.usb.bus,\n                                  def->hostdevs[i]->source.subsys.u.usb.device);\n\n            if (VIR_ALLOC(val) < 0) {\n                VIR_FREE(buf);\n                goto error;\n            }\n            val->type = VIR_CONF_STRING;\n            val->str = buf;\n            tmp = usbVal->list;\n            while (tmp && tmp->next)\n                tmp = tmp->next;\n            if (tmp)\n                tmp->next = val;\n            else\n                usbVal->list = val;\n        }\n    }\n\n    if (usbVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"usbdev\", usbVal);\n        usbVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(usbVal);\n\n    return 0;\n\n error:\n    virConfFreeValue(usbVal);\n    return -1;\n}"
  },
  {
    "function_name": "xenFormatXLUSBController",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1943-2020",
    "snippet": "static int\nxenFormatXLUSBController(virConfPtr conf,\n                         virDomainDefPtr def)\n{\n    virConfValuePtr usbctrlVal = NULL;\n    int hasUSBCtrl = 0;\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) {\n            hasUSBCtrl = 1;\n            break;\n        }\n    }\n\n    if (!hasUSBCtrl)\n        return 0;\n\n    if (VIR_ALLOC(usbctrlVal) < 0)\n        return -1;\n\n    usbctrlVal->type = VIR_CONF_LIST;\n    usbctrlVal->list = NULL;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) {\n            virConfValuePtr val, tmp;\n            virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n            if (def->controllers[i]->model != -1) {\n                switch (def->controllers[i]->model) {\n                case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1:\n                    virBufferAddLit(&buf, \"type=qusb,version=1,\");\n                    break;\n\n                case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2:\n                    virBufferAddLit(&buf, \"type=qusb,version=2,\");\n                    break;\n\n                default:\n                    goto error;\n                }\n            }\n\n            if (def->controllers[i]->opts.usbopts.ports != -1)\n                virBufferAsprintf(&buf, \"ports=%x\",\n                                  def->controllers[i]->opts.usbopts.ports);\n\n            if (VIR_ALLOC(val) < 0) {\n                virBufferFreeAndReset(&buf);\n                goto error;\n            }\n            val->type = VIR_CONF_STRING;\n            val->str = virBufferContentAndReset(&buf);\n            tmp = usbctrlVal->list;\n            while (tmp && tmp->next)\n                tmp = tmp->next;\n            if (tmp)\n                tmp->next = val;\n            else\n                usbctrlVal->list = val;\n        }\n    }\n\n    if (usbctrlVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"usbctrl\", usbctrlVal);\n        usbctrlVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(usbctrlVal);\n\n    return 0;\n\n error:\n    virConfFreeValue(usbctrlVal);\n    return -1;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConfFreeValue",
          "args": [
            "usbctrlVal"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "virConfFreeValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "147-159",
          "snippet": "void\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "usbctrlVal"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfSetValue",
          "args": [
            "conf",
            "\"usbctrl\"",
            "usbctrlVal"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "virConfSetValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1338-1378",
          "snippet": "int\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "val"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"ports=%x\"",
            "def->controllers[i]->opts.usbopts.ports"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"type=qusb,version=2,\""
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"type=qusb,version=1,\""
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "usbctrlVal"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLUSBController(virConfPtr conf,\n                         virDomainDefPtr def)\n{\n    virConfValuePtr usbctrlVal = NULL;\n    int hasUSBCtrl = 0;\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) {\n            hasUSBCtrl = 1;\n            break;\n        }\n    }\n\n    if (!hasUSBCtrl)\n        return 0;\n\n    if (VIR_ALLOC(usbctrlVal) < 0)\n        return -1;\n\n    usbctrlVal->type = VIR_CONF_LIST;\n    usbctrlVal->list = NULL;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_USB) {\n            virConfValuePtr val, tmp;\n            virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n            if (def->controllers[i]->model != -1) {\n                switch (def->controllers[i]->model) {\n                case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1:\n                    virBufferAddLit(&buf, \"type=qusb,version=1,\");\n                    break;\n\n                case VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2:\n                    virBufferAddLit(&buf, \"type=qusb,version=2,\");\n                    break;\n\n                default:\n                    goto error;\n                }\n            }\n\n            if (def->controllers[i]->opts.usbopts.ports != -1)\n                virBufferAsprintf(&buf, \"ports=%x\",\n                                  def->controllers[i]->opts.usbopts.ports);\n\n            if (VIR_ALLOC(val) < 0) {\n                virBufferFreeAndReset(&buf);\n                goto error;\n            }\n            val->type = VIR_CONF_STRING;\n            val->str = virBufferContentAndReset(&buf);\n            tmp = usbctrlVal->list;\n            while (tmp && tmp->next)\n                tmp = tmp->next;\n            if (tmp)\n                tmp->next = val;\n            else\n                usbctrlVal->list = val;\n        }\n    }\n\n    if (usbctrlVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"usbctrl\", usbctrlVal);\n        usbctrlVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(usbctrlVal);\n\n    return 0;\n\n error:\n    virConfFreeValue(usbctrlVal);\n    return -1;\n}"
  },
  {
    "function_name": "xenFormatXLInputDevs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1876-1941",
    "snippet": "static int\nxenFormatXLInputDevs(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n    const char *devtype;\n    virConfValuePtr usbdevices = NULL, lastdev;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (VIR_ALLOC(usbdevices) < 0)\n            goto error;\n\n        usbdevices->type = VIR_CONF_LIST;\n        usbdevices->list = NULL;\n        lastdev = NULL;\n        for (i = 0; i < def->ninputs; i++) {\n            if (def->inputs[i]->bus == VIR_DOMAIN_INPUT_BUS_USB) {\n                if (xenConfigSetInt(conf, \"usb\", 1) < 0)\n                    goto error;\n\n                switch (def->inputs[i]->type) {\n                    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n                        devtype = \"mouse\";\n                        break;\n                    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n                        devtype = \"tablet\";\n                        break;\n                    case VIR_DOMAIN_INPUT_TYPE_KBD:\n                        devtype = \"keyboard\";\n                        break;\n                    default:\n                        continue;\n                }\n\n                if (lastdev == NULL) {\n                    if (VIR_ALLOC(lastdev) < 0)\n                        goto error;\n                    usbdevices->list = lastdev;\n                } else {\n                    if (VIR_ALLOC(lastdev->next) < 0)\n                        goto error;\n                    lastdev = lastdev->next;\n                }\n                lastdev->type = VIR_CONF_STRING;\n                lastdev->str = g_strdup(devtype);\n            }\n        }\n        if (usbdevices->list != NULL) {\n            if (usbdevices->list->next == NULL) {\n                /* for compatibility with Xen <= 4.2, use old syntax when\n                 * only one device present */\n                if (xenConfigSetString(conf, \"usbdevice\", usbdevices->list->str) < 0)\n                    goto error;\n                virConfFreeValue(usbdevices);\n            } else {\n                virConfSetValue(conf, \"usbdevice\", usbdevices);\n            }\n        } else {\n            VIR_FREE(usbdevices);\n        }\n    }\n\n    return 0;\n error:\n    virConfFreeValue(usbdevices);\n    return -1;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConfFreeValue",
          "args": [
            "usbdevices"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "virConfFreeValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "147-159",
          "snippet": "void\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "usbdevices"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfSetValue",
          "args": [
            "conf",
            "\"usbdevice\"",
            "usbdevices"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "virConfSetValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1338-1378",
          "snippet": "int\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigSetString",
          "args": [
            "conf",
            "\"usbdevice\"",
            "usbdevices->list->str"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "267-280",
          "snippet": "int\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "devtype"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "lastdev->next"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "lastdev"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigSetInt",
          "args": [
            "conf",
            "\"usb\"",
            "1"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "246-264",
          "snippet": "int\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "usbdevices"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLInputDevs(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n    const char *devtype;\n    virConfValuePtr usbdevices = NULL, lastdev;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (VIR_ALLOC(usbdevices) < 0)\n            goto error;\n\n        usbdevices->type = VIR_CONF_LIST;\n        usbdevices->list = NULL;\n        lastdev = NULL;\n        for (i = 0; i < def->ninputs; i++) {\n            if (def->inputs[i]->bus == VIR_DOMAIN_INPUT_BUS_USB) {\n                if (xenConfigSetInt(conf, \"usb\", 1) < 0)\n                    goto error;\n\n                switch (def->inputs[i]->type) {\n                    case VIR_DOMAIN_INPUT_TYPE_MOUSE:\n                        devtype = \"mouse\";\n                        break;\n                    case VIR_DOMAIN_INPUT_TYPE_TABLET:\n                        devtype = \"tablet\";\n                        break;\n                    case VIR_DOMAIN_INPUT_TYPE_KBD:\n                        devtype = \"keyboard\";\n                        break;\n                    default:\n                        continue;\n                }\n\n                if (lastdev == NULL) {\n                    if (VIR_ALLOC(lastdev) < 0)\n                        goto error;\n                    usbdevices->list = lastdev;\n                } else {\n                    if (VIR_ALLOC(lastdev->next) < 0)\n                        goto error;\n                    lastdev = lastdev->next;\n                }\n                lastdev->type = VIR_CONF_STRING;\n                lastdev->str = g_strdup(devtype);\n            }\n        }\n        if (usbdevices->list != NULL) {\n            if (usbdevices->list->next == NULL) {\n                /* for compatibility with Xen <= 4.2, use old syntax when\n                 * only one device present */\n                if (xenConfigSetString(conf, \"usbdevice\", usbdevices->list->str) < 0)\n                    goto error;\n                virConfFreeValue(usbdevices);\n            } else {\n                virConfSetValue(conf, \"usbdevice\", usbdevices);\n            }\n        } else {\n            VIR_FREE(usbdevices);\n        }\n    }\n\n    return 0;\n error:\n    virConfFreeValue(usbdevices);\n    return -1;\n}"
  },
  {
    "function_name": "xenFormatXLSpice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1789-1874",
    "snippet": "static int\nxenFormatXLSpice(virConfPtr conf, virDomainDefPtr def)\n{\n    virDomainGraphicsListenDefPtr glisten;\n    virDomainGraphicsDefPtr graphics;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM && def->graphics) {\n        graphics = def->graphics[0];\n\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            /* set others to false but may not be necessary */\n            if (xenConfigSetInt(conf, \"sdl\", 0) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"vnc\", 0) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"spice\", 1) < 0)\n                return -1;\n\n            if ((glisten = virDomainGraphicsGetListen(graphics, 0)) &&\n                glisten->address &&\n                xenConfigSetString(conf, \"spicehost\", glisten->address) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"spiceport\",\n                                graphics->data.spice.port) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"spicetls_port\",\n                                graphics->data.spice.tlsPort) < 0)\n                return -1;\n\n            if (graphics->data.spice.auth.passwd) {\n                if (xenConfigSetInt(conf, \"spicedisable_ticketing\", 0) < 0)\n                    return -1;\n\n                if (xenConfigSetString(conf, \"spicepasswd\",\n                                       graphics->data.spice.auth.passwd) < 0)\n                    return -1;\n            } else {\n                if (xenConfigSetInt(conf, \"spicedisable_ticketing\", 1) < 0)\n                    return -1;\n            }\n\n            if (graphics->data.spice.mousemode) {\n                switch (graphics->data.spice.mousemode) {\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_SERVER:\n                    if (xenConfigSetInt(conf, \"spiceagent_mouse\", 0) < 0)\n                        return -1;\n                    break;\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_CLIENT:\n                    if (xenConfigSetInt(conf, \"spiceagent_mouse\", 1) < 0)\n                        return -1;\n                    /*\n                     * spicevdagent must be enabled if using client\n                     * mode mouse\n                     */\n                    if (xenConfigSetInt(conf, \"spicevdagent\", 1) < 0)\n                        return -1;\n                    break;\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_DEFAULT:\n                    break;\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_LAST:\n                default:\n                    virReportEnumRangeError(virDomainGraphicsSpiceMouseMode,\n                                            graphics->data.spice.mousemode);\n                    return -1;\n                }\n            }\n\n            if (graphics->data.spice.copypaste == VIR_TRISTATE_BOOL_YES) {\n                if (xenConfigSetInt(conf, \"spice_clipboard_sharing\", 1) < 0)\n                    return -1;\n                /*\n                 * spicevdagent must be enabled if spice_clipboard_sharing\n                 * is enabled\n                 */\n                if (xenConfigSetInt(conf, \"spicevdagent\", 1) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenConfigSetInt",
          "args": [
            "conf",
            "\"spicevdagent\"",
            "1"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "246-264",
          "snippet": "int\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virDomainGraphicsSpiceMouseMode",
            "graphics->data.spice.mousemode"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigSetString",
          "args": [
            "conf",
            "\"spicepasswd\"",
            "graphics->data.spice.auth.passwd"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "267-280",
          "snippet": "int\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsGetListen",
          "args": [
            "graphics",
            "0"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsGetListen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30357-30364",
          "snippet": "virDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLSpice(virConfPtr conf, virDomainDefPtr def)\n{\n    virDomainGraphicsListenDefPtr glisten;\n    virDomainGraphicsDefPtr graphics;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM && def->graphics) {\n        graphics = def->graphics[0];\n\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            /* set others to false but may not be necessary */\n            if (xenConfigSetInt(conf, \"sdl\", 0) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"vnc\", 0) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"spice\", 1) < 0)\n                return -1;\n\n            if ((glisten = virDomainGraphicsGetListen(graphics, 0)) &&\n                glisten->address &&\n                xenConfigSetString(conf, \"spicehost\", glisten->address) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"spiceport\",\n                                graphics->data.spice.port) < 0)\n                return -1;\n\n            if (xenConfigSetInt(conf, \"spicetls_port\",\n                                graphics->data.spice.tlsPort) < 0)\n                return -1;\n\n            if (graphics->data.spice.auth.passwd) {\n                if (xenConfigSetInt(conf, \"spicedisable_ticketing\", 0) < 0)\n                    return -1;\n\n                if (xenConfigSetString(conf, \"spicepasswd\",\n                                       graphics->data.spice.auth.passwd) < 0)\n                    return -1;\n            } else {\n                if (xenConfigSetInt(conf, \"spicedisable_ticketing\", 1) < 0)\n                    return -1;\n            }\n\n            if (graphics->data.spice.mousemode) {\n                switch (graphics->data.spice.mousemode) {\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_SERVER:\n                    if (xenConfigSetInt(conf, \"spiceagent_mouse\", 0) < 0)\n                        return -1;\n                    break;\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_CLIENT:\n                    if (xenConfigSetInt(conf, \"spiceagent_mouse\", 1) < 0)\n                        return -1;\n                    /*\n                     * spicevdagent must be enabled if using client\n                     * mode mouse\n                     */\n                    if (xenConfigSetInt(conf, \"spicevdagent\", 1) < 0)\n                        return -1;\n                    break;\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_DEFAULT:\n                    break;\n                case VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_LAST:\n                default:\n                    virReportEnumRangeError(virDomainGraphicsSpiceMouseMode,\n                                            graphics->data.spice.mousemode);\n                    return -1;\n                }\n            }\n\n            if (graphics->data.spice.copypaste == VIR_TRISTATE_BOOL_YES) {\n                if (xenConfigSetInt(conf, \"spice_clipboard_sharing\", 1) < 0)\n                    return -1;\n                /*\n                 * spicevdagent must be enabled if spice_clipboard_sharing\n                 * is enabled\n                 */\n                if (xenConfigSetInt(conf, \"spicevdagent\", 1) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenFormatXLDomainDisks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1753-1786",
    "snippet": "static int\nxenFormatXLDomainDisks(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr diskVal;\n    size_t i;\n\n    if (VIR_ALLOC(diskVal) < 0)\n        return -1;\n\n    diskVal->type = VIR_CONF_LIST;\n    diskVal->list = NULL;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_FLOPPY)\n            continue;\n\n        if (xenFormatXLDisk(diskVal, def->disks[i]) < 0)\n            goto cleanup;\n    }\n\n    if (diskVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"disk\", diskVal);\n        diskVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(diskVal);\n\n    return 0;\n\n cleanup:\n    virConfFreeValue(diskVal);\n    return -1;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConfFreeValue",
          "args": [
            "diskVal"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "virConfFreeValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "147-159",
          "snippet": "void\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "diskVal"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfSetValue",
          "args": [
            "conf",
            "\"disk\"",
            "diskVal"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "virConfSetValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1338-1378",
          "snippet": "int\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatXLDisk",
          "args": [
            "diskVal",
            "def->disks[i]"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "1653-1750",
          "snippet": "static int\nxenFormatXLDisk(virConfValuePtr list, virDomainDiskDefPtr disk)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr val, tmp;\n    int format = virDomainDiskGetFormat(disk);\n    const char *driver = virDomainDiskGetDriver(disk);\n    char *target = NULL;\n    int ret = -1;\n\n    /* format */\n    virBufferAddLit(&buf, \"format=\");\n    switch (format) {\n        case VIR_STORAGE_FILE_RAW:\n            virBufferAddLit(&buf, \"raw\");\n            break;\n        case VIR_STORAGE_FILE_VHD:\n            virBufferAddLit(&buf, \"xvhd\");\n            break;\n        case VIR_STORAGE_FILE_QCOW:\n            virBufferAddLit(&buf, \"qcow\");\n            break;\n        case VIR_STORAGE_FILE_QCOW2:\n            virBufferAddLit(&buf, \"qcow2\");\n            break;\n        case VIR_STORAGE_FILE_QED:\n            virBufferAddLit(&buf, \"qed\");\n            break;\n      /* set default */\n        default:\n            virBufferAddLit(&buf, \"raw\");\n    }\n\n    /* device */\n    virBufferAsprintf(&buf, \",vdev=%s\", disk->dst);\n\n    /* access */\n    virBufferAddLit(&buf, \",access=\");\n    if (disk->src->readonly)\n        virBufferAddLit(&buf, \"ro\");\n    else if (disk->src->shared)\n        virBufferAddLit(&buf, \"!\");\n    else\n        virBufferAddLit(&buf, \"rw\");\n    if (disk->transient) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"transient disks not supported yet\"));\n        goto cleanup;\n    }\n\n    /* backendtype */\n    if (driver) {\n        virBufferAddLit(&buf, \",backendtype=\");\n        if (STREQ(driver, \"qemu\") || STREQ(driver, \"file\"))\n            virBufferAddLit(&buf, \"qdisk\");\n        else if (STREQ(driver, \"tap\"))\n            virBufferAddLit(&buf, \"tap\");\n        else if (STREQ(driver, \"phy\"))\n            virBufferAddLit(&buf, \"phy\");\n    }\n\n    /* devtype */\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_CDROM)\n        virBufferAddLit(&buf, \",devtype=cdrom\");\n\n    /*\n     * target\n     * From $xensrc/docs/misc/xl-disk-configuration.txt:\n     * When this parameter is specified by name, ie with the \"target=\"\n     * syntax in the configuration file, it consumes the whole rest of the\n     * <diskspec> including trailing whitespaces.  Therefore in that case\n     * it must come last.\n     */\n    if (xenFormatXLDiskSrc(disk->src, &target) < 0)\n        goto cleanup;\n\n    if (target)\n        virBufferAsprintf(&buf, \",target=%s\", target);\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(target);\n    virBufferFreeAndReset(&buf);\n    return ret;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLDisk(virConfValuePtr list, virDomainDiskDefPtr disk)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr val, tmp;\n    int format = virDomainDiskGetFormat(disk);\n    const char *driver = virDomainDiskGetDriver(disk);\n    char *target = NULL;\n    int ret = -1;\n\n    /* format */\n    virBufferAddLit(&buf, \"format=\");\n    switch (format) {\n        case VIR_STORAGE_FILE_RAW:\n            virBufferAddLit(&buf, \"raw\");\n            break;\n        case VIR_STORAGE_FILE_VHD:\n            virBufferAddLit(&buf, \"xvhd\");\n            break;\n        case VIR_STORAGE_FILE_QCOW:\n            virBufferAddLit(&buf, \"qcow\");\n            break;\n        case VIR_STORAGE_FILE_QCOW2:\n            virBufferAddLit(&buf, \"qcow2\");\n            break;\n        case VIR_STORAGE_FILE_QED:\n            virBufferAddLit(&buf, \"qed\");\n            break;\n      /* set default */\n        default:\n            virBufferAddLit(&buf, \"raw\");\n    }\n\n    /* device */\n    virBufferAsprintf(&buf, \",vdev=%s\", disk->dst);\n\n    /* access */\n    virBufferAddLit(&buf, \",access=\");\n    if (disk->src->readonly)\n        virBufferAddLit(&buf, \"ro\");\n    else if (disk->src->shared)\n        virBufferAddLit(&buf, \"!\");\n    else\n        virBufferAddLit(&buf, \"rw\");\n    if (disk->transient) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"transient disks not supported yet\"));\n        goto cleanup;\n    }\n\n    /* backendtype */\n    if (driver) {\n        virBufferAddLit(&buf, \",backendtype=\");\n        if (STREQ(driver, \"qemu\") || STREQ(driver, \"file\"))\n            virBufferAddLit(&buf, \"qdisk\");\n        else if (STREQ(driver, \"tap\"))\n            virBufferAddLit(&buf, \"tap\");\n        else if (STREQ(driver, \"phy\"))\n            virBufferAddLit(&buf, \"phy\");\n    }\n\n    /* devtype */\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_CDROM)\n        virBufferAddLit(&buf, \",devtype=cdrom\");\n\n    /*\n     * target\n     * From $xensrc/docs/misc/xl-disk-configuration.txt:\n     * When this parameter is specified by name, ie with the \"target=\"\n     * syntax in the configuration file, it consumes the whole rest of the\n     * <diskspec> including trailing whitespaces.  Therefore in that case\n     * it must come last.\n     */\n    if (xenFormatXLDiskSrc(disk->src, &target) < 0)\n        goto cleanup;\n\n    if (target)\n        virBufferAsprintf(&buf, \",target=%s\", target);\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(target);\n    virBufferFreeAndReset(&buf);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "diskVal"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLDomainDisks(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr diskVal;\n    size_t i;\n\n    if (VIR_ALLOC(diskVal) < 0)\n        return -1;\n\n    diskVal->type = VIR_CONF_LIST;\n    diskVal->list = NULL;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_FLOPPY)\n            continue;\n\n        if (xenFormatXLDisk(diskVal, def->disks[i]) < 0)\n            goto cleanup;\n    }\n\n    if (diskVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"disk\", diskVal);\n        diskVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(diskVal);\n\n    return 0;\n\n cleanup:\n    virConfFreeValue(diskVal);\n    return -1;\n}"
  },
  {
    "function_name": "xenFormatXLDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1653-1750",
    "snippet": "static int\nxenFormatXLDisk(virConfValuePtr list, virDomainDiskDefPtr disk)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr val, tmp;\n    int format = virDomainDiskGetFormat(disk);\n    const char *driver = virDomainDiskGetDriver(disk);\n    char *target = NULL;\n    int ret = -1;\n\n    /* format */\n    virBufferAddLit(&buf, \"format=\");\n    switch (format) {\n        case VIR_STORAGE_FILE_RAW:\n            virBufferAddLit(&buf, \"raw\");\n            break;\n        case VIR_STORAGE_FILE_VHD:\n            virBufferAddLit(&buf, \"xvhd\");\n            break;\n        case VIR_STORAGE_FILE_QCOW:\n            virBufferAddLit(&buf, \"qcow\");\n            break;\n        case VIR_STORAGE_FILE_QCOW2:\n            virBufferAddLit(&buf, \"qcow2\");\n            break;\n        case VIR_STORAGE_FILE_QED:\n            virBufferAddLit(&buf, \"qed\");\n            break;\n      /* set default */\n        default:\n            virBufferAddLit(&buf, \"raw\");\n    }\n\n    /* device */\n    virBufferAsprintf(&buf, \",vdev=%s\", disk->dst);\n\n    /* access */\n    virBufferAddLit(&buf, \",access=\");\n    if (disk->src->readonly)\n        virBufferAddLit(&buf, \"ro\");\n    else if (disk->src->shared)\n        virBufferAddLit(&buf, \"!\");\n    else\n        virBufferAddLit(&buf, \"rw\");\n    if (disk->transient) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"transient disks not supported yet\"));\n        goto cleanup;\n    }\n\n    /* backendtype */\n    if (driver) {\n        virBufferAddLit(&buf, \",backendtype=\");\n        if (STREQ(driver, \"qemu\") || STREQ(driver, \"file\"))\n            virBufferAddLit(&buf, \"qdisk\");\n        else if (STREQ(driver, \"tap\"))\n            virBufferAddLit(&buf, \"tap\");\n        else if (STREQ(driver, \"phy\"))\n            virBufferAddLit(&buf, \"phy\");\n    }\n\n    /* devtype */\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_CDROM)\n        virBufferAddLit(&buf, \",devtype=cdrom\");\n\n    /*\n     * target\n     * From $xensrc/docs/misc/xl-disk-configuration.txt:\n     * When this parameter is specified by name, ie with the \"target=\"\n     * syntax in the configuration file, it consumes the whole rest of the\n     * <diskspec> including trailing whitespaces.  Therefore in that case\n     * it must come last.\n     */\n    if (xenFormatXLDiskSrc(disk->src, &target) < 0)\n        goto cleanup;\n\n    if (target)\n        virBufferAsprintf(&buf, \",target=%s\", target);\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(target);\n    virBufferFreeAndReset(&buf);\n    return ret;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "target"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "val"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\",target=%s\"",
            "target"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatXLDiskSrc",
          "args": [
            "disk->src",
            "&target"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLDiskSrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "1620-1650",
          "snippet": "static int\nxenFormatXLDiskSrc(virStorageSourcePtr src, char **srcstr)\n{\n    int actualType = virStorageSourceGetActualType(src);\n\n    *srcstr = NULL;\n\n    if (virStorageSourceIsEmpty(src))\n        return 0;\n\n    switch ((virStorageType)actualType) {\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_DIR:\n        *srcstr = g_strdup(src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n        if (!(*srcstr = xenFormatXLDiskSrcNet(src)))\n            return -1;\n        break;\n\n    case VIR_STORAGE_TYPE_VOLUME:\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLDiskSrc(virStorageSourcePtr src, char **srcstr)\n{\n    int actualType = virStorageSourceGetActualType(src);\n\n    *srcstr = NULL;\n\n    if (virStorageSourceIsEmpty(src))\n        return 0;\n\n    switch ((virStorageType)actualType) {\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_DIR:\n        *srcstr = g_strdup(src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n        if (!(*srcstr = xenFormatXLDiskSrcNet(src)))\n            return -1;\n        break;\n\n    case VIR_STORAGE_TYPE_VOLUME:\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\",devtype=cdrom\""
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"phy\""
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "driver",
            "\"phy\""
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"tap\""
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "driver",
            "\"tap\""
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"qdisk\""
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "driver",
            "\"file\""
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "driver",
            "\"qemu\""
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\",backendtype=\""
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"transient disks not supported yet\")"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"transient disks not supported yet\""
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"rw\""
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"!\""
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"ro\""
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\",access=\""
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"raw\""
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"qed\""
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"qcow2\""
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"qcow\""
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"xvhd\""
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"raw\""
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"format=\""
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetDriver",
          "args": [
            "disk"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2185-2189",
          "snippet": "const char *\nvirDomainDiskGetDriver(const virDomainDiskDef *def)\n{\n    return def->driverName;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetDriver(const virDomainDiskDef *def)\n{\n    return def->driverName;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetFormat",
          "args": [
            "disk"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2202-2206",
          "snippet": "int\nvirDomainDiskGetFormat(virDomainDiskDefPtr def)\n{\n    return def->src->format;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetFormat(virDomainDiskDefPtr def)\n{\n    return def->src->format;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLDisk(virConfValuePtr list, virDomainDiskDefPtr disk)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr val, tmp;\n    int format = virDomainDiskGetFormat(disk);\n    const char *driver = virDomainDiskGetDriver(disk);\n    char *target = NULL;\n    int ret = -1;\n\n    /* format */\n    virBufferAddLit(&buf, \"format=\");\n    switch (format) {\n        case VIR_STORAGE_FILE_RAW:\n            virBufferAddLit(&buf, \"raw\");\n            break;\n        case VIR_STORAGE_FILE_VHD:\n            virBufferAddLit(&buf, \"xvhd\");\n            break;\n        case VIR_STORAGE_FILE_QCOW:\n            virBufferAddLit(&buf, \"qcow\");\n            break;\n        case VIR_STORAGE_FILE_QCOW2:\n            virBufferAddLit(&buf, \"qcow2\");\n            break;\n        case VIR_STORAGE_FILE_QED:\n            virBufferAddLit(&buf, \"qed\");\n            break;\n      /* set default */\n        default:\n            virBufferAddLit(&buf, \"raw\");\n    }\n\n    /* device */\n    virBufferAsprintf(&buf, \",vdev=%s\", disk->dst);\n\n    /* access */\n    virBufferAddLit(&buf, \",access=\");\n    if (disk->src->readonly)\n        virBufferAddLit(&buf, \"ro\");\n    else if (disk->src->shared)\n        virBufferAddLit(&buf, \"!\");\n    else\n        virBufferAddLit(&buf, \"rw\");\n    if (disk->transient) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"transient disks not supported yet\"));\n        goto cleanup;\n    }\n\n    /* backendtype */\n    if (driver) {\n        virBufferAddLit(&buf, \",backendtype=\");\n        if (STREQ(driver, \"qemu\") || STREQ(driver, \"file\"))\n            virBufferAddLit(&buf, \"qdisk\");\n        else if (STREQ(driver, \"tap\"))\n            virBufferAddLit(&buf, \"tap\");\n        else if (STREQ(driver, \"phy\"))\n            virBufferAddLit(&buf, \"phy\");\n    }\n\n    /* devtype */\n    if (disk->device == VIR_DOMAIN_DISK_DEVICE_CDROM)\n        virBufferAddLit(&buf, \",devtype=cdrom\");\n\n    /*\n     * target\n     * From $xensrc/docs/misc/xl-disk-configuration.txt:\n     * When this parameter is specified by name, ie with the \"target=\"\n     * syntax in the configuration file, it consumes the whole rest of the\n     * <diskspec> including trailing whitespaces.  Therefore in that case\n     * it must come last.\n     */\n    if (xenFormatXLDiskSrc(disk->src, &target) < 0)\n        goto cleanup;\n\n    if (target)\n        virBufferAsprintf(&buf, \",target=%s\", target);\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(target);\n    virBufferFreeAndReset(&buf);\n    return ret;\n}"
  },
  {
    "function_name": "xenFormatXLDiskSrc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1620-1650",
    "snippet": "static int\nxenFormatXLDiskSrc(virStorageSourcePtr src, char **srcstr)\n{\n    int actualType = virStorageSourceGetActualType(src);\n\n    *srcstr = NULL;\n\n    if (virStorageSourceIsEmpty(src))\n        return 0;\n\n    switch ((virStorageType)actualType) {\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_DIR:\n        *srcstr = g_strdup(src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n        if (!(*srcstr = xenFormatXLDiskSrcNet(src)))\n            return -1;\n        break;\n\n    case VIR_STORAGE_TYPE_VOLUME:\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenFormatXLDiskSrcNet",
          "args": [
            "src"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLDiskSrcNet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "1553-1617",
          "snippet": "static char *\nxenFormatXLDiskSrcNet(virStorageSourcePtr src)\n{\n    char *ret = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    switch ((virStorageNetProtocol) src->protocol) {\n    case VIR_STORAGE_NET_PROTOCOL_NBD:\n    case VIR_STORAGE_NET_PROTOCOL_HTTP:\n    case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n    case VIR_STORAGE_NET_PROTOCOL_FTP:\n    case VIR_STORAGE_NET_PROTOCOL_FTPS:\n    case VIR_STORAGE_NET_PROTOCOL_TFTP:\n    case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n    case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n    case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n    case VIR_STORAGE_NET_PROTOCOL_SSH:\n    case VIR_STORAGE_NET_PROTOCOL_VXHS:\n    case VIR_STORAGE_NET_PROTOCOL_LAST:\n    case VIR_STORAGE_NET_PROTOCOL_NONE:\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"Unsupported network block protocol '%s'\"),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        goto cleanup;\n\n    case VIR_STORAGE_NET_PROTOCOL_RBD:\n        if (strchr(src->path, ':')) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"':' not allowed in RBD source volume name '%s'\"),\n                           src->path);\n            goto cleanup;\n        }\n\n        virBufferStrcat(&buf, \"rbd:\", src->volume, \"/\", src->path, NULL);\n\n        virBufferAddLit(&buf, \":auth_supported=none\");\n\n        if (src->nhosts > 0) {\n            virBufferAddLit(&buf, \":mon_host=\");\n            for (i = 0; i < src->nhosts; i++) {\n                if (i)\n                    virBufferAddLit(&buf, \"\\\\\\\\;\");\n\n                /* assume host containing : is ipv6 */\n                if (strchr(src->hosts[i].name, ':'))\n                    virBufferEscape(&buf, '\\\\', \":\", \"[%s]\",\n                                    src->hosts[i].name);\n                else\n                    virBufferAsprintf(&buf, \"%s\", src->hosts[i].name);\n\n                if (src->hosts[i].port)\n                    virBufferAsprintf(&buf, \"\\\\\\\\:%u\", src->hosts[i].port);\n            }\n        }\n\n        ret = virBufferContentAndReset(&buf);\n        break;\n    }\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n\n    return ret;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic char *\nxenFormatXLDiskSrcNet(virStorageSourcePtr src)\n{\n    char *ret = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    switch ((virStorageNetProtocol) src->protocol) {\n    case VIR_STORAGE_NET_PROTOCOL_NBD:\n    case VIR_STORAGE_NET_PROTOCOL_HTTP:\n    case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n    case VIR_STORAGE_NET_PROTOCOL_FTP:\n    case VIR_STORAGE_NET_PROTOCOL_FTPS:\n    case VIR_STORAGE_NET_PROTOCOL_TFTP:\n    case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n    case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n    case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n    case VIR_STORAGE_NET_PROTOCOL_SSH:\n    case VIR_STORAGE_NET_PROTOCOL_VXHS:\n    case VIR_STORAGE_NET_PROTOCOL_LAST:\n    case VIR_STORAGE_NET_PROTOCOL_NONE:\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"Unsupported network block protocol '%s'\"),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        goto cleanup;\n\n    case VIR_STORAGE_NET_PROTOCOL_RBD:\n        if (strchr(src->path, ':')) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"':' not allowed in RBD source volume name '%s'\"),\n                           src->path);\n            goto cleanup;\n        }\n\n        virBufferStrcat(&buf, \"rbd:\", src->volume, \"/\", src->path, NULL);\n\n        virBufferAddLit(&buf, \":auth_supported=none\");\n\n        if (src->nhosts > 0) {\n            virBufferAddLit(&buf, \":mon_host=\");\n            for (i = 0; i < src->nhosts; i++) {\n                if (i)\n                    virBufferAddLit(&buf, \"\\\\\\\\;\");\n\n                /* assume host containing : is ipv6 */\n                if (strchr(src->hosts[i].name, ':'))\n                    virBufferEscape(&buf, '\\\\', \":\", \"[%s]\",\n                                    src->hosts[i].name);\n                else\n                    virBufferAsprintf(&buf, \"%s\", src->hosts[i].name);\n\n                if (src->hosts[i].port)\n                    virBufferAsprintf(&buf, \"\\\\\\\\:%u\", src->hosts[i].port);\n            }\n        }\n\n        ret = virBufferContentAndReset(&buf);\n        break;\n    }\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "src->path"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsEmpty",
          "args": [
            "src"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2619-2633",
          "snippet": "bool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "src"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLDiskSrc(virStorageSourcePtr src, char **srcstr)\n{\n    int actualType = virStorageSourceGetActualType(src);\n\n    *srcstr = NULL;\n\n    if (virStorageSourceIsEmpty(src))\n        return 0;\n\n    switch ((virStorageType)actualType) {\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_DIR:\n        *srcstr = g_strdup(src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n        if (!(*srcstr = xenFormatXLDiskSrcNet(src)))\n            return -1;\n        break;\n\n    case VIR_STORAGE_TYPE_VOLUME:\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenFormatXLDiskSrcNet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1553-1617",
    "snippet": "static char *\nxenFormatXLDiskSrcNet(virStorageSourcePtr src)\n{\n    char *ret = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    switch ((virStorageNetProtocol) src->protocol) {\n    case VIR_STORAGE_NET_PROTOCOL_NBD:\n    case VIR_STORAGE_NET_PROTOCOL_HTTP:\n    case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n    case VIR_STORAGE_NET_PROTOCOL_FTP:\n    case VIR_STORAGE_NET_PROTOCOL_FTPS:\n    case VIR_STORAGE_NET_PROTOCOL_TFTP:\n    case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n    case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n    case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n    case VIR_STORAGE_NET_PROTOCOL_SSH:\n    case VIR_STORAGE_NET_PROTOCOL_VXHS:\n    case VIR_STORAGE_NET_PROTOCOL_LAST:\n    case VIR_STORAGE_NET_PROTOCOL_NONE:\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"Unsupported network block protocol '%s'\"),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        goto cleanup;\n\n    case VIR_STORAGE_NET_PROTOCOL_RBD:\n        if (strchr(src->path, ':')) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"':' not allowed in RBD source volume name '%s'\"),\n                           src->path);\n            goto cleanup;\n        }\n\n        virBufferStrcat(&buf, \"rbd:\", src->volume, \"/\", src->path, NULL);\n\n        virBufferAddLit(&buf, \":auth_supported=none\");\n\n        if (src->nhosts > 0) {\n            virBufferAddLit(&buf, \":mon_host=\");\n            for (i = 0; i < src->nhosts; i++) {\n                if (i)\n                    virBufferAddLit(&buf, \"\\\\\\\\;\");\n\n                /* assume host containing : is ipv6 */\n                if (strchr(src->hosts[i].name, ':'))\n                    virBufferEscape(&buf, '\\\\', \":\", \"[%s]\",\n                                    src->hosts[i].name);\n                else\n                    virBufferAsprintf(&buf, \"%s\", src->hosts[i].name);\n\n                if (src->hosts[i].port)\n                    virBufferAsprintf(&buf, \"\\\\\\\\:%u\", src->hosts[i].port);\n            }\n        }\n\n        ret = virBufferContentAndReset(&buf);\n        break;\n    }\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n\n    return ret;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"\\\\\\\\:%u\"",
            "src->hosts[i].port"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscape",
          "args": [
            "&buf",
            "'\\\\'",
            "\":\"",
            "\"[%s]\"",
            "src->hosts[i].name"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "491-522",
          "snippet": "void\nvirBufferEscape(virBufferPtr buf, char escape, const char *toescape,\n                const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, toescape) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 2);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (strchr(toescape, *cur))\n            *out++ = escape;\n        *out++ = *cur;\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscape(virBufferPtr buf, char escape, const char *toescape,\n                const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, toescape) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 2);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (strchr(toescape, *cur))\n            *out++ = escape;\n        *out++ = *cur;\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "src->hosts[i].name",
            "':'"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"\\\\\\\\;\""
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\":mon_host=\""
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\":auth_supported=none\""
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferStrcat",
          "args": [
            "&buf",
            "\"rbd:\"",
            "src->volume",
            "\"/\"",
            "src->path",
            "NULL"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferStrcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "624-635",
          "snippet": "void\nvirBufferStrcat(virBufferPtr buf, ...)\n{\n    va_list ap;\n\n    if (!buf)\n        return;\n\n    va_start(ap, buf);\n    virBufferStrcatVArgs(buf, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferStrcat(virBufferPtr buf, ...)\n{\n    va_list ap;\n\n    if (!buf)\n        return;\n\n    va_start(ap, buf);\n    virBufferStrcatVArgs(buf, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"':' not allowed in RBD source volume name '%s'\")",
            "src->path"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"':' not allowed in RBD source volume name '%s'\""
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "src->path",
            "':'"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"Unsupported network block protocol '%s'\")",
            "virStorageNetProtocolTypeToString(src->protocol)"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageNetProtocolTypeToString",
          "args": [
            "src->protocol"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic char *\nxenFormatXLDiskSrcNet(virStorageSourcePtr src)\n{\n    char *ret = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    switch ((virStorageNetProtocol) src->protocol) {\n    case VIR_STORAGE_NET_PROTOCOL_NBD:\n    case VIR_STORAGE_NET_PROTOCOL_HTTP:\n    case VIR_STORAGE_NET_PROTOCOL_HTTPS:\n    case VIR_STORAGE_NET_PROTOCOL_FTP:\n    case VIR_STORAGE_NET_PROTOCOL_FTPS:\n    case VIR_STORAGE_NET_PROTOCOL_TFTP:\n    case VIR_STORAGE_NET_PROTOCOL_ISCSI:\n    case VIR_STORAGE_NET_PROTOCOL_GLUSTER:\n    case VIR_STORAGE_NET_PROTOCOL_SHEEPDOG:\n    case VIR_STORAGE_NET_PROTOCOL_SSH:\n    case VIR_STORAGE_NET_PROTOCOL_VXHS:\n    case VIR_STORAGE_NET_PROTOCOL_LAST:\n    case VIR_STORAGE_NET_PROTOCOL_NONE:\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"Unsupported network block protocol '%s'\"),\n                       virStorageNetProtocolTypeToString(src->protocol));\n        goto cleanup;\n\n    case VIR_STORAGE_NET_PROTOCOL_RBD:\n        if (strchr(src->path, ':')) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"':' not allowed in RBD source volume name '%s'\"),\n                           src->path);\n            goto cleanup;\n        }\n\n        virBufferStrcat(&buf, \"rbd:\", src->volume, \"/\", src->path, NULL);\n\n        virBufferAddLit(&buf, \":auth_supported=none\");\n\n        if (src->nhosts > 0) {\n            virBufferAddLit(&buf, \":mon_host=\");\n            for (i = 0; i < src->nhosts; i++) {\n                if (i)\n                    virBufferAddLit(&buf, \"\\\\\\\\;\");\n\n                /* assume host containing : is ipv6 */\n                if (strchr(src->hosts[i].name, ':'))\n                    virBufferEscape(&buf, '\\\\', \":\", \"[%s]\",\n                                    src->hosts[i].name);\n                else\n                    virBufferAsprintf(&buf, \"%s\", src->hosts[i].name);\n\n                if (src->hosts[i].port)\n                    virBufferAsprintf(&buf, \"\\\\\\\\:%u\", src->hosts[i].port);\n            }\n        }\n\n        ret = virBufferContentAndReset(&buf);\n        break;\n    }\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n\n    return ret;\n}"
  },
  {
    "function_name": "xenFormatXLGntLimits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1536-1550",
    "snippet": "static int\nxenFormatXLGntLimits(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_XENBUS &&\n            def->controllers[i]->opts.xenbusopts.maxGrantFrames > 0) {\n            if (xenConfigSetInt(conf, \"max_grant_frames\",\n                                def->controllers[i]->opts.xenbusopts.maxGrantFrames) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenConfigSetInt",
          "args": [
            "conf",
            "\"max_grant_frames\"",
            "def->controllers[i]->opts.xenbusopts.maxGrantFrames"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "246-264",
          "snippet": "int\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLGntLimits(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_XENBUS &&\n            def->controllers[i]->opts.xenbusopts.maxGrantFrames > 0) {\n            if (xenConfigSetInt(conf, \"max_grant_frames\",\n                                def->controllers[i]->opts.xenbusopts.maxGrantFrames) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "xenFormatXLDomainVnuma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1495-1532",
    "snippet": "static int\nxenFormatXLDomainVnuma(virConfPtr conf,\n                       virDomainDefPtr def)\n{\n    virDomainNumaPtr numa = def->numa;\n    virConfValuePtr vnumaVal;\n    size_t i;\n    size_t nr_nodes;\n\n    if (numa == NULL)\n        return -1;\n\n    if (VIR_ALLOC(vnumaVal) < 0)\n        return -1;\n\n    vnumaVal->type = VIR_CONF_LIST;\n    vnumaVal->list = NULL;\n\n    nr_nodes = virDomainNumaGetNodeCount(numa);\n    for (i = 0; i < nr_nodes; i++) {\n        if (xenFormatXLVnuma(vnumaVal, numa, i, nr_nodes) < 0)\n            goto cleanup;\n    }\n\n    if (vnumaVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"vnuma\", vnumaVal);\n            vnumaVal = NULL;\n            if (ret < 0)\n                return -1;\n    }\n    VIR_FREE(vnumaVal);\n\n    return 0;\n\n cleanup:\n    virConfFreeValue(vnumaVal);\n    return -1;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConfFreeValue",
          "args": [
            "vnumaVal"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "virConfFreeValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "147-159",
          "snippet": "void\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vnumaVal"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfSetValue",
          "args": [
            "conf",
            "\"vnuma\"",
            "vnumaVal"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "virConfSetValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1338-1378",
          "snippet": "int\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatXLVnuma",
          "args": [
            "vnumaVal",
            "numa",
            "i",
            "nr_nodes"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLVnuma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "1438-1493",
          "snippet": "static int\nxenFormatXLVnuma(virConfValuePtr list,\n                 virDomainNumaPtr numa,\n                 size_t node,\n                 size_t nr_nodes)\n{\n    int ret = -1;\n    size_t i;\n\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr numaVnode, tmp;\n\n    size_t nodeSize = virDomainNumaGetNodeMemorySize(numa, node) / 1024;\n    char *nodeVcpus = virBitmapFormat(virDomainNumaGetNodeCpumask(numa, node));\n\n    if (VIR_ALLOC(numaVnode) < 0)\n        goto cleanup;\n\n    numaVnode->type = VIR_CONF_LIST;\n    numaVnode->list = NULL;\n\n    /* pnode */\n    virBufferAsprintf(&buf, \"pnode=%zu\", node);\n    xenFormatXLVnode(numaVnode, &buf);\n\n    /* size */\n    virBufferAsprintf(&buf, \"size=%zu\", nodeSize);\n    xenFormatXLVnode(numaVnode, &buf);\n\n    /* vcpus */\n    virBufferAsprintf(&buf, \"vcpus=%s\", nodeVcpus);\n    xenFormatXLVnode(numaVnode, &buf);\n\n    /* distances */\n    virBufferAddLit(&buf, \"vdistances=\");\n    for (i = 0; i < nr_nodes; i++) {\n        virBufferAsprintf(&buf, \"%zu\",\n            virDomainNumaGetNodeDistance(numa, node, i));\n        if ((nr_nodes - i) > 1)\n            virBufferAddLit(&buf, \",\");\n    }\n    xenFormatXLVnode(numaVnode, &buf);\n\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = numaVnode;\n    else\n        list->list = numaVnode;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(nodeVcpus);\n    return ret;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLVnuma(virConfValuePtr list,\n                 virDomainNumaPtr numa,\n                 size_t node,\n                 size_t nr_nodes)\n{\n    int ret = -1;\n    size_t i;\n\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr numaVnode, tmp;\n\n    size_t nodeSize = virDomainNumaGetNodeMemorySize(numa, node) / 1024;\n    char *nodeVcpus = virBitmapFormat(virDomainNumaGetNodeCpumask(numa, node));\n\n    if (VIR_ALLOC(numaVnode) < 0)\n        goto cleanup;\n\n    numaVnode->type = VIR_CONF_LIST;\n    numaVnode->list = NULL;\n\n    /* pnode */\n    virBufferAsprintf(&buf, \"pnode=%zu\", node);\n    xenFormatXLVnode(numaVnode, &buf);\n\n    /* size */\n    virBufferAsprintf(&buf, \"size=%zu\", nodeSize);\n    xenFormatXLVnode(numaVnode, &buf);\n\n    /* vcpus */\n    virBufferAsprintf(&buf, \"vcpus=%s\", nodeVcpus);\n    xenFormatXLVnode(numaVnode, &buf);\n\n    /* distances */\n    virBufferAddLit(&buf, \"vdistances=\");\n    for (i = 0; i < nr_nodes; i++) {\n        virBufferAsprintf(&buf, \"%zu\",\n            virDomainNumaGetNodeDistance(numa, node, i));\n        if ((nr_nodes - i) > 1)\n            virBufferAddLit(&buf, \",\");\n    }\n    xenFormatXLVnode(numaVnode, &buf);\n\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = numaVnode;\n    else\n        list->list = numaVnode;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(nodeVcpus);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeCount",
          "args": [
            "numa"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1137-1144",
          "snippet": "size_t\nvirDomainNumaGetNodeCount(virDomainNumaPtr numa)\n{\n    if (!numa)\n        return 0;\n\n    return numa->nmem_nodes;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nsize_t\nvirDomainNumaGetNodeCount(virDomainNumaPtr numa)\n{\n    if (!numa)\n        return 0;\n\n    return numa->nmem_nodes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "vnumaVal"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLDomainVnuma(virConfPtr conf,\n                       virDomainDefPtr def)\n{\n    virDomainNumaPtr numa = def->numa;\n    virConfValuePtr vnumaVal;\n    size_t i;\n    size_t nr_nodes;\n\n    if (numa == NULL)\n        return -1;\n\n    if (VIR_ALLOC(vnumaVal) < 0)\n        return -1;\n\n    vnumaVal->type = VIR_CONF_LIST;\n    vnumaVal->list = NULL;\n\n    nr_nodes = virDomainNumaGetNodeCount(numa);\n    for (i = 0; i < nr_nodes; i++) {\n        if (xenFormatXLVnuma(vnumaVal, numa, i, nr_nodes) < 0)\n            goto cleanup;\n    }\n\n    if (vnumaVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"vnuma\", vnumaVal);\n            vnumaVal = NULL;\n            if (ret < 0)\n                return -1;\n    }\n    VIR_FREE(vnumaVal);\n\n    return 0;\n\n cleanup:\n    virConfFreeValue(vnumaVal);\n    return -1;\n}"
  },
  {
    "function_name": "xenFormatXLVnuma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1438-1493",
    "snippet": "static int\nxenFormatXLVnuma(virConfValuePtr list,\n                 virDomainNumaPtr numa,\n                 size_t node,\n                 size_t nr_nodes)\n{\n    int ret = -1;\n    size_t i;\n\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr numaVnode, tmp;\n\n    size_t nodeSize = virDomainNumaGetNodeMemorySize(numa, node) / 1024;\n    char *nodeVcpus = virBitmapFormat(virDomainNumaGetNodeCpumask(numa, node));\n\n    if (VIR_ALLOC(numaVnode) < 0)\n        goto cleanup;\n\n    numaVnode->type = VIR_CONF_LIST;\n    numaVnode->list = NULL;\n\n    /* pnode */\n    virBufferAsprintf(&buf, \"pnode=%zu\", node);\n    xenFormatXLVnode(numaVnode, &buf);\n\n    /* size */\n    virBufferAsprintf(&buf, \"size=%zu\", nodeSize);\n    xenFormatXLVnode(numaVnode, &buf);\n\n    /* vcpus */\n    virBufferAsprintf(&buf, \"vcpus=%s\", nodeVcpus);\n    xenFormatXLVnode(numaVnode, &buf);\n\n    /* distances */\n    virBufferAddLit(&buf, \"vdistances=\");\n    for (i = 0; i < nr_nodes; i++) {\n        virBufferAsprintf(&buf, \"%zu\",\n            virDomainNumaGetNodeDistance(numa, node, i));\n        if ((nr_nodes - i) > 1)\n            virBufferAddLit(&buf, \",\");\n    }\n    xenFormatXLVnode(numaVnode, &buf);\n\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = numaVnode;\n    else\n        list->list = numaVnode;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(nodeVcpus);\n    return ret;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodeVcpus"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenFormatXLVnode",
          "args": [
            "numaVnode",
            "&buf"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatXLVnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "1410-1436",
          "snippet": "static int\nxenFormatXLVnode(virConfValuePtr list,\n                 virBufferPtr buf)\n{\n    int ret = -1;\n    virConfValuePtr numaPnode, tmp;\n\n    if (VIR_ALLOC(numaPnode) < 0)\n        goto cleanup;\n\n    /* Place VNODE directive */\n    numaPnode->type = VIR_CONF_STRING;\n    numaPnode->str = virBufferContentAndReset(buf);\n\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = numaPnode;\n    else\n        list->list = numaPnode;\n    ret = 0;\n\n cleanup:\n    virBufferFreeAndReset(buf);\n    return ret;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLVnode(virConfValuePtr list,\n                 virBufferPtr buf)\n{\n    int ret = -1;\n    virConfValuePtr numaPnode, tmp;\n\n    if (VIR_ALLOC(numaPnode) < 0)\n        goto cleanup;\n\n    /* Place VNODE directive */\n    numaPnode->type = VIR_CONF_STRING;\n    numaPnode->str = virBufferContentAndReset(buf);\n\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = numaPnode;\n    else\n        list->list = numaPnode;\n    ret = 0;\n\n cleanup:\n    virBufferFreeAndReset(buf);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\",\""
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"%zu\"",
            "virDomainNumaGetNodeDistance(numa, node, i)"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeDistance",
          "args": [
            "numa",
            "node",
            "i"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeDistance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1210-1231",
          "snippet": "size_t\nvirDomainNumaGetNodeDistance(virDomainNumaPtr numa,\n                             size_t node,\n                             size_t cellid)\n{\n    virDomainNumaDistancePtr distances = NULL;\n\n    if (node < numa->nmem_nodes)\n        distances = numa->mem_nodes[node].distances;\n\n    /*\n     * Present the configured distance value. If\n     * out of range or not available set the platform\n     * defined default for local and remote nodes.\n     */\n    if (!distances ||\n        cellid >= numa->nmem_nodes ||\n        !distances[cellid].value)\n        return (node == cellid) ? LOCAL_DISTANCE : REMOTE_DISTANCE;\n\n    return distances[cellid].value;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define REMOTE_DISTANCE         20",
            "#define LOCAL_DISTANCE          10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\n#define REMOTE_DISTANCE         20\n#define LOCAL_DISTANCE          10\n\nsize_t\nvirDomainNumaGetNodeDistance(virDomainNumaPtr numa,\n                             size_t node,\n                             size_t cellid)\n{\n    virDomainNumaDistancePtr distances = NULL;\n\n    if (node < numa->nmem_nodes)\n        distances = numa->mem_nodes[node].distances;\n\n    /*\n     * Present the configured distance value. If\n     * out of range or not available set the platform\n     * defined default for local and remote nodes.\n     */\n    if (!distances ||\n        cellid >= numa->nmem_nodes ||\n        !distances[cellid].value)\n        return (node == cellid) ? LOCAL_DISTANCE : REMOTE_DISTANCE;\n\n    return distances[cellid].value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"vdistances=\""
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "numaVnode"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFormat",
          "args": [
            "virDomainNumaGetNodeCpumask(numa, node)"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "404-442",
          "snippet": "char *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeCpumask",
          "args": [
            "numa",
            "node"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeCpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1313-1318",
          "snippet": "virBitmapPtr\nvirDomainNumaGetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].cpumask;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirBitmapPtr\nvirDomainNumaGetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].cpumask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeMemorySize",
          "args": [
            "numa",
            "node"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeMemorySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1348-1353",
          "snippet": "unsigned long long\nvirDomainNumaGetNodeMemorySize(virDomainNumaPtr numa,\n                               size_t node)\n{\n    return numa->mem_nodes[node].mem;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned long long\nvirDomainNumaGetNodeMemorySize(virDomainNumaPtr numa,\n                               size_t node)\n{\n    return numa->mem_nodes[node].mem;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLVnuma(virConfValuePtr list,\n                 virDomainNumaPtr numa,\n                 size_t node,\n                 size_t nr_nodes)\n{\n    int ret = -1;\n    size_t i;\n\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr numaVnode, tmp;\n\n    size_t nodeSize = virDomainNumaGetNodeMemorySize(numa, node) / 1024;\n    char *nodeVcpus = virBitmapFormat(virDomainNumaGetNodeCpumask(numa, node));\n\n    if (VIR_ALLOC(numaVnode) < 0)\n        goto cleanup;\n\n    numaVnode->type = VIR_CONF_LIST;\n    numaVnode->list = NULL;\n\n    /* pnode */\n    virBufferAsprintf(&buf, \"pnode=%zu\", node);\n    xenFormatXLVnode(numaVnode, &buf);\n\n    /* size */\n    virBufferAsprintf(&buf, \"size=%zu\", nodeSize);\n    xenFormatXLVnode(numaVnode, &buf);\n\n    /* vcpus */\n    virBufferAsprintf(&buf, \"vcpus=%s\", nodeVcpus);\n    xenFormatXLVnode(numaVnode, &buf);\n\n    /* distances */\n    virBufferAddLit(&buf, \"vdistances=\");\n    for (i = 0; i < nr_nodes; i++) {\n        virBufferAsprintf(&buf, \"%zu\",\n            virDomainNumaGetNodeDistance(numa, node, i));\n        if ((nr_nodes - i) > 1)\n            virBufferAddLit(&buf, \",\");\n    }\n    xenFormatXLVnode(numaVnode, &buf);\n\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = numaVnode;\n    else\n        list->list = numaVnode;\n    ret = 0;\n\n cleanup:\n    VIR_FREE(nodeVcpus);\n    return ret;\n}"
  },
  {
    "function_name": "xenFormatXLVnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1410-1436",
    "snippet": "static int\nxenFormatXLVnode(virConfValuePtr list,\n                 virBufferPtr buf)\n{\n    int ret = -1;\n    virConfValuePtr numaPnode, tmp;\n\n    if (VIR_ALLOC(numaPnode) < 0)\n        goto cleanup;\n\n    /* Place VNODE directive */\n    numaPnode->type = VIR_CONF_STRING;\n    numaPnode->str = virBufferContentAndReset(buf);\n\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = numaPnode;\n    else\n        list->list = numaPnode;\n    ret = 0;\n\n cleanup:\n    virBufferFreeAndReset(buf);\n    return ret;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "buf"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "buf"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "numaPnode"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLVnode(virConfValuePtr list,\n                 virBufferPtr buf)\n{\n    int ret = -1;\n    virConfValuePtr numaPnode, tmp;\n\n    if (VIR_ALLOC(numaPnode) < 0)\n        goto cleanup;\n\n    /* Place VNODE directive */\n    numaPnode->type = VIR_CONF_STRING;\n    numaPnode->str = virBufferContentAndReset(buf);\n\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = numaPnode;\n    else\n        list->list = numaPnode;\n    ret = 0;\n\n cleanup:\n    virBufferFreeAndReset(buf);\n    return ret;\n}"
  },
  {
    "function_name": "xenFormatXLCPUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1340-1407",
    "snippet": "static int\nxenFormatXLCPUID(virConfPtr conf, virDomainDefPtr def)\n{\n    char **cpuid_pairs = NULL;\n    char *cpuid_string = NULL;\n    size_t i, j;\n    int ret = -1;\n\n    if (!def->cpu)\n        return 0;\n\n    if (def->cpu->mode != VIR_CPU_MODE_HOST_PASSTHROUGH) {\n        VIR_WARN(\"ignoring CPU mode '%s', only host-passthrough mode \"\n                 \"is supported\", virCPUModeTypeToString(def->cpu->mode));\n        return 0;\n    }\n\n    /* \"host\" + all features + NULL */\n    if (VIR_ALLOC_N(cpuid_pairs, def->cpu->nfeatures + 2) < 0)\n        return -1;\n\n    cpuid_pairs[0] = g_strdup(\"host\");\n\n    j = 1;\n    for (i = 0; i < def->cpu->nfeatures; i++) {\n        const char *feature_name = xenTranslateCPUFeature(\n                def->cpu->features[i].name,\n                false);\n        const char *policy = NULL;\n\n        if (STREQ(feature_name, \"vmx\") || STREQ(feature_name, \"svm\"))\n            /* ignore vmx/svm in cpuid option, translated into nestedhvm\n             * elsewhere */\n            continue;\n\n        switch (def->cpu->features[i].policy) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                policy = \"1\";\n                break;\n            case VIR_CPU_FEATURE_OPTIONAL:\n                policy = \"x\";\n                break;\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                policy = \"0\";\n                break;\n        }\n        cpuid_pairs[j++] = g_strdup_printf(\"%s=%s\", feature_name, policy);\n    }\n    cpuid_pairs[j] = NULL;\n\n    if (j > 1) {\n        cpuid_string = virStringListJoin((const char **)cpuid_pairs, \",\");\n        if (!cpuid_string)\n            goto cleanup;\n\n        if (xenConfigSetString(conf, \"cpuid\", cpuid_string) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virStringListFree(cpuid_pairs);\n    VIR_FREE(cpuid_string);\n    return ret;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpuid_string"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "cpuid_pairs"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigSetString",
          "args": [
            "conf",
            "\"cpuid\"",
            "cpuid_string"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "267-280",
          "snippet": "int\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringListJoin",
          "args": [
            "(const char **)cpuid_pairs",
            "\",\""
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListJoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "147-162",
          "snippet": "char *virStringListJoin(const char **strings,\n                        const char *delim)\n{\n    char *ret;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    while (*strings) {\n        virBufferAdd(&buf, *strings, -1);\n        if (*(strings+1))\n            virBufferAdd(&buf, delim, -1);\n        strings++;\n    }\n    ret = virBufferContentAndReset(&buf);\n    if (!ret)\n        ret = g_strdup(\"\");\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar *virStringListJoin(const char **strings,\n                        const char *delim)\n{\n    char *ret;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    while (*strings) {\n        virBufferAdd(&buf, *strings, -1);\n        if (*(strings+1))\n            virBufferAdd(&buf, delim, -1);\n        strings++;\n    }\n    ret = virBufferContentAndReset(&buf);\n    if (!ret)\n        ret = g_strdup(\"\");\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s=%s\"",
            "feature_name",
            "policy"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "feature_name",
            "\"svm\""
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "feature_name",
            "\"vmx\""
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenTranslateCPUFeature",
          "args": [
            "def->cpu->features[i].name",
            "false"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "xenTranslateCPUFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "218-247",
          "snippet": "const char *\nxenTranslateCPUFeature(const char *feature_name, bool from_libxl)\n{\n    static const char *translation_table[][2] = {\n        /* libvirt name, libxl name */\n        { \"cx16\", \"cmpxchg16\" },\n        { \"cid\", \"cntxid\" },\n        { \"ds_cpl\", \"dscpl\" },\n        { \"pclmuldq\", \"pclmulqdq\" },\n        { \"pni\", \"sse3\" },\n        { \"ht\", \"htt\" },\n        { \"pn\", \"psn\" },\n        { \"clflush\", \"clfsh\" },\n        { \"sep\", \"sysenter\" },\n        { \"cx8\", \"cmpxchg8\" },\n        { \"nodeid_msr\", \"nodeid\" },\n        { \"cr8legacy\", \"altmovcr8\" },\n        { \"lahf_lm\", \"lahfsahf\" },\n        { \"cmp_legacy\", \"cmplegacy\" },\n        { \"fxsr_opt\", \"ffxsr\" },\n        { \"pdpe1gb\", \"page1gb\" },\n        { \"spec-ctrl\", \"ibrsb\" },\n    };\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(translation_table); i++)\n        if (STREQ(translation_table[i][from_libxl], feature_name))\n            return translation_table[i][!from_libxl];\n    return feature_name;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nconst char *\nxenTranslateCPUFeature(const char *feature_name, bool from_libxl)\n{\n    static const char *translation_table[][2] = {\n        /* libvirt name, libxl name */\n        { \"cx16\", \"cmpxchg16\" },\n        { \"cid\", \"cntxid\" },\n        { \"ds_cpl\", \"dscpl\" },\n        { \"pclmuldq\", \"pclmulqdq\" },\n        { \"pni\", \"sse3\" },\n        { \"ht\", \"htt\" },\n        { \"pn\", \"psn\" },\n        { \"clflush\", \"clfsh\" },\n        { \"sep\", \"sysenter\" },\n        { \"cx8\", \"cmpxchg8\" },\n        { \"nodeid_msr\", \"nodeid\" },\n        { \"cr8legacy\", \"altmovcr8\" },\n        { \"lahf_lm\", \"lahfsahf\" },\n        { \"cmp_legacy\", \"cmplegacy\" },\n        { \"fxsr_opt\", \"ffxsr\" },\n        { \"pdpe1gb\", \"page1gb\" },\n        { \"spec-ctrl\", \"ibrsb\" },\n    };\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(translation_table); i++)\n        if (STREQ(translation_table[i][from_libxl], feature_name))\n            return translation_table[i][!from_libxl];\n    return feature_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "cpuid_pairs",
            "def->cpu->nfeatures + 2"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"ignoring CPU mode '%s', only host-passthrough mode \"\n                 \"is supported\"",
            "virCPUModeTypeToString(def->cpu->mode)"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUModeTypeToString",
          "args": [
            "def->cpu->mode"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLCPUID(virConfPtr conf, virDomainDefPtr def)\n{\n    char **cpuid_pairs = NULL;\n    char *cpuid_string = NULL;\n    size_t i, j;\n    int ret = -1;\n\n    if (!def->cpu)\n        return 0;\n\n    if (def->cpu->mode != VIR_CPU_MODE_HOST_PASSTHROUGH) {\n        VIR_WARN(\"ignoring CPU mode '%s', only host-passthrough mode \"\n                 \"is supported\", virCPUModeTypeToString(def->cpu->mode));\n        return 0;\n    }\n\n    /* \"host\" + all features + NULL */\n    if (VIR_ALLOC_N(cpuid_pairs, def->cpu->nfeatures + 2) < 0)\n        return -1;\n\n    cpuid_pairs[0] = g_strdup(\"host\");\n\n    j = 1;\n    for (i = 0; i < def->cpu->nfeatures; i++) {\n        const char *feature_name = xenTranslateCPUFeature(\n                def->cpu->features[i].name,\n                false);\n        const char *policy = NULL;\n\n        if (STREQ(feature_name, \"vmx\") || STREQ(feature_name, \"svm\"))\n            /* ignore vmx/svm in cpuid option, translated into nestedhvm\n             * elsewhere */\n            continue;\n\n        switch (def->cpu->features[i].policy) {\n            case VIR_CPU_FEATURE_FORCE:\n            case VIR_CPU_FEATURE_REQUIRE:\n                policy = \"1\";\n                break;\n            case VIR_CPU_FEATURE_OPTIONAL:\n                policy = \"x\";\n                break;\n            case VIR_CPU_FEATURE_DISABLE:\n            case VIR_CPU_FEATURE_FORBID:\n                policy = \"0\";\n                break;\n        }\n        cpuid_pairs[j++] = g_strdup_printf(\"%s=%s\", feature_name, policy);\n    }\n    cpuid_pairs[j] = NULL;\n\n    if (j > 1) {\n        cpuid_string = virStringListJoin((const char **)cpuid_pairs, \",\");\n        if (!cpuid_string)\n            goto cleanup;\n\n        if (xenConfigSetString(conf, \"cpuid\", cpuid_string) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virStringListFree(cpuid_pairs);\n    VIR_FREE(cpuid_string);\n    return ret;\n}"
  },
  {
    "function_name": "xenFormatXLOS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1221-1338",
    "snippet": "static int\nxenFormatXLOS(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        char boot[VIR_DOMAIN_BOOT_LAST+1];\n        if (xenConfigSetString(conf, \"builder\", \"hvm\") < 0)\n            return -1;\n\n        if (virDomainDefHasOldStyleUEFI(def) &&\n            xenConfigSetString(conf, \"bios\", \"ovmf\") < 0)\n            return -1;\n\n        if (def->os.slic_table &&\n            xenConfigSetString(conf, \"acpi_firmware\", def->os.slic_table) < 0)\n            return -1;\n\n#ifdef LIBXL_HAVE_BUILDINFO_KERNEL\n        if (def->os.kernel &&\n            xenConfigSetString(conf, \"kernel\", def->os.kernel) < 0)\n            return -1;\n\n        if (def->os.initrd &&\n            xenConfigSetString(conf, \"ramdisk\", def->os.initrd) < 0)\n            return -1;\n\n        if (def->os.cmdline &&\n            xenConfigSetString(conf, \"cmdline\", def->os.cmdline) < 0)\n            return -1;\n#endif\n\n        for (i = 0; i < def->os.nBootDevs; i++) {\n            switch (def->os.bootDevs[i]) {\n            case VIR_DOMAIN_BOOT_FLOPPY:\n                boot[i] = 'a';\n                break;\n            case VIR_DOMAIN_BOOT_CDROM:\n                boot[i] = 'd';\n                break;\n            case VIR_DOMAIN_BOOT_NET:\n                boot[i] = 'n';\n                break;\n            case VIR_DOMAIN_BOOT_DISK:\n            default:\n                boot[i] = 'c';\n                break;\n            }\n        }\n\n        if (!def->os.nBootDevs) {\n            boot[0] = 'c';\n            boot[1] = '\\0';\n        } else {\n            boot[def->os.nBootDevs] = '\\0';\n        }\n\n        if (xenConfigSetString(conf, \"boot\", boot) < 0)\n            return -1;\n\n        if (def->cpu &&\n            def->cpu->mode == VIR_CPU_MODE_HOST_PASSTHROUGH) {\n            bool hasHwVirt = true;\n\n            if (def->cpu->nfeatures) {\n                for (i = 0; i < def->cpu->nfeatures; i++) {\n\n                    switch (def->cpu->features[i].policy) {\n                        case VIR_CPU_FEATURE_DISABLE:\n                        case VIR_CPU_FEATURE_FORBID:\n                            if (STREQ(def->cpu->features[i].name, \"vmx\") ||\n                                STREQ(def->cpu->features[i].name, \"svm\"))\n                                hasHwVirt = false;\n                            break;\n\n                        case VIR_CPU_FEATURE_FORCE:\n                        case VIR_CPU_FEATURE_REQUIRE:\n                        case VIR_CPU_FEATURE_OPTIONAL:\n                        case VIR_CPU_FEATURE_LAST:\n                            break;\n                    }\n                }\n            }\n\n            if (xenConfigSetInt(conf, \"nestedhvm\", hasHwVirt) < 0)\n                return -1;\n        }\n\n        /* XXX floppy disks */\n    } else {\n        if (def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) {\n            if (xenConfigSetString(conf, \"type\", \"pvh\") < 0)\n                return -1;\n        }\n\n        if (def->os.bootloader &&\n             xenConfigSetString(conf, \"bootloader\", def->os.bootloader) < 0)\n            return -1;\n\n         if (def->os.bootloaderArgs &&\n             xenConfigSetString(conf, \"bootargs\", def->os.bootloaderArgs) < 0)\n            return -1;\n\n         if (def->os.kernel &&\n             xenConfigSetString(conf, \"kernel\", def->os.kernel) < 0)\n            return -1;\n\n         if (def->os.initrd &&\n             xenConfigSetString(conf, \"ramdisk\", def->os.initrd) < 0)\n            return -1;\n\n         if (def->os.cmdline &&\n             xenConfigSetString(conf, \"cmdline\", def->os.cmdline) < 0)\n            return -1;\n     } /* !hvm */\n\n    return 0;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenConfigSetString",
          "args": [
            "conf",
            "\"cmdline\"",
            "def->os.cmdline"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "267-280",
          "snippet": "int\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigSetInt",
          "args": [
            "conf",
            "\"nestedhvm\"",
            "hasHwVirt"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "246-264",
          "snippet": "int\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->cpu->features[i].name",
            "\"svm\""
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->cpu->features[i].name",
            "\"vmx\""
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefHasOldStyleUEFI",
          "args": [
            "def"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefHasOldStyleUEFI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32082-32087",
          "snippet": "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def)\n{\n    return def->os.loader &&\n           def->os.loader->type == VIR_DOMAIN_LOADER_TYPE_PFLASH;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def)\n{\n    return def->os.loader &&\n           def->os.loader->type == VIR_DOMAIN_LOADER_TYPE_PFLASH;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenFormatXLOS(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        char boot[VIR_DOMAIN_BOOT_LAST+1];\n        if (xenConfigSetString(conf, \"builder\", \"hvm\") < 0)\n            return -1;\n\n        if (virDomainDefHasOldStyleUEFI(def) &&\n            xenConfigSetString(conf, \"bios\", \"ovmf\") < 0)\n            return -1;\n\n        if (def->os.slic_table &&\n            xenConfigSetString(conf, \"acpi_firmware\", def->os.slic_table) < 0)\n            return -1;\n\n#ifdef LIBXL_HAVE_BUILDINFO_KERNEL\n        if (def->os.kernel &&\n            xenConfigSetString(conf, \"kernel\", def->os.kernel) < 0)\n            return -1;\n\n        if (def->os.initrd &&\n            xenConfigSetString(conf, \"ramdisk\", def->os.initrd) < 0)\n            return -1;\n\n        if (def->os.cmdline &&\n            xenConfigSetString(conf, \"cmdline\", def->os.cmdline) < 0)\n            return -1;\n#endif\n\n        for (i = 0; i < def->os.nBootDevs; i++) {\n            switch (def->os.bootDevs[i]) {\n            case VIR_DOMAIN_BOOT_FLOPPY:\n                boot[i] = 'a';\n                break;\n            case VIR_DOMAIN_BOOT_CDROM:\n                boot[i] = 'd';\n                break;\n            case VIR_DOMAIN_BOOT_NET:\n                boot[i] = 'n';\n                break;\n            case VIR_DOMAIN_BOOT_DISK:\n            default:\n                boot[i] = 'c';\n                break;\n            }\n        }\n\n        if (!def->os.nBootDevs) {\n            boot[0] = 'c';\n            boot[1] = '\\0';\n        } else {\n            boot[def->os.nBootDevs] = '\\0';\n        }\n\n        if (xenConfigSetString(conf, \"boot\", boot) < 0)\n            return -1;\n\n        if (def->cpu &&\n            def->cpu->mode == VIR_CPU_MODE_HOST_PASSTHROUGH) {\n            bool hasHwVirt = true;\n\n            if (def->cpu->nfeatures) {\n                for (i = 0; i < def->cpu->nfeatures; i++) {\n\n                    switch (def->cpu->features[i].policy) {\n                        case VIR_CPU_FEATURE_DISABLE:\n                        case VIR_CPU_FEATURE_FORBID:\n                            if (STREQ(def->cpu->features[i].name, \"vmx\") ||\n                                STREQ(def->cpu->features[i].name, \"svm\"))\n                                hasHwVirt = false;\n                            break;\n\n                        case VIR_CPU_FEATURE_FORCE:\n                        case VIR_CPU_FEATURE_REQUIRE:\n                        case VIR_CPU_FEATURE_OPTIONAL:\n                        case VIR_CPU_FEATURE_LAST:\n                            break;\n                    }\n                }\n            }\n\n            if (xenConfigSetInt(conf, \"nestedhvm\", hasHwVirt) < 0)\n                return -1;\n        }\n\n        /* XXX floppy disks */\n    } else {\n        if (def->os.type == VIR_DOMAIN_OSTYPE_XENPVH) {\n            if (xenConfigSetString(conf, \"type\", \"pvh\") < 0)\n                return -1;\n        }\n\n        if (def->os.bootloader &&\n             xenConfigSetString(conf, \"bootloader\", def->os.bootloader) < 0)\n            return -1;\n\n         if (def->os.bootloaderArgs &&\n             xenConfigSetString(conf, \"bootargs\", def->os.bootloaderArgs) < 0)\n            return -1;\n\n         if (def->os.kernel &&\n             xenConfigSetString(conf, \"kernel\", def->os.kernel) < 0)\n            return -1;\n\n         if (def->os.initrd &&\n             xenConfigSetString(conf, \"ramdisk\", def->os.initrd) < 0)\n            return -1;\n\n         if (def->os.cmdline &&\n             xenConfigSetString(conf, \"cmdline\", def->os.cmdline) < 0)\n            return -1;\n     } /* !hvm */\n\n    return 0;\n}"
  },
  {
    "function_name": "xenParseXL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1158-1218",
    "snippet": "virDomainDefPtr\nxenParseXL(virConfPtr conf,\n           virCapsPtr caps,\n           virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDefPtr def = NULL;\n\n    if (!(def = virDomainDefNew()))\n        return NULL;\n\n    def->virtType = VIR_DOMAIN_VIRT_XEN;\n    def->id = -1;\n\n    if (xenParseConfigCommon(conf, def, caps, XEN_CONFIG_FORMAT_XL,\n                             xmlopt) < 0)\n        goto cleanup;\n\n    if (xenParseXLOS(conf, def, caps) < 0)\n        goto cleanup;\n\n#ifdef LIBXL_HAVE_VNUMA\n    if (xenParseXLVnuma(conf, def) < 0)\n        goto cleanup;\n#endif\n\n#ifdef LIBXL_HAVE_BUILDINFO_GRANT_LIMITS\n    if (xenParseXLGntLimits(conf, def) < 0)\n        goto cleanup;\n#endif\n\n    if (xenParseXLCPUID(conf, def) < 0)\n        goto cleanup;\n\n    if (xenParseXLDisk(conf, def) < 0)\n        goto cleanup;\n\n    if (xenParseXLSpice(conf, def) < 0)\n        goto cleanup;\n\n    if (xenParseXLInputDevs(conf, def) < 0)\n        goto cleanup;\n\n    if (xenParseXLUSB(conf, def) < 0)\n        goto cleanup;\n\n    if (xenParseXLUSBController(conf, def) < 0)\n        goto cleanup;\n\n    if (xenParseXLChannel(conf, def) < 0)\n        goto cleanup;\n\n    if (virDomainDefPostParse(def, VIR_DOMAIN_DEF_PARSE_ABI_UPDATE,\n                              xmlopt, NULL) < 0)\n        goto cleanup;\n\n    return def;\n\n cleanup:\n    virDomainDefFree(def);\n    return NULL;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefPostParse",
          "args": [
            "def",
            "VIR_DOMAIN_DEF_PARSE_ABI_UPDATE",
            "xmlopt",
            "NULL"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefPostParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "5869-5953",
          "snippet": "int\nvirDomainDefPostParse(virDomainDefPtr def,\n                      unsigned int parseFlags,\n                      virDomainXMLOptionPtr xmlopt,\n                      void *parseOpaque)\n{\n    int ret = -1;\n    bool localParseOpaque = false;\n    struct virDomainDefPostParseDeviceIteratorData data = {\n        .xmlopt = xmlopt,\n        .parseFlags = parseFlags,\n        .parseOpaque = parseOpaque,\n    };\n\n    def->postParseFailed = false;\n\n    /* call the basic post parse callback */\n    if (xmlopt->config.domainPostParseBasicCallback) {\n        ret = xmlopt->config.domainPostParseBasicCallback(def,\n                                                          xmlopt->config.priv);\n\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n    }\n\n    if (!data.parseOpaque &&\n        xmlopt->config.domainPostParseDataAlloc) {\n        ret = xmlopt->config.domainPostParseDataAlloc(def, parseFlags,\n                                                      xmlopt->config.priv,\n                                                      &data.parseOpaque);\n\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n        localParseOpaque = true;\n    }\n\n    /* this must be done before the hypervisor-specific callback,\n     * in case presence of a controller at a specific index is checked\n     */\n    virDomainAssignControllerIndexes(def);\n\n    /* call the domain config callback */\n    if (xmlopt->config.domainPostParseCallback) {\n        ret = xmlopt->config.domainPostParseCallback(def, parseFlags,\n                                                     xmlopt->config.priv,\n                                                     data.parseOpaque);\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n    }\n\n    /* iterate the devices */\n    ret = virDomainDeviceInfoIterateInternal(def,\n                                             virDomainDefPostParseDeviceIterator,\n                                             DOMAIN_DEVICE_ITERATE_ALL_CONSOLES |\n                                             DOMAIN_DEVICE_ITERATE_MISSING_INFO,\n                                             &data);\n\n    if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n        goto cleanup;\n\n    if ((ret = virDomainDefPostParseCommon(def, &data, xmlopt)) < 0)\n        goto cleanup;\n\n    if (xmlopt->config.assignAddressesCallback) {\n        ret = xmlopt->config.assignAddressesCallback(def, parseFlags,\n                                                     xmlopt->config.priv,\n                                                     data.parseOpaque);\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n    }\n\n    if ((ret = virDomainDefPostParseCheckFeatures(def, xmlopt)) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (localParseOpaque && xmlopt->config.domainPostParseDataFree)\n        xmlopt->config.domainPostParseDataFree(data.parseOpaque);\n\n    if (ret == 1)\n        ret = -1;\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum {\n    DOMAIN_DEVICE_ITERATE_ALL_CONSOLES = 1 << 0,\n    DOMAIN_DEVICE_ITERATE_MISSING_INFO = 1 << 1,\n} virDomainDeviceIterateFlags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nenum {\n    DOMAIN_DEVICE_ITERATE_ALL_CONSOLES = 1 << 0,\n    DOMAIN_DEVICE_ITERATE_MISSING_INFO = 1 << 1,\n} virDomainDeviceIterateFlags;\n\nint\nvirDomainDefPostParse(virDomainDefPtr def,\n                      unsigned int parseFlags,\n                      virDomainXMLOptionPtr xmlopt,\n                      void *parseOpaque)\n{\n    int ret = -1;\n    bool localParseOpaque = false;\n    struct virDomainDefPostParseDeviceIteratorData data = {\n        .xmlopt = xmlopt,\n        .parseFlags = parseFlags,\n        .parseOpaque = parseOpaque,\n    };\n\n    def->postParseFailed = false;\n\n    /* call the basic post parse callback */\n    if (xmlopt->config.domainPostParseBasicCallback) {\n        ret = xmlopt->config.domainPostParseBasicCallback(def,\n                                                          xmlopt->config.priv);\n\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n    }\n\n    if (!data.parseOpaque &&\n        xmlopt->config.domainPostParseDataAlloc) {\n        ret = xmlopt->config.domainPostParseDataAlloc(def, parseFlags,\n                                                      xmlopt->config.priv,\n                                                      &data.parseOpaque);\n\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n        localParseOpaque = true;\n    }\n\n    /* this must be done before the hypervisor-specific callback,\n     * in case presence of a controller at a specific index is checked\n     */\n    virDomainAssignControllerIndexes(def);\n\n    /* call the domain config callback */\n    if (xmlopt->config.domainPostParseCallback) {\n        ret = xmlopt->config.domainPostParseCallback(def, parseFlags,\n                                                     xmlopt->config.priv,\n                                                     data.parseOpaque);\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n    }\n\n    /* iterate the devices */\n    ret = virDomainDeviceInfoIterateInternal(def,\n                                             virDomainDefPostParseDeviceIterator,\n                                             DOMAIN_DEVICE_ITERATE_ALL_CONSOLES |\n                                             DOMAIN_DEVICE_ITERATE_MISSING_INFO,\n                                             &data);\n\n    if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n        goto cleanup;\n\n    if ((ret = virDomainDefPostParseCommon(def, &data, xmlopt)) < 0)\n        goto cleanup;\n\n    if (xmlopt->config.assignAddressesCallback) {\n        ret = xmlopt->config.assignAddressesCallback(def, parseFlags,\n                                                     xmlopt->config.priv,\n                                                     data.parseOpaque);\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n    }\n\n    if ((ret = virDomainDefPostParseCheckFeatures(def, xmlopt)) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (localParseOpaque && xmlopt->config.domainPostParseDataFree)\n        xmlopt->config.domainPostParseDataFree(data.parseOpaque);\n\n    if (ret == 1)\n        ret = -1;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseXLChannel",
          "args": [
            "conf",
            "def"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseXLChannel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "1071-1156",
          "snippet": "static int\nxenParseXLChannel(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"channel\");\n    virDomainChrDefPtr channel = NULL;\n    char *name = NULL;\n    char *path = NULL;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            char type[10];\n            char *key;\n\n            if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n                goto skipchannel;\n\n            key = list->str;\n            while (key) {\n                char *data;\n                char *nextkey = strchr(key, ',');\n\n                if (!(data = strchr(key, '=')))\n                    goto skipchannel;\n                data++;\n\n                if (STRPREFIX(key, \"connection=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(type, data, len, sizeof(type)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"connection %s too big\"), data);\n                        goto skipchannel;\n                    }\n                } else if (STRPREFIX(key, \"name=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    VIR_FREE(name);\n                    name = g_strndup(data, len);\n                } else if (STRPREFIX(key, \"path=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    VIR_FREE(path);\n                    path = g_strndup(data, len);\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n\n            if (!(channel = virDomainChrDefNew(NULL)))\n                goto cleanup;\n\n            if (STRPREFIX(type, \"socket\")) {\n                channel->source->type = VIR_DOMAIN_CHR_TYPE_UNIX;\n                channel->source->data.nix.listen = 1;\n                channel->source->data.nix.path = path;\n                path = NULL;\n            } else if (STRPREFIX(type, \"pty\")) {\n                channel->source->type = VIR_DOMAIN_CHR_TYPE_PTY;\n                VIR_FREE(path);\n            } else {\n                goto cleanup;\n            }\n\n            channel->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL;\n            channel->targetType = VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN;\n            channel->target.name = name;\n            name = NULL;\n\n            if (VIR_APPEND_ELEMENT(def->channels, def->nchannels, channel) < 0)\n                goto cleanup;\n\n        skipchannel:\n            list = list->next;\n        }\n    }\n\n    return 0;\n\n cleanup:\n    virDomainChrDefFree(channel);\n    VIR_FREE(path);\n    VIR_FREE(name);\n    return -1;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLChannel(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"channel\");\n    virDomainChrDefPtr channel = NULL;\n    char *name = NULL;\n    char *path = NULL;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            char type[10];\n            char *key;\n\n            if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n                goto skipchannel;\n\n            key = list->str;\n            while (key) {\n                char *data;\n                char *nextkey = strchr(key, ',');\n\n                if (!(data = strchr(key, '=')))\n                    goto skipchannel;\n                data++;\n\n                if (STRPREFIX(key, \"connection=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(type, data, len, sizeof(type)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"connection %s too big\"), data);\n                        goto skipchannel;\n                    }\n                } else if (STRPREFIX(key, \"name=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    VIR_FREE(name);\n                    name = g_strndup(data, len);\n                } else if (STRPREFIX(key, \"path=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    VIR_FREE(path);\n                    path = g_strndup(data, len);\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n\n            if (!(channel = virDomainChrDefNew(NULL)))\n                goto cleanup;\n\n            if (STRPREFIX(type, \"socket\")) {\n                channel->source->type = VIR_DOMAIN_CHR_TYPE_UNIX;\n                channel->source->data.nix.listen = 1;\n                channel->source->data.nix.path = path;\n                path = NULL;\n            } else if (STRPREFIX(type, \"pty\")) {\n                channel->source->type = VIR_DOMAIN_CHR_TYPE_PTY;\n                VIR_FREE(path);\n            } else {\n                goto cleanup;\n            }\n\n            channel->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL;\n            channel->targetType = VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN;\n            channel->target.name = name;\n            name = NULL;\n\n            if (VIR_APPEND_ELEMENT(def->channels, def->nchannels, channel) < 0)\n                goto cleanup;\n\n        skipchannel:\n            list = list->next;\n        }\n    }\n\n    return 0;\n\n cleanup:\n    virDomainChrDefFree(channel);\n    VIR_FREE(path);\n    VIR_FREE(name);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseXLUSBController",
          "args": [
            "conf",
            "def"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseXLUSBController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "888-990",
          "snippet": "static int\nxenParseXLUSBController(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"usbctrl\");\n    virDomainControllerDefPtr controller = NULL;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            char type[8];\n            char version[4];\n            char ports[4];\n            char *key;\n            int usbctrl_version = 2; /* by default USB 2.0 */\n            int usbctrl_ports = 8; /* by default 8 ports */\n            int usbctrl_type = -1;\n\n            type[0] = version[0] = ports[0] = '\\0';\n\n            if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n                goto skipusbctrl;\n            /* usbctrl=['type=pv,version=2,ports=8'] */\n            key = list->str;\n            while (key) {\n                char *data;\n                char *nextkey = strchr(key, ',');\n\n                if (!(data = strchr(key, '=')))\n                    goto skipusbctrl;\n                data++;\n\n                if (STRPREFIX(key, \"type=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(type, data, len, sizeof(type)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"type %s invalid\"),\n                                       data);\n                        goto skipusbctrl;\n                    }\n                } else if (STRPREFIX(key, \"version=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(version, data, len, sizeof(version)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"version %s invalid\"),\n                                       data);\n                        goto skipusbctrl;\n                    }\n                    if (virStrToLong_i(version, NULL, 16, &usbctrl_version) < 0)\n                        goto skipusbctrl;\n                } else if (STRPREFIX(key, \"ports=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(ports, data, len, sizeof(ports)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"version %s invalid\"),\n                                       data);\n                        goto skipusbctrl;\n                    }\n                    if (virStrToLong_i(ports, NULL, 16, &usbctrl_ports) < 0)\n                        goto skipusbctrl;\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n\n            if (type[0] == '\\0') {\n                if (usbctrl_version == 1)\n                    usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1;\n                else\n                    usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2;\n            } else {\n                if (STREQLEN(type, \"qusb\", 4)) {\n                    if (usbctrl_version == 1)\n                        usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1;\n                    else\n                        usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2;\n                } else {\n                    goto skipusbctrl;\n                }\n            }\n\n            if (!(controller = virDomainControllerDefNew(VIR_DOMAIN_CONTROLLER_TYPE_USB)))\n                return -1;\n\n            controller->type = VIR_DOMAIN_CONTROLLER_TYPE_USB;\n            controller->model = usbctrl_type;\n            controller->opts.usbopts.ports = usbctrl_ports;\n\n            if (VIR_APPEND_ELEMENT(def->controllers, def->ncontrollers, controller) < 0) {\n                virDomainControllerDefFree(controller);\n                return -1;\n            }\n\n        skipusbctrl:\n            list = list->next;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLUSBController(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"usbctrl\");\n    virDomainControllerDefPtr controller = NULL;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            char type[8];\n            char version[4];\n            char ports[4];\n            char *key;\n            int usbctrl_version = 2; /* by default USB 2.0 */\n            int usbctrl_ports = 8; /* by default 8 ports */\n            int usbctrl_type = -1;\n\n            type[0] = version[0] = ports[0] = '\\0';\n\n            if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n                goto skipusbctrl;\n            /* usbctrl=['type=pv,version=2,ports=8'] */\n            key = list->str;\n            while (key) {\n                char *data;\n                char *nextkey = strchr(key, ',');\n\n                if (!(data = strchr(key, '=')))\n                    goto skipusbctrl;\n                data++;\n\n                if (STRPREFIX(key, \"type=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(type, data, len, sizeof(type)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"type %s invalid\"),\n                                       data);\n                        goto skipusbctrl;\n                    }\n                } else if (STRPREFIX(key, \"version=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(version, data, len, sizeof(version)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"version %s invalid\"),\n                                       data);\n                        goto skipusbctrl;\n                    }\n                    if (virStrToLong_i(version, NULL, 16, &usbctrl_version) < 0)\n                        goto skipusbctrl;\n                } else if (STRPREFIX(key, \"ports=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(ports, data, len, sizeof(ports)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"version %s invalid\"),\n                                       data);\n                        goto skipusbctrl;\n                    }\n                    if (virStrToLong_i(ports, NULL, 16, &usbctrl_ports) < 0)\n                        goto skipusbctrl;\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n\n            if (type[0] == '\\0') {\n                if (usbctrl_version == 1)\n                    usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1;\n                else\n                    usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2;\n            } else {\n                if (STREQLEN(type, \"qusb\", 4)) {\n                    if (usbctrl_version == 1)\n                        usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1;\n                    else\n                        usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2;\n                } else {\n                    goto skipusbctrl;\n                }\n            }\n\n            if (!(controller = virDomainControllerDefNew(VIR_DOMAIN_CONTROLLER_TYPE_USB)))\n                return -1;\n\n            controller->type = VIR_DOMAIN_CONTROLLER_TYPE_USB;\n            controller->model = usbctrl_type;\n            controller->opts.usbopts.ports = usbctrl_ports;\n\n            if (VIR_APPEND_ELEMENT(def->controllers, def->ncontrollers, controller) < 0) {\n                virDomainControllerDefFree(controller);\n                return -1;\n            }\n\n        skipusbctrl:\n            list = list->next;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseXLUSB",
          "args": [
            "conf",
            "def"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseXLUSB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "992-1069",
          "snippet": "static int\nxenParseXLUSB(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"usbdev\");\n    virDomainHostdevDefPtr hostdev = NULL;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            char bus[3];\n            char device[3];\n            char *key;\n            int busNum;\n            int devNum;\n\n            bus[0] = device[0] = '\\0';\n\n            if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n                goto skipusb;\n            /* usbdev=['hostbus=1,hostaddr=3'] */\n            key = list->str;\n            while (key) {\n                char *data;\n                char *nextkey = strchr(key, ',');\n\n                if (!(data = strchr(key, '=')))\n                    goto skipusb;\n                data++;\n\n                if (STRPREFIX(key, \"hostbus=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(bus, data, len, sizeof(bus)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"bus %s too big for destination\"),\n                                       data);\n                        goto skipusb;\n                    }\n                } else if (STRPREFIX(key, \"hostaddr=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(device, data, len, sizeof(device)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"device %s too big for destination\"),\n                                       data);\n                        goto skipusb;\n                    }\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n\n            if (virStrToLong_i(bus, NULL, 16, &busNum) < 0)\n                goto skipusb;\n            if (virStrToLong_i(device, NULL, 16, &devNum) < 0)\n                goto skipusb;\n            if (!(hostdev = virDomainHostdevDefNew()))\n               return -1;\n\n            hostdev->managed = false;\n            hostdev->source.subsys.type = VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB;\n            hostdev->source.subsys.u.usb.bus = busNum;\n            hostdev->source.subsys.u.usb.device = devNum;\n\n            if (VIR_APPEND_ELEMENT(def->hostdevs, def->nhostdevs, hostdev) < 0) {\n                virDomainHostdevDefFree(hostdev);\n                return -1;\n            }\n\n        skipusb:\n            list = list->next;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLUSB(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"usbdev\");\n    virDomainHostdevDefPtr hostdev = NULL;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            char bus[3];\n            char device[3];\n            char *key;\n            int busNum;\n            int devNum;\n\n            bus[0] = device[0] = '\\0';\n\n            if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n                goto skipusb;\n            /* usbdev=['hostbus=1,hostaddr=3'] */\n            key = list->str;\n            while (key) {\n                char *data;\n                char *nextkey = strchr(key, ',');\n\n                if (!(data = strchr(key, '=')))\n                    goto skipusb;\n                data++;\n\n                if (STRPREFIX(key, \"hostbus=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(bus, data, len, sizeof(bus)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"bus %s too big for destination\"),\n                                       data);\n                        goto skipusb;\n                    }\n                } else if (STRPREFIX(key, \"hostaddr=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(device, data, len, sizeof(device)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"device %s too big for destination\"),\n                                       data);\n                        goto skipusb;\n                    }\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n\n            if (virStrToLong_i(bus, NULL, 16, &busNum) < 0)\n                goto skipusb;\n            if (virStrToLong_i(device, NULL, 16, &devNum) < 0)\n                goto skipusb;\n            if (!(hostdev = virDomainHostdevDefNew()))\n               return -1;\n\n            hostdev->managed = false;\n            hostdev->source.subsys.type = VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB;\n            hostdev->source.subsys.u.usb.bus = busNum;\n            hostdev->source.subsys.u.usb.device = devNum;\n\n            if (VIR_APPEND_ELEMENT(def->hostdevs, def->nhostdevs, hostdev) < 0) {\n                virDomainHostdevDefFree(hostdev);\n                return -1;\n            }\n\n        skipusb:\n            list = list->next;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseXLInputDevs",
          "args": [
            "conf",
            "def"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseXLInputDevs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "834-886",
          "snippet": "static int\nxenParseXLInputDevs(virConfPtr conf, virDomainDefPtr def)\n{\n    const char *str;\n    virConfValuePtr val;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        val = virConfGetValue(conf, \"usbdevice\");\n        /* usbdevice can be defined as either a single string or a list */\n        if (val && val->type == VIR_CONF_LIST) {\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n            val = val->list;\n#else\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"multiple USB devices not supported\"));\n            return -1;\n#endif\n        }\n        /* otherwise val->next is NULL, so can be handled by the same code */\n        while (val) {\n            if (val->type != VIR_CONF_STRING) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"config value %s was malformed\"),\n                               \"usbdevice\");\n                return -1;\n            }\n            str = val->str;\n\n            if (str &&\n                    (STREQ(str, \"tablet\") ||\n                     STREQ(str, \"mouse\") ||\n                     STREQ(str, \"keyboard\"))) {\n                virDomainInputDefPtr input;\n                if (VIR_ALLOC(input) < 0)\n                    return -1;\n\n                input->bus = VIR_DOMAIN_INPUT_BUS_USB;\n                if (STREQ(str, \"mouse\"))\n                    input->type = VIR_DOMAIN_INPUT_TYPE_MOUSE;\n                else if (STREQ(str, \"tablet\"))\n                    input->type = VIR_DOMAIN_INPUT_TYPE_TABLET;\n                else if (STREQ(str, \"keyboard\"))\n                    input->type = VIR_DOMAIN_INPUT_TYPE_KBD;\n                if (VIR_APPEND_ELEMENT(def->inputs, def->ninputs, input) < 0) {\n                    virDomainInputDefFree(input);\n                    return -1;\n                }\n            }\n            val = val->next;\n        }\n    }\n    return 0;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLInputDevs(virConfPtr conf, virDomainDefPtr def)\n{\n    const char *str;\n    virConfValuePtr val;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        val = virConfGetValue(conf, \"usbdevice\");\n        /* usbdevice can be defined as either a single string or a list */\n        if (val && val->type == VIR_CONF_LIST) {\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n            val = val->list;\n#else\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"multiple USB devices not supported\"));\n            return -1;\n#endif\n        }\n        /* otherwise val->next is NULL, so can be handled by the same code */\n        while (val) {\n            if (val->type != VIR_CONF_STRING) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"config value %s was malformed\"),\n                               \"usbdevice\");\n                return -1;\n            }\n            str = val->str;\n\n            if (str &&\n                    (STREQ(str, \"tablet\") ||\n                     STREQ(str, \"mouse\") ||\n                     STREQ(str, \"keyboard\"))) {\n                virDomainInputDefPtr input;\n                if (VIR_ALLOC(input) < 0)\n                    return -1;\n\n                input->bus = VIR_DOMAIN_INPUT_BUS_USB;\n                if (STREQ(str, \"mouse\"))\n                    input->type = VIR_DOMAIN_INPUT_TYPE_MOUSE;\n                else if (STREQ(str, \"tablet\"))\n                    input->type = VIR_DOMAIN_INPUT_TYPE_TABLET;\n                else if (STREQ(str, \"keyboard\"))\n                    input->type = VIR_DOMAIN_INPUT_TYPE_KBD;\n                if (VIR_APPEND_ELEMENT(def->inputs, def->ninputs, input) < 0) {\n                    virDomainInputDefFree(input);\n                    return -1;\n                }\n            }\n            val = val->next;\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseXLSpice",
          "args": [
            "conf",
            "def"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseXLSpice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "334-409",
          "snippet": "static int\nxenParseXLSpice(virConfPtr conf, virDomainDefPtr def)\n{\n    virDomainGraphicsDefPtr graphics = NULL;\n    unsigned long port;\n    char *listenAddr = NULL;\n    int val;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (xenConfigGetBool(conf, \"spice\", &val, 0) < 0)\n            return -1;\n\n        if (val) {\n            if (VIR_ALLOC(graphics) < 0)\n                return -1;\n\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SPICE;\n            if (xenConfigCopyStringOpt(conf, \"spicehost\", &listenAddr) < 0)\n                goto cleanup;\n            if (virDomainGraphicsListenAppendAddress(graphics, listenAddr) < 0)\n                goto cleanup;\n            VIR_FREE(listenAddr);\n\n            if (xenConfigGetULong(conf, \"spicetls_port\", &port, 0) < 0)\n                goto cleanup;\n            graphics->data.spice.tlsPort = (int)port;\n\n            if (xenConfigGetULong(conf, \"spiceport\", &port, 0) < 0)\n                goto cleanup;\n\n            graphics->data.spice.port = (int)port;\n\n            if (!graphics->data.spice.tlsPort &&\n                !graphics->data.spice.port)\n            graphics->data.spice.autoport = 1;\n\n            if (xenConfigGetBool(conf, \"spicedisable_ticketing\", &val, 0) < 0)\n                goto cleanup;\n            if (!val) {\n                if (xenConfigCopyString(conf, \"spicepasswd\",\n                                        &graphics->data.spice.auth.passwd) < 0)\n                    goto cleanup;\n            }\n\n            if (xenConfigGetBool(conf, \"spiceagent_mouse\",\n                                 &val, 0) < 0)\n                goto cleanup;\n            if (val) {\n                graphics->data.spice.mousemode =\n                    VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_CLIENT;\n            } else {\n                graphics->data.spice.mousemode =\n                    VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_SERVER;\n            }\n\n            if (xenConfigGetBool(conf, \"spice_clipboard_sharing\", &val, 0) < 0)\n                goto cleanup;\n            if (val)\n                graphics->data.spice.copypaste = VIR_TRISTATE_BOOL_YES;\n            else\n                graphics->data.spice.copypaste = VIR_TRISTATE_BOOL_NO;\n\n            if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                goto cleanup;\n            def->graphics[0] = graphics;\n            def->ngraphics = 1;\n        }\n    }\n\n    return 0;\n\n cleanup:\n    VIR_FREE(listenAddr);\n    virDomainGraphicsDefFree(graphics);\n    return -1;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLSpice(virConfPtr conf, virDomainDefPtr def)\n{\n    virDomainGraphicsDefPtr graphics = NULL;\n    unsigned long port;\n    char *listenAddr = NULL;\n    int val;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (xenConfigGetBool(conf, \"spice\", &val, 0) < 0)\n            return -1;\n\n        if (val) {\n            if (VIR_ALLOC(graphics) < 0)\n                return -1;\n\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SPICE;\n            if (xenConfigCopyStringOpt(conf, \"spicehost\", &listenAddr) < 0)\n                goto cleanup;\n            if (virDomainGraphicsListenAppendAddress(graphics, listenAddr) < 0)\n                goto cleanup;\n            VIR_FREE(listenAddr);\n\n            if (xenConfigGetULong(conf, \"spicetls_port\", &port, 0) < 0)\n                goto cleanup;\n            graphics->data.spice.tlsPort = (int)port;\n\n            if (xenConfigGetULong(conf, \"spiceport\", &port, 0) < 0)\n                goto cleanup;\n\n            graphics->data.spice.port = (int)port;\n\n            if (!graphics->data.spice.tlsPort &&\n                !graphics->data.spice.port)\n            graphics->data.spice.autoport = 1;\n\n            if (xenConfigGetBool(conf, \"spicedisable_ticketing\", &val, 0) < 0)\n                goto cleanup;\n            if (!val) {\n                if (xenConfigCopyString(conf, \"spicepasswd\",\n                                        &graphics->data.spice.auth.passwd) < 0)\n                    goto cleanup;\n            }\n\n            if (xenConfigGetBool(conf, \"spiceagent_mouse\",\n                                 &val, 0) < 0)\n                goto cleanup;\n            if (val) {\n                graphics->data.spice.mousemode =\n                    VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_CLIENT;\n            } else {\n                graphics->data.spice.mousemode =\n                    VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_SERVER;\n            }\n\n            if (xenConfigGetBool(conf, \"spice_clipboard_sharing\", &val, 0) < 0)\n                goto cleanup;\n            if (val)\n                graphics->data.spice.copypaste = VIR_TRISTATE_BOOL_YES;\n            else\n                graphics->data.spice.copypaste = VIR_TRISTATE_BOOL_NO;\n\n            if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                goto cleanup;\n            def->graphics[0] = graphics;\n            def->ngraphics = 1;\n        }\n    }\n\n    return 0;\n\n cleanup:\n    VIR_FREE(listenAddr);\n    virDomainGraphicsDefFree(graphics);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseXLDisk",
          "args": [
            "conf",
            "def"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseXLDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "692-832",
          "snippet": "static int\nxenParseXLDisk(virConfPtr conf, virDomainDefPtr def)\n{\n    int ret = -1;\n    virConfValuePtr list = virConfGetValue(conf, \"disk\");\n    XLU_Config *xluconf;\n    libxl_device_disk *libxldisk;\n    virDomainDiskDefPtr disk = NULL;\n\n    if (VIR_ALLOC(libxldisk) < 0)\n        return -1;\n\n    if (!(xluconf = xlu_cfg_init(stderr, \"command line\")))\n        goto cleanup;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            const char *disk_spec = list->str;\n\n            if (list->type != VIR_CONF_STRING || list->str == NULL)\n                goto skipdisk;\n\n            libxl_device_disk_init(libxldisk);\n\n            if (xlu_disk_parse(xluconf, 1, &disk_spec, libxldisk))\n                goto fail;\n\n            if (!(disk = virDomainDiskDefNew(NULL)))\n                goto fail;\n\n            if (xenParseXLDiskSrc(disk, libxldisk->pdev_path) < 0)\n                goto fail;\n\n            disk->dst = g_strdup(libxldisk->vdev);\n\n            disk->src->readonly = !libxldisk->readwrite;\n            disk->removable = libxldisk->removable;\n\n            if (libxldisk->is_cdrom) {\n                if (virDomainDiskSetDriver(disk, \"qemu\") < 0)\n                    goto fail;\n\n                virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n                disk->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n                if (!disk->src->path || STREQ(disk->src->path, \"\"))\n                    disk->src->format = VIR_STORAGE_FILE_NONE;\n                else\n                    disk->src->format = VIR_STORAGE_FILE_RAW;\n            } else {\n                switch (libxldisk->format) {\n                case LIBXL_DISK_FORMAT_QCOW:\n                    disk->src->format = VIR_STORAGE_FILE_QCOW;\n                    break;\n\n                case LIBXL_DISK_FORMAT_QCOW2:\n                    disk->src->format = VIR_STORAGE_FILE_QCOW2;\n                    break;\n\n                case LIBXL_DISK_FORMAT_VHD:\n                    disk->src->format = VIR_STORAGE_FILE_VHD;\n                    break;\n\n                case LIBXL_DISK_FORMAT_RAW:\n                case LIBXL_DISK_FORMAT_UNKNOWN:\n                    disk->src->format = VIR_STORAGE_FILE_RAW;\n                    break;\n\n                case LIBXL_DISK_FORMAT_EMPTY:\n                    break;\n\n#ifdef LIBXL_HAVE_QED\n                case LIBXL_DISK_FORMAT_QED:\n                    disk->src->format = VIR_STORAGE_FILE_QED;\n                    break;\n#endif\n\n                default:\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"disk image format not supported: %s\"),\n                                   libxl_disk_format_to_string(libxldisk->format));\n                    goto fail;\n                }\n\n                switch (libxldisk->backend) {\n                case LIBXL_DISK_BACKEND_QDISK:\n                case LIBXL_DISK_BACKEND_UNKNOWN:\n                    if (virDomainDiskSetDriver(disk, \"qemu\") < 0)\n                        goto fail;\n                    if (virDomainDiskGetType(disk) == VIR_STORAGE_TYPE_NONE)\n                        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n                    break;\n\n                case LIBXL_DISK_BACKEND_TAP:\n                    if (virDomainDiskSetDriver(disk, \"tap\") < 0)\n                        goto fail;\n                    virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n                    break;\n\n                case LIBXL_DISK_BACKEND_PHY:\n                    if (virDomainDiskSetDriver(disk, \"phy\") < 0)\n                        goto fail;\n                    virDomainDiskSetType(disk, VIR_STORAGE_TYPE_BLOCK);\n                    break;\n                default:\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"disk backend not supported: %s\"),\n                                   libxl_disk_backend_to_string(libxldisk->backend));\n                    goto fail;\n                }\n            }\n\n            if (STRPREFIX(libxldisk->vdev, \"xvd\") ||\n                def->os.type != VIR_DOMAIN_OSTYPE_HVM)\n                disk->bus = VIR_DOMAIN_DISK_BUS_XEN;\n            else if (STRPREFIX(libxldisk->vdev, \"sd\"))\n                disk->bus = VIR_DOMAIN_DISK_BUS_SCSI;\n            else\n                disk->bus = VIR_DOMAIN_DISK_BUS_IDE;\n\n            if (VIR_APPEND_ELEMENT(def->disks, def->ndisks, disk) < 0)\n                goto fail;\n\n            libxl_device_disk_dispose(libxldisk);\n\n        skipdisk:\n            list = list->next;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    virDomainDiskDefFree(disk);\n    xlu_cfg_destroy(xluconf);\n    VIR_FREE(libxldisk);\n    return ret;\n\n fail:\n    libxl_device_disk_dispose(libxldisk);\n    goto cleanup;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLDisk(virConfPtr conf, virDomainDefPtr def)\n{\n    int ret = -1;\n    virConfValuePtr list = virConfGetValue(conf, \"disk\");\n    XLU_Config *xluconf;\n    libxl_device_disk *libxldisk;\n    virDomainDiskDefPtr disk = NULL;\n\n    if (VIR_ALLOC(libxldisk) < 0)\n        return -1;\n\n    if (!(xluconf = xlu_cfg_init(stderr, \"command line\")))\n        goto cleanup;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            const char *disk_spec = list->str;\n\n            if (list->type != VIR_CONF_STRING || list->str == NULL)\n                goto skipdisk;\n\n            libxl_device_disk_init(libxldisk);\n\n            if (xlu_disk_parse(xluconf, 1, &disk_spec, libxldisk))\n                goto fail;\n\n            if (!(disk = virDomainDiskDefNew(NULL)))\n                goto fail;\n\n            if (xenParseXLDiskSrc(disk, libxldisk->pdev_path) < 0)\n                goto fail;\n\n            disk->dst = g_strdup(libxldisk->vdev);\n\n            disk->src->readonly = !libxldisk->readwrite;\n            disk->removable = libxldisk->removable;\n\n            if (libxldisk->is_cdrom) {\n                if (virDomainDiskSetDriver(disk, \"qemu\") < 0)\n                    goto fail;\n\n                virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n                disk->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n                if (!disk->src->path || STREQ(disk->src->path, \"\"))\n                    disk->src->format = VIR_STORAGE_FILE_NONE;\n                else\n                    disk->src->format = VIR_STORAGE_FILE_RAW;\n            } else {\n                switch (libxldisk->format) {\n                case LIBXL_DISK_FORMAT_QCOW:\n                    disk->src->format = VIR_STORAGE_FILE_QCOW;\n                    break;\n\n                case LIBXL_DISK_FORMAT_QCOW2:\n                    disk->src->format = VIR_STORAGE_FILE_QCOW2;\n                    break;\n\n                case LIBXL_DISK_FORMAT_VHD:\n                    disk->src->format = VIR_STORAGE_FILE_VHD;\n                    break;\n\n                case LIBXL_DISK_FORMAT_RAW:\n                case LIBXL_DISK_FORMAT_UNKNOWN:\n                    disk->src->format = VIR_STORAGE_FILE_RAW;\n                    break;\n\n                case LIBXL_DISK_FORMAT_EMPTY:\n                    break;\n\n#ifdef LIBXL_HAVE_QED\n                case LIBXL_DISK_FORMAT_QED:\n                    disk->src->format = VIR_STORAGE_FILE_QED;\n                    break;\n#endif\n\n                default:\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"disk image format not supported: %s\"),\n                                   libxl_disk_format_to_string(libxldisk->format));\n                    goto fail;\n                }\n\n                switch (libxldisk->backend) {\n                case LIBXL_DISK_BACKEND_QDISK:\n                case LIBXL_DISK_BACKEND_UNKNOWN:\n                    if (virDomainDiskSetDriver(disk, \"qemu\") < 0)\n                        goto fail;\n                    if (virDomainDiskGetType(disk) == VIR_STORAGE_TYPE_NONE)\n                        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n                    break;\n\n                case LIBXL_DISK_BACKEND_TAP:\n                    if (virDomainDiskSetDriver(disk, \"tap\") < 0)\n                        goto fail;\n                    virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n                    break;\n\n                case LIBXL_DISK_BACKEND_PHY:\n                    if (virDomainDiskSetDriver(disk, \"phy\") < 0)\n                        goto fail;\n                    virDomainDiskSetType(disk, VIR_STORAGE_TYPE_BLOCK);\n                    break;\n                default:\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"disk backend not supported: %s\"),\n                                   libxl_disk_backend_to_string(libxldisk->backend));\n                    goto fail;\n                }\n            }\n\n            if (STRPREFIX(libxldisk->vdev, \"xvd\") ||\n                def->os.type != VIR_DOMAIN_OSTYPE_HVM)\n                disk->bus = VIR_DOMAIN_DISK_BUS_XEN;\n            else if (STRPREFIX(libxldisk->vdev, \"sd\"))\n                disk->bus = VIR_DOMAIN_DISK_BUS_SCSI;\n            else\n                disk->bus = VIR_DOMAIN_DISK_BUS_IDE;\n\n            if (VIR_APPEND_ELEMENT(def->disks, def->ndisks, disk) < 0)\n                goto fail;\n\n            libxl_device_disk_dispose(libxldisk);\n\n        skipdisk:\n            list = list->next;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    virDomainDiskDefFree(disk);\n    xlu_cfg_destroy(xluconf);\n    VIR_FREE(libxldisk);\n    return ret;\n\n fail:\n    libxl_device_disk_dispose(libxldisk);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseXLCPUID",
          "args": [
            "conf",
            "def"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseXLCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "249-331",
          "snippet": "static int\nxenParseXLCPUID(virConfPtr conf, virDomainDefPtr def)\n{\n    g_autofree char *cpuid_str = NULL;\n    char **cpuid_pairs = NULL;\n    char **name_and_value = NULL;\n    size_t i;\n    int ret = -1;\n    int policy;\n\n    if (xenConfigGetString(conf, \"cpuid\", &cpuid_str, NULL) < 0)\n        return -1;\n\n    if (!cpuid_str)\n        return 0;\n\n    if (!def->cpu) {\n        def->cpu = virCPUDefNew();\n        def->cpu->mode = VIR_CPU_MODE_HOST_PASSTHROUGH;\n        def->cpu->type = VIR_CPU_TYPE_GUEST;\n        def->cpu->nfeatures = 0;\n        def->cpu->nfeatures_max = 0;\n    }\n\n    cpuid_pairs = virStringSplit(cpuid_str, \",\", 0);\n    if (!cpuid_pairs)\n        goto cleanup;\n\n    if (!cpuid_pairs[0]) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (STRNEQ(cpuid_pairs[0], \"host\")) {\n        virReportError(VIR_ERR_CONF_SYNTAX,\n                       _(\"cpuid starting with %s is not supported, only libxl format is\"),\n                       cpuid_pairs[0]);\n        goto cleanup;\n    }\n\n    for (i = 1; cpuid_pairs[i]; i++) {\n        name_and_value = virStringSplit(cpuid_pairs[i], \"=\", 2);\n        if (!name_and_value)\n            goto cleanup;\n        if (!name_and_value[0] || !name_and_value[1]) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Invalid libxl cpuid key=value element: %s\"),\n                           cpuid_pairs[i]);\n            goto cleanup;\n        }\n        if (STREQ(name_and_value[1], \"1\")) {\n            policy = VIR_CPU_FEATURE_FORCE;\n        } else if (STREQ(name_and_value[1], \"0\")) {\n            policy = VIR_CPU_FEATURE_DISABLE;\n        } else if (STREQ(name_and_value[1], \"x\")) {\n            policy = VIR_CPU_FEATURE_OPTIONAL;\n        } else if (STREQ(name_and_value[1], \"k\")) {\n            policy = VIR_CPU_FEATURE_OPTIONAL;\n        } else if (STREQ(name_and_value[1], \"s\")) {\n            policy = VIR_CPU_FEATURE_OPTIONAL;\n        } else {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Invalid libxl cpuid value: %s\"),\n                           cpuid_pairs[i]);\n            goto cleanup;\n        }\n\n        if (virCPUDefAddFeature(def->cpu,\n                                xenTranslateCPUFeature(name_and_value[0], true),\n                                policy) < 0)\n            goto cleanup;\n\n        virStringListFree(name_and_value);\n        name_and_value = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virStringListFree(name_and_value);\n    virStringListFree(cpuid_pairs);\n    return ret;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLCPUID(virConfPtr conf, virDomainDefPtr def)\n{\n    g_autofree char *cpuid_str = NULL;\n    char **cpuid_pairs = NULL;\n    char **name_and_value = NULL;\n    size_t i;\n    int ret = -1;\n    int policy;\n\n    if (xenConfigGetString(conf, \"cpuid\", &cpuid_str, NULL) < 0)\n        return -1;\n\n    if (!cpuid_str)\n        return 0;\n\n    if (!def->cpu) {\n        def->cpu = virCPUDefNew();\n        def->cpu->mode = VIR_CPU_MODE_HOST_PASSTHROUGH;\n        def->cpu->type = VIR_CPU_TYPE_GUEST;\n        def->cpu->nfeatures = 0;\n        def->cpu->nfeatures_max = 0;\n    }\n\n    cpuid_pairs = virStringSplit(cpuid_str, \",\", 0);\n    if (!cpuid_pairs)\n        goto cleanup;\n\n    if (!cpuid_pairs[0]) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (STRNEQ(cpuid_pairs[0], \"host\")) {\n        virReportError(VIR_ERR_CONF_SYNTAX,\n                       _(\"cpuid starting with %s is not supported, only libxl format is\"),\n                       cpuid_pairs[0]);\n        goto cleanup;\n    }\n\n    for (i = 1; cpuid_pairs[i]; i++) {\n        name_and_value = virStringSplit(cpuid_pairs[i], \"=\", 2);\n        if (!name_and_value)\n            goto cleanup;\n        if (!name_and_value[0] || !name_and_value[1]) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Invalid libxl cpuid key=value element: %s\"),\n                           cpuid_pairs[i]);\n            goto cleanup;\n        }\n        if (STREQ(name_and_value[1], \"1\")) {\n            policy = VIR_CPU_FEATURE_FORCE;\n        } else if (STREQ(name_and_value[1], \"0\")) {\n            policy = VIR_CPU_FEATURE_DISABLE;\n        } else if (STREQ(name_and_value[1], \"x\")) {\n            policy = VIR_CPU_FEATURE_OPTIONAL;\n        } else if (STREQ(name_and_value[1], \"k\")) {\n            policy = VIR_CPU_FEATURE_OPTIONAL;\n        } else if (STREQ(name_and_value[1], \"s\")) {\n            policy = VIR_CPU_FEATURE_OPTIONAL;\n        } else {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Invalid libxl cpuid value: %s\"),\n                           cpuid_pairs[i]);\n            goto cleanup;\n        }\n\n        if (virCPUDefAddFeature(def->cpu,\n                                xenTranslateCPUFeature(name_and_value[0], true),\n                                policy) < 0)\n            goto cleanup;\n\n        virStringListFree(name_and_value);\n        name_and_value = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virStringListFree(name_and_value);\n    virStringListFree(cpuid_pairs);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseXLGntLimits",
          "args": [
            "conf",
            "def"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseXLGntLimits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "601-625",
          "snippet": "static int\nxenParseXLGntLimits(virConfPtr conf, virDomainDefPtr def)\n{\n    unsigned long max_gntframes;\n    int ctlr_idx;\n    virDomainControllerDefPtr xenbus_ctlr;\n\n    if (xenConfigGetULong(conf, \"max_grant_frames\", &max_gntframes, 0) < 0)\n        return -1;\n\n    if (max_gntframes <= 0)\n        return 0;\n\n    ctlr_idx = virDomainControllerFindByType(def, VIR_DOMAIN_CONTROLLER_TYPE_XENBUS);\n    if (ctlr_idx == -1)\n        xenbus_ctlr = virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_XENBUS, -1, -1);\n    else\n        xenbus_ctlr = def->controllers[ctlr_idx];\n\n    if (xenbus_ctlr == NULL)\n        return -1;\n\n    xenbus_ctlr->opts.xenbusopts.maxGrantFrames = max_gntframes;\n    return 0;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLGntLimits(virConfPtr conf, virDomainDefPtr def)\n{\n    unsigned long max_gntframes;\n    int ctlr_idx;\n    virDomainControllerDefPtr xenbus_ctlr;\n\n    if (xenConfigGetULong(conf, \"max_grant_frames\", &max_gntframes, 0) < 0)\n        return -1;\n\n    if (max_gntframes <= 0)\n        return 0;\n\n    ctlr_idx = virDomainControllerFindByType(def, VIR_DOMAIN_CONTROLLER_TYPE_XENBUS);\n    if (ctlr_idx == -1)\n        xenbus_ctlr = virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_XENBUS, -1, -1);\n    else\n        xenbus_ctlr = def->controllers[ctlr_idx];\n\n    if (xenbus_ctlr == NULL)\n        return -1;\n\n    xenbus_ctlr->opts.xenbusopts.maxGrantFrames = max_gntframes;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseXLVnuma",
          "args": [
            "conf",
            "def"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseXLVnuma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "412-597",
          "snippet": "static int\nxenParseXLVnuma(virConfPtr conf,\n                virDomainDefPtr def)\n{\n    int ret = -1;\n    char *tmp = NULL;\n    char **token = NULL;\n    size_t vcpus = 0;\n    size_t nr_nodes = 0;\n    size_t vnodeCnt = 0;\n    virCPUDefPtr cpu = NULL;\n    virConfValuePtr list;\n    virConfValuePtr vnode;\n    virDomainNumaPtr numa;\n\n    numa = def->numa;\n    if (numa == NULL)\n        return -1;\n\n    list = virConfGetValue(conf, \"vnuma\");\n    if (!list || list->type != VIR_CONF_LIST)\n        return 0;\n\n    vnode = list->list;\n    while (vnode && vnode->type == VIR_CONF_LIST) {\n        vnode = vnode->next;\n        nr_nodes++;\n    }\n\n    if (!virDomainNumaSetNodeCount(numa, nr_nodes))\n        goto cleanup;\n\n    cpu = virCPUDefNew();\n\n    list = list->list;\n    while (list) {\n        int pnode = -1;\n        virBitmapPtr cpumask = NULL;\n        unsigned long long kbsize = 0;\n\n        /* Is there a sublist (vnode)? */\n        if (list && list->type == VIR_CONF_LIST) {\n            vnode = list->list;\n\n            while (vnode && vnode->type == VIR_CONF_STRING) {\n                const char *data;\n                const char *str = vnode->str;\n\n                if (!str ||\n                   !(data = strrchr(str, '='))) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"vnuma vnode invalid format '%s'\"),\n                                   str);\n                    goto cleanup;\n                }\n                data++;\n\n                if (*data) {\n                    char vtoken[64];\n\n                    if (STRPREFIX(str, \"pnode\")) {\n                        unsigned int cellid;\n\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu pnode '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        if ((virStrToLong_ui(vtoken, NULL, 10, &cellid) < 0) ||\n                            (cellid >= nr_nodes)) {\n                            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                           _(\"vnuma vnode %zu contains invalid pnode value '%s'\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n                        pnode = cellid;\n                    } else if (STRPREFIX(str, \"size\")) {\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu size '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        if (virStrToLong_ull(vtoken, NULL, 10, &kbsize) < 0)\n                            goto cleanup;\n\n                        virDomainNumaSetNodeMemorySize(numa, vnodeCnt, (kbsize * 1024));\n\n                    } else if (STRPREFIX(str, \"vcpus\")) {\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu vcpus '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        if ((virBitmapParse(vtoken, &cpumask, VIR_DOMAIN_CPUMASK_LEN) < 0) ||\n                            (virDomainNumaSetNodeCpumask(numa, vnodeCnt, cpumask) == NULL))\n                            goto cleanup;\n\n                        vcpus += virBitmapCountBits(cpumask);\n\n                    } else if (STRPREFIX(str, \"vdistances\")) {\n                        size_t i, ndistances;\n                        unsigned int value;\n\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu vdistances '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        VIR_FREE(tmp);\n                        tmp = g_strdup(vtoken);\n\n                        virStringListFree(token);\n                        if (!(token = virStringSplitCount(tmp, \",\", 0, &ndistances)))\n                            goto cleanup;\n\n                        if (ndistances != nr_nodes) {\n                            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                       _(\"vnuma pnode %d configured '%s' (count %zu) doesn't fit the number of specified vnodes %zu\"),\n                                       pnode, str, ndistances, nr_nodes);\n                            goto cleanup;\n                        }\n\n                        if (virDomainNumaSetNodeDistanceCount(numa, vnodeCnt, ndistances) != ndistances)\n                            goto cleanup;\n\n                        for (i = 0; i < ndistances; i++) {\n                            if ((virStrToLong_ui(token[i], NULL, 10, &value) < 0) ||\n                                (virDomainNumaSetNodeDistance(numa, vnodeCnt, i, value) != value))\n                                goto cleanup;\n                        }\n\n                    } else {\n                        virReportError(VIR_ERR_CONF_SYNTAX,\n                                       _(\"Invalid vnuma configuration for vnode %zu\"),\n                                       vnodeCnt);\n                        goto cleanup;\n                    }\n                }\n                vnode = vnode->next;\n            }\n        }\n\n        if ((pnode < 0) ||\n            (cpumask == NULL) ||\n            (kbsize == 0)) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Incomplete vnuma configuration for vnode %zu\"),\n                           vnodeCnt);\n            goto cleanup;\n        }\n\n        list = list->next;\n        vnodeCnt++;\n    }\n\n    if (def->maxvcpus == 0)\n        def->maxvcpus = vcpus;\n\n    if (def->maxvcpus < vcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"vnuma configuration contains %zu vcpus, which is greater than %zu maxvcpus\"),\n                       vcpus, def->maxvcpus);\n        goto cleanup;\n    }\n\n    cpu->type = VIR_CPU_TYPE_GUEST;\n    def->cpu = cpu;\n\n    ret = 0;\n\n cleanup:\n    if (ret)\n        VIR_FREE(cpu);\n    virStringListFree(token);\n    VIR_FREE(tmp);\n\n    return ret;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLVnuma(virConfPtr conf,\n                virDomainDefPtr def)\n{\n    int ret = -1;\n    char *tmp = NULL;\n    char **token = NULL;\n    size_t vcpus = 0;\n    size_t nr_nodes = 0;\n    size_t vnodeCnt = 0;\n    virCPUDefPtr cpu = NULL;\n    virConfValuePtr list;\n    virConfValuePtr vnode;\n    virDomainNumaPtr numa;\n\n    numa = def->numa;\n    if (numa == NULL)\n        return -1;\n\n    list = virConfGetValue(conf, \"vnuma\");\n    if (!list || list->type != VIR_CONF_LIST)\n        return 0;\n\n    vnode = list->list;\n    while (vnode && vnode->type == VIR_CONF_LIST) {\n        vnode = vnode->next;\n        nr_nodes++;\n    }\n\n    if (!virDomainNumaSetNodeCount(numa, nr_nodes))\n        goto cleanup;\n\n    cpu = virCPUDefNew();\n\n    list = list->list;\n    while (list) {\n        int pnode = -1;\n        virBitmapPtr cpumask = NULL;\n        unsigned long long kbsize = 0;\n\n        /* Is there a sublist (vnode)? */\n        if (list && list->type == VIR_CONF_LIST) {\n            vnode = list->list;\n\n            while (vnode && vnode->type == VIR_CONF_STRING) {\n                const char *data;\n                const char *str = vnode->str;\n\n                if (!str ||\n                   !(data = strrchr(str, '='))) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"vnuma vnode invalid format '%s'\"),\n                                   str);\n                    goto cleanup;\n                }\n                data++;\n\n                if (*data) {\n                    char vtoken[64];\n\n                    if (STRPREFIX(str, \"pnode\")) {\n                        unsigned int cellid;\n\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu pnode '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        if ((virStrToLong_ui(vtoken, NULL, 10, &cellid) < 0) ||\n                            (cellid >= nr_nodes)) {\n                            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                           _(\"vnuma vnode %zu contains invalid pnode value '%s'\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n                        pnode = cellid;\n                    } else if (STRPREFIX(str, \"size\")) {\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu size '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        if (virStrToLong_ull(vtoken, NULL, 10, &kbsize) < 0)\n                            goto cleanup;\n\n                        virDomainNumaSetNodeMemorySize(numa, vnodeCnt, (kbsize * 1024));\n\n                    } else if (STRPREFIX(str, \"vcpus\")) {\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu vcpus '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        if ((virBitmapParse(vtoken, &cpumask, VIR_DOMAIN_CPUMASK_LEN) < 0) ||\n                            (virDomainNumaSetNodeCpumask(numa, vnodeCnt, cpumask) == NULL))\n                            goto cleanup;\n\n                        vcpus += virBitmapCountBits(cpumask);\n\n                    } else if (STRPREFIX(str, \"vdistances\")) {\n                        size_t i, ndistances;\n                        unsigned int value;\n\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu vdistances '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        VIR_FREE(tmp);\n                        tmp = g_strdup(vtoken);\n\n                        virStringListFree(token);\n                        if (!(token = virStringSplitCount(tmp, \",\", 0, &ndistances)))\n                            goto cleanup;\n\n                        if (ndistances != nr_nodes) {\n                            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                       _(\"vnuma pnode %d configured '%s' (count %zu) doesn't fit the number of specified vnodes %zu\"),\n                                       pnode, str, ndistances, nr_nodes);\n                            goto cleanup;\n                        }\n\n                        if (virDomainNumaSetNodeDistanceCount(numa, vnodeCnt, ndistances) != ndistances)\n                            goto cleanup;\n\n                        for (i = 0; i < ndistances; i++) {\n                            if ((virStrToLong_ui(token[i], NULL, 10, &value) < 0) ||\n                                (virDomainNumaSetNodeDistance(numa, vnodeCnt, i, value) != value))\n                                goto cleanup;\n                        }\n\n                    } else {\n                        virReportError(VIR_ERR_CONF_SYNTAX,\n                                       _(\"Invalid vnuma configuration for vnode %zu\"),\n                                       vnodeCnt);\n                        goto cleanup;\n                    }\n                }\n                vnode = vnode->next;\n            }\n        }\n\n        if ((pnode < 0) ||\n            (cpumask == NULL) ||\n            (kbsize == 0)) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Incomplete vnuma configuration for vnode %zu\"),\n                           vnodeCnt);\n            goto cleanup;\n        }\n\n        list = list->next;\n        vnodeCnt++;\n    }\n\n    if (def->maxvcpus == 0)\n        def->maxvcpus = vcpus;\n\n    if (def->maxvcpus < vcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"vnuma configuration contains %zu vcpus, which is greater than %zu maxvcpus\"),\n                       vcpus, def->maxvcpus);\n        goto cleanup;\n    }\n\n    cpu->type = VIR_CPU_TYPE_GUEST;\n    def->cpu = cpu;\n\n    ret = 0;\n\n cleanup:\n    if (ret)\n        VIR_FREE(cpu);\n    virStringListFree(token);\n    VIR_FREE(tmp);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseXLOS",
          "args": [
            "conf",
            "def",
            "caps"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseXLOS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "98-212",
          "snippet": "static int\nxenParseXLOS(virConfPtr conf, virDomainDefPtr def, virCapsPtr caps)\n{\n    size_t i;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        g_autofree char *bios = NULL;\n        g_autofree char *boot = NULL;\n        int val = 0;\n\n        if (xenConfigGetString(conf, \"bios\", &bios, NULL) < 0)\n            return -1;\n\n        if (bios && STREQ(bios, \"ovmf\")) {\n            if (VIR_ALLOC(def->os.loader) < 0)\n                return -1;\n\n            def->os.loader->type = VIR_DOMAIN_LOADER_TYPE_PFLASH;\n            def->os.loader->readonly = VIR_TRISTATE_BOOL_YES;\n\n            def->os.loader->path = g_strdup(LIBXL_FIRMWARE_DIR \"/ovmf.bin\");\n        } else {\n            for (i = 0; i < caps->nguests; i++) {\n                if (caps->guests[i]->ostype == VIR_DOMAIN_OSTYPE_HVM &&\n                    caps->guests[i]->arch.id == def->os.arch) {\n                    if (VIR_ALLOC(def->os.loader) < 0)\n                        return -1;\n                    def->os.loader->path = g_strdup(caps->guests[i]->arch.defaultInfo.loader);\n                }\n            }\n        }\n\n        if (xenConfigCopyStringOpt(conf, \"acpi_firmware\", &def->os.slic_table) < 0)\n            return -1;\n\n#ifdef LIBXL_HAVE_BUILDINFO_KERNEL\n        if (xenConfigCopyStringOpt(conf, \"kernel\", &def->os.kernel) < 0)\n            return -1;\n\n        if (xenConfigCopyStringOpt(conf, \"ramdisk\", &def->os.initrd) < 0)\n            return -1;\n\n        if (xenParseCmdline(conf, &def->os.cmdline) < 0)\n            return -1;\n#endif\n\n        if (xenConfigGetString(conf, \"boot\", &boot, \"c\") < 0)\n            return -1;\n\n        for (i = 0; i < VIR_DOMAIN_BOOT_LAST && boot[i]; i++) {\n            switch (boot[i]) {\n            case 'a':\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_FLOPPY;\n                break;\n            case 'd':\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_CDROM;\n                break;\n            case 'n':\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_NET;\n                break;\n            case 'c':\n            default:\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_DISK;\n                break;\n            }\n            def->os.nBootDevs++;\n        }\n\n        if (xenConfigGetBool(conf, \"nestedhvm\", &val, -1) < 0)\n            return -1;\n\n        if (val != -1) {\n            const char *vtfeature = \"vmx\";\n\n            if (caps && caps->host.cpu && ARCH_IS_X86(def->os.arch)) {\n                if (virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"vmx\"))\n                    vtfeature = \"vmx\";\n                else if (virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"svm\"))\n                    vtfeature = \"svm\";\n            }\n\n            if (!def->cpu) {\n                virCPUDefPtr cpu = virCPUDefNew();\n                cpu->mode = VIR_CPU_MODE_HOST_PASSTHROUGH;\n                cpu->type = VIR_CPU_TYPE_GUEST;\n                cpu->nfeatures = 0;\n                cpu->nfeatures_max = 0;\n                def->cpu = cpu;\n            }\n\n            if (val == 0) {\n                if (virCPUDefAddFeature(def->cpu,\n                                        vtfeature,\n                                        VIR_CPU_FEATURE_DISABLE) < 0)\n                    return -1;\n            }\n        }\n    } else {\n        if (xenConfigCopyStringOpt(conf, \"bootloader\", &def->os.bootloader) < 0)\n            return -1;\n        if (xenConfigCopyStringOpt(conf, \"bootargs\", &def->os.bootloaderArgs) < 0)\n            return -1;\n\n        if (xenConfigCopyStringOpt(conf, \"kernel\", &def->os.kernel) < 0)\n            return -1;\n\n        if (xenConfigCopyStringOpt(conf, \"ramdisk\", &def->os.initrd) < 0)\n            return -1;\n\n        if (xenParseCmdline(conf, &def->os.cmdline) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLOS(virConfPtr conf, virDomainDefPtr def, virCapsPtr caps)\n{\n    size_t i;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        g_autofree char *bios = NULL;\n        g_autofree char *boot = NULL;\n        int val = 0;\n\n        if (xenConfigGetString(conf, \"bios\", &bios, NULL) < 0)\n            return -1;\n\n        if (bios && STREQ(bios, \"ovmf\")) {\n            if (VIR_ALLOC(def->os.loader) < 0)\n                return -1;\n\n            def->os.loader->type = VIR_DOMAIN_LOADER_TYPE_PFLASH;\n            def->os.loader->readonly = VIR_TRISTATE_BOOL_YES;\n\n            def->os.loader->path = g_strdup(LIBXL_FIRMWARE_DIR \"/ovmf.bin\");\n        } else {\n            for (i = 0; i < caps->nguests; i++) {\n                if (caps->guests[i]->ostype == VIR_DOMAIN_OSTYPE_HVM &&\n                    caps->guests[i]->arch.id == def->os.arch) {\n                    if (VIR_ALLOC(def->os.loader) < 0)\n                        return -1;\n                    def->os.loader->path = g_strdup(caps->guests[i]->arch.defaultInfo.loader);\n                }\n            }\n        }\n\n        if (xenConfigCopyStringOpt(conf, \"acpi_firmware\", &def->os.slic_table) < 0)\n            return -1;\n\n#ifdef LIBXL_HAVE_BUILDINFO_KERNEL\n        if (xenConfigCopyStringOpt(conf, \"kernel\", &def->os.kernel) < 0)\n            return -1;\n\n        if (xenConfigCopyStringOpt(conf, \"ramdisk\", &def->os.initrd) < 0)\n            return -1;\n\n        if (xenParseCmdline(conf, &def->os.cmdline) < 0)\n            return -1;\n#endif\n\n        if (xenConfigGetString(conf, \"boot\", &boot, \"c\") < 0)\n            return -1;\n\n        for (i = 0; i < VIR_DOMAIN_BOOT_LAST && boot[i]; i++) {\n            switch (boot[i]) {\n            case 'a':\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_FLOPPY;\n                break;\n            case 'd':\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_CDROM;\n                break;\n            case 'n':\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_NET;\n                break;\n            case 'c':\n            default:\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_DISK;\n                break;\n            }\n            def->os.nBootDevs++;\n        }\n\n        if (xenConfigGetBool(conf, \"nestedhvm\", &val, -1) < 0)\n            return -1;\n\n        if (val != -1) {\n            const char *vtfeature = \"vmx\";\n\n            if (caps && caps->host.cpu && ARCH_IS_X86(def->os.arch)) {\n                if (virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"vmx\"))\n                    vtfeature = \"vmx\";\n                else if (virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"svm\"))\n                    vtfeature = \"svm\";\n            }\n\n            if (!def->cpu) {\n                virCPUDefPtr cpu = virCPUDefNew();\n                cpu->mode = VIR_CPU_MODE_HOST_PASSTHROUGH;\n                cpu->type = VIR_CPU_TYPE_GUEST;\n                cpu->nfeatures = 0;\n                cpu->nfeatures_max = 0;\n                def->cpu = cpu;\n            }\n\n            if (val == 0) {\n                if (virCPUDefAddFeature(def->cpu,\n                                        vtfeature,\n                                        VIR_CPU_FEATURE_DISABLE) < 0)\n                    return -1;\n            }\n        }\n    } else {\n        if (xenConfigCopyStringOpt(conf, \"bootloader\", &def->os.bootloader) < 0)\n            return -1;\n        if (xenConfigCopyStringOpt(conf, \"bootargs\", &def->os.bootloaderArgs) < 0)\n            return -1;\n\n        if (xenConfigCopyStringOpt(conf, \"kernel\", &def->os.kernel) < 0)\n            return -1;\n\n        if (xenConfigCopyStringOpt(conf, \"ramdisk\", &def->os.initrd) < 0)\n            return -1;\n\n        if (xenParseCmdline(conf, &def->os.cmdline) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseConfigCommon",
          "args": [
            "conf",
            "def",
            "caps",
            "XEN_CONFIG_FORMAT_XL",
            "xmlopt"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseConfigCommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1463-1513",
          "snippet": "int\nxenParseConfigCommon(virConfPtr conf,\n                     virDomainDefPtr def,\n                     virCapsPtr caps,\n                     const char *nativeFormat,\n                     virDomainXMLOptionPtr xmlopt)\n{\n    if (xenParseGeneralMeta(conf, def, caps) < 0)\n        return -1;\n\n    if (xenParseMem(conf, def) < 0)\n        return -1;\n\n    if (xenParseEventsActions(conf, def) < 0)\n        return -1;\n\n    if (xenParseCPUFeatures(conf, def, xmlopt) < 0)\n        return -1;\n\n    if (xenParseTimeOffset(conf, def) < 0)\n        return -1;\n\n    if (xenConfigCopyStringOpt(conf, \"device_model\", &def->emulator) < 0)\n        return -1;\n\n    if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XL)) {\n        if (xenParseVifList(conf, def, \"vif\") < 0)\n            return -1;\n    } else if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n        if (xenParseVifList(conf, def, \"netfront\") < 0)\n            return -1;\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported config type %s\"), nativeFormat);\n        return -1;\n    }\n\n    if (xenParsePCIList(conf, def) < 0)\n        return -1;\n\n    if (xenParseEmulatedDevices(conf, def) < 0)\n        return -1;\n\n    if (xenParseVfb(conf, def) < 0)\n        return -1;\n\n    if (xenParseCharDev(conf, def, nativeFormat) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenParseConfigCommon(virConfPtr conf,\n                     virDomainDefPtr def,\n                     virCapsPtr caps,\n                     const char *nativeFormat,\n                     virDomainXMLOptionPtr xmlopt)\n{\n    if (xenParseGeneralMeta(conf, def, caps) < 0)\n        return -1;\n\n    if (xenParseMem(conf, def) < 0)\n        return -1;\n\n    if (xenParseEventsActions(conf, def) < 0)\n        return -1;\n\n    if (xenParseCPUFeatures(conf, def, xmlopt) < 0)\n        return -1;\n\n    if (xenParseTimeOffset(conf, def) < 0)\n        return -1;\n\n    if (xenConfigCopyStringOpt(conf, \"device_model\", &def->emulator) < 0)\n        return -1;\n\n    if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XL)) {\n        if (xenParseVifList(conf, def, \"vif\") < 0)\n            return -1;\n    } else if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n        if (xenParseVifList(conf, def, \"netfront\") < 0)\n            return -1;\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported config type %s\"), nativeFormat);\n        return -1;\n    }\n\n    if (xenParsePCIList(conf, def) < 0)\n        return -1;\n\n    if (xenParseEmulatedDevices(conf, def) < 0)\n        return -1;\n\n    if (xenParseVfb(conf, def) < 0)\n        return -1;\n\n    if (xenParseCharDev(conf, def, nativeFormat) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefNew",
          "args": [],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3574-3594",
          "snippet": "virDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nvirDomainDefPtr\nxenParseXL(virConfPtr conf,\n           virCapsPtr caps,\n           virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDefPtr def = NULL;\n\n    if (!(def = virDomainDefNew()))\n        return NULL;\n\n    def->virtType = VIR_DOMAIN_VIRT_XEN;\n    def->id = -1;\n\n    if (xenParseConfigCommon(conf, def, caps, XEN_CONFIG_FORMAT_XL,\n                             xmlopt) < 0)\n        goto cleanup;\n\n    if (xenParseXLOS(conf, def, caps) < 0)\n        goto cleanup;\n\n#ifdef LIBXL_HAVE_VNUMA\n    if (xenParseXLVnuma(conf, def) < 0)\n        goto cleanup;\n#endif\n\n#ifdef LIBXL_HAVE_BUILDINFO_GRANT_LIMITS\n    if (xenParseXLGntLimits(conf, def) < 0)\n        goto cleanup;\n#endif\n\n    if (xenParseXLCPUID(conf, def) < 0)\n        goto cleanup;\n\n    if (xenParseXLDisk(conf, def) < 0)\n        goto cleanup;\n\n    if (xenParseXLSpice(conf, def) < 0)\n        goto cleanup;\n\n    if (xenParseXLInputDevs(conf, def) < 0)\n        goto cleanup;\n\n    if (xenParseXLUSB(conf, def) < 0)\n        goto cleanup;\n\n    if (xenParseXLUSBController(conf, def) < 0)\n        goto cleanup;\n\n    if (xenParseXLChannel(conf, def) < 0)\n        goto cleanup;\n\n    if (virDomainDefPostParse(def, VIR_DOMAIN_DEF_PARSE_ABI_UPDATE,\n                              xmlopt, NULL) < 0)\n        goto cleanup;\n\n    return def;\n\n cleanup:\n    virDomainDefFree(def);\n    return NULL;\n}"
  },
  {
    "function_name": "xenParseXLChannel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "1071-1156",
    "snippet": "static int\nxenParseXLChannel(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"channel\");\n    virDomainChrDefPtr channel = NULL;\n    char *name = NULL;\n    char *path = NULL;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            char type[10];\n            char *key;\n\n            if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n                goto skipchannel;\n\n            key = list->str;\n            while (key) {\n                char *data;\n                char *nextkey = strchr(key, ',');\n\n                if (!(data = strchr(key, '=')))\n                    goto skipchannel;\n                data++;\n\n                if (STRPREFIX(key, \"connection=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(type, data, len, sizeof(type)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"connection %s too big\"), data);\n                        goto skipchannel;\n                    }\n                } else if (STRPREFIX(key, \"name=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    VIR_FREE(name);\n                    name = g_strndup(data, len);\n                } else if (STRPREFIX(key, \"path=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    VIR_FREE(path);\n                    path = g_strndup(data, len);\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n\n            if (!(channel = virDomainChrDefNew(NULL)))\n                goto cleanup;\n\n            if (STRPREFIX(type, \"socket\")) {\n                channel->source->type = VIR_DOMAIN_CHR_TYPE_UNIX;\n                channel->source->data.nix.listen = 1;\n                channel->source->data.nix.path = path;\n                path = NULL;\n            } else if (STRPREFIX(type, \"pty\")) {\n                channel->source->type = VIR_DOMAIN_CHR_TYPE_PTY;\n                VIR_FREE(path);\n            } else {\n                goto cleanup;\n            }\n\n            channel->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL;\n            channel->targetType = VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN;\n            channel->target.name = name;\n            name = NULL;\n\n            if (VIR_APPEND_ELEMENT(def->channels, def->nchannels, channel) < 0)\n                goto cleanup;\n\n        skipchannel:\n            list = list->next;\n        }\n    }\n\n    return 0;\n\n cleanup:\n    virDomainChrDefFree(channel);\n    VIR_FREE(path);\n    VIR_FREE(name);\n    return -1;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrDefFree",
          "args": [
            "channel"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2706-2733",
          "snippet": "void virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->channels",
            "def->nchannels",
            "channel"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "type",
            "\"pty\""
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "type",
            "\"socket\""
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrDefNew",
          "args": [
            "NULL"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "13232-13246",
          "snippet": "virDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "data",
            "len"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"path=\""
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "data",
            "len"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"name=\""
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"connection %s too big\")",
            "data"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"connection %s too big\""
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrncpy",
          "args": [
            "type",
            "data",
            "len",
            "sizeof(type)"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "virStrncpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "746-765",
          "snippet": "int\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"connection=\""
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "'='"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "','"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfGetValue",
          "args": [
            "conf",
            "\"channel\""
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "849-857",
          "snippet": "virConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvirConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLChannel(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"channel\");\n    virDomainChrDefPtr channel = NULL;\n    char *name = NULL;\n    char *path = NULL;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            char type[10];\n            char *key;\n\n            if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n                goto skipchannel;\n\n            key = list->str;\n            while (key) {\n                char *data;\n                char *nextkey = strchr(key, ',');\n\n                if (!(data = strchr(key, '=')))\n                    goto skipchannel;\n                data++;\n\n                if (STRPREFIX(key, \"connection=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(type, data, len, sizeof(type)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"connection %s too big\"), data);\n                        goto skipchannel;\n                    }\n                } else if (STRPREFIX(key, \"name=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    VIR_FREE(name);\n                    name = g_strndup(data, len);\n                } else if (STRPREFIX(key, \"path=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    VIR_FREE(path);\n                    path = g_strndup(data, len);\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n\n            if (!(channel = virDomainChrDefNew(NULL)))\n                goto cleanup;\n\n            if (STRPREFIX(type, \"socket\")) {\n                channel->source->type = VIR_DOMAIN_CHR_TYPE_UNIX;\n                channel->source->data.nix.listen = 1;\n                channel->source->data.nix.path = path;\n                path = NULL;\n            } else if (STRPREFIX(type, \"pty\")) {\n                channel->source->type = VIR_DOMAIN_CHR_TYPE_PTY;\n                VIR_FREE(path);\n            } else {\n                goto cleanup;\n            }\n\n            channel->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL;\n            channel->targetType = VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN;\n            channel->target.name = name;\n            name = NULL;\n\n            if (VIR_APPEND_ELEMENT(def->channels, def->nchannels, channel) < 0)\n                goto cleanup;\n\n        skipchannel:\n            list = list->next;\n        }\n    }\n\n    return 0;\n\n cleanup:\n    virDomainChrDefFree(channel);\n    VIR_FREE(path);\n    VIR_FREE(name);\n    return -1;\n}"
  },
  {
    "function_name": "xenParseXLUSB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "992-1069",
    "snippet": "static int\nxenParseXLUSB(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"usbdev\");\n    virDomainHostdevDefPtr hostdev = NULL;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            char bus[3];\n            char device[3];\n            char *key;\n            int busNum;\n            int devNum;\n\n            bus[0] = device[0] = '\\0';\n\n            if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n                goto skipusb;\n            /* usbdev=['hostbus=1,hostaddr=3'] */\n            key = list->str;\n            while (key) {\n                char *data;\n                char *nextkey = strchr(key, ',');\n\n                if (!(data = strchr(key, '=')))\n                    goto skipusb;\n                data++;\n\n                if (STRPREFIX(key, \"hostbus=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(bus, data, len, sizeof(bus)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"bus %s too big for destination\"),\n                                       data);\n                        goto skipusb;\n                    }\n                } else if (STRPREFIX(key, \"hostaddr=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(device, data, len, sizeof(device)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"device %s too big for destination\"),\n                                       data);\n                        goto skipusb;\n                    }\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n\n            if (virStrToLong_i(bus, NULL, 16, &busNum) < 0)\n                goto skipusb;\n            if (virStrToLong_i(device, NULL, 16, &devNum) < 0)\n                goto skipusb;\n            if (!(hostdev = virDomainHostdevDefNew()))\n               return -1;\n\n            hostdev->managed = false;\n            hostdev->source.subsys.type = VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB;\n            hostdev->source.subsys.u.usb.bus = busNum;\n            hostdev->source.subsys.u.usb.device = devNum;\n\n            if (VIR_APPEND_ELEMENT(def->hostdevs, def->nhostdevs, hostdev) < 0) {\n                virDomainHostdevDefFree(hostdev);\n                return -1;\n            }\n\n        skipusb:\n            list = list->next;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainHostdevDefFree",
          "args": [
            "hostdev"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainHostdevDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3002-3015",
          "snippet": "void virDomainHostdevDefFree(virDomainHostdevDefPtr def)\n{\n    if (!def)\n        return;\n\n    /* free all subordinate objects */\n    virDomainHostdevDefClear(def);\n\n    /* If there is a parentnet device object, it will handle freeing\n     * the memory.\n     */\n    if (!def->parentnet)\n        VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def)\n{\n    if (!def)\n        return;\n\n    /* free all subordinate objects */\n    virDomainHostdevDefClear(def);\n\n    /* If there is a parentnet device object, it will handle freeing\n     * the memory.\n     */\n    if (!def->parentnet)\n        VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->hostdevs",
            "def->nhostdevs",
            "hostdev"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainHostdevDefNew",
          "args": [],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainHostdevDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2889-2906",
          "snippet": "virDomainHostdevDefPtr\nvirDomainHostdevDefNew(void)\n{\n    virDomainHostdevDefPtr def;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(def->info) < 0)\n        goto error;\n\n    return def;\n\n error:\n    VIR_FREE(def->info);\n    VIR_FREE(def);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainHostdevDefPtr\nvirDomainHostdevDefNew(void)\n{\n    virDomainHostdevDefPtr def;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(def->info) < 0)\n        goto error;\n\n    return def;\n\n error:\n    VIR_FREE(def->info);\n    VIR_FREE(def);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "device",
            "NULL",
            "16",
            "&devNum"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"device %s too big for destination\")",
            "data"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"device %s too big for destination\""
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrncpy",
          "args": [
            "device",
            "data",
            "len",
            "sizeof(device)"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "virStrncpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "746-765",
          "snippet": "int\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"hostaddr=\""
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"bus %s too big for destination\")",
            "data"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"hostbus=\""
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "'='"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "','"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfGetValue",
          "args": [
            "conf",
            "\"usbdev\""
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "849-857",
          "snippet": "virConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvirConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLUSB(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"usbdev\");\n    virDomainHostdevDefPtr hostdev = NULL;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            char bus[3];\n            char device[3];\n            char *key;\n            int busNum;\n            int devNum;\n\n            bus[0] = device[0] = '\\0';\n\n            if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n                goto skipusb;\n            /* usbdev=['hostbus=1,hostaddr=3'] */\n            key = list->str;\n            while (key) {\n                char *data;\n                char *nextkey = strchr(key, ',');\n\n                if (!(data = strchr(key, '=')))\n                    goto skipusb;\n                data++;\n\n                if (STRPREFIX(key, \"hostbus=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(bus, data, len, sizeof(bus)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"bus %s too big for destination\"),\n                                       data);\n                        goto skipusb;\n                    }\n                } else if (STRPREFIX(key, \"hostaddr=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(device, data, len, sizeof(device)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"device %s too big for destination\"),\n                                       data);\n                        goto skipusb;\n                    }\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n\n            if (virStrToLong_i(bus, NULL, 16, &busNum) < 0)\n                goto skipusb;\n            if (virStrToLong_i(device, NULL, 16, &devNum) < 0)\n                goto skipusb;\n            if (!(hostdev = virDomainHostdevDefNew()))\n               return -1;\n\n            hostdev->managed = false;\n            hostdev->source.subsys.type = VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB;\n            hostdev->source.subsys.u.usb.bus = busNum;\n            hostdev->source.subsys.u.usb.device = devNum;\n\n            if (VIR_APPEND_ELEMENT(def->hostdevs, def->nhostdevs, hostdev) < 0) {\n                virDomainHostdevDefFree(hostdev);\n                return -1;\n            }\n\n        skipusb:\n            list = list->next;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenParseXLUSBController",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "888-990",
    "snippet": "static int\nxenParseXLUSBController(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"usbctrl\");\n    virDomainControllerDefPtr controller = NULL;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            char type[8];\n            char version[4];\n            char ports[4];\n            char *key;\n            int usbctrl_version = 2; /* by default USB 2.0 */\n            int usbctrl_ports = 8; /* by default 8 ports */\n            int usbctrl_type = -1;\n\n            type[0] = version[0] = ports[0] = '\\0';\n\n            if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n                goto skipusbctrl;\n            /* usbctrl=['type=pv,version=2,ports=8'] */\n            key = list->str;\n            while (key) {\n                char *data;\n                char *nextkey = strchr(key, ',');\n\n                if (!(data = strchr(key, '=')))\n                    goto skipusbctrl;\n                data++;\n\n                if (STRPREFIX(key, \"type=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(type, data, len, sizeof(type)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"type %s invalid\"),\n                                       data);\n                        goto skipusbctrl;\n                    }\n                } else if (STRPREFIX(key, \"version=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(version, data, len, sizeof(version)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"version %s invalid\"),\n                                       data);\n                        goto skipusbctrl;\n                    }\n                    if (virStrToLong_i(version, NULL, 16, &usbctrl_version) < 0)\n                        goto skipusbctrl;\n                } else if (STRPREFIX(key, \"ports=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(ports, data, len, sizeof(ports)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"version %s invalid\"),\n                                       data);\n                        goto skipusbctrl;\n                    }\n                    if (virStrToLong_i(ports, NULL, 16, &usbctrl_ports) < 0)\n                        goto skipusbctrl;\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n\n            if (type[0] == '\\0') {\n                if (usbctrl_version == 1)\n                    usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1;\n                else\n                    usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2;\n            } else {\n                if (STREQLEN(type, \"qusb\", 4)) {\n                    if (usbctrl_version == 1)\n                        usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1;\n                    else\n                        usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2;\n                } else {\n                    goto skipusbctrl;\n                }\n            }\n\n            if (!(controller = virDomainControllerDefNew(VIR_DOMAIN_CONTROLLER_TYPE_USB)))\n                return -1;\n\n            controller->type = VIR_DOMAIN_CONTROLLER_TYPE_USB;\n            controller->model = usbctrl_type;\n            controller->opts.usbopts.ports = usbctrl_ports;\n\n            if (VIR_APPEND_ELEMENT(def->controllers, def->ncontrollers, controller) < 0) {\n                virDomainControllerDefFree(controller);\n                return -1;\n            }\n\n        skipusbctrl:\n            list = list->next;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainControllerDefFree",
          "args": [
            "controller"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainControllerDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2262-2271",
          "snippet": "void virDomainControllerDefFree(virDomainControllerDefPtr def)\n{\n    if (!def)\n        return;\n\n    virDomainDeviceInfoClear(&def->info);\n    VIR_FREE(def->virtio);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def)\n{\n    if (!def)\n        return;\n\n    virDomainDeviceInfoClear(&def->info);\n    VIR_FREE(def->virtio);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->controllers",
            "def->ncontrollers",
            "controller"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainControllerDefNew",
          "args": [
            "VIR_DOMAIN_CONTROLLER_TYPE_USB"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainControllerDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2216-2259",
          "snippet": "virDomainControllerDefPtr\nvirDomainControllerDefNew(virDomainControllerType type)\n{\n    virDomainControllerDefPtr def;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->type = type;\n\n    /* initialize anything that has a non-0 default */\n    def->model = -1;\n    def->idx = -1;\n\n    switch ((virDomainControllerType) def->type) {\n    case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL:\n        def->opts.vioserial.ports = -1;\n        def->opts.vioserial.vectors = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n        def->opts.usbopts.ports = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n        def->opts.pciopts.chassisNr = -1;\n        def->opts.pciopts.chassis = -1;\n        def->opts.pciopts.port = -1;\n        def->opts.pciopts.busNr = -1;\n        def->opts.pciopts.targetIndex = -1;\n        def->opts.pciopts.numaNode = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS:\n        def->opts.xenbusopts.maxGrantFrames = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_IDE:\n    case VIR_DOMAIN_CONTROLLER_TYPE_FDC:\n    case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:\n    case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n    case VIR_DOMAIN_CONTROLLER_TYPE_CCID:\n    case VIR_DOMAIN_CONTROLLER_TYPE_LAST:\n        break;\n    }\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainControllerDefPtr\nvirDomainControllerDefNew(virDomainControllerType type)\n{\n    virDomainControllerDefPtr def;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->type = type;\n\n    /* initialize anything that has a non-0 default */\n    def->model = -1;\n    def->idx = -1;\n\n    switch ((virDomainControllerType) def->type) {\n    case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL:\n        def->opts.vioserial.ports = -1;\n        def->opts.vioserial.vectors = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n        def->opts.usbopts.ports = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n        def->opts.pciopts.chassisNr = -1;\n        def->opts.pciopts.chassis = -1;\n        def->opts.pciopts.port = -1;\n        def->opts.pciopts.busNr = -1;\n        def->opts.pciopts.targetIndex = -1;\n        def->opts.pciopts.numaNode = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS:\n        def->opts.xenbusopts.maxGrantFrames = -1;\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_IDE:\n    case VIR_DOMAIN_CONTROLLER_TYPE_FDC:\n    case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:\n    case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n    case VIR_DOMAIN_CONTROLLER_TYPE_CCID:\n    case VIR_DOMAIN_CONTROLLER_TYPE_LAST:\n        break;\n    }\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQLEN",
          "args": [
            "type",
            "\"qusb\"",
            "4"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "ports",
            "NULL",
            "16",
            "&usbctrl_ports"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"version %s invalid\")",
            "data"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"version %s invalid\""
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrncpy",
          "args": [
            "ports",
            "data",
            "len",
            "sizeof(ports)"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "virStrncpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "746-765",
          "snippet": "int\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"ports=\""
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"version %s invalid\")",
            "data"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"version=\""
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"type %s invalid\")",
            "data"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"type=\""
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "'='"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "','"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfGetValue",
          "args": [
            "conf",
            "\"usbctrl\""
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "849-857",
          "snippet": "virConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvirConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLUSBController(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"usbctrl\");\n    virDomainControllerDefPtr controller = NULL;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            char type[8];\n            char version[4];\n            char ports[4];\n            char *key;\n            int usbctrl_version = 2; /* by default USB 2.0 */\n            int usbctrl_ports = 8; /* by default 8 ports */\n            int usbctrl_type = -1;\n\n            type[0] = version[0] = ports[0] = '\\0';\n\n            if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n                goto skipusbctrl;\n            /* usbctrl=['type=pv,version=2,ports=8'] */\n            key = list->str;\n            while (key) {\n                char *data;\n                char *nextkey = strchr(key, ',');\n\n                if (!(data = strchr(key, '=')))\n                    goto skipusbctrl;\n                data++;\n\n                if (STRPREFIX(key, \"type=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(type, data, len, sizeof(type)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"type %s invalid\"),\n                                       data);\n                        goto skipusbctrl;\n                    }\n                } else if (STRPREFIX(key, \"version=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(version, data, len, sizeof(version)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"version %s invalid\"),\n                                       data);\n                        goto skipusbctrl;\n                    }\n                    if (virStrToLong_i(version, NULL, 16, &usbctrl_version) < 0)\n                        goto skipusbctrl;\n                } else if (STRPREFIX(key, \"ports=\")) {\n                    int len = nextkey ? (nextkey - data) : strlen(data);\n                    if (virStrncpy(ports, data, len, sizeof(ports)) < 0) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"version %s invalid\"),\n                                       data);\n                        goto skipusbctrl;\n                    }\n                    if (virStrToLong_i(ports, NULL, 16, &usbctrl_ports) < 0)\n                        goto skipusbctrl;\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n\n            if (type[0] == '\\0') {\n                if (usbctrl_version == 1)\n                    usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1;\n                else\n                    usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2;\n            } else {\n                if (STREQLEN(type, \"qusb\", 4)) {\n                    if (usbctrl_version == 1)\n                        usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB1;\n                    else\n                        usbctrl_type = VIR_DOMAIN_CONTROLLER_MODEL_USB_QUSB2;\n                } else {\n                    goto skipusbctrl;\n                }\n            }\n\n            if (!(controller = virDomainControllerDefNew(VIR_DOMAIN_CONTROLLER_TYPE_USB)))\n                return -1;\n\n            controller->type = VIR_DOMAIN_CONTROLLER_TYPE_USB;\n            controller->model = usbctrl_type;\n            controller->opts.usbopts.ports = usbctrl_ports;\n\n            if (VIR_APPEND_ELEMENT(def->controllers, def->ncontrollers, controller) < 0) {\n                virDomainControllerDefFree(controller);\n                return -1;\n            }\n\n        skipusbctrl:\n            list = list->next;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenParseXLInputDevs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "834-886",
    "snippet": "static int\nxenParseXLInputDevs(virConfPtr conf, virDomainDefPtr def)\n{\n    const char *str;\n    virConfValuePtr val;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        val = virConfGetValue(conf, \"usbdevice\");\n        /* usbdevice can be defined as either a single string or a list */\n        if (val && val->type == VIR_CONF_LIST) {\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n            val = val->list;\n#else\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"multiple USB devices not supported\"));\n            return -1;\n#endif\n        }\n        /* otherwise val->next is NULL, so can be handled by the same code */\n        while (val) {\n            if (val->type != VIR_CONF_STRING) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"config value %s was malformed\"),\n                               \"usbdevice\");\n                return -1;\n            }\n            str = val->str;\n\n            if (str &&\n                    (STREQ(str, \"tablet\") ||\n                     STREQ(str, \"mouse\") ||\n                     STREQ(str, \"keyboard\"))) {\n                virDomainInputDefPtr input;\n                if (VIR_ALLOC(input) < 0)\n                    return -1;\n\n                input->bus = VIR_DOMAIN_INPUT_BUS_USB;\n                if (STREQ(str, \"mouse\"))\n                    input->type = VIR_DOMAIN_INPUT_TYPE_MOUSE;\n                else if (STREQ(str, \"tablet\"))\n                    input->type = VIR_DOMAIN_INPUT_TYPE_TABLET;\n                else if (STREQ(str, \"keyboard\"))\n                    input->type = VIR_DOMAIN_INPUT_TYPE_KBD;\n                if (VIR_APPEND_ELEMENT(def->inputs, def->ninputs, input) < 0) {\n                    virDomainInputDefFree(input);\n                    return -1;\n                }\n            }\n            val = val->next;\n        }\n    }\n    return 0;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainInputDefFree",
          "args": [
            "input"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainInputDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1782-1791",
          "snippet": "void virDomainInputDefFree(virDomainInputDefPtr def)\n{\n    if (!def)\n        return;\n\n    virDomainDeviceInfoClear(&def->info);\n    VIR_FREE(def->source.evdev);\n    VIR_FREE(def->virtio);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainInputDefFree(virDomainInputDefPtr def)\n{\n    if (!def)\n        return;\n\n    virDomainDeviceInfoClear(&def->info);\n    VIR_FREE(def->source.evdev);\n    VIR_FREE(def->virtio);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->inputs",
            "def->ninputs",
            "input"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "str",
            "\"keyboard\""
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "str",
            "\"tablet\""
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "str",
            "\"mouse\""
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "input"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "str",
            "\"keyboard\""
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "str",
            "\"mouse\""
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "str",
            "\"tablet\""
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"config value %s was malformed\")",
            "\"usbdevice\""
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"config value %s was malformed\""
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"multiple USB devices not supported\")"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfGetValue",
          "args": [
            "conf",
            "\"usbdevice\""
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "849-857",
          "snippet": "virConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvirConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLInputDevs(virConfPtr conf, virDomainDefPtr def)\n{\n    const char *str;\n    virConfValuePtr val;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        val = virConfGetValue(conf, \"usbdevice\");\n        /* usbdevice can be defined as either a single string or a list */\n        if (val && val->type == VIR_CONF_LIST) {\n#ifdef LIBXL_HAVE_BUILDINFO_USBDEVICE_LIST\n            val = val->list;\n#else\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"multiple USB devices not supported\"));\n            return -1;\n#endif\n        }\n        /* otherwise val->next is NULL, so can be handled by the same code */\n        while (val) {\n            if (val->type != VIR_CONF_STRING) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"config value %s was malformed\"),\n                               \"usbdevice\");\n                return -1;\n            }\n            str = val->str;\n\n            if (str &&\n                    (STREQ(str, \"tablet\") ||\n                     STREQ(str, \"mouse\") ||\n                     STREQ(str, \"keyboard\"))) {\n                virDomainInputDefPtr input;\n                if (VIR_ALLOC(input) < 0)\n                    return -1;\n\n                input->bus = VIR_DOMAIN_INPUT_BUS_USB;\n                if (STREQ(str, \"mouse\"))\n                    input->type = VIR_DOMAIN_INPUT_TYPE_MOUSE;\n                else if (STREQ(str, \"tablet\"))\n                    input->type = VIR_DOMAIN_INPUT_TYPE_TABLET;\n                else if (STREQ(str, \"keyboard\"))\n                    input->type = VIR_DOMAIN_INPUT_TYPE_KBD;\n                if (VIR_APPEND_ELEMENT(def->inputs, def->ninputs, input) < 0) {\n                    virDomainInputDefFree(input);\n                    return -1;\n                }\n            }\n            val = val->next;\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "xenParseXLDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "692-832",
    "snippet": "static int\nxenParseXLDisk(virConfPtr conf, virDomainDefPtr def)\n{\n    int ret = -1;\n    virConfValuePtr list = virConfGetValue(conf, \"disk\");\n    XLU_Config *xluconf;\n    libxl_device_disk *libxldisk;\n    virDomainDiskDefPtr disk = NULL;\n\n    if (VIR_ALLOC(libxldisk) < 0)\n        return -1;\n\n    if (!(xluconf = xlu_cfg_init(stderr, \"command line\")))\n        goto cleanup;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            const char *disk_spec = list->str;\n\n            if (list->type != VIR_CONF_STRING || list->str == NULL)\n                goto skipdisk;\n\n            libxl_device_disk_init(libxldisk);\n\n            if (xlu_disk_parse(xluconf, 1, &disk_spec, libxldisk))\n                goto fail;\n\n            if (!(disk = virDomainDiskDefNew(NULL)))\n                goto fail;\n\n            if (xenParseXLDiskSrc(disk, libxldisk->pdev_path) < 0)\n                goto fail;\n\n            disk->dst = g_strdup(libxldisk->vdev);\n\n            disk->src->readonly = !libxldisk->readwrite;\n            disk->removable = libxldisk->removable;\n\n            if (libxldisk->is_cdrom) {\n                if (virDomainDiskSetDriver(disk, \"qemu\") < 0)\n                    goto fail;\n\n                virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n                disk->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n                if (!disk->src->path || STREQ(disk->src->path, \"\"))\n                    disk->src->format = VIR_STORAGE_FILE_NONE;\n                else\n                    disk->src->format = VIR_STORAGE_FILE_RAW;\n            } else {\n                switch (libxldisk->format) {\n                case LIBXL_DISK_FORMAT_QCOW:\n                    disk->src->format = VIR_STORAGE_FILE_QCOW;\n                    break;\n\n                case LIBXL_DISK_FORMAT_QCOW2:\n                    disk->src->format = VIR_STORAGE_FILE_QCOW2;\n                    break;\n\n                case LIBXL_DISK_FORMAT_VHD:\n                    disk->src->format = VIR_STORAGE_FILE_VHD;\n                    break;\n\n                case LIBXL_DISK_FORMAT_RAW:\n                case LIBXL_DISK_FORMAT_UNKNOWN:\n                    disk->src->format = VIR_STORAGE_FILE_RAW;\n                    break;\n\n                case LIBXL_DISK_FORMAT_EMPTY:\n                    break;\n\n#ifdef LIBXL_HAVE_QED\n                case LIBXL_DISK_FORMAT_QED:\n                    disk->src->format = VIR_STORAGE_FILE_QED;\n                    break;\n#endif\n\n                default:\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"disk image format not supported: %s\"),\n                                   libxl_disk_format_to_string(libxldisk->format));\n                    goto fail;\n                }\n\n                switch (libxldisk->backend) {\n                case LIBXL_DISK_BACKEND_QDISK:\n                case LIBXL_DISK_BACKEND_UNKNOWN:\n                    if (virDomainDiskSetDriver(disk, \"qemu\") < 0)\n                        goto fail;\n                    if (virDomainDiskGetType(disk) == VIR_STORAGE_TYPE_NONE)\n                        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n                    break;\n\n                case LIBXL_DISK_BACKEND_TAP:\n                    if (virDomainDiskSetDriver(disk, \"tap\") < 0)\n                        goto fail;\n                    virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n                    break;\n\n                case LIBXL_DISK_BACKEND_PHY:\n                    if (virDomainDiskSetDriver(disk, \"phy\") < 0)\n                        goto fail;\n                    virDomainDiskSetType(disk, VIR_STORAGE_TYPE_BLOCK);\n                    break;\n                default:\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"disk backend not supported: %s\"),\n                                   libxl_disk_backend_to_string(libxldisk->backend));\n                    goto fail;\n                }\n            }\n\n            if (STRPREFIX(libxldisk->vdev, \"xvd\") ||\n                def->os.type != VIR_DOMAIN_OSTYPE_HVM)\n                disk->bus = VIR_DOMAIN_DISK_BUS_XEN;\n            else if (STRPREFIX(libxldisk->vdev, \"sd\"))\n                disk->bus = VIR_DOMAIN_DISK_BUS_SCSI;\n            else\n                disk->bus = VIR_DOMAIN_DISK_BUS_IDE;\n\n            if (VIR_APPEND_ELEMENT(def->disks, def->ndisks, disk) < 0)\n                goto fail;\n\n            libxl_device_disk_dispose(libxldisk);\n\n        skipdisk:\n            list = list->next;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    virDomainDiskDefFree(disk);\n    xlu_cfg_destroy(xluconf);\n    VIR_FREE(libxldisk);\n    return ret;\n\n fail:\n    libxl_device_disk_dispose(libxldisk);\n    goto cleanup;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxl_device_disk_dispose",
          "args": [
            "libxldisk"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "libxldisk"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlu_cfg_destroy",
          "args": [
            "xluconf"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDefFree",
          "args": [
            "disk"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2117-2138",
          "snippet": "void\nvirDomainDiskDefFree(virDomainDiskDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->serial);\n    VIR_FREE(def->dst);\n    virObjectUnref(def->mirror);\n    VIR_FREE(def->wwn);\n    VIR_FREE(def->driverName);\n    VIR_FREE(def->vendor);\n    VIR_FREE(def->product);\n    VIR_FREE(def->domain_name);\n    VIR_FREE(def->blkdeviotune.group_name);\n    VIR_FREE(def->virtio);\n    virDomainDeviceInfoClear(&def->info);\n    virObjectUnref(def->privateData);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDiskDefFree(virDomainDiskDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->serial);\n    VIR_FREE(def->dst);\n    virObjectUnref(def->mirror);\n    VIR_FREE(def->wwn);\n    VIR_FREE(def->driverName);\n    VIR_FREE(def->vendor);\n    VIR_FREE(def->product);\n    VIR_FREE(def->domain_name);\n    VIR_FREE(def->blkdeviotune.group_name);\n    VIR_FREE(def->virtio);\n    virDomainDeviceInfoClear(&def->info);\n    virObjectUnref(def->privateData);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_device_disk_dispose",
          "args": [
            "libxldisk"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->disks",
            "def->ndisks",
            "disk"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "libxldisk->vdev",
            "\"sd\""
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "libxldisk->vdev",
            "\"xvd\""
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"disk backend not supported: %s\")",
            "libxl_disk_backend_to_string(libxldisk->backend)"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_disk_backend_to_string",
          "args": [
            "libxldisk->backend"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"disk backend not supported: %s\""
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskSetType",
          "args": [
            "disk",
            "VIR_STORAGE_TYPE_BLOCK"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2148-2152",
          "snippet": "void\nvirDomainDiskSetType(virDomainDiskDefPtr def, int type)\n{\n    def->src->type = type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDiskSetType(virDomainDiskDefPtr def, int type)\n{\n    def->src->type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskSetDriver",
          "args": [
            "disk",
            "\"phy\""
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2192-2199",
          "snippet": "int\nvirDomainDiskSetDriver(virDomainDiskDefPtr def, const char *name)\n{\n    char *tmp = g_strdup(name);\n    g_free(def->driverName);\n    def->driverName = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskSetDriver(virDomainDiskDefPtr def, const char *name)\n{\n    char *tmp = g_strdup(name);\n    g_free(def->driverName);\n    def->driverName = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetType",
          "args": [
            "disk"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2141-2145",
          "snippet": "int\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"disk image format not supported: %s\")",
            "libxl_disk_format_to_string(libxldisk->format)"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_disk_format_to_string",
          "args": [
            "libxldisk->format"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "disk->src->path",
            "\"\""
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "libxldisk->vdev"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseXLDiskSrc",
          "args": [
            "disk",
            "libxldisk->pdev_path"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseXLDiskSrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "628-655",
          "snippet": "static int\nxenParseXLDiskSrc(virDomainDiskDefPtr disk, char *srcstr)\n{\n    char *tmpstr = NULL;\n    int ret = -1;\n\n    /* A NULL source is valid, e.g. an empty CDROM */\n    if (srcstr == NULL)\n        return 0;\n\n    if (STRPREFIX(srcstr, \"rbd:\")) {\n        if (!(tmpstr = virStringReplace(srcstr, \"\\\\\\\\\", \"\\\\\")))\n            goto cleanup;\n\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_NETWORK);\n        disk->src->protocol = VIR_STORAGE_NET_PROTOCOL_RBD;\n        ret = virStorageSourceParseRBDColonString(tmpstr, disk->src);\n    } else {\n        if (virDomainDiskSetSource(disk, srcstr) < 0)\n            goto cleanup;\n\n        ret = 0;\n    }\n\n cleanup:\n    VIR_FREE(tmpstr);\n    return ret;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLDiskSrc(virDomainDiskDefPtr disk, char *srcstr)\n{\n    char *tmpstr = NULL;\n    int ret = -1;\n\n    /* A NULL source is valid, e.g. an empty CDROM */\n    if (srcstr == NULL)\n        return 0;\n\n    if (STRPREFIX(srcstr, \"rbd:\")) {\n        if (!(tmpstr = virStringReplace(srcstr, \"\\\\\\\\\", \"\\\\\")))\n            goto cleanup;\n\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_NETWORK);\n        disk->src->protocol = VIR_STORAGE_NET_PROTOCOL_RBD;\n        ret = virStorageSourceParseRBDColonString(tmpstr, disk->src);\n    } else {\n        if (virDomainDiskSetSource(disk, srcstr) < 0)\n            goto cleanup;\n\n        ret = 0;\n    }\n\n cleanup:\n    VIR_FREE(tmpstr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskDefNew",
          "args": [
            "NULL"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2093-2114",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDiskDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto error;\n\n    if (xmlopt &&\n        xmlopt->privateData.diskNew &&\n        !(ret->privateData = xmlopt->privateData.diskNew()))\n        goto error;\n\n    return ret;\n\n error:\n    virDomainDiskDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDiskDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto error;\n\n    if (xmlopt &&\n        xmlopt->privateData.diskNew &&\n        !(ret->privateData = xmlopt->privateData.diskNew()))\n        goto error;\n\n    return ret;\n\n error:\n    virDomainDiskDefFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlu_disk_parse",
          "args": [
            "xluconf",
            "1",
            "&disk_spec",
            "libxldisk"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_device_disk_init",
          "args": [
            "libxldisk"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlu_cfg_init",
          "args": [
            "stderr",
            "\"command line\""
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "libxldisk"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfGetValue",
          "args": [
            "conf",
            "\"disk\""
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "849-857",
          "snippet": "virConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvirConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLDisk(virConfPtr conf, virDomainDefPtr def)\n{\n    int ret = -1;\n    virConfValuePtr list = virConfGetValue(conf, \"disk\");\n    XLU_Config *xluconf;\n    libxl_device_disk *libxldisk;\n    virDomainDiskDefPtr disk = NULL;\n\n    if (VIR_ALLOC(libxldisk) < 0)\n        return -1;\n\n    if (!(xluconf = xlu_cfg_init(stderr, \"command line\")))\n        goto cleanup;\n\n    if (list && list->type == VIR_CONF_LIST) {\n        list = list->list;\n        while (list) {\n            const char *disk_spec = list->str;\n\n            if (list->type != VIR_CONF_STRING || list->str == NULL)\n                goto skipdisk;\n\n            libxl_device_disk_init(libxldisk);\n\n            if (xlu_disk_parse(xluconf, 1, &disk_spec, libxldisk))\n                goto fail;\n\n            if (!(disk = virDomainDiskDefNew(NULL)))\n                goto fail;\n\n            if (xenParseXLDiskSrc(disk, libxldisk->pdev_path) < 0)\n                goto fail;\n\n            disk->dst = g_strdup(libxldisk->vdev);\n\n            disk->src->readonly = !libxldisk->readwrite;\n            disk->removable = libxldisk->removable;\n\n            if (libxldisk->is_cdrom) {\n                if (virDomainDiskSetDriver(disk, \"qemu\") < 0)\n                    goto fail;\n\n                virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n                disk->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n                if (!disk->src->path || STREQ(disk->src->path, \"\"))\n                    disk->src->format = VIR_STORAGE_FILE_NONE;\n                else\n                    disk->src->format = VIR_STORAGE_FILE_RAW;\n            } else {\n                switch (libxldisk->format) {\n                case LIBXL_DISK_FORMAT_QCOW:\n                    disk->src->format = VIR_STORAGE_FILE_QCOW;\n                    break;\n\n                case LIBXL_DISK_FORMAT_QCOW2:\n                    disk->src->format = VIR_STORAGE_FILE_QCOW2;\n                    break;\n\n                case LIBXL_DISK_FORMAT_VHD:\n                    disk->src->format = VIR_STORAGE_FILE_VHD;\n                    break;\n\n                case LIBXL_DISK_FORMAT_RAW:\n                case LIBXL_DISK_FORMAT_UNKNOWN:\n                    disk->src->format = VIR_STORAGE_FILE_RAW;\n                    break;\n\n                case LIBXL_DISK_FORMAT_EMPTY:\n                    break;\n\n#ifdef LIBXL_HAVE_QED\n                case LIBXL_DISK_FORMAT_QED:\n                    disk->src->format = VIR_STORAGE_FILE_QED;\n                    break;\n#endif\n\n                default:\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"disk image format not supported: %s\"),\n                                   libxl_disk_format_to_string(libxldisk->format));\n                    goto fail;\n                }\n\n                switch (libxldisk->backend) {\n                case LIBXL_DISK_BACKEND_QDISK:\n                case LIBXL_DISK_BACKEND_UNKNOWN:\n                    if (virDomainDiskSetDriver(disk, \"qemu\") < 0)\n                        goto fail;\n                    if (virDomainDiskGetType(disk) == VIR_STORAGE_TYPE_NONE)\n                        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n                    break;\n\n                case LIBXL_DISK_BACKEND_TAP:\n                    if (virDomainDiskSetDriver(disk, \"tap\") < 0)\n                        goto fail;\n                    virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n                    break;\n\n                case LIBXL_DISK_BACKEND_PHY:\n                    if (virDomainDiskSetDriver(disk, \"phy\") < 0)\n                        goto fail;\n                    virDomainDiskSetType(disk, VIR_STORAGE_TYPE_BLOCK);\n                    break;\n                default:\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"disk backend not supported: %s\"),\n                                   libxl_disk_backend_to_string(libxldisk->backend));\n                    goto fail;\n                }\n            }\n\n            if (STRPREFIX(libxldisk->vdev, \"xvd\") ||\n                def->os.type != VIR_DOMAIN_OSTYPE_HVM)\n                disk->bus = VIR_DOMAIN_DISK_BUS_XEN;\n            else if (STRPREFIX(libxldisk->vdev, \"sd\"))\n                disk->bus = VIR_DOMAIN_DISK_BUS_SCSI;\n            else\n                disk->bus = VIR_DOMAIN_DISK_BUS_IDE;\n\n            if (VIR_APPEND_ELEMENT(def->disks, def->ndisks, disk) < 0)\n                goto fail;\n\n            libxl_device_disk_dispose(libxldisk);\n\n        skipdisk:\n            list = list->next;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    virDomainDiskDefFree(disk);\n    xlu_cfg_destroy(xluconf);\n    VIR_FREE(libxldisk);\n    return ret;\n\n fail:\n    libxl_device_disk_dispose(libxldisk);\n    goto cleanup;\n}"
  },
  {
    "function_name": "xenParseXLDiskSrc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "628-655",
    "snippet": "static int\nxenParseXLDiskSrc(virDomainDiskDefPtr disk, char *srcstr)\n{\n    char *tmpstr = NULL;\n    int ret = -1;\n\n    /* A NULL source is valid, e.g. an empty CDROM */\n    if (srcstr == NULL)\n        return 0;\n\n    if (STRPREFIX(srcstr, \"rbd:\")) {\n        if (!(tmpstr = virStringReplace(srcstr, \"\\\\\\\\\", \"\\\\\")))\n            goto cleanup;\n\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_NETWORK);\n        disk->src->protocol = VIR_STORAGE_NET_PROTOCOL_RBD;\n        ret = virStorageSourceParseRBDColonString(tmpstr, disk->src);\n    } else {\n        if (virDomainDiskSetSource(disk, srcstr) < 0)\n            goto cleanup;\n\n        ret = 0;\n    }\n\n cleanup:\n    VIR_FREE(tmpstr);\n    return ret;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmpstr"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskSetSource",
          "args": [
            "disk",
            "srcstr"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2162-2169",
          "snippet": "int\nvirDomainDiskSetSource(virDomainDiskDefPtr def, const char *src)\n{\n    char *tmp = g_strdup(src);\n    g_free(def->src->path);\n    def->src->path = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskSetSource(virDomainDiskDefPtr def, const char *src)\n{\n    char *tmp = g_strdup(src);\n    g_free(def->src->path);\n    def->src->path = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceParseRBDColonString",
          "args": [
            "tmpstr",
            "disk->src"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceParseRBDColonString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2940-3042",
          "snippet": "int\nvirStorageSourceParseRBDColonString(const char *rbdstr,\n                                    virStorageSourcePtr src)\n{\n    char *p, *e, *next;\n    g_autofree char *options = NULL;\n    g_autoptr(virStorageAuthDef) authdef = NULL;\n\n    /* optionally skip the \"rbd:\" prefix if provided */\n    if (STRPREFIX(rbdstr, \"rbd:\"))\n        rbdstr += strlen(\"rbd:\");\n\n    src->path = g_strdup(rbdstr);\n\n    p = strchr(src->path, ':');\n    if (p) {\n        options = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* snapshot name */\n    if ((p = strchr(src->path, '@'))) {\n        src->snapshot = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* pool vs. image name */\n    if ((p = strchr(src->path, '/'))) {\n        src->volume = g_steal_pointer(&src->path);\n        src->path = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* options */\n    if (!options)\n        return 0; /* all done */\n\n    p = options;\n    while (*p) {\n        /* find : delimiter or end of string */\n        for (e = p; *e && *e != ':'; ++e) {\n            if (*e == '\\\\') {\n                e++;\n                if (*e == '\\0')\n                    break;\n            }\n        }\n        if (*e == '\\0') {\n            next = e;    /* last kv pair */\n        } else {\n            next = e + 1;\n            *e = '\\0';\n        }\n\n        if (STRPREFIX(p, \"id=\")) {\n            /* formulate authdef for src->auth */\n            if (src->auth) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"duplicate 'id' found in '%s'\"), src->path);\n                return -1;\n            }\n            if (VIR_ALLOC(authdef) < 0)\n                return -1;\n\n            authdef->username = g_strdup(p + strlen(\"id=\"));\n\n            authdef->secrettype = g_strdup(virSecretUsageTypeToString(VIR_SECRET_USAGE_TYPE_CEPH));\n            src->auth = g_steal_pointer(&authdef);\n            src->authInherited = true;\n\n            /* Cannot formulate a secretType (eg, usage or uuid) given\n             * what is provided.\n             */\n        }\n        if (STRPREFIX(p, \"mon_host=\")) {\n            char *h, *sep;\n\n            h = p + strlen(\"mon_host=\");\n            while (h < e) {\n                for (sep = h; sep < e; ++sep) {\n                    if (*sep == '\\\\' && (sep[1] == ',' ||\n                                         sep[1] == ';' ||\n                                         sep[1] == ' ')) {\n                        *sep = '\\0';\n                        sep += 2;\n                        break;\n                    }\n                }\n\n                if (virStorageSourceRBDAddHost(src, h) < 0)\n                    return -1;\n\n                h = sep;\n            }\n        }\n\n        if (STRPREFIX(p, \"conf=\"))\n            src->configFile = g_strdup(p + strlen(\"conf=\"));\n\n        p = next;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceParseRBDColonString(const char *rbdstr,\n                                    virStorageSourcePtr src)\n{\n    char *p, *e, *next;\n    g_autofree char *options = NULL;\n    g_autoptr(virStorageAuthDef) authdef = NULL;\n\n    /* optionally skip the \"rbd:\" prefix if provided */\n    if (STRPREFIX(rbdstr, \"rbd:\"))\n        rbdstr += strlen(\"rbd:\");\n\n    src->path = g_strdup(rbdstr);\n\n    p = strchr(src->path, ':');\n    if (p) {\n        options = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* snapshot name */\n    if ((p = strchr(src->path, '@'))) {\n        src->snapshot = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* pool vs. image name */\n    if ((p = strchr(src->path, '/'))) {\n        src->volume = g_steal_pointer(&src->path);\n        src->path = g_strdup(p + 1);\n        *p = '\\0';\n    }\n\n    /* options */\n    if (!options)\n        return 0; /* all done */\n\n    p = options;\n    while (*p) {\n        /* find : delimiter or end of string */\n        for (e = p; *e && *e != ':'; ++e) {\n            if (*e == '\\\\') {\n                e++;\n                if (*e == '\\0')\n                    break;\n            }\n        }\n        if (*e == '\\0') {\n            next = e;    /* last kv pair */\n        } else {\n            next = e + 1;\n            *e = '\\0';\n        }\n\n        if (STRPREFIX(p, \"id=\")) {\n            /* formulate authdef for src->auth */\n            if (src->auth) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"duplicate 'id' found in '%s'\"), src->path);\n                return -1;\n            }\n            if (VIR_ALLOC(authdef) < 0)\n                return -1;\n\n            authdef->username = g_strdup(p + strlen(\"id=\"));\n\n            authdef->secrettype = g_strdup(virSecretUsageTypeToString(VIR_SECRET_USAGE_TYPE_CEPH));\n            src->auth = g_steal_pointer(&authdef);\n            src->authInherited = true;\n\n            /* Cannot formulate a secretType (eg, usage or uuid) given\n             * what is provided.\n             */\n        }\n        if (STRPREFIX(p, \"mon_host=\")) {\n            char *h, *sep;\n\n            h = p + strlen(\"mon_host=\");\n            while (h < e) {\n                for (sep = h; sep < e; ++sep) {\n                    if (*sep == '\\\\' && (sep[1] == ',' ||\n                                         sep[1] == ';' ||\n                                         sep[1] == ' ')) {\n                        *sep = '\\0';\n                        sep += 2;\n                        break;\n                    }\n                }\n\n                if (virStorageSourceRBDAddHost(src, h) < 0)\n                    return -1;\n\n                h = sep;\n            }\n        }\n\n        if (STRPREFIX(p, \"conf=\"))\n            src->configFile = g_strdup(p + strlen(\"conf=\"));\n\n        p = next;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskSetType",
          "args": [
            "disk",
            "VIR_STORAGE_TYPE_NETWORK"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2148-2152",
          "snippet": "void\nvirDomainDiskSetType(virDomainDiskDefPtr def, int type)\n{\n    def->src->type = type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDiskSetType(virDomainDiskDefPtr def, int type)\n{\n    def->src->type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringReplace",
          "args": [
            "srcstr",
            "\"\\\\\\\\\"",
            "\"\\\\\""
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "virStringReplace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1067-1095",
          "snippet": "char *\nvirStringReplace(const char *haystack,\n                 const char *oldneedle,\n                 const char *newneedle)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *tmp1, *tmp2;\n    size_t oldneedlelen = strlen(oldneedle);\n    size_t newneedlelen = strlen(newneedle);\n\n    tmp1 = haystack;\n    tmp2 = NULL;\n\n    while (tmp1) {\n        tmp2 = strstr(tmp1, oldneedle);\n\n        if (tmp2) {\n            virBufferAdd(&buf, tmp1, (tmp2 - tmp1));\n            virBufferAdd(&buf, newneedle, newneedlelen);\n            tmp2 += oldneedlelen;\n        } else {\n            virBufferAdd(&buf, tmp1, -1);\n        }\n\n        tmp1 = tmp2;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar *\nvirStringReplace(const char *haystack,\n                 const char *oldneedle,\n                 const char *newneedle)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *tmp1, *tmp2;\n    size_t oldneedlelen = strlen(oldneedle);\n    size_t newneedlelen = strlen(newneedle);\n\n    tmp1 = haystack;\n    tmp2 = NULL;\n\n    while (tmp1) {\n        tmp2 = strstr(tmp1, oldneedle);\n\n        if (tmp2) {\n            virBufferAdd(&buf, tmp1, (tmp2 - tmp1));\n            virBufferAdd(&buf, newneedle, newneedlelen);\n            tmp2 += oldneedlelen;\n        } else {\n            virBufferAdd(&buf, tmp1, -1);\n        }\n\n        tmp1 = tmp2;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "srcstr",
            "\"rbd:\""
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLDiskSrc(virDomainDiskDefPtr disk, char *srcstr)\n{\n    char *tmpstr = NULL;\n    int ret = -1;\n\n    /* A NULL source is valid, e.g. an empty CDROM */\n    if (srcstr == NULL)\n        return 0;\n\n    if (STRPREFIX(srcstr, \"rbd:\")) {\n        if (!(tmpstr = virStringReplace(srcstr, \"\\\\\\\\\", \"\\\\\")))\n            goto cleanup;\n\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_NETWORK);\n        disk->src->protocol = VIR_STORAGE_NET_PROTOCOL_RBD;\n        ret = virStorageSourceParseRBDColonString(tmpstr, disk->src);\n    } else {\n        if (virDomainDiskSetSource(disk, srcstr) < 0)\n            goto cleanup;\n\n        ret = 0;\n    }\n\n cleanup:\n    VIR_FREE(tmpstr);\n    return ret;\n}"
  },
  {
    "function_name": "xenParseXLGntLimits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "601-625",
    "snippet": "static int\nxenParseXLGntLimits(virConfPtr conf, virDomainDefPtr def)\n{\n    unsigned long max_gntframes;\n    int ctlr_idx;\n    virDomainControllerDefPtr xenbus_ctlr;\n\n    if (xenConfigGetULong(conf, \"max_grant_frames\", &max_gntframes, 0) < 0)\n        return -1;\n\n    if (max_gntframes <= 0)\n        return 0;\n\n    ctlr_idx = virDomainControllerFindByType(def, VIR_DOMAIN_CONTROLLER_TYPE_XENBUS);\n    if (ctlr_idx == -1)\n        xenbus_ctlr = virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_XENBUS, -1, -1);\n    else\n        xenbus_ctlr = def->controllers[ctlr_idx];\n\n    if (xenbus_ctlr == NULL)\n        return -1;\n\n    xenbus_ctlr->opts.xenbusopts.maxGrantFrames = max_gntframes;\n    return 0;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefAddController",
          "args": [
            "def",
            "VIR_DOMAIN_CONTROLLER_TYPE_XENBUS",
            "-1",
            "-1"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefAddController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "18932-18952",
          "snippet": "virDomainControllerDefPtr\nvirDomainDefAddController(virDomainDefPtr def, int type, int idx, int model)\n{\n    virDomainControllerDefPtr cont;\n\n    if (!(cont = virDomainControllerDefNew(type)))\n        return NULL;\n\n    if (idx < 0)\n        idx = virDomainControllerFindUnusedIndex(def, type);\n\n    cont->idx = idx;\n    cont->model = model;\n\n    if (VIR_APPEND_ELEMENT_COPY(def->controllers, def->ncontrollers, cont) < 0) {\n        VIR_FREE(cont);\n        return NULL;\n    }\n\n    return cont;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainControllerDefPtr\nvirDomainDefAddController(virDomainDefPtr def, int type, int idx, int model)\n{\n    virDomainControllerDefPtr cont;\n\n    if (!(cont = virDomainControllerDefNew(type)))\n        return NULL;\n\n    if (idx < 0)\n        idx = virDomainControllerFindUnusedIndex(def, type);\n\n    cont->idx = idx;\n    cont->model = model;\n\n    if (VIR_APPEND_ELEMENT_COPY(def->controllers, def->ncontrollers, cont) < 0) {\n        VIR_FREE(cont);\n        return NULL;\n    }\n\n    return cont;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainControllerFindByType",
          "args": [
            "def",
            "VIR_DOMAIN_CONTROLLER_TYPE_XENBUS"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainControllerFindByType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17867-17879",
          "snippet": "int\nvirDomainControllerFindByType(virDomainDefPtr def,\n                              int type)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == type)\n            return i;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainControllerFindByType(virDomainDefPtr def,\n                              int type)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == type)\n            return i;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigGetULong",
          "args": [
            "conf",
            "\"max_grant_frames\"",
            "&max_gntframes",
            "0"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "106-134",
          "snippet": "static int\nxenConfigGetULongLong(virConfPtr conf,\n                      const char *name,\n                      unsigned long long *value,\n                      unsigned long long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ull(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenConfigGetULongLong(virConfPtr conf,\n                      const char *name,\n                      unsigned long long *value,\n                      unsigned long long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ull(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLGntLimits(virConfPtr conf, virDomainDefPtr def)\n{\n    unsigned long max_gntframes;\n    int ctlr_idx;\n    virDomainControllerDefPtr xenbus_ctlr;\n\n    if (xenConfigGetULong(conf, \"max_grant_frames\", &max_gntframes, 0) < 0)\n        return -1;\n\n    if (max_gntframes <= 0)\n        return 0;\n\n    ctlr_idx = virDomainControllerFindByType(def, VIR_DOMAIN_CONTROLLER_TYPE_XENBUS);\n    if (ctlr_idx == -1)\n        xenbus_ctlr = virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_XENBUS, -1, -1);\n    else\n        xenbus_ctlr = def->controllers[ctlr_idx];\n\n    if (xenbus_ctlr == NULL)\n        return -1;\n\n    xenbus_ctlr->opts.xenbusopts.maxGrantFrames = max_gntframes;\n    return 0;\n}"
  },
  {
    "function_name": "xenParseXLVnuma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "412-597",
    "snippet": "static int\nxenParseXLVnuma(virConfPtr conf,\n                virDomainDefPtr def)\n{\n    int ret = -1;\n    char *tmp = NULL;\n    char **token = NULL;\n    size_t vcpus = 0;\n    size_t nr_nodes = 0;\n    size_t vnodeCnt = 0;\n    virCPUDefPtr cpu = NULL;\n    virConfValuePtr list;\n    virConfValuePtr vnode;\n    virDomainNumaPtr numa;\n\n    numa = def->numa;\n    if (numa == NULL)\n        return -1;\n\n    list = virConfGetValue(conf, \"vnuma\");\n    if (!list || list->type != VIR_CONF_LIST)\n        return 0;\n\n    vnode = list->list;\n    while (vnode && vnode->type == VIR_CONF_LIST) {\n        vnode = vnode->next;\n        nr_nodes++;\n    }\n\n    if (!virDomainNumaSetNodeCount(numa, nr_nodes))\n        goto cleanup;\n\n    cpu = virCPUDefNew();\n\n    list = list->list;\n    while (list) {\n        int pnode = -1;\n        virBitmapPtr cpumask = NULL;\n        unsigned long long kbsize = 0;\n\n        /* Is there a sublist (vnode)? */\n        if (list && list->type == VIR_CONF_LIST) {\n            vnode = list->list;\n\n            while (vnode && vnode->type == VIR_CONF_STRING) {\n                const char *data;\n                const char *str = vnode->str;\n\n                if (!str ||\n                   !(data = strrchr(str, '='))) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"vnuma vnode invalid format '%s'\"),\n                                   str);\n                    goto cleanup;\n                }\n                data++;\n\n                if (*data) {\n                    char vtoken[64];\n\n                    if (STRPREFIX(str, \"pnode\")) {\n                        unsigned int cellid;\n\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu pnode '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        if ((virStrToLong_ui(vtoken, NULL, 10, &cellid) < 0) ||\n                            (cellid >= nr_nodes)) {\n                            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                           _(\"vnuma vnode %zu contains invalid pnode value '%s'\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n                        pnode = cellid;\n                    } else if (STRPREFIX(str, \"size\")) {\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu size '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        if (virStrToLong_ull(vtoken, NULL, 10, &kbsize) < 0)\n                            goto cleanup;\n\n                        virDomainNumaSetNodeMemorySize(numa, vnodeCnt, (kbsize * 1024));\n\n                    } else if (STRPREFIX(str, \"vcpus\")) {\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu vcpus '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        if ((virBitmapParse(vtoken, &cpumask, VIR_DOMAIN_CPUMASK_LEN) < 0) ||\n                            (virDomainNumaSetNodeCpumask(numa, vnodeCnt, cpumask) == NULL))\n                            goto cleanup;\n\n                        vcpus += virBitmapCountBits(cpumask);\n\n                    } else if (STRPREFIX(str, \"vdistances\")) {\n                        size_t i, ndistances;\n                        unsigned int value;\n\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu vdistances '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        VIR_FREE(tmp);\n                        tmp = g_strdup(vtoken);\n\n                        virStringListFree(token);\n                        if (!(token = virStringSplitCount(tmp, \",\", 0, &ndistances)))\n                            goto cleanup;\n\n                        if (ndistances != nr_nodes) {\n                            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                       _(\"vnuma pnode %d configured '%s' (count %zu) doesn't fit the number of specified vnodes %zu\"),\n                                       pnode, str, ndistances, nr_nodes);\n                            goto cleanup;\n                        }\n\n                        if (virDomainNumaSetNodeDistanceCount(numa, vnodeCnt, ndistances) != ndistances)\n                            goto cleanup;\n\n                        for (i = 0; i < ndistances; i++) {\n                            if ((virStrToLong_ui(token[i], NULL, 10, &value) < 0) ||\n                                (virDomainNumaSetNodeDistance(numa, vnodeCnt, i, value) != value))\n                                goto cleanup;\n                        }\n\n                    } else {\n                        virReportError(VIR_ERR_CONF_SYNTAX,\n                                       _(\"Invalid vnuma configuration for vnode %zu\"),\n                                       vnodeCnt);\n                        goto cleanup;\n                    }\n                }\n                vnode = vnode->next;\n            }\n        }\n\n        if ((pnode < 0) ||\n            (cpumask == NULL) ||\n            (kbsize == 0)) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Incomplete vnuma configuration for vnode %zu\"),\n                           vnodeCnt);\n            goto cleanup;\n        }\n\n        list = list->next;\n        vnodeCnt++;\n    }\n\n    if (def->maxvcpus == 0)\n        def->maxvcpus = vcpus;\n\n    if (def->maxvcpus < vcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"vnuma configuration contains %zu vcpus, which is greater than %zu maxvcpus\"),\n                       vcpus, def->maxvcpus);\n        goto cleanup;\n    }\n\n    cpu->type = VIR_CPU_TYPE_GUEST;\n    def->cpu = cpu;\n\n    ret = 0;\n\n cleanup:\n    if (ret)\n        VIR_FREE(cpu);\n    virStringListFree(token);\n    VIR_FREE(tmp);\n\n    return ret;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "token"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpu"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"vnuma configuration contains %zu vcpus, which is greater than %zu maxvcpus\")",
            "vcpus",
            "def->maxvcpus"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"vnuma configuration contains %zu vcpus, which is greater than %zu maxvcpus\""
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONF_SYNTAX",
            "_(\"Incomplete vnuma configuration for vnode %zu\")",
            "vnodeCnt"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONF_SYNTAX",
            "_(\"Invalid vnuma configuration for vnode %zu\")",
            "vnodeCnt"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumaSetNodeDistance",
          "args": [
            "numa",
            "vnodeCnt",
            "i",
            "value"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaSetNodeDistance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1234-1285",
          "snippet": "int\nvirDomainNumaSetNodeDistance(virDomainNumaPtr numa,\n                             size_t node,\n                             size_t cellid,\n                             unsigned int value)\n{\n    virDomainNumaDistancePtr distances;\n\n    if (node >= numa->nmem_nodes) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Argument 'node' %zu outranges \"\n                         \"defined number of NUMA nodes\"),\n                       node);\n        return -1;\n    }\n\n    distances = numa->mem_nodes[node].distances;\n    if (!distances ||\n        cellid >= numa->mem_nodes[node].ndistances) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Arguments under memnode element do not \"\n                         \"correspond with existing guest's NUMA cell\"));\n        return -1;\n    }\n\n    /*\n     * Advanced Configuration and Power Interface\n     * Specification version 6.1. Chapter 5.2.17\n     * System Locality Distance Information Table\n     * ... Distance values of 0-9 are reserved.\n     */\n    if (value < LOCAL_DISTANCE ||\n        value > UNREACHABLE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Distance value of %d is not in valid range\"),\n                       value);\n        return -1;\n    }\n\n    if (value == LOCAL_DISTANCE && node != cellid) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Distance value %d under node %zu is \"\n                         \"LOCAL_DISTANCE and should be set to 10\"),\n                       value, node);\n        return -1;\n    }\n\n    distances[cellid].cellid = cellid;\n    distances[cellid].value = value;\n\n    return distances[cellid].value;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define UNREACHABLE            255",
            "#define LOCAL_DISTANCE          10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\n#define UNREACHABLE            255\n#define LOCAL_DISTANCE          10\n\nint\nvirDomainNumaSetNodeDistance(virDomainNumaPtr numa,\n                             size_t node,\n                             size_t cellid,\n                             unsigned int value)\n{\n    virDomainNumaDistancePtr distances;\n\n    if (node >= numa->nmem_nodes) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Argument 'node' %zu outranges \"\n                         \"defined number of NUMA nodes\"),\n                       node);\n        return -1;\n    }\n\n    distances = numa->mem_nodes[node].distances;\n    if (!distances ||\n        cellid >= numa->mem_nodes[node].ndistances) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Arguments under memnode element do not \"\n                         \"correspond with existing guest's NUMA cell\"));\n        return -1;\n    }\n\n    /*\n     * Advanced Configuration and Power Interface\n     * Specification version 6.1. Chapter 5.2.17\n     * System Locality Distance Information Table\n     * ... Distance values of 0-9 are reserved.\n     */\n    if (value < LOCAL_DISTANCE ||\n        value > UNREACHABLE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Distance value of %d is not in valid range\"),\n                       value);\n        return -1;\n    }\n\n    if (value == LOCAL_DISTANCE && node != cellid) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Distance value %d under node %zu is \"\n                         \"LOCAL_DISTANCE and should be set to 10\"),\n                       value, node);\n        return -1;\n    }\n\n    distances[cellid].cellid = cellid;\n    distances[cellid].value = value;\n\n    return distances[cellid].value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "token[i]",
            "NULL",
            "10",
            "&value"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaSetNodeDistanceCount",
          "args": [
            "numa",
            "vnodeCnt",
            "ndistances"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaSetNodeDistanceCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1288-1310",
          "snippet": "size_t\nvirDomainNumaSetNodeDistanceCount(virDomainNumaPtr numa,\n                                  size_t node,\n                                  size_t ndistances)\n{\n    virDomainNumaDistancePtr distances;\n\n    distances = numa->mem_nodes[node].distances;\n    if (distances) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot alter an existing nmem_nodes distances set for node: %zu\"),\n                       node);\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(distances, ndistances) < 0)\n        return 0;\n\n    numa->mem_nodes[node].distances = distances;\n    numa->mem_nodes[node].ndistances = ndistances;\n\n    return numa->mem_nodes[node].ndistances;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nsize_t\nvirDomainNumaSetNodeDistanceCount(virDomainNumaPtr numa,\n                                  size_t node,\n                                  size_t ndistances)\n{\n    virDomainNumaDistancePtr distances;\n\n    distances = numa->mem_nodes[node].distances;\n    if (distances) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot alter an existing nmem_nodes distances set for node: %zu\"),\n                       node);\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(distances, ndistances) < 0)\n        return 0;\n\n    numa->mem_nodes[node].distances = distances;\n    numa->mem_nodes[node].ndistances = ndistances;\n\n    return numa->mem_nodes[node].ndistances;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"vnuma pnode %d configured '%s' (count %zu) doesn't fit the number of specified vnodes %zu\")",
            "pnode",
            "str",
            "ndistances",
            "nr_nodes"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringSplitCount",
          "args": [
            "tmp",
            "\",\"",
            "0",
            "&ndistances"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplitCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "69-123",
          "snippet": "char **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "vtoken"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"vnuma vnode %zu vdistances '%s' too long for destination\")",
            "vnodeCnt",
            "data"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "vtoken",
            "data"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "str",
            "\"vdistances\""
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapCountBits",
          "args": [
            "cpumask"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapCountBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1122-1132",
          "snippet": "size_t\nvirBitmapCountBits(virBitmapPtr bitmap)\n{\n    size_t i;\n    size_t ret = 0;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        ret += __builtin_popcountl(bitmap->map[i]);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nsize_t\nvirBitmapCountBits(virBitmapPtr bitmap)\n{\n    size_t i;\n    size_t ret = 0;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        ret += __builtin_popcountl(bitmap->map[i]);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaSetNodeCpumask",
          "args": [
            "numa",
            "vnodeCnt",
            "cpumask"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaSetNodeCpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1321-1329",
          "snippet": "virBitmapPtr\nvirDomainNumaSetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node,\n                            virBitmapPtr cpumask)\n{\n    numa->mem_nodes[node].cpumask = cpumask;\n\n    return numa->mem_nodes[node].cpumask;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirBitmapPtr\nvirDomainNumaSetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node,\n                            virBitmapPtr cpumask)\n{\n    numa->mem_nodes[node].cpumask = cpumask;\n\n    return numa->mem_nodes[node].cpumask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapParse",
          "args": [
            "vtoken",
            "&cpumask",
            "VIR_DOMAIN_CPUMASK_LEN"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "581-587",
          "snippet": "int\nvirBitmapParse(const char *str,\n               virBitmapPtr *bitmap,\n               size_t bitmapSize)\n{\n    return virBitmapParseSeparator(str, '\\0', bitmap, bitmapSize);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapParse(const char *str,\n               virBitmapPtr *bitmap,\n               size_t bitmapSize)\n{\n    return virBitmapParseSeparator(str, '\\0', bitmap, bitmapSize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"vnuma vnode %zu vcpus '%s' too long for destination\")",
            "vnodeCnt",
            "data"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "vtoken",
            "data"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "str",
            "\"vcpus\""
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumaSetNodeMemorySize",
          "args": [
            "numa",
            "vnodeCnt",
            "(kbsize * 1024)"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaSetNodeMemorySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1356-1362",
          "snippet": "void\nvirDomainNumaSetNodeMemorySize(virDomainNumaPtr numa,\n                               size_t node,\n                               unsigned long long size)\n{\n    numa->mem_nodes[node].mem = size;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvoid\nvirDomainNumaSetNodeMemorySize(virDomainNumaPtr numa,\n                               size_t node,\n                               unsigned long long size)\n{\n    numa->mem_nodes[node].mem = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "vtoken",
            "NULL",
            "10",
            "&kbsize"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"vnuma vnode %zu size '%s' too long for destination\")",
            "vnodeCnt",
            "data"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "vtoken",
            "data"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "str",
            "\"size\""
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"vnuma vnode %zu contains invalid pnode value '%s'\")",
            "vnodeCnt",
            "data"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"vnuma vnode %zu pnode '%s' too long for destination\")",
            "vnodeCnt",
            "data"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "vtoken",
            "data"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "str",
            "\"pnode\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"vnuma vnode invalid format '%s'\")",
            "str"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "'='"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefNew",
          "args": [],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "85-90",
          "snippet": "virCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaSetNodeCount",
          "args": [
            "numa",
            "nr_nodes"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaSetNodeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1147-1168",
          "snippet": "size_t\nvirDomainNumaSetNodeCount(virDomainNumaPtr numa, size_t nmem_nodes)\n{\n    if (!nmem_nodes) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set an empty mem_nodes set\"));\n        return 0;\n    }\n\n    if (numa->mem_nodes) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot alter an existing mem_nodes set\"));\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(numa->mem_nodes, nmem_nodes) < 0)\n        return 0;\n\n    numa->nmem_nodes = nmem_nodes;\n\n    return numa->nmem_nodes;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nsize_t\nvirDomainNumaSetNodeCount(virDomainNumaPtr numa, size_t nmem_nodes)\n{\n    if (!nmem_nodes) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set an empty mem_nodes set\"));\n        return 0;\n    }\n\n    if (numa->mem_nodes) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot alter an existing mem_nodes set\"));\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(numa->mem_nodes, nmem_nodes) < 0)\n        return 0;\n\n    numa->nmem_nodes = nmem_nodes;\n\n    return numa->nmem_nodes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValue",
          "args": [
            "conf",
            "\"vnuma\""
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "849-857",
          "snippet": "virConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvirConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLVnuma(virConfPtr conf,\n                virDomainDefPtr def)\n{\n    int ret = -1;\n    char *tmp = NULL;\n    char **token = NULL;\n    size_t vcpus = 0;\n    size_t nr_nodes = 0;\n    size_t vnodeCnt = 0;\n    virCPUDefPtr cpu = NULL;\n    virConfValuePtr list;\n    virConfValuePtr vnode;\n    virDomainNumaPtr numa;\n\n    numa = def->numa;\n    if (numa == NULL)\n        return -1;\n\n    list = virConfGetValue(conf, \"vnuma\");\n    if (!list || list->type != VIR_CONF_LIST)\n        return 0;\n\n    vnode = list->list;\n    while (vnode && vnode->type == VIR_CONF_LIST) {\n        vnode = vnode->next;\n        nr_nodes++;\n    }\n\n    if (!virDomainNumaSetNodeCount(numa, nr_nodes))\n        goto cleanup;\n\n    cpu = virCPUDefNew();\n\n    list = list->list;\n    while (list) {\n        int pnode = -1;\n        virBitmapPtr cpumask = NULL;\n        unsigned long long kbsize = 0;\n\n        /* Is there a sublist (vnode)? */\n        if (list && list->type == VIR_CONF_LIST) {\n            vnode = list->list;\n\n            while (vnode && vnode->type == VIR_CONF_STRING) {\n                const char *data;\n                const char *str = vnode->str;\n\n                if (!str ||\n                   !(data = strrchr(str, '='))) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"vnuma vnode invalid format '%s'\"),\n                                   str);\n                    goto cleanup;\n                }\n                data++;\n\n                if (*data) {\n                    char vtoken[64];\n\n                    if (STRPREFIX(str, \"pnode\")) {\n                        unsigned int cellid;\n\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu pnode '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        if ((virStrToLong_ui(vtoken, NULL, 10, &cellid) < 0) ||\n                            (cellid >= nr_nodes)) {\n                            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                           _(\"vnuma vnode %zu contains invalid pnode value '%s'\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n                        pnode = cellid;\n                    } else if (STRPREFIX(str, \"size\")) {\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu size '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        if (virStrToLong_ull(vtoken, NULL, 10, &kbsize) < 0)\n                            goto cleanup;\n\n                        virDomainNumaSetNodeMemorySize(numa, vnodeCnt, (kbsize * 1024));\n\n                    } else if (STRPREFIX(str, \"vcpus\")) {\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu vcpus '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        if ((virBitmapParse(vtoken, &cpumask, VIR_DOMAIN_CPUMASK_LEN) < 0) ||\n                            (virDomainNumaSetNodeCpumask(numa, vnodeCnt, cpumask) == NULL))\n                            goto cleanup;\n\n                        vcpus += virBitmapCountBits(cpumask);\n\n                    } else if (STRPREFIX(str, \"vdistances\")) {\n                        size_t i, ndistances;\n                        unsigned int value;\n\n                        if (virStrcpyStatic(vtoken, data) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"vnuma vnode %zu vdistances '%s' too long for destination\"),\n                                           vnodeCnt, data);\n                            goto cleanup;\n                        }\n\n                        VIR_FREE(tmp);\n                        tmp = g_strdup(vtoken);\n\n                        virStringListFree(token);\n                        if (!(token = virStringSplitCount(tmp, \",\", 0, &ndistances)))\n                            goto cleanup;\n\n                        if (ndistances != nr_nodes) {\n                            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                       _(\"vnuma pnode %d configured '%s' (count %zu) doesn't fit the number of specified vnodes %zu\"),\n                                       pnode, str, ndistances, nr_nodes);\n                            goto cleanup;\n                        }\n\n                        if (virDomainNumaSetNodeDistanceCount(numa, vnodeCnt, ndistances) != ndistances)\n                            goto cleanup;\n\n                        for (i = 0; i < ndistances; i++) {\n                            if ((virStrToLong_ui(token[i], NULL, 10, &value) < 0) ||\n                                (virDomainNumaSetNodeDistance(numa, vnodeCnt, i, value) != value))\n                                goto cleanup;\n                        }\n\n                    } else {\n                        virReportError(VIR_ERR_CONF_SYNTAX,\n                                       _(\"Invalid vnuma configuration for vnode %zu\"),\n                                       vnodeCnt);\n                        goto cleanup;\n                    }\n                }\n                vnode = vnode->next;\n            }\n        }\n\n        if ((pnode < 0) ||\n            (cpumask == NULL) ||\n            (kbsize == 0)) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Incomplete vnuma configuration for vnode %zu\"),\n                           vnodeCnt);\n            goto cleanup;\n        }\n\n        list = list->next;\n        vnodeCnt++;\n    }\n\n    if (def->maxvcpus == 0)\n        def->maxvcpus = vcpus;\n\n    if (def->maxvcpus < vcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"vnuma configuration contains %zu vcpus, which is greater than %zu maxvcpus\"),\n                       vcpus, def->maxvcpus);\n        goto cleanup;\n    }\n\n    cpu->type = VIR_CPU_TYPE_GUEST;\n    def->cpu = cpu;\n\n    ret = 0;\n\n cleanup:\n    if (ret)\n        VIR_FREE(cpu);\n    virStringListFree(token);\n    VIR_FREE(tmp);\n\n    return ret;\n}"
  },
  {
    "function_name": "xenParseXLSpice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "334-409",
    "snippet": "static int\nxenParseXLSpice(virConfPtr conf, virDomainDefPtr def)\n{\n    virDomainGraphicsDefPtr graphics = NULL;\n    unsigned long port;\n    char *listenAddr = NULL;\n    int val;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (xenConfigGetBool(conf, \"spice\", &val, 0) < 0)\n            return -1;\n\n        if (val) {\n            if (VIR_ALLOC(graphics) < 0)\n                return -1;\n\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SPICE;\n            if (xenConfigCopyStringOpt(conf, \"spicehost\", &listenAddr) < 0)\n                goto cleanup;\n            if (virDomainGraphicsListenAppendAddress(graphics, listenAddr) < 0)\n                goto cleanup;\n            VIR_FREE(listenAddr);\n\n            if (xenConfigGetULong(conf, \"spicetls_port\", &port, 0) < 0)\n                goto cleanup;\n            graphics->data.spice.tlsPort = (int)port;\n\n            if (xenConfigGetULong(conf, \"spiceport\", &port, 0) < 0)\n                goto cleanup;\n\n            graphics->data.spice.port = (int)port;\n\n            if (!graphics->data.spice.tlsPort &&\n                !graphics->data.spice.port)\n            graphics->data.spice.autoport = 1;\n\n            if (xenConfigGetBool(conf, \"spicedisable_ticketing\", &val, 0) < 0)\n                goto cleanup;\n            if (!val) {\n                if (xenConfigCopyString(conf, \"spicepasswd\",\n                                        &graphics->data.spice.auth.passwd) < 0)\n                    goto cleanup;\n            }\n\n            if (xenConfigGetBool(conf, \"spiceagent_mouse\",\n                                 &val, 0) < 0)\n                goto cleanup;\n            if (val) {\n                graphics->data.spice.mousemode =\n                    VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_CLIENT;\n            } else {\n                graphics->data.spice.mousemode =\n                    VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_SERVER;\n            }\n\n            if (xenConfigGetBool(conf, \"spice_clipboard_sharing\", &val, 0) < 0)\n                goto cleanup;\n            if (val)\n                graphics->data.spice.copypaste = VIR_TRISTATE_BOOL_YES;\n            else\n                graphics->data.spice.copypaste = VIR_TRISTATE_BOOL_NO;\n\n            if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                goto cleanup;\n            def->graphics[0] = graphics;\n            def->ngraphics = 1;\n        }\n    }\n\n    return 0;\n\n cleanup:\n    VIR_FREE(listenAddr);\n    virDomainGraphicsDefFree(graphics);\n    return -1;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainGraphicsDefFree",
          "args": [
            "graphics"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1719-1764",
          "snippet": "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    switch (def->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        VIR_FREE(def->data.vnc.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.vnc.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n        VIR_FREE(def->data.sdl.display);\n        VIR_FREE(def->data.sdl.xauth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n        VIR_FREE(def->data.desktop.display);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        VIR_FREE(def->data.spice.rendernode);\n        VIR_FREE(def->data.spice.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.spice.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        VIR_FREE(def->data.egl_headless.rendernode);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    for (i = 0; i < def->nListens; i++)\n        virDomainGraphicsListenDefClear(&def->listens[i]);\n    VIR_FREE(def->listens);\n\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    switch (def->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        VIR_FREE(def->data.vnc.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.vnc.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n        VIR_FREE(def->data.sdl.display);\n        VIR_FREE(def->data.sdl.xauth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n        VIR_FREE(def->data.desktop.display);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        VIR_FREE(def->data.spice.rendernode);\n        VIR_FREE(def->data.spice.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.spice.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        VIR_FREE(def->data.egl_headless.rendernode);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    for (i = 0; i < def->nListens; i++)\n        virDomainGraphicsListenDefClear(&def->listens[i]);\n    VIR_FREE(def->listens);\n\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "listenAddr"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->graphics",
            "1"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigGetBool",
          "args": [
            "conf",
            "\"spice_clipboard_sharing\"",
            "&val",
            "0"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "42-66",
          "snippet": "int\nxenConfigGetBool(virConfPtr conf,\n                 const char *name,\n                 int *value,\n                 int def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l ? 1 : 0;\n    } else if (val->type == VIR_CONF_STRING) {\n        *value = STREQ(val->str, \"1\") ? 1 : 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetBool(virConfPtr conf,\n                 const char *name,\n                 int *value,\n                 int def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l ? 1 : 0;\n    } else if (val->type == VIR_CONF_STRING) {\n        *value = STREQ(val->str, \"1\") ? 1 : 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigCopyString",
          "args": [
            "conf",
            "\"spicepasswd\"",
            "&graphics->data.spice.auth.passwd"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigCopyStringOpt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "168-172",
          "snippet": "int\nxenConfigCopyStringOpt(virConfPtr conf, const char *name, char **value)\n{\n    return xenConfigCopyStringInternal(conf, name, value, 1);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigCopyStringOpt(virConfPtr conf, const char *name, char **value)\n{\n    return xenConfigCopyStringInternal(conf, name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigGetULong",
          "args": [
            "conf",
            "\"spiceport\"",
            "&port",
            "0"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "106-134",
          "snippet": "static int\nxenConfigGetULongLong(virConfPtr conf,\n                      const char *name,\n                      unsigned long long *value,\n                      unsigned long long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ull(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenConfigGetULongLong(virConfPtr conf,\n                      const char *name,\n                      unsigned long long *value,\n                      unsigned long long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ull(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "listenAddr"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsListenAppendAddress",
          "args": [
            "graphics",
            "listenAddr"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsListenAppendAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30367-30386",
          "snippet": "int\nvirDomainGraphicsListenAppendAddress(virDomainGraphicsDefPtr def,\n                                     const char *address)\n{\n    virDomainGraphicsListenDef glisten;\n\n    memset(&glisten, 0, sizeof(glisten));\n\n    glisten.type = VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS;\n\n    glisten.address = g_strdup(address);\n\n    if (VIR_APPEND_ELEMENT_COPY(def->listens, def->nListens, glisten) < 0)\n        goto error;\n\n    return 0;\n error:\n    VIR_FREE(glisten.address);\n    return -1;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainGraphicsListenAppendAddress(virDomainGraphicsDefPtr def,\n                                     const char *address)\n{\n    virDomainGraphicsListenDef glisten;\n\n    memset(&glisten, 0, sizeof(glisten));\n\n    glisten.type = VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS;\n\n    glisten.address = g_strdup(address);\n\n    if (VIR_APPEND_ELEMENT_COPY(def->listens, def->nListens, glisten) < 0)\n        goto error;\n\n    return 0;\n error:\n    VIR_FREE(glisten.address);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "graphics"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLSpice(virConfPtr conf, virDomainDefPtr def)\n{\n    virDomainGraphicsDefPtr graphics = NULL;\n    unsigned long port;\n    char *listenAddr = NULL;\n    int val;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (xenConfigGetBool(conf, \"spice\", &val, 0) < 0)\n            return -1;\n\n        if (val) {\n            if (VIR_ALLOC(graphics) < 0)\n                return -1;\n\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SPICE;\n            if (xenConfigCopyStringOpt(conf, \"spicehost\", &listenAddr) < 0)\n                goto cleanup;\n            if (virDomainGraphicsListenAppendAddress(graphics, listenAddr) < 0)\n                goto cleanup;\n            VIR_FREE(listenAddr);\n\n            if (xenConfigGetULong(conf, \"spicetls_port\", &port, 0) < 0)\n                goto cleanup;\n            graphics->data.spice.tlsPort = (int)port;\n\n            if (xenConfigGetULong(conf, \"spiceport\", &port, 0) < 0)\n                goto cleanup;\n\n            graphics->data.spice.port = (int)port;\n\n            if (!graphics->data.spice.tlsPort &&\n                !graphics->data.spice.port)\n            graphics->data.spice.autoport = 1;\n\n            if (xenConfigGetBool(conf, \"spicedisable_ticketing\", &val, 0) < 0)\n                goto cleanup;\n            if (!val) {\n                if (xenConfigCopyString(conf, \"spicepasswd\",\n                                        &graphics->data.spice.auth.passwd) < 0)\n                    goto cleanup;\n            }\n\n            if (xenConfigGetBool(conf, \"spiceagent_mouse\",\n                                 &val, 0) < 0)\n                goto cleanup;\n            if (val) {\n                graphics->data.spice.mousemode =\n                    VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_CLIENT;\n            } else {\n                graphics->data.spice.mousemode =\n                    VIR_DOMAIN_GRAPHICS_SPICE_MOUSE_MODE_SERVER;\n            }\n\n            if (xenConfigGetBool(conf, \"spice_clipboard_sharing\", &val, 0) < 0)\n                goto cleanup;\n            if (val)\n                graphics->data.spice.copypaste = VIR_TRISTATE_BOOL_YES;\n            else\n                graphics->data.spice.copypaste = VIR_TRISTATE_BOOL_NO;\n\n            if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                goto cleanup;\n            def->graphics[0] = graphics;\n            def->ngraphics = 1;\n        }\n    }\n\n    return 0;\n\n cleanup:\n    VIR_FREE(listenAddr);\n    virDomainGraphicsDefFree(graphics);\n    return -1;\n}"
  },
  {
    "function_name": "xenParseXLCPUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "249-331",
    "snippet": "static int\nxenParseXLCPUID(virConfPtr conf, virDomainDefPtr def)\n{\n    g_autofree char *cpuid_str = NULL;\n    char **cpuid_pairs = NULL;\n    char **name_and_value = NULL;\n    size_t i;\n    int ret = -1;\n    int policy;\n\n    if (xenConfigGetString(conf, \"cpuid\", &cpuid_str, NULL) < 0)\n        return -1;\n\n    if (!cpuid_str)\n        return 0;\n\n    if (!def->cpu) {\n        def->cpu = virCPUDefNew();\n        def->cpu->mode = VIR_CPU_MODE_HOST_PASSTHROUGH;\n        def->cpu->type = VIR_CPU_TYPE_GUEST;\n        def->cpu->nfeatures = 0;\n        def->cpu->nfeatures_max = 0;\n    }\n\n    cpuid_pairs = virStringSplit(cpuid_str, \",\", 0);\n    if (!cpuid_pairs)\n        goto cleanup;\n\n    if (!cpuid_pairs[0]) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (STRNEQ(cpuid_pairs[0], \"host\")) {\n        virReportError(VIR_ERR_CONF_SYNTAX,\n                       _(\"cpuid starting with %s is not supported, only libxl format is\"),\n                       cpuid_pairs[0]);\n        goto cleanup;\n    }\n\n    for (i = 1; cpuid_pairs[i]; i++) {\n        name_and_value = virStringSplit(cpuid_pairs[i], \"=\", 2);\n        if (!name_and_value)\n            goto cleanup;\n        if (!name_and_value[0] || !name_and_value[1]) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Invalid libxl cpuid key=value element: %s\"),\n                           cpuid_pairs[i]);\n            goto cleanup;\n        }\n        if (STREQ(name_and_value[1], \"1\")) {\n            policy = VIR_CPU_FEATURE_FORCE;\n        } else if (STREQ(name_and_value[1], \"0\")) {\n            policy = VIR_CPU_FEATURE_DISABLE;\n        } else if (STREQ(name_and_value[1], \"x\")) {\n            policy = VIR_CPU_FEATURE_OPTIONAL;\n        } else if (STREQ(name_and_value[1], \"k\")) {\n            policy = VIR_CPU_FEATURE_OPTIONAL;\n        } else if (STREQ(name_and_value[1], \"s\")) {\n            policy = VIR_CPU_FEATURE_OPTIONAL;\n        } else {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Invalid libxl cpuid value: %s\"),\n                           cpuid_pairs[i]);\n            goto cleanup;\n        }\n\n        if (virCPUDefAddFeature(def->cpu,\n                                xenTranslateCPUFeature(name_and_value[0], true),\n                                policy) < 0)\n            goto cleanup;\n\n        virStringListFree(name_and_value);\n        name_and_value = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virStringListFree(name_and_value);\n    virStringListFree(cpuid_pairs);\n    return ret;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "cpuid_pairs"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefAddFeature",
          "args": [
            "def->cpu",
            "xenTranslateCPUFeature(name_and_value[0], true)",
            "policy"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "928-934",
          "snippet": "int\nvirCPUDefAddFeature(virCPUDefPtr def,\n                    const char *name,\n                    int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, false);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefAddFeature(virCPUDefPtr def,\n                    const char *name,\n                    int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenTranslateCPUFeature",
          "args": [
            "name_and_value[0]",
            "true"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "xenTranslateCPUFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "218-247",
          "snippet": "const char *\nxenTranslateCPUFeature(const char *feature_name, bool from_libxl)\n{\n    static const char *translation_table[][2] = {\n        /* libvirt name, libxl name */\n        { \"cx16\", \"cmpxchg16\" },\n        { \"cid\", \"cntxid\" },\n        { \"ds_cpl\", \"dscpl\" },\n        { \"pclmuldq\", \"pclmulqdq\" },\n        { \"pni\", \"sse3\" },\n        { \"ht\", \"htt\" },\n        { \"pn\", \"psn\" },\n        { \"clflush\", \"clfsh\" },\n        { \"sep\", \"sysenter\" },\n        { \"cx8\", \"cmpxchg8\" },\n        { \"nodeid_msr\", \"nodeid\" },\n        { \"cr8legacy\", \"altmovcr8\" },\n        { \"lahf_lm\", \"lahfsahf\" },\n        { \"cmp_legacy\", \"cmplegacy\" },\n        { \"fxsr_opt\", \"ffxsr\" },\n        { \"pdpe1gb\", \"page1gb\" },\n        { \"spec-ctrl\", \"ibrsb\" },\n    };\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(translation_table); i++)\n        if (STREQ(translation_table[i][from_libxl], feature_name))\n            return translation_table[i][!from_libxl];\n    return feature_name;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nconst char *\nxenTranslateCPUFeature(const char *feature_name, bool from_libxl)\n{\n    static const char *translation_table[][2] = {\n        /* libvirt name, libxl name */\n        { \"cx16\", \"cmpxchg16\" },\n        { \"cid\", \"cntxid\" },\n        { \"ds_cpl\", \"dscpl\" },\n        { \"pclmuldq\", \"pclmulqdq\" },\n        { \"pni\", \"sse3\" },\n        { \"ht\", \"htt\" },\n        { \"pn\", \"psn\" },\n        { \"clflush\", \"clfsh\" },\n        { \"sep\", \"sysenter\" },\n        { \"cx8\", \"cmpxchg8\" },\n        { \"nodeid_msr\", \"nodeid\" },\n        { \"cr8legacy\", \"altmovcr8\" },\n        { \"lahf_lm\", \"lahfsahf\" },\n        { \"cmp_legacy\", \"cmplegacy\" },\n        { \"fxsr_opt\", \"ffxsr\" },\n        { \"pdpe1gb\", \"page1gb\" },\n        { \"spec-ctrl\", \"ibrsb\" },\n    };\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(translation_table); i++)\n        if (STREQ(translation_table[i][from_libxl], feature_name))\n            return translation_table[i][!from_libxl];\n    return feature_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONF_SYNTAX",
            "_(\"Invalid libxl cpuid value: %s\")",
            "cpuid_pairs[i]"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid libxl cpuid value: %s\""
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name_and_value[1]",
            "\"s\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name_and_value[1]",
            "\"k\""
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name_and_value[1]",
            "\"x\""
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name_and_value[1]",
            "\"0\""
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name_and_value[1]",
            "\"1\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONF_SYNTAX",
            "_(\"Invalid libxl cpuid key=value element: %s\")",
            "cpuid_pairs[i]"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplit",
          "args": [
            "cpuid_pairs[i]",
            "\"=\"",
            "2"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "126-132",
          "snippet": "char **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONF_SYNTAX",
            "_(\"cpuid starting with %s is not supported, only libxl format is\")",
            "cpuid_pairs[0]"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "cpuid_pairs[0]",
            "\"host\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefNew",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "85-90",
          "snippet": "virCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigGetString",
          "args": [
            "conf",
            "\"cpuid\"",
            "&cpuid_str",
            "NULL"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "223-243",
          "snippet": "int\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLCPUID(virConfPtr conf, virDomainDefPtr def)\n{\n    g_autofree char *cpuid_str = NULL;\n    char **cpuid_pairs = NULL;\n    char **name_and_value = NULL;\n    size_t i;\n    int ret = -1;\n    int policy;\n\n    if (xenConfigGetString(conf, \"cpuid\", &cpuid_str, NULL) < 0)\n        return -1;\n\n    if (!cpuid_str)\n        return 0;\n\n    if (!def->cpu) {\n        def->cpu = virCPUDefNew();\n        def->cpu->mode = VIR_CPU_MODE_HOST_PASSTHROUGH;\n        def->cpu->type = VIR_CPU_TYPE_GUEST;\n        def->cpu->nfeatures = 0;\n        def->cpu->nfeatures_max = 0;\n    }\n\n    cpuid_pairs = virStringSplit(cpuid_str, \",\", 0);\n    if (!cpuid_pairs)\n        goto cleanup;\n\n    if (!cpuid_pairs[0]) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (STRNEQ(cpuid_pairs[0], \"host\")) {\n        virReportError(VIR_ERR_CONF_SYNTAX,\n                       _(\"cpuid starting with %s is not supported, only libxl format is\"),\n                       cpuid_pairs[0]);\n        goto cleanup;\n    }\n\n    for (i = 1; cpuid_pairs[i]; i++) {\n        name_and_value = virStringSplit(cpuid_pairs[i], \"=\", 2);\n        if (!name_and_value)\n            goto cleanup;\n        if (!name_and_value[0] || !name_and_value[1]) {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Invalid libxl cpuid key=value element: %s\"),\n                           cpuid_pairs[i]);\n            goto cleanup;\n        }\n        if (STREQ(name_and_value[1], \"1\")) {\n            policy = VIR_CPU_FEATURE_FORCE;\n        } else if (STREQ(name_and_value[1], \"0\")) {\n            policy = VIR_CPU_FEATURE_DISABLE;\n        } else if (STREQ(name_and_value[1], \"x\")) {\n            policy = VIR_CPU_FEATURE_OPTIONAL;\n        } else if (STREQ(name_and_value[1], \"k\")) {\n            policy = VIR_CPU_FEATURE_OPTIONAL;\n        } else if (STREQ(name_and_value[1], \"s\")) {\n            policy = VIR_CPU_FEATURE_OPTIONAL;\n        } else {\n            virReportError(VIR_ERR_CONF_SYNTAX,\n                           _(\"Invalid libxl cpuid value: %s\"),\n                           cpuid_pairs[i]);\n            goto cleanup;\n        }\n\n        if (virCPUDefAddFeature(def->cpu,\n                                xenTranslateCPUFeature(name_and_value[0], true),\n                                policy) < 0)\n            goto cleanup;\n\n        virStringListFree(name_and_value);\n        name_and_value = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virStringListFree(name_and_value);\n    virStringListFree(cpuid_pairs);\n    return ret;\n}"
  },
  {
    "function_name": "xenTranslateCPUFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "218-247",
    "snippet": "const char *\nxenTranslateCPUFeature(const char *feature_name, bool from_libxl)\n{\n    static const char *translation_table[][2] = {\n        /* libvirt name, libxl name */\n        { \"cx16\", \"cmpxchg16\" },\n        { \"cid\", \"cntxid\" },\n        { \"ds_cpl\", \"dscpl\" },\n        { \"pclmuldq\", \"pclmulqdq\" },\n        { \"pni\", \"sse3\" },\n        { \"ht\", \"htt\" },\n        { \"pn\", \"psn\" },\n        { \"clflush\", \"clfsh\" },\n        { \"sep\", \"sysenter\" },\n        { \"cx8\", \"cmpxchg8\" },\n        { \"nodeid_msr\", \"nodeid\" },\n        { \"cr8legacy\", \"altmovcr8\" },\n        { \"lahf_lm\", \"lahfsahf\" },\n        { \"cmp_legacy\", \"cmplegacy\" },\n        { \"fxsr_opt\", \"ffxsr\" },\n        { \"pdpe1gb\", \"page1gb\" },\n        { \"spec-ctrl\", \"ibrsb\" },\n    };\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(translation_table); i++)\n        if (STREQ(translation_table[i][from_libxl], feature_name))\n            return translation_table[i][!from_libxl];\n    return feature_name;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "translation_table[i][from_libxl]",
            "feature_name"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "translation_table"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nconst char *\nxenTranslateCPUFeature(const char *feature_name, bool from_libxl)\n{\n    static const char *translation_table[][2] = {\n        /* libvirt name, libxl name */\n        { \"cx16\", \"cmpxchg16\" },\n        { \"cid\", \"cntxid\" },\n        { \"ds_cpl\", \"dscpl\" },\n        { \"pclmuldq\", \"pclmulqdq\" },\n        { \"pni\", \"sse3\" },\n        { \"ht\", \"htt\" },\n        { \"pn\", \"psn\" },\n        { \"clflush\", \"clfsh\" },\n        { \"sep\", \"sysenter\" },\n        { \"cx8\", \"cmpxchg8\" },\n        { \"nodeid_msr\", \"nodeid\" },\n        { \"cr8legacy\", \"altmovcr8\" },\n        { \"lahf_lm\", \"lahfsahf\" },\n        { \"cmp_legacy\", \"cmplegacy\" },\n        { \"fxsr_opt\", \"ffxsr\" },\n        { \"pdpe1gb\", \"page1gb\" },\n        { \"spec-ctrl\", \"ibrsb\" },\n    };\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(translation_table); i++)\n        if (STREQ(translation_table[i][from_libxl], feature_name))\n            return translation_table[i][!from_libxl];\n    return feature_name;\n}"
  },
  {
    "function_name": "xenParseXLOS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "98-212",
    "snippet": "static int\nxenParseXLOS(virConfPtr conf, virDomainDefPtr def, virCapsPtr caps)\n{\n    size_t i;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        g_autofree char *bios = NULL;\n        g_autofree char *boot = NULL;\n        int val = 0;\n\n        if (xenConfigGetString(conf, \"bios\", &bios, NULL) < 0)\n            return -1;\n\n        if (bios && STREQ(bios, \"ovmf\")) {\n            if (VIR_ALLOC(def->os.loader) < 0)\n                return -1;\n\n            def->os.loader->type = VIR_DOMAIN_LOADER_TYPE_PFLASH;\n            def->os.loader->readonly = VIR_TRISTATE_BOOL_YES;\n\n            def->os.loader->path = g_strdup(LIBXL_FIRMWARE_DIR \"/ovmf.bin\");\n        } else {\n            for (i = 0; i < caps->nguests; i++) {\n                if (caps->guests[i]->ostype == VIR_DOMAIN_OSTYPE_HVM &&\n                    caps->guests[i]->arch.id == def->os.arch) {\n                    if (VIR_ALLOC(def->os.loader) < 0)\n                        return -1;\n                    def->os.loader->path = g_strdup(caps->guests[i]->arch.defaultInfo.loader);\n                }\n            }\n        }\n\n        if (xenConfigCopyStringOpt(conf, \"acpi_firmware\", &def->os.slic_table) < 0)\n            return -1;\n\n#ifdef LIBXL_HAVE_BUILDINFO_KERNEL\n        if (xenConfigCopyStringOpt(conf, \"kernel\", &def->os.kernel) < 0)\n            return -1;\n\n        if (xenConfigCopyStringOpt(conf, \"ramdisk\", &def->os.initrd) < 0)\n            return -1;\n\n        if (xenParseCmdline(conf, &def->os.cmdline) < 0)\n            return -1;\n#endif\n\n        if (xenConfigGetString(conf, \"boot\", &boot, \"c\") < 0)\n            return -1;\n\n        for (i = 0; i < VIR_DOMAIN_BOOT_LAST && boot[i]; i++) {\n            switch (boot[i]) {\n            case 'a':\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_FLOPPY;\n                break;\n            case 'd':\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_CDROM;\n                break;\n            case 'n':\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_NET;\n                break;\n            case 'c':\n            default:\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_DISK;\n                break;\n            }\n            def->os.nBootDevs++;\n        }\n\n        if (xenConfigGetBool(conf, \"nestedhvm\", &val, -1) < 0)\n            return -1;\n\n        if (val != -1) {\n            const char *vtfeature = \"vmx\";\n\n            if (caps && caps->host.cpu && ARCH_IS_X86(def->os.arch)) {\n                if (virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"vmx\"))\n                    vtfeature = \"vmx\";\n                else if (virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"svm\"))\n                    vtfeature = \"svm\";\n            }\n\n            if (!def->cpu) {\n                virCPUDefPtr cpu = virCPUDefNew();\n                cpu->mode = VIR_CPU_MODE_HOST_PASSTHROUGH;\n                cpu->type = VIR_CPU_TYPE_GUEST;\n                cpu->nfeatures = 0;\n                cpu->nfeatures_max = 0;\n                def->cpu = cpu;\n            }\n\n            if (val == 0) {\n                if (virCPUDefAddFeature(def->cpu,\n                                        vtfeature,\n                                        VIR_CPU_FEATURE_DISABLE) < 0)\n                    return -1;\n            }\n        }\n    } else {\n        if (xenConfigCopyStringOpt(conf, \"bootloader\", &def->os.bootloader) < 0)\n            return -1;\n        if (xenConfigCopyStringOpt(conf, \"bootargs\", &def->os.bootloaderArgs) < 0)\n            return -1;\n\n        if (xenConfigCopyStringOpt(conf, \"kernel\", &def->os.kernel) < 0)\n            return -1;\n\n        if (xenConfigCopyStringOpt(conf, \"ramdisk\", &def->os.initrd) < 0)\n            return -1;\n\n        if (xenParseCmdline(conf, &def->os.cmdline) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenParseCmdline",
          "args": [
            "conf",
            "&def->os.cmdline"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseCmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
          "lines": "64-96",
          "snippet": "static int xenParseCmdline(virConfPtr conf, char **r_cmdline)\n{\n    char *cmdline = NULL;\n    g_autofree char *root = NULL;\n    g_autofree char *extra = NULL;\n    g_autofree char *buf = NULL;\n\n    if (xenConfigGetString(conf, \"cmdline\", &buf, NULL) < 0)\n        return -1;\n\n    if (xenConfigGetString(conf, \"root\", &root, NULL) < 0)\n        return -1;\n\n    if (xenConfigGetString(conf, \"extra\", &extra, NULL) < 0)\n        return -1;\n\n    if (buf) {\n        cmdline = g_strdup(buf);\n        if (root || extra)\n            VIR_WARN(\"ignoring root= and extra= in favour of cmdline=\");\n    } else {\n        if (root && extra) {\n            cmdline = g_strdup_printf(\"root=%s %s\", root, extra);\n        } else if (root) {\n            cmdline = g_strdup_printf(\"root=%s\", root);\n        } else if (extra) {\n            cmdline = g_strdup(extra);\n        }\n    }\n\n    *r_cmdline = cmdline;\n    return 0;\n}",
          "includes": [
            "# include <libxlutil.h>",
            "#include \"cpu/cpu.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"xen_xl.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virconf.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int xenParseCmdline(virConfPtr conf, char **r_cmdline)\n{\n    char *cmdline = NULL;\n    g_autofree char *root = NULL;\n    g_autofree char *extra = NULL;\n    g_autofree char *buf = NULL;\n\n    if (xenConfigGetString(conf, \"cmdline\", &buf, NULL) < 0)\n        return -1;\n\n    if (xenConfigGetString(conf, \"root\", &root, NULL) < 0)\n        return -1;\n\n    if (xenConfigGetString(conf, \"extra\", &extra, NULL) < 0)\n        return -1;\n\n    if (buf) {\n        cmdline = g_strdup(buf);\n        if (root || extra)\n            VIR_WARN(\"ignoring root= and extra= in favour of cmdline=\");\n    } else {\n        if (root && extra) {\n            cmdline = g_strdup_printf(\"root=%s %s\", root, extra);\n        } else if (root) {\n            cmdline = g_strdup_printf(\"root=%s\", root);\n        } else if (extra) {\n            cmdline = g_strdup(extra);\n        }\n    }\n\n    *r_cmdline = cmdline;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigCopyStringOpt",
          "args": [
            "conf",
            "\"ramdisk\"",
            "&def->os.initrd"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigCopyStringOpt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "168-172",
          "snippet": "int\nxenConfigCopyStringOpt(virConfPtr conf, const char *name, char **value)\n{\n    return xenConfigCopyStringInternal(conf, name, value, 1);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigCopyStringOpt(virConfPtr conf, const char *name, char **value)\n{\n    return xenConfigCopyStringInternal(conf, name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefAddFeature",
          "args": [
            "def->cpu",
            "vtfeature",
            "VIR_CPU_FEATURE_DISABLE"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "928-934",
          "snippet": "int\nvirCPUDefAddFeature(virCPUDefPtr def,\n                    const char *name,\n                    int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, false);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefAddFeature(virCPUDefPtr def,\n                    const char *name,\n                    int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefNew",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "85-90",
          "snippet": "virCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUCheckFeature",
          "args": [
            "caps->host.arch",
            "caps->host.cpu",
            "\"svm\""
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUCheckFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "674-695",
          "snippet": "int\nvirCPUCheckFeature(virArch arch,\n                   const virCPUDef *cpu,\n                   const char *feature)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, feature=%s\",\n              virArchToString(arch), cpu, feature);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->checkFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot check guest CPU feature for %s architecture\"),\n                       virArchToString(arch));\n        return -1;\n    }\n\n    return driver->checkFeature(cpu, feature);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUCheckFeature(virArch arch,\n                   const virCPUDef *cpu,\n                   const char *feature)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, feature=%s\",\n              virArchToString(arch), cpu, feature);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->checkFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot check guest CPU feature for %s architecture\"),\n                       virArchToString(arch));\n        return -1;\n    }\n\n    return driver->checkFeature(cpu, feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "def->os.arch"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigGetBool",
          "args": [
            "conf",
            "\"nestedhvm\"",
            "&val",
            "-1"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "42-66",
          "snippet": "int\nxenConfigGetBool(virConfPtr conf,\n                 const char *name,\n                 int *value,\n                 int def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l ? 1 : 0;\n    } else if (val->type == VIR_CONF_STRING) {\n        *value = STREQ(val->str, \"1\") ? 1 : 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetBool(virConfPtr conf,\n                 const char *name,\n                 int *value,\n                 int def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l ? 1 : 0;\n    } else if (val->type == VIR_CONF_STRING) {\n        *value = STREQ(val->str, \"1\") ? 1 : 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigGetString",
          "args": [
            "conf",
            "\"boot\"",
            "&boot",
            "\"c\""
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "223-243",
          "snippet": "int\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "caps->guests[i]->arch.defaultInfo.loader"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def->os.loader"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def->os.loader"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "bios",
            "\"ovmf\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nxenParseXLOS(virConfPtr conf, virDomainDefPtr def, virCapsPtr caps)\n{\n    size_t i;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        g_autofree char *bios = NULL;\n        g_autofree char *boot = NULL;\n        int val = 0;\n\n        if (xenConfigGetString(conf, \"bios\", &bios, NULL) < 0)\n            return -1;\n\n        if (bios && STREQ(bios, \"ovmf\")) {\n            if (VIR_ALLOC(def->os.loader) < 0)\n                return -1;\n\n            def->os.loader->type = VIR_DOMAIN_LOADER_TYPE_PFLASH;\n            def->os.loader->readonly = VIR_TRISTATE_BOOL_YES;\n\n            def->os.loader->path = g_strdup(LIBXL_FIRMWARE_DIR \"/ovmf.bin\");\n        } else {\n            for (i = 0; i < caps->nguests; i++) {\n                if (caps->guests[i]->ostype == VIR_DOMAIN_OSTYPE_HVM &&\n                    caps->guests[i]->arch.id == def->os.arch) {\n                    if (VIR_ALLOC(def->os.loader) < 0)\n                        return -1;\n                    def->os.loader->path = g_strdup(caps->guests[i]->arch.defaultInfo.loader);\n                }\n            }\n        }\n\n        if (xenConfigCopyStringOpt(conf, \"acpi_firmware\", &def->os.slic_table) < 0)\n            return -1;\n\n#ifdef LIBXL_HAVE_BUILDINFO_KERNEL\n        if (xenConfigCopyStringOpt(conf, \"kernel\", &def->os.kernel) < 0)\n            return -1;\n\n        if (xenConfigCopyStringOpt(conf, \"ramdisk\", &def->os.initrd) < 0)\n            return -1;\n\n        if (xenParseCmdline(conf, &def->os.cmdline) < 0)\n            return -1;\n#endif\n\n        if (xenConfigGetString(conf, \"boot\", &boot, \"c\") < 0)\n            return -1;\n\n        for (i = 0; i < VIR_DOMAIN_BOOT_LAST && boot[i]; i++) {\n            switch (boot[i]) {\n            case 'a':\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_FLOPPY;\n                break;\n            case 'd':\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_CDROM;\n                break;\n            case 'n':\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_NET;\n                break;\n            case 'c':\n            default:\n                def->os.bootDevs[i] = VIR_DOMAIN_BOOT_DISK;\n                break;\n            }\n            def->os.nBootDevs++;\n        }\n\n        if (xenConfigGetBool(conf, \"nestedhvm\", &val, -1) < 0)\n            return -1;\n\n        if (val != -1) {\n            const char *vtfeature = \"vmx\";\n\n            if (caps && caps->host.cpu && ARCH_IS_X86(def->os.arch)) {\n                if (virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"vmx\"))\n                    vtfeature = \"vmx\";\n                else if (virCPUCheckFeature(caps->host.arch, caps->host.cpu, \"svm\"))\n                    vtfeature = \"svm\";\n            }\n\n            if (!def->cpu) {\n                virCPUDefPtr cpu = virCPUDefNew();\n                cpu->mode = VIR_CPU_MODE_HOST_PASSTHROUGH;\n                cpu->type = VIR_CPU_TYPE_GUEST;\n                cpu->nfeatures = 0;\n                cpu->nfeatures_max = 0;\n                def->cpu = cpu;\n            }\n\n            if (val == 0) {\n                if (virCPUDefAddFeature(def->cpu,\n                                        vtfeature,\n                                        VIR_CPU_FEATURE_DISABLE) < 0)\n                    return -1;\n            }\n        }\n    } else {\n        if (xenConfigCopyStringOpt(conf, \"bootloader\", &def->os.bootloader) < 0)\n            return -1;\n        if (xenConfigCopyStringOpt(conf, \"bootargs\", &def->os.bootloaderArgs) < 0)\n            return -1;\n\n        if (xenConfigCopyStringOpt(conf, \"kernel\", &def->os.kernel) < 0)\n            return -1;\n\n        if (xenConfigCopyStringOpt(conf, \"ramdisk\", &def->os.initrd) < 0)\n            return -1;\n\n        if (xenParseCmdline(conf, &def->os.cmdline) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenParseCmdline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_xl.c",
    "lines": "64-96",
    "snippet": "static int xenParseCmdline(virConfPtr conf, char **r_cmdline)\n{\n    char *cmdline = NULL;\n    g_autofree char *root = NULL;\n    g_autofree char *extra = NULL;\n    g_autofree char *buf = NULL;\n\n    if (xenConfigGetString(conf, \"cmdline\", &buf, NULL) < 0)\n        return -1;\n\n    if (xenConfigGetString(conf, \"root\", &root, NULL) < 0)\n        return -1;\n\n    if (xenConfigGetString(conf, \"extra\", &extra, NULL) < 0)\n        return -1;\n\n    if (buf) {\n        cmdline = g_strdup(buf);\n        if (root || extra)\n            VIR_WARN(\"ignoring root= and extra= in favour of cmdline=\");\n    } else {\n        if (root && extra) {\n            cmdline = g_strdup_printf(\"root=%s %s\", root, extra);\n        } else if (root) {\n            cmdline = g_strdup_printf(\"root=%s\", root);\n        } else if (extra) {\n            cmdline = g_strdup(extra);\n        }\n    }\n\n    *r_cmdline = cmdline;\n    return 0;\n}",
    "includes": [
      "# include <libxlutil.h>",
      "#include \"cpu/cpu.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"xen_xl.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virconf.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "extra"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"ignoring root= and extra= in favour of cmdline=\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigGetString",
          "args": [
            "conf",
            "\"extra\"",
            "&extra",
            "NULL"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "223-243",
          "snippet": "int\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "# include <libxlutil.h>\n#include \"cpu/cpu.h\"\n#include \"libxl_capabilities.h\"\n#include \"xen_xl.h\"\n#include \"virstoragefile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virconf.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int xenParseCmdline(virConfPtr conf, char **r_cmdline)\n{\n    char *cmdline = NULL;\n    g_autofree char *root = NULL;\n    g_autofree char *extra = NULL;\n    g_autofree char *buf = NULL;\n\n    if (xenConfigGetString(conf, \"cmdline\", &buf, NULL) < 0)\n        return -1;\n\n    if (xenConfigGetString(conf, \"root\", &root, NULL) < 0)\n        return -1;\n\n    if (xenConfigGetString(conf, \"extra\", &extra, NULL) < 0)\n        return -1;\n\n    if (buf) {\n        cmdline = g_strdup(buf);\n        if (root || extra)\n            VIR_WARN(\"ignoring root= and extra= in favour of cmdline=\");\n    } else {\n        if (root && extra) {\n            cmdline = g_strdup_printf(\"root=%s %s\", root, extra);\n        } else if (root) {\n            cmdline = g_strdup_printf(\"root=%s\", root);\n        } else if (extra) {\n            cmdline = g_strdup(extra);\n        }\n    }\n\n    *r_cmdline = cmdline;\n    return 0;\n}"
  }
]