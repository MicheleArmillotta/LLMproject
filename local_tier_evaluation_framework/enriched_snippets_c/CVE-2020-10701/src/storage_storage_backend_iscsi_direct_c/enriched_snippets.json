[
  {
    "function_name": "virStorageBackendISCSIDirectRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "712-716",
    "snippet": "int\nvirStorageBackendISCSIDirectRegister(void)\n{\n    return virStorageBackendRegister(&virStorageBackendISCSIDirect);\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageBackend virStorageBackendISCSIDirect = {\n    .type = VIR_STORAGE_POOL_ISCSI_DIRECT,\n\n    .checkPool = virStorageBackendISCSIDirectCheckPool,\n    .findPoolSources = virStorageBackendISCSIDirectFindPoolSources,\n    .refreshPool = virStorageBackendISCSIDirectRefreshPool,\n    .wipeVol = virStorageBackenISCSIDirectWipeVol,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendRegister",
          "args": [
            "&virStorageBackendISCSIDirect"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend.c",
          "lines": "153-169",
          "snippet": "int\nvirStorageBackendRegister(virStorageBackendPtr backend)\n{\n    VIR_DEBUG(\"Registering storage backend '%s'\",\n              virStoragePoolTypeToString(backend->type));\n\n    if (virStorageBackendsCount >= VIR_STORAGE_BACKENDS_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register storage backend '%s'\"),\n                       virStoragePoolTypeToString(backend->type));\n        return -1;\n    }\n\n    virStorageBackends[virStorageBackendsCount] = backend;\n    virStorageBackendsCount++;\n    return 0;\n}",
          "includes": [
            "# include \"storage_backend_vstorage.h\"",
            "# include \"storage_backend_zfs.h\"",
            "# include \"storage_backend_gluster.h\"",
            "# include \"storage_backend_sheepdog.h\"",
            "# include \"storage_backend_rbd.h\"",
            "# include \"storage_backend_fs.h\"",
            "# include \"storage_backend_disk.h\"",
            "# include \"storage_backend_mpath.h\"",
            "# include \"storage_backend_scsi.h\"",
            "# include \"storage_backend_iscsi_direct.h\"",
            "# include \"storage_backend_iscsi.h\"",
            "# include \"storage_backend_logical.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_STORAGE_BACKENDS_MAX 20"
          ],
          "globals_used": [
            "static virStorageBackendPtr virStorageBackends[VIR_STORAGE_BACKENDS_MAX];",
            "static size_t virStorageBackendsCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"storage_backend_vstorage.h\"\n# include \"storage_backend_zfs.h\"\n# include \"storage_backend_gluster.h\"\n# include \"storage_backend_sheepdog.h\"\n# include \"storage_backend_rbd.h\"\n# include \"storage_backend_fs.h\"\n# include \"storage_backend_disk.h\"\n# include \"storage_backend_mpath.h\"\n# include \"storage_backend_scsi.h\"\n# include \"storage_backend_iscsi_direct.h\"\n# include \"storage_backend_iscsi.h\"\n# include \"storage_backend_logical.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"virstoragefile.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\n#define VIR_STORAGE_BACKENDS_MAX 20\n\nstatic virStorageBackendPtr virStorageBackends[VIR_STORAGE_BACKENDS_MAX];\nstatic size_t virStorageBackendsCount;\n\nint\nvirStorageBackendRegister(virStorageBackendPtr backend)\n{\n    VIR_DEBUG(\"Registering storage backend '%s'\",\n              virStoragePoolTypeToString(backend->type));\n\n    if (virStorageBackendsCount >= VIR_STORAGE_BACKENDS_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register storage backend '%s'\"),\n                       virStoragePoolTypeToString(backend->type));\n        return -1;\n    }\n\n    virStorageBackends[virStorageBackendsCount] = backend;\n    virStorageBackendsCount++;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nvirStorageBackend virStorageBackendISCSIDirect = {\n    .type = VIR_STORAGE_POOL_ISCSI_DIRECT,\n\n    .checkPool = virStorageBackendISCSIDirectCheckPool,\n    .findPoolSources = virStorageBackendISCSIDirectFindPoolSources,\n    .refreshPool = virStorageBackendISCSIDirectRefreshPool,\n    .wipeVol = virStorageBackenISCSIDirectWipeVol,\n};\n\nint\nvirStorageBackendISCSIDirectRegister(void)\n{\n    return virStorageBackendRegister(&virStorageBackendISCSIDirect);\n}"
  },
  {
    "function_name": "virStorageBackenISCSIDirectWipeVol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "657-700",
    "snippet": "static int\nvirStorageBackenISCSIDirectWipeVol(virStoragePoolObjPtr pool,\n                                   virStorageVolDefPtr vol,\n                                   unsigned int algorithm,\n                                   unsigned int flags)\n{\n    struct iscsi_context *iscsi = NULL;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    virObjectLock(pool);\n    iscsi = virStorageBackendISCSIDirectSetConnection(pool, NULL);\n    virObjectUnlock(pool);\n\n    if (!iscsi)\n        return -1;\n\n    switch ((virStorageVolWipeAlgorithm) algorithm) {\n    case VIR_STORAGE_VOL_WIPE_ALG_ZERO:\n        if (virStorageBackendISCSIDirectVolWipeZero(vol, iscsi) < 0)\n            goto cleanup;\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_TRIM:\n    case VIR_STORAGE_VOL_WIPE_ALG_NNSA:\n    case VIR_STORAGE_VOL_WIPE_ALG_DOD:\n    case VIR_STORAGE_VOL_WIPE_ALG_BSI:\n    case VIR_STORAGE_VOL_WIPE_ALG_GUTMANN:\n    case VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER:\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7:\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33:\n    case VIR_STORAGE_VOL_WIPE_ALG_RANDOM:\n    case VIR_STORAGE_VOL_WIPE_ALG_LAST:\n        virReportError(VIR_ERR_INVALID_ARG, _(\"unsupported algorithm %d\"),\n                       algorithm);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virISCSIDirectDisconnect(iscsi);\n    iscsi_destroy_context(iscsi);\n    return ret;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iscsi_destroy_context",
          "args": [
            "iscsi"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virISCSIDirectDisconnect",
          "args": [
            "iscsi"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectDisconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "386-402",
          "snippet": "static int\nvirISCSIDirectDisconnect(struct iscsi_context *iscsi)\n{\n    if (iscsi_logout_sync(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to logout: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (iscsi_disconnect(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to disconnect: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectDisconnect(struct iscsi_context *iscsi)\n{\n    if (iscsi_logout_sync(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to logout: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (iscsi_disconnect(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to disconnect: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"unsupported algorithm %d\")",
            "algorithm"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported algorithm %d\""
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendISCSIDirectVolWipeZero",
          "args": [
            "vol",
            "iscsi"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendISCSIDirectVolWipeZero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "613-655",
          "snippet": "static int\nvirStorageBackendISCSIDirectVolWipeZero(virStorageVolDefPtr vol,\n                                        struct iscsi_context *iscsi)\n{\n    uint64_t lba = 0;\n    uint32_t block_size;\n    uint64_t nb_block;\n    struct scsi_task *task = NULL;\n    int lun = 0;\n    int ret = -1;\n    g_autofree unsigned char *data = NULL;\n\n    if (virStorageBackendISCSIDirectGetLun(vol, &lun) < 0)\n        return ret;\n    if (virISCSIDirectTestUnitReady(iscsi, lun) < 0)\n        return ret;\n    if (virISCSIDirectGetVolumeCapacity(iscsi, lun, &block_size, &nb_block))\n        return ret;\n    if (VIR_ALLOC_N(data, block_size * BLOCK_PER_PACKET))\n        return ret;\n\n    while (lba < nb_block) {\n        const uint64_t to_write = MIN(nb_block - lba + 1, BLOCK_PER_PACKET);\n\n        task = iscsi_write16_sync(iscsi, lun, lba, data,\n                                  block_size * to_write,\n                                  block_size, 0, 0, 0, 0, 0);\n\n        if (!task ||\n            task->status != SCSI_STATUS_GOOD) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to write to LUN %d: %s\"),\n                           lun, iscsi_get_error(iscsi));\n            scsi_free_scsi_task(task);\n            return -1;\n        }\n\n        scsi_free_scsi_task(task);\n        lba += to_write;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define BLOCK_PER_PACKET 128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\n#define BLOCK_PER_PACKET 128\n\nstatic int\nvirStorageBackendISCSIDirectVolWipeZero(virStorageVolDefPtr vol,\n                                        struct iscsi_context *iscsi)\n{\n    uint64_t lba = 0;\n    uint32_t block_size;\n    uint64_t nb_block;\n    struct scsi_task *task = NULL;\n    int lun = 0;\n    int ret = -1;\n    g_autofree unsigned char *data = NULL;\n\n    if (virStorageBackendISCSIDirectGetLun(vol, &lun) < 0)\n        return ret;\n    if (virISCSIDirectTestUnitReady(iscsi, lun) < 0)\n        return ret;\n    if (virISCSIDirectGetVolumeCapacity(iscsi, lun, &block_size, &nb_block))\n        return ret;\n    if (VIR_ALLOC_N(data, block_size * BLOCK_PER_PACKET))\n        return ret;\n\n    while (lba < nb_block) {\n        const uint64_t to_write = MIN(nb_block - lba + 1, BLOCK_PER_PACKET);\n\n        task = iscsi_write16_sync(iscsi, lun, lba, data,\n                                  block_size * to_write,\n                                  block_size, 0, 0, 0, 0, 0);\n\n        if (!task ||\n            task->status != SCSI_STATUS_GOOD) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to write to LUN %d: %s\"),\n                           lun, iscsi_get_error(iscsi));\n            scsi_free_scsi_task(task);\n            return -1;\n        }\n\n        scsi_free_scsi_task(task);\n        lba += to_write;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "pool"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendISCSIDirectSetConnection",
          "args": [
            "pool",
            "NULL"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendISCSIDirectSetConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "553-580",
          "snippet": "static struct iscsi_context *\nvirStorageBackendISCSIDirectSetConnection(virStoragePoolObjPtr pool,\n                                          char **portalRet)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct iscsi_context *iscsi = NULL;\n    g_autofree char *portal = NULL;\n\n    if (!(iscsi = virISCSIDirectCreateContext(def->source.initiator.iqn)))\n        goto error;\n    if (!(portal = virStorageBackendISCSIDirectPortal(&def->source)))\n        goto error;\n    if (virStorageBackendISCSIDirectSetAuth(iscsi, &def->source) < 0)\n        goto error;\n    if (virISCSIDirectSetContext(iscsi, def->source.devices[0].path, ISCSI_SESSION_NORMAL) < 0)\n        goto error;\n    if (virISCSIDirectConnect(iscsi, portal) < 0)\n        goto error;\n\n    if (portalRet)\n        *portalRet = g_steal_pointer(&portal);\n\n    return iscsi;\n\n error:\n    iscsi_destroy_context(iscsi);\n    return NULL;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic struct iscsi_context *\nvirStorageBackendISCSIDirectSetConnection(virStoragePoolObjPtr pool,\n                                          char **portalRet)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct iscsi_context *iscsi = NULL;\n    g_autofree char *portal = NULL;\n\n    if (!(iscsi = virISCSIDirectCreateContext(def->source.initiator.iqn)))\n        goto error;\n    if (!(portal = virStorageBackendISCSIDirectPortal(&def->source)))\n        goto error;\n    if (virStorageBackendISCSIDirectSetAuth(iscsi, &def->source) < 0)\n        goto error;\n    if (virISCSIDirectSetContext(iscsi, def->source.devices[0].path, ISCSI_SESSION_NORMAL) < 0)\n        goto error;\n    if (virISCSIDirectConnect(iscsi, portal) < 0)\n        goto error;\n\n    if (portalRet)\n        *portalRet = g_steal_pointer(&portal);\n\n    return iscsi;\n\n error:\n    iscsi_destroy_context(iscsi);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "pool"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirStorageBackenISCSIDirectWipeVol(virStoragePoolObjPtr pool,\n                                   virStorageVolDefPtr vol,\n                                   unsigned int algorithm,\n                                   unsigned int flags)\n{\n    struct iscsi_context *iscsi = NULL;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    virObjectLock(pool);\n    iscsi = virStorageBackendISCSIDirectSetConnection(pool, NULL);\n    virObjectUnlock(pool);\n\n    if (!iscsi)\n        return -1;\n\n    switch ((virStorageVolWipeAlgorithm) algorithm) {\n    case VIR_STORAGE_VOL_WIPE_ALG_ZERO:\n        if (virStorageBackendISCSIDirectVolWipeZero(vol, iscsi) < 0)\n            goto cleanup;\n        break;\n    case VIR_STORAGE_VOL_WIPE_ALG_TRIM:\n    case VIR_STORAGE_VOL_WIPE_ALG_NNSA:\n    case VIR_STORAGE_VOL_WIPE_ALG_DOD:\n    case VIR_STORAGE_VOL_WIPE_ALG_BSI:\n    case VIR_STORAGE_VOL_WIPE_ALG_GUTMANN:\n    case VIR_STORAGE_VOL_WIPE_ALG_SCHNEIER:\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER7:\n    case VIR_STORAGE_VOL_WIPE_ALG_PFITZNER33:\n    case VIR_STORAGE_VOL_WIPE_ALG_RANDOM:\n    case VIR_STORAGE_VOL_WIPE_ALG_LAST:\n        virReportError(VIR_ERR_INVALID_ARG, _(\"unsupported algorithm %d\"),\n                       algorithm);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virISCSIDirectDisconnect(iscsi);\n    iscsi_destroy_context(iscsi);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendISCSIDirectVolWipeZero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "613-655",
    "snippet": "static int\nvirStorageBackendISCSIDirectVolWipeZero(virStorageVolDefPtr vol,\n                                        struct iscsi_context *iscsi)\n{\n    uint64_t lba = 0;\n    uint32_t block_size;\n    uint64_t nb_block;\n    struct scsi_task *task = NULL;\n    int lun = 0;\n    int ret = -1;\n    g_autofree unsigned char *data = NULL;\n\n    if (virStorageBackendISCSIDirectGetLun(vol, &lun) < 0)\n        return ret;\n    if (virISCSIDirectTestUnitReady(iscsi, lun) < 0)\n        return ret;\n    if (virISCSIDirectGetVolumeCapacity(iscsi, lun, &block_size, &nb_block))\n        return ret;\n    if (VIR_ALLOC_N(data, block_size * BLOCK_PER_PACKET))\n        return ret;\n\n    while (lba < nb_block) {\n        const uint64_t to_write = MIN(nb_block - lba + 1, BLOCK_PER_PACKET);\n\n        task = iscsi_write16_sync(iscsi, lun, lba, data,\n                                  block_size * to_write,\n                                  block_size, 0, 0, 0, 0, 0);\n\n        if (!task ||\n            task->status != SCSI_STATUS_GOOD) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to write to LUN %d: %s\"),\n                           lun, iscsi_get_error(iscsi));\n            scsi_free_scsi_task(task);\n            return -1;\n        }\n\n        scsi_free_scsi_task(task);\n        lba += to_write;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define BLOCK_PER_PACKET 128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_free_scsi_task",
          "args": [
            "task"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsi_free_scsi_task",
          "args": [
            "task"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to write to LUN %d: %s\")",
            "lun",
            "iscsi_get_error(iscsi)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to write to LUN %d: %s\""
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iscsi_write16_sync",
          "args": [
            "iscsi",
            "lun",
            "lba",
            "data",
            "block_size * to_write",
            "block_size",
            "0",
            "0",
            "0",
            "0",
            "0"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "nb_block - lba + 1",
            "BLOCK_PER_PACKET"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "data",
            "block_size * BLOCK_PER_PACKET"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virISCSIDirectGetVolumeCapacity",
          "args": [
            "iscsi",
            "lun",
            "&block_size",
            "&nb_block"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectGetVolumeCapacity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "241-296",
          "snippet": "static int\nvirISCSIDirectGetVolumeCapacity(struct iscsi_context *iscsi,\n                                int lun,\n                                uint32_t *block_size,\n                                uint64_t *nb_block)\n{\n    struct scsi_task *task = NULL;\n    struct scsi_inquiry_standard *inq = NULL;\n    int ret = -1;\n\n    if (!(task = iscsi_inquiry_sync(iscsi, lun, 0, 0, 64)) ||\n        task->status != SCSI_STATUS_GOOD) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to send inquiry command: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    if (!(inq = scsi_datain_unmarshall(task))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to unmarshall reply: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    if (inq->device_type == SCSI_INQUIRY_PERIPHERAL_DEVICE_TYPE_DIRECT_ACCESS) {\n        struct scsi_readcapacity16 *rc16 = NULL;\n\n        scsi_free_scsi_task(task);\n        task = NULL;\n\n        if (!(task = iscsi_readcapacity16_sync(iscsi, lun)) ||\n            task->status != SCSI_STATUS_GOOD) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get capacity of lun: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        if (!(rc16 = scsi_datain_unmarshall(task))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to unmarshall reply: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        *block_size  = rc16->block_length;\n        *nb_block = rc16->returned_lba;\n\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectGetVolumeCapacity(struct iscsi_context *iscsi,\n                                int lun,\n                                uint32_t *block_size,\n                                uint64_t *nb_block)\n{\n    struct scsi_task *task = NULL;\n    struct scsi_inquiry_standard *inq = NULL;\n    int ret = -1;\n\n    if (!(task = iscsi_inquiry_sync(iscsi, lun, 0, 0, 64)) ||\n        task->status != SCSI_STATUS_GOOD) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to send inquiry command: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    if (!(inq = scsi_datain_unmarshall(task))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to unmarshall reply: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    if (inq->device_type == SCSI_INQUIRY_PERIPHERAL_DEVICE_TYPE_DIRECT_ACCESS) {\n        struct scsi_readcapacity16 *rc16 = NULL;\n\n        scsi_free_scsi_task(task);\n        task = NULL;\n\n        if (!(task = iscsi_readcapacity16_sync(iscsi, lun)) ||\n            task->status != SCSI_STATUS_GOOD) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get capacity of lun: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        if (!(rc16 = scsi_datain_unmarshall(task))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to unmarshall reply: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        *block_size  = rc16->block_length;\n        *nb_block = rc16->returned_lba;\n\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virISCSIDirectTestUnitReady",
          "args": [
            "iscsi",
            "lun"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectTestUnitReady",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "184-223",
          "snippet": "static int\nvirISCSIDirectTestUnitReady(struct iscsi_context *iscsi,\n                            int lun)\n{\n    struct scsi_task *task = NULL;\n    int ret = -1;\n    virTimeBackOffVar timebackoff;\n\n    if (virTimeBackOffStart(&timebackoff, 1,\n                            VIR_ISCSI_TEST_UNIT_TIMEOUT) < 0)\n        goto cleanup;\n\n    do {\n        if (!(task = iscsi_testunitready_sync(iscsi, lun))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed testunitready: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        if (task->status != SCSI_STATUS_CHECK_CONDITION ||\n            task->sense.key != SCSI_SENSE_UNIT_ATTENTION ||\n            task->sense.ascq != SCSI_SENSE_ASCQ_BUS_RESET)\n            break;\n\n        scsi_free_scsi_task(task);\n    } while (virTimeBackOffWait(&timebackoff));\n\n    if (task->status != SCSI_STATUS_GOOD) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed testunitready: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_ISCSI_TEST_UNIT_TIMEOUT 30 * 1000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\n#define VIR_ISCSI_TEST_UNIT_TIMEOUT 30 * 1000\n\nstatic int\nvirISCSIDirectTestUnitReady(struct iscsi_context *iscsi,\n                            int lun)\n{\n    struct scsi_task *task = NULL;\n    int ret = -1;\n    virTimeBackOffVar timebackoff;\n\n    if (virTimeBackOffStart(&timebackoff, 1,\n                            VIR_ISCSI_TEST_UNIT_TIMEOUT) < 0)\n        goto cleanup;\n\n    do {\n        if (!(task = iscsi_testunitready_sync(iscsi, lun))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed testunitready: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        if (task->status != SCSI_STATUS_CHECK_CONDITION ||\n            task->sense.key != SCSI_SENSE_UNIT_ATTENTION ||\n            task->sense.ascq != SCSI_SENSE_ASCQ_BUS_RESET)\n            break;\n\n        scsi_free_scsi_task(task);\n    } while (virTimeBackOffWait(&timebackoff));\n\n    if (task->status != SCSI_STATUS_GOOD) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed testunitready: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendISCSIDirectGetLun",
          "args": [
            "vol",
            "&lun"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendISCSIDirectGetLun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "597-611",
          "snippet": "static int\nvirStorageBackendISCSIDirectGetLun(virStorageVolDefPtr vol,\n                                   int *lun)\n{\n    const char *name;\n\n    if (!(name = STRSKIP(vol->name, VOL_NAME_PREFIX)) ||\n        virStrToLong_i(name, NULL, 10, lun) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid volume name %s\"), vol->name);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VOL_NAME_PREFIX \"unit:0:0:\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\n#define VOL_NAME_PREFIX \"unit:0:0:\"\n\nstatic int\nvirStorageBackendISCSIDirectGetLun(virStorageVolDefPtr vol,\n                                   int *lun)\n{\n    const char *name;\n\n    if (!(name = STRSKIP(vol->name, VOL_NAME_PREFIX)) ||\n        virStrToLong_i(name, NULL, 10, lun) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid volume name %s\"), vol->name);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\n#define BLOCK_PER_PACKET 128\n\nstatic int\nvirStorageBackendISCSIDirectVolWipeZero(virStorageVolDefPtr vol,\n                                        struct iscsi_context *iscsi)\n{\n    uint64_t lba = 0;\n    uint32_t block_size;\n    uint64_t nb_block;\n    struct scsi_task *task = NULL;\n    int lun = 0;\n    int ret = -1;\n    g_autofree unsigned char *data = NULL;\n\n    if (virStorageBackendISCSIDirectGetLun(vol, &lun) < 0)\n        return ret;\n    if (virISCSIDirectTestUnitReady(iscsi, lun) < 0)\n        return ret;\n    if (virISCSIDirectGetVolumeCapacity(iscsi, lun, &block_size, &nb_block))\n        return ret;\n    if (VIR_ALLOC_N(data, block_size * BLOCK_PER_PACKET))\n        return ret;\n\n    while (lba < nb_block) {\n        const uint64_t to_write = MIN(nb_block - lba + 1, BLOCK_PER_PACKET);\n\n        task = iscsi_write16_sync(iscsi, lun, lba, data,\n                                  block_size * to_write,\n                                  block_size, 0, 0, 0, 0, 0);\n\n        if (!task ||\n            task->status != SCSI_STATUS_GOOD) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to write to LUN %d: %s\"),\n                           lun, iscsi_get_error(iscsi));\n            scsi_free_scsi_task(task);\n            return -1;\n        }\n\n        scsi_free_scsi_task(task);\n        lba += to_write;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendISCSIDirectGetLun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "597-611",
    "snippet": "static int\nvirStorageBackendISCSIDirectGetLun(virStorageVolDefPtr vol,\n                                   int *lun)\n{\n    const char *name;\n\n    if (!(name = STRSKIP(vol->name, VOL_NAME_PREFIX)) ||\n        virStrToLong_i(name, NULL, 10, lun) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid volume name %s\"), vol->name);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VOL_NAME_PREFIX \"unit:0:0:\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid volume name %s\")",
            "vol->name"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid volume name %s\""
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "name",
            "NULL",
            "10",
            "lun"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "vol->name",
            "VOL_NAME_PREFIX"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\n#define VOL_NAME_PREFIX \"unit:0:0:\"\n\nstatic int\nvirStorageBackendISCSIDirectGetLun(virStorageVolDefPtr vol,\n                                   int *lun)\n{\n    const char *name;\n\n    if (!(name = STRSKIP(vol->name, VOL_NAME_PREFIX)) ||\n        virStrToLong_i(name, NULL, 10, lun) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid volume name %s\"), vol->name);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendISCSIDirectRefreshPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "582-595",
    "snippet": "static int\nvirStorageBackendISCSIDirectRefreshPool(virStoragePoolObjPtr pool)\n{\n    struct iscsi_context *iscsi = NULL;\n    int ret = -1;\n    g_autofree char *portal = NULL;\n\n    if (!(iscsi = virStorageBackendISCSIDirectSetConnection(pool, &portal)))\n        return -1;\n    ret = virISCSIDirectReportLuns(pool, iscsi, portal);\n    virISCSIDirectDisconnect(iscsi);\n    iscsi_destroy_context(iscsi);\n    return ret;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iscsi_destroy_context",
          "args": [
            "iscsi"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virISCSIDirectDisconnect",
          "args": [
            "iscsi"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectDisconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "386-402",
          "snippet": "static int\nvirISCSIDirectDisconnect(struct iscsi_context *iscsi)\n{\n    if (iscsi_logout_sync(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to logout: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (iscsi_disconnect(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to disconnect: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectDisconnect(struct iscsi_context *iscsi)\n{\n    if (iscsi_logout_sync(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to logout: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (iscsi_disconnect(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to disconnect: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virISCSIDirectReportLuns",
          "args": [
            "pool",
            "iscsi",
            "portal"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectReportLuns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "335-384",
          "snippet": "static int\nvirISCSIDirectReportLuns(virStoragePoolObjPtr pool,\n                         struct iscsi_context *iscsi,\n                         char *portal)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct scsi_task *task = NULL;\n    struct scsi_reportluns_list *list = NULL;\n    int full_size;\n    size_t i;\n    int ret = -1;\n\n    if (!(task = iscsi_reportluns_sync(iscsi, 0, 16))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to reportluns: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    full_size = scsi_datain_getfullsize(task);\n\n    if (full_size > task->datain.size) {\n        scsi_free_scsi_task(task);\n        if (!(task = iscsi_reportluns_sync(iscsi, 0, full_size))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to reportluns: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n    }\n\n    if (!(list = scsi_datain_unmarshall(task))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to unmarshall reportluns: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    def->capacity = 0;\n    def->allocation = 0;\n    for (i = 0; i < list->num; i++) {\n        if (virISCSIDirectRefreshVol(pool, iscsi, list->luns[i], portal) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectReportLuns(virStoragePoolObjPtr pool,\n                         struct iscsi_context *iscsi,\n                         char *portal)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct scsi_task *task = NULL;\n    struct scsi_reportluns_list *list = NULL;\n    int full_size;\n    size_t i;\n    int ret = -1;\n\n    if (!(task = iscsi_reportluns_sync(iscsi, 0, 16))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to reportluns: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    full_size = scsi_datain_getfullsize(task);\n\n    if (full_size > task->datain.size) {\n        scsi_free_scsi_task(task);\n        if (!(task = iscsi_reportluns_sync(iscsi, 0, full_size))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to reportluns: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n    }\n\n    if (!(list = scsi_datain_unmarshall(task))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to unmarshall reportluns: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    def->capacity = 0;\n    def->allocation = 0;\n    for (i = 0; i < list->num; i++) {\n        if (virISCSIDirectRefreshVol(pool, iscsi, list->luns[i], portal) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendISCSIDirectSetConnection",
          "args": [
            "pool",
            "&portal"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendISCSIDirectSetConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "553-580",
          "snippet": "static struct iscsi_context *\nvirStorageBackendISCSIDirectSetConnection(virStoragePoolObjPtr pool,\n                                          char **portalRet)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct iscsi_context *iscsi = NULL;\n    g_autofree char *portal = NULL;\n\n    if (!(iscsi = virISCSIDirectCreateContext(def->source.initiator.iqn)))\n        goto error;\n    if (!(portal = virStorageBackendISCSIDirectPortal(&def->source)))\n        goto error;\n    if (virStorageBackendISCSIDirectSetAuth(iscsi, &def->source) < 0)\n        goto error;\n    if (virISCSIDirectSetContext(iscsi, def->source.devices[0].path, ISCSI_SESSION_NORMAL) < 0)\n        goto error;\n    if (virISCSIDirectConnect(iscsi, portal) < 0)\n        goto error;\n\n    if (portalRet)\n        *portalRet = g_steal_pointer(&portal);\n\n    return iscsi;\n\n error:\n    iscsi_destroy_context(iscsi);\n    return NULL;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic struct iscsi_context *\nvirStorageBackendISCSIDirectSetConnection(virStoragePoolObjPtr pool,\n                                          char **portalRet)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct iscsi_context *iscsi = NULL;\n    g_autofree char *portal = NULL;\n\n    if (!(iscsi = virISCSIDirectCreateContext(def->source.initiator.iqn)))\n        goto error;\n    if (!(portal = virStorageBackendISCSIDirectPortal(&def->source)))\n        goto error;\n    if (virStorageBackendISCSIDirectSetAuth(iscsi, &def->source) < 0)\n        goto error;\n    if (virISCSIDirectSetContext(iscsi, def->source.devices[0].path, ISCSI_SESSION_NORMAL) < 0)\n        goto error;\n    if (virISCSIDirectConnect(iscsi, portal) < 0)\n        goto error;\n\n    if (portalRet)\n        *portalRet = g_steal_pointer(&portal);\n\n    return iscsi;\n\n error:\n    iscsi_destroy_context(iscsi);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendISCSIDirectRefreshPool(virStoragePoolObjPtr pool)\n{\n    struct iscsi_context *iscsi = NULL;\n    int ret = -1;\n    g_autofree char *portal = NULL;\n\n    if (!(iscsi = virStorageBackendISCSIDirectSetConnection(pool, &portal)))\n        return -1;\n    ret = virISCSIDirectReportLuns(pool, iscsi, portal);\n    virISCSIDirectDisconnect(iscsi);\n    iscsi_destroy_context(iscsi);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendISCSIDirectSetConnection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "553-580",
    "snippet": "static struct iscsi_context *\nvirStorageBackendISCSIDirectSetConnection(virStoragePoolObjPtr pool,\n                                          char **portalRet)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct iscsi_context *iscsi = NULL;\n    g_autofree char *portal = NULL;\n\n    if (!(iscsi = virISCSIDirectCreateContext(def->source.initiator.iqn)))\n        goto error;\n    if (!(portal = virStorageBackendISCSIDirectPortal(&def->source)))\n        goto error;\n    if (virStorageBackendISCSIDirectSetAuth(iscsi, &def->source) < 0)\n        goto error;\n    if (virISCSIDirectSetContext(iscsi, def->source.devices[0].path, ISCSI_SESSION_NORMAL) < 0)\n        goto error;\n    if (virISCSIDirectConnect(iscsi, portal) < 0)\n        goto error;\n\n    if (portalRet)\n        *portalRet = g_steal_pointer(&portal);\n\n    return iscsi;\n\n error:\n    iscsi_destroy_context(iscsi);\n    return NULL;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iscsi_destroy_context",
          "args": [
            "iscsi"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&portal"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virISCSIDirectConnect",
          "args": [
            "iscsi",
            "portal"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectConnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "165-182",
          "snippet": "static int\nvirISCSIDirectConnect(struct iscsi_context *iscsi,\n                      const char *portal)\n{\n    if (iscsi_connect_sync(iscsi, portal) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to connect: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (iscsi_login_sync(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to login: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectConnect(struct iscsi_context *iscsi,\n                      const char *portal)\n{\n    if (iscsi_connect_sync(iscsi, portal) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to connect: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (iscsi_login_sync(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to login: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virISCSIDirectSetContext",
          "args": [
            "iscsi",
            "def->source.devices[0].path",
            "ISCSI_SESSION_NORMAL"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectSetContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "137-163",
          "snippet": "static int\nvirISCSIDirectSetContext(struct iscsi_context *iscsi,\n                         const char *target_name,\n                         enum iscsi_session_type session)\n{\n    if (iscsi_init_transport(iscsi, TCP_TRANSPORT) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to init transport: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (session == ISCSI_SESSION_NORMAL) {\n        if (iscsi_set_targetname(iscsi, target_name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to set target name: %s\"),\n                           iscsi_get_error(iscsi));\n            return -1;\n        }\n    }\n    if (iscsi_set_session_type(iscsi, session) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to set session type: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectSetContext(struct iscsi_context *iscsi,\n                         const char *target_name,\n                         enum iscsi_session_type session)\n{\n    if (iscsi_init_transport(iscsi, TCP_TRANSPORT) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to init transport: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (session == ISCSI_SESSION_NORMAL) {\n        if (iscsi_set_targetname(iscsi, target_name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to set target name: %s\"),\n                           iscsi_get_error(iscsi));\n            return -1;\n        }\n    }\n    if (iscsi_set_session_type(iscsi, session) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to set session type: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendISCSIDirectSetAuth",
          "args": [
            "iscsi",
            "&def->source"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendISCSIDirectSetAuth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "86-135",
          "snippet": "static int\nvirStorageBackendISCSIDirectSetAuth(struct iscsi_context *iscsi,\n                                    virStoragePoolSourcePtr source)\n{\n    unsigned char *secret_value = NULL;\n    size_t secret_size;\n    virStorageAuthDefPtr authdef = source->auth;\n    int ret = -1;\n    virConnectPtr conn = NULL;\n\n    if (!authdef || authdef->authType == VIR_STORAGE_AUTH_TYPE_NONE)\n        return 0;\n\n    VIR_DEBUG(\"username='%s' authType=%d seclookupdef.type=%d\",\n              authdef->username, authdef->authType, authdef->seclookupdef.type);\n\n    if (authdef->authType != VIR_STORAGE_AUTH_TYPE_CHAP) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"iscsi-direct pool only supports 'chap' auth type\"));\n        return ret;\n    }\n\n    if (!(conn = virGetConnectSecret()))\n        return ret;\n\n    if (virSecretGetSecretString(conn, &authdef->seclookupdef,\n                                 VIR_SECRET_USAGE_TYPE_ISCSI,\n                                 &secret_value, &secret_size) < 0)\n        goto cleanup;\n\n    if (VIR_REALLOC_N(secret_value, secret_size + 1) < 0)\n        goto cleanup;\n\n    secret_value[secret_size] = '\\0';\n\n    if (iscsi_set_initiator_username_pwd(iscsi,\n                                         authdef->username,\n                                         (const char *)secret_value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to set credential: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_DISPOSE_N(secret_value, secret_size);\n    virObjectUnref(conn);\n    return ret;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendISCSIDirectSetAuth(struct iscsi_context *iscsi,\n                                    virStoragePoolSourcePtr source)\n{\n    unsigned char *secret_value = NULL;\n    size_t secret_size;\n    virStorageAuthDefPtr authdef = source->auth;\n    int ret = -1;\n    virConnectPtr conn = NULL;\n\n    if (!authdef || authdef->authType == VIR_STORAGE_AUTH_TYPE_NONE)\n        return 0;\n\n    VIR_DEBUG(\"username='%s' authType=%d seclookupdef.type=%d\",\n              authdef->username, authdef->authType, authdef->seclookupdef.type);\n\n    if (authdef->authType != VIR_STORAGE_AUTH_TYPE_CHAP) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"iscsi-direct pool only supports 'chap' auth type\"));\n        return ret;\n    }\n\n    if (!(conn = virGetConnectSecret()))\n        return ret;\n\n    if (virSecretGetSecretString(conn, &authdef->seclookupdef,\n                                 VIR_SECRET_USAGE_TYPE_ISCSI,\n                                 &secret_value, &secret_size) < 0)\n        goto cleanup;\n\n    if (VIR_REALLOC_N(secret_value, secret_size + 1) < 0)\n        goto cleanup;\n\n    secret_value[secret_size] = '\\0';\n\n    if (iscsi_set_initiator_username_pwd(iscsi,\n                                         authdef->username,\n                                         (const char *)secret_value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to set credential: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_DISPOSE_N(secret_value, secret_size);\n    virObjectUnref(conn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendISCSIDirectPortal",
          "args": [
            "&def->source"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendISCSIDirectPortal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "60-84",
          "snippet": "static char *\nvirStorageBackendISCSIDirectPortal(virStoragePoolSourcePtr source)\n{\n    char *portal = NULL;\n\n    if (source->nhost != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Expected exactly 1 host for the storage pool\"));\n        return NULL;\n    }\n    if (source->hosts[0].port == 0) {\n        portal = g_strdup_printf(\"%s:%d\",\n                                 source->hosts[0].name,\n                                 ISCSI_DEFAULT_TARGET_PORT);\n    } else if (strchr(source->hosts[0].name, ':')) {\n        portal = g_strdup_printf(\"[%s]:%d\",\n                                 source->hosts[0].name,\n                                 source->hosts[0].port);\n    } else {\n        portal = g_strdup_printf(\"%s:%d\",\n                                 source->hosts[0].name,\n                                 source->hosts[0].port);\n    }\n    return portal;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define ISCSI_DEFAULT_TARGET_PORT 3260"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\n#define ISCSI_DEFAULT_TARGET_PORT 3260\n\nstatic char *\nvirStorageBackendISCSIDirectPortal(virStoragePoolSourcePtr source)\n{\n    char *portal = NULL;\n\n    if (source->nhost != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Expected exactly 1 host for the storage pool\"));\n        return NULL;\n    }\n    if (source->hosts[0].port == 0) {\n        portal = g_strdup_printf(\"%s:%d\",\n                                 source->hosts[0].name,\n                                 ISCSI_DEFAULT_TARGET_PORT);\n    } else if (strchr(source->hosts[0].name, ':')) {\n        portal = g_strdup_printf(\"[%s]:%d\",\n                                 source->hosts[0].name,\n                                 source->hosts[0].port);\n    } else {\n        portal = g_strdup_printf(\"%s:%d\",\n                                 source->hosts[0].name,\n                                 source->hosts[0].port);\n    }\n    return portal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virISCSIDirectCreateContext",
          "args": [
            "def->source.initiator.iqn"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectCreateContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "47-58",
          "snippet": "static struct iscsi_context *\nvirISCSIDirectCreateContext(const char* initiator_iqn)\n{\n    struct iscsi_context *iscsi = NULL;\n\n    iscsi = iscsi_create_context(initiator_iqn);\n    if (!iscsi)\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to create iscsi context for %s\"),\n                       initiator_iqn);\n    return iscsi;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic struct iscsi_context *\nvirISCSIDirectCreateContext(const char* initiator_iqn)\n{\n    struct iscsi_context *iscsi = NULL;\n\n    iscsi = iscsi_create_context(initiator_iqn);\n    if (!iscsi)\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to create iscsi context for %s\"),\n                       initiator_iqn);\n    return iscsi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic struct iscsi_context *\nvirStorageBackendISCSIDirectSetConnection(virStoragePoolObjPtr pool,\n                                          char **portalRet)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct iscsi_context *iscsi = NULL;\n    g_autofree char *portal = NULL;\n\n    if (!(iscsi = virISCSIDirectCreateContext(def->source.initiator.iqn)))\n        goto error;\n    if (!(portal = virStorageBackendISCSIDirectPortal(&def->source)))\n        goto error;\n    if (virStorageBackendISCSIDirectSetAuth(iscsi, &def->source) < 0)\n        goto error;\n    if (virISCSIDirectSetContext(iscsi, def->source.devices[0].path, ISCSI_SESSION_NORMAL) < 0)\n        goto error;\n    if (virISCSIDirectConnect(iscsi, portal) < 0)\n        goto error;\n\n    if (portalRet)\n        *portalRet = g_steal_pointer(&portal);\n\n    return iscsi;\n\n error:\n    iscsi_destroy_context(iscsi);\n    return NULL;\n}"
  },
  {
    "function_name": "virStorageBackendISCSIDirectFindPoolSources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "476-551",
    "snippet": "static char *\nvirStorageBackendISCSIDirectFindPoolSources(const char *srcSpec,\n                                            unsigned int flags)\n{\n    size_t ntargets = 0;\n    char **targets = NULL;\n    char *ret = NULL;\n    size_t i;\n    virStoragePoolSourceList list = {\n        .type = VIR_STORAGE_POOL_ISCSI_DIRECT,\n        .nsources = 0,\n        .sources = NULL\n    };\n    g_autofree char *portal = NULL;\n    g_autoptr(virStoragePoolSource) source = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (!srcSpec) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"hostname must be specified for iscsi sources\"));\n        return NULL;\n    }\n\n    if (!(source = virStoragePoolDefParseSourceString(srcSpec, list.type)))\n        return NULL;\n\n    if (source->nhost != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Expected exactly 1 host for the storage pool\"));\n        goto cleanup;\n    }\n\n    if (!source->initiator.iqn) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"missing initiator IQN\"));\n        goto cleanup;\n    }\n\n    if (!(portal = virStorageBackendISCSIDirectPortal(source)))\n        goto cleanup;\n\n    if (virISCSIDirectScanTargets(source->initiator.iqn, portal, &ntargets, &targets) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(list.sources, ntargets) < 0)\n        goto cleanup;\n\n    for (i = 0; i < ntargets; i++) {\n        if (VIR_ALLOC_N(list.sources[i].devices, 1) < 0 ||\n            VIR_ALLOC_N(list.sources[i].hosts, 1) < 0)\n            goto cleanup;\n        list.sources[i].nhost = 1;\n        list.sources[i].hosts[0] = source->hosts[0];\n        list.sources[i].initiator = source->initiator;\n        list.sources[i].ndevice = 1;\n        list.sources[i].devices[0].path = targets[i];\n        list.nsources++;\n    }\n\n    if (!(ret = virStoragePoolSourceListFormat(&list)))\n        goto cleanup;\n\n cleanup:\n    if (list.sources) {\n        for (i = 0; i < ntargets; i++) {\n            VIR_FREE(list.sources[i].hosts);\n            VIR_FREE(list.sources[i].devices);\n        }\n        VIR_FREE(list.sources);\n    }\n    for (i = 0; i < ntargets; i++)\n        VIR_FREE(targets[i]);\n    VIR_FREE(targets);\n    return ret;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "targets"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "targets[i]"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "list.sources"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "list.sources[i].devices"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "list.sources[i].hosts"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolSourceListFormat",
          "args": [
            "&list"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolSourceListFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "1744-1777",
          "snippet": "char *\nvirStoragePoolSourceListFormat(virStoragePoolSourceListPtr def)\n{\n    virStoragePoolOptionsPtr options;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *type;\n    size_t i;\n\n    options = virStoragePoolOptionsForPoolType(def->type);\n    if (options == NULL)\n        return NULL;\n\n    type = virStoragePoolTypeToString(def->type);\n    if (!type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unexpected pool type\"));\n        goto cleanup;\n    }\n\n    virBufferAddLit(&buf, \"<sources>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    for (i = 0; i < def->nsources; i++)\n        virStoragePoolSourceFormat(&buf, options, &def->sources[i]);\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</sources>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirStoragePoolSourceListFormat(virStoragePoolSourceListPtr def)\n{\n    virStoragePoolOptionsPtr options;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *type;\n    size_t i;\n\n    options = virStoragePoolOptionsForPoolType(def->type);\n    if (options == NULL)\n        return NULL;\n\n    type = virStoragePoolTypeToString(def->type);\n    if (!type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unexpected pool type\"));\n        goto cleanup;\n    }\n\n    virBufferAddLit(&buf, \"<sources>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    for (i = 0; i < def->nsources; i++)\n        virStoragePoolSourceFormat(&buf, options, &def->sources[i]);\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</sources>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "list.sources[i].hosts",
            "1"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "list.sources[i].devices",
            "1"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "list.sources",
            "ntargets"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virISCSIDirectScanTargets",
          "args": [
            "source->initiator.iqn",
            "portal",
            "&ntargets",
            "&targets"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectScanTargets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "442-466",
          "snippet": "static int\nvirISCSIDirectScanTargets(char *initiator_iqn,\n                          char *portal,\n                          size_t *ntargets,\n                          char ***targets)\n{\n    struct iscsi_context *iscsi = NULL;\n    int ret = -1;\n\n    if (!(iscsi = virISCSIDirectCreateContext(initiator_iqn)))\n        goto cleanup;\n    if (virISCSIDirectSetContext(iscsi, NULL, ISCSI_SESSION_DISCOVERY) < 0)\n        goto cleanup;\n    if (virISCSIDirectConnect(iscsi, portal) < 0)\n        goto cleanup;\n    if (virISCSIDirectUpdateTargets(iscsi, ntargets, targets) < 0)\n        goto disconnect;\n\n    ret = 0;\n disconnect:\n    virISCSIDirectDisconnect(iscsi);\n cleanup:\n    iscsi_destroy_context(iscsi);\n    return ret;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectScanTargets(char *initiator_iqn,\n                          char *portal,\n                          size_t *ntargets,\n                          char ***targets)\n{\n    struct iscsi_context *iscsi = NULL;\n    int ret = -1;\n\n    if (!(iscsi = virISCSIDirectCreateContext(initiator_iqn)))\n        goto cleanup;\n    if (virISCSIDirectSetContext(iscsi, NULL, ISCSI_SESSION_DISCOVERY) < 0)\n        goto cleanup;\n    if (virISCSIDirectConnect(iscsi, portal) < 0)\n        goto cleanup;\n    if (virISCSIDirectUpdateTargets(iscsi, ntargets, targets) < 0)\n        goto disconnect;\n\n    ret = 0;\n disconnect:\n    virISCSIDirectDisconnect(iscsi);\n cleanup:\n    iscsi_destroy_context(iscsi);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendISCSIDirectPortal",
          "args": [
            "source"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendISCSIDirectPortal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "60-84",
          "snippet": "static char *\nvirStorageBackendISCSIDirectPortal(virStoragePoolSourcePtr source)\n{\n    char *portal = NULL;\n\n    if (source->nhost != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Expected exactly 1 host for the storage pool\"));\n        return NULL;\n    }\n    if (source->hosts[0].port == 0) {\n        portal = g_strdup_printf(\"%s:%d\",\n                                 source->hosts[0].name,\n                                 ISCSI_DEFAULT_TARGET_PORT);\n    } else if (strchr(source->hosts[0].name, ':')) {\n        portal = g_strdup_printf(\"[%s]:%d\",\n                                 source->hosts[0].name,\n                                 source->hosts[0].port);\n    } else {\n        portal = g_strdup_printf(\"%s:%d\",\n                                 source->hosts[0].name,\n                                 source->hosts[0].port);\n    }\n    return portal;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define ISCSI_DEFAULT_TARGET_PORT 3260"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\n#define ISCSI_DEFAULT_TARGET_PORT 3260\n\nstatic char *\nvirStorageBackendISCSIDirectPortal(virStoragePoolSourcePtr source)\n{\n    char *portal = NULL;\n\n    if (source->nhost != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Expected exactly 1 host for the storage pool\"));\n        return NULL;\n    }\n    if (source->hosts[0].port == 0) {\n        portal = g_strdup_printf(\"%s:%d\",\n                                 source->hosts[0].name,\n                                 ISCSI_DEFAULT_TARGET_PORT);\n    } else if (strchr(source->hosts[0].name, ':')) {\n        portal = g_strdup_printf(\"[%s]:%d\",\n                                 source->hosts[0].name,\n                                 source->hosts[0].port);\n    } else {\n        portal = g_strdup_printf(\"%s:%d\",\n                                 source->hosts[0].name,\n                                 source->hosts[0].port);\n    }\n    return portal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"missing initiator IQN\")"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing initiator IQN\""
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Expected exactly 1 host for the storage pool\")"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolDefParseSourceString",
          "args": [
            "srcSpec",
            "list.type"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolDefParseSourceString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "692-720",
          "snippet": "virStoragePoolSourcePtr\nvirStoragePoolDefParseSourceString(const char *srcSpec,\n                                   int pool_type)\n{\n    g_autoptr(xmlDoc) doc = NULL;\n    xmlNodePtr node = NULL;\n    g_autoptr(xmlXPathContext) xpath_ctxt = NULL;\n    g_autoptr(virStoragePoolSource) def = NULL;\n\n    if (!(doc = virXMLParseStringCtxt(srcSpec,\n                                      _(\"(storage_source_specification)\"),\n                                      &xpath_ctxt)))\n        return NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (!(node = virXPathNode(\"/source\", xpath_ctxt))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"root element was not source\"));\n        return NULL;\n    }\n\n    if (virStoragePoolDefParseSource(xpath_ctxt, def, pool_type,\n                                     node) < 0)\n        return NULL;\n\n    return g_steal_pointer(&def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirStoragePoolSourcePtr\nvirStoragePoolDefParseSourceString(const char *srcSpec,\n                                   int pool_type)\n{\n    g_autoptr(xmlDoc) doc = NULL;\n    xmlNodePtr node = NULL;\n    g_autoptr(xmlXPathContext) xpath_ctxt = NULL;\n    g_autoptr(virStoragePoolSource) def = NULL;\n\n    if (!(doc = virXMLParseStringCtxt(srcSpec,\n                                      _(\"(storage_source_specification)\"),\n                                      &xpath_ctxt)))\n        return NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (!(node = virXPathNode(\"/source\", xpath_ctxt))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"root element was not source\"));\n        return NULL;\n    }\n\n    if (virStoragePoolDefParseSource(xpath_ctxt, def, pool_type,\n                                     node) < 0)\n        return NULL;\n\n    return g_steal_pointer(&def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"hostname must be specified for iscsi sources\")"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic char *\nvirStorageBackendISCSIDirectFindPoolSources(const char *srcSpec,\n                                            unsigned int flags)\n{\n    size_t ntargets = 0;\n    char **targets = NULL;\n    char *ret = NULL;\n    size_t i;\n    virStoragePoolSourceList list = {\n        .type = VIR_STORAGE_POOL_ISCSI_DIRECT,\n        .nsources = 0,\n        .sources = NULL\n    };\n    g_autofree char *portal = NULL;\n    g_autoptr(virStoragePoolSource) source = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (!srcSpec) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"hostname must be specified for iscsi sources\"));\n        return NULL;\n    }\n\n    if (!(source = virStoragePoolDefParseSourceString(srcSpec, list.type)))\n        return NULL;\n\n    if (source->nhost != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Expected exactly 1 host for the storage pool\"));\n        goto cleanup;\n    }\n\n    if (!source->initiator.iqn) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"missing initiator IQN\"));\n        goto cleanup;\n    }\n\n    if (!(portal = virStorageBackendISCSIDirectPortal(source)))\n        goto cleanup;\n\n    if (virISCSIDirectScanTargets(source->initiator.iqn, portal, &ntargets, &targets) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(list.sources, ntargets) < 0)\n        goto cleanup;\n\n    for (i = 0; i < ntargets; i++) {\n        if (VIR_ALLOC_N(list.sources[i].devices, 1) < 0 ||\n            VIR_ALLOC_N(list.sources[i].hosts, 1) < 0)\n            goto cleanup;\n        list.sources[i].nhost = 1;\n        list.sources[i].hosts[0] = source->hosts[0];\n        list.sources[i].initiator = source->initiator;\n        list.sources[i].ndevice = 1;\n        list.sources[i].devices[0].path = targets[i];\n        list.nsources++;\n    }\n\n    if (!(ret = virStoragePoolSourceListFormat(&list)))\n        goto cleanup;\n\n cleanup:\n    if (list.sources) {\n        for (i = 0; i < ntargets; i++) {\n            VIR_FREE(list.sources[i].hosts);\n            VIR_FREE(list.sources[i].devices);\n        }\n        VIR_FREE(list.sources);\n    }\n    for (i = 0; i < ntargets; i++)\n        VIR_FREE(targets[i]);\n    VIR_FREE(targets);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendISCSIDirectCheckPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "468-474",
    "snippet": "static int\nvirStorageBackendISCSIDirectCheckPool(virStoragePoolObjPtr pool,\n                                      bool *isActive)\n{\n    *isActive = virStoragePoolObjIsActive(pool);\n    return 0;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStoragePoolObjIsActive",
          "args": [
            "pool"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "301-305",
          "snippet": "bool\nvirStoragePoolObjIsActive(virStoragePoolObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nbool\nvirStoragePoolObjIsActive(virStoragePoolObjPtr obj)\n{\n    return obj->active;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendISCSIDirectCheckPool(virStoragePoolObjPtr pool,\n                                      bool *isActive)\n{\n    *isActive = virStoragePoolObjIsActive(pool);\n    return 0;\n}"
  },
  {
    "function_name": "virISCSIDirectScanTargets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "442-466",
    "snippet": "static int\nvirISCSIDirectScanTargets(char *initiator_iqn,\n                          char *portal,\n                          size_t *ntargets,\n                          char ***targets)\n{\n    struct iscsi_context *iscsi = NULL;\n    int ret = -1;\n\n    if (!(iscsi = virISCSIDirectCreateContext(initiator_iqn)))\n        goto cleanup;\n    if (virISCSIDirectSetContext(iscsi, NULL, ISCSI_SESSION_DISCOVERY) < 0)\n        goto cleanup;\n    if (virISCSIDirectConnect(iscsi, portal) < 0)\n        goto cleanup;\n    if (virISCSIDirectUpdateTargets(iscsi, ntargets, targets) < 0)\n        goto disconnect;\n\n    ret = 0;\n disconnect:\n    virISCSIDirectDisconnect(iscsi);\n cleanup:\n    iscsi_destroy_context(iscsi);\n    return ret;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iscsi_destroy_context",
          "args": [
            "iscsi"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virISCSIDirectDisconnect",
          "args": [
            "iscsi"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectDisconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "386-402",
          "snippet": "static int\nvirISCSIDirectDisconnect(struct iscsi_context *iscsi)\n{\n    if (iscsi_logout_sync(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to logout: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (iscsi_disconnect(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to disconnect: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectDisconnect(struct iscsi_context *iscsi)\n{\n    if (iscsi_logout_sync(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to logout: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (iscsi_disconnect(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to disconnect: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virISCSIDirectUpdateTargets",
          "args": [
            "iscsi",
            "ntargets",
            "targets"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectUpdateTargets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "404-440",
          "snippet": "static int\nvirISCSIDirectUpdateTargets(struct iscsi_context *iscsi,\n                            size_t *ntargets,\n                            char ***targets)\n{\n    int ret = -1;\n    struct iscsi_discovery_address *addr;\n    struct iscsi_discovery_address *tmp_addr;\n    size_t tmp_ntargets = 0;\n    char **tmp_targets = NULL;\n\n    if (!(addr = iscsi_discovery_sync(iscsi))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to discover session: %s\"),\n                       iscsi_get_error(iscsi));\n        return ret;\n    }\n\n    for (tmp_addr = addr; tmp_addr; tmp_addr = tmp_addr->next) {\n        g_autofree char *target = NULL;\n\n        target = g_strdup(tmp_addr->target_name);\n\n        if (VIR_APPEND_ELEMENT(tmp_targets, tmp_ntargets, target) < 0)\n            goto cleanup;\n    }\n\n    *targets = g_steal_pointer(&tmp_targets);\n    *ntargets = tmp_ntargets;\n    tmp_ntargets = 0;\n\n    ret = 0;\n cleanup:\n    iscsi_free_discovery_data(iscsi, addr);\n    virStringListFreeCount(tmp_targets, tmp_ntargets);\n    return ret;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectUpdateTargets(struct iscsi_context *iscsi,\n                            size_t *ntargets,\n                            char ***targets)\n{\n    int ret = -1;\n    struct iscsi_discovery_address *addr;\n    struct iscsi_discovery_address *tmp_addr;\n    size_t tmp_ntargets = 0;\n    char **tmp_targets = NULL;\n\n    if (!(addr = iscsi_discovery_sync(iscsi))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to discover session: %s\"),\n                       iscsi_get_error(iscsi));\n        return ret;\n    }\n\n    for (tmp_addr = addr; tmp_addr; tmp_addr = tmp_addr->next) {\n        g_autofree char *target = NULL;\n\n        target = g_strdup(tmp_addr->target_name);\n\n        if (VIR_APPEND_ELEMENT(tmp_targets, tmp_ntargets, target) < 0)\n            goto cleanup;\n    }\n\n    *targets = g_steal_pointer(&tmp_targets);\n    *ntargets = tmp_ntargets;\n    tmp_ntargets = 0;\n\n    ret = 0;\n cleanup:\n    iscsi_free_discovery_data(iscsi, addr);\n    virStringListFreeCount(tmp_targets, tmp_ntargets);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virISCSIDirectConnect",
          "args": [
            "iscsi",
            "portal"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectConnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "165-182",
          "snippet": "static int\nvirISCSIDirectConnect(struct iscsi_context *iscsi,\n                      const char *portal)\n{\n    if (iscsi_connect_sync(iscsi, portal) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to connect: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (iscsi_login_sync(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to login: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectConnect(struct iscsi_context *iscsi,\n                      const char *portal)\n{\n    if (iscsi_connect_sync(iscsi, portal) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to connect: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (iscsi_login_sync(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to login: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virISCSIDirectSetContext",
          "args": [
            "iscsi",
            "NULL",
            "ISCSI_SESSION_DISCOVERY"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectSetContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "137-163",
          "snippet": "static int\nvirISCSIDirectSetContext(struct iscsi_context *iscsi,\n                         const char *target_name,\n                         enum iscsi_session_type session)\n{\n    if (iscsi_init_transport(iscsi, TCP_TRANSPORT) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to init transport: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (session == ISCSI_SESSION_NORMAL) {\n        if (iscsi_set_targetname(iscsi, target_name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to set target name: %s\"),\n                           iscsi_get_error(iscsi));\n            return -1;\n        }\n    }\n    if (iscsi_set_session_type(iscsi, session) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to set session type: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectSetContext(struct iscsi_context *iscsi,\n                         const char *target_name,\n                         enum iscsi_session_type session)\n{\n    if (iscsi_init_transport(iscsi, TCP_TRANSPORT) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to init transport: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (session == ISCSI_SESSION_NORMAL) {\n        if (iscsi_set_targetname(iscsi, target_name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to set target name: %s\"),\n                           iscsi_get_error(iscsi));\n            return -1;\n        }\n    }\n    if (iscsi_set_session_type(iscsi, session) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to set session type: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virISCSIDirectCreateContext",
          "args": [
            "initiator_iqn"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectCreateContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "47-58",
          "snippet": "static struct iscsi_context *\nvirISCSIDirectCreateContext(const char* initiator_iqn)\n{\n    struct iscsi_context *iscsi = NULL;\n\n    iscsi = iscsi_create_context(initiator_iqn);\n    if (!iscsi)\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to create iscsi context for %s\"),\n                       initiator_iqn);\n    return iscsi;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic struct iscsi_context *\nvirISCSIDirectCreateContext(const char* initiator_iqn)\n{\n    struct iscsi_context *iscsi = NULL;\n\n    iscsi = iscsi_create_context(initiator_iqn);\n    if (!iscsi)\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to create iscsi context for %s\"),\n                       initiator_iqn);\n    return iscsi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectScanTargets(char *initiator_iqn,\n                          char *portal,\n                          size_t *ntargets,\n                          char ***targets)\n{\n    struct iscsi_context *iscsi = NULL;\n    int ret = -1;\n\n    if (!(iscsi = virISCSIDirectCreateContext(initiator_iqn)))\n        goto cleanup;\n    if (virISCSIDirectSetContext(iscsi, NULL, ISCSI_SESSION_DISCOVERY) < 0)\n        goto cleanup;\n    if (virISCSIDirectConnect(iscsi, portal) < 0)\n        goto cleanup;\n    if (virISCSIDirectUpdateTargets(iscsi, ntargets, targets) < 0)\n        goto disconnect;\n\n    ret = 0;\n disconnect:\n    virISCSIDirectDisconnect(iscsi);\n cleanup:\n    iscsi_destroy_context(iscsi);\n    return ret;\n}"
  },
  {
    "function_name": "virISCSIDirectUpdateTargets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "404-440",
    "snippet": "static int\nvirISCSIDirectUpdateTargets(struct iscsi_context *iscsi,\n                            size_t *ntargets,\n                            char ***targets)\n{\n    int ret = -1;\n    struct iscsi_discovery_address *addr;\n    struct iscsi_discovery_address *tmp_addr;\n    size_t tmp_ntargets = 0;\n    char **tmp_targets = NULL;\n\n    if (!(addr = iscsi_discovery_sync(iscsi))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to discover session: %s\"),\n                       iscsi_get_error(iscsi));\n        return ret;\n    }\n\n    for (tmp_addr = addr; tmp_addr; tmp_addr = tmp_addr->next) {\n        g_autofree char *target = NULL;\n\n        target = g_strdup(tmp_addr->target_name);\n\n        if (VIR_APPEND_ELEMENT(tmp_targets, tmp_ntargets, target) < 0)\n            goto cleanup;\n    }\n\n    *targets = g_steal_pointer(&tmp_targets);\n    *ntargets = tmp_ntargets;\n    tmp_ntargets = 0;\n\n    ret = 0;\n cleanup:\n    iscsi_free_discovery_data(iscsi, addr);\n    virStringListFreeCount(tmp_targets, tmp_ntargets);\n    return ret;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFreeCount",
          "args": [
            "tmp_targets",
            "tmp_ntargets"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFreeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "334-347",
          "snippet": "void\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iscsi_free_discovery_data",
          "args": [
            "iscsi",
            "addr"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&tmp_targets"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "tmp_targets",
            "tmp_ntargets",
            "target"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "tmp_addr->target_name"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to discover session: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_discovery_sync",
          "args": [
            "iscsi"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectUpdateTargets(struct iscsi_context *iscsi,\n                            size_t *ntargets,\n                            char ***targets)\n{\n    int ret = -1;\n    struct iscsi_discovery_address *addr;\n    struct iscsi_discovery_address *tmp_addr;\n    size_t tmp_ntargets = 0;\n    char **tmp_targets = NULL;\n\n    if (!(addr = iscsi_discovery_sync(iscsi))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to discover session: %s\"),\n                       iscsi_get_error(iscsi));\n        return ret;\n    }\n\n    for (tmp_addr = addr; tmp_addr; tmp_addr = tmp_addr->next) {\n        g_autofree char *target = NULL;\n\n        target = g_strdup(tmp_addr->target_name);\n\n        if (VIR_APPEND_ELEMENT(tmp_targets, tmp_ntargets, target) < 0)\n            goto cleanup;\n    }\n\n    *targets = g_steal_pointer(&tmp_targets);\n    *ntargets = tmp_ntargets;\n    tmp_ntargets = 0;\n\n    ret = 0;\n cleanup:\n    iscsi_free_discovery_data(iscsi, addr);\n    virStringListFreeCount(tmp_targets, tmp_ntargets);\n    return ret;\n}"
  },
  {
    "function_name": "virISCSIDirectDisconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "386-402",
    "snippet": "static int\nvirISCSIDirectDisconnect(struct iscsi_context *iscsi)\n{\n    if (iscsi_logout_sync(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to logout: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (iscsi_disconnect(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to disconnect: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to disconnect: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to disconnect: %s\""
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iscsi_disconnect",
          "args": [
            "iscsi"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to logout: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_logout_sync",
          "args": [
            "iscsi"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectDisconnect(struct iscsi_context *iscsi)\n{\n    if (iscsi_logout_sync(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to logout: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (iscsi_disconnect(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to disconnect: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virISCSIDirectReportLuns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "335-384",
    "snippet": "static int\nvirISCSIDirectReportLuns(virStoragePoolObjPtr pool,\n                         struct iscsi_context *iscsi,\n                         char *portal)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct scsi_task *task = NULL;\n    struct scsi_reportluns_list *list = NULL;\n    int full_size;\n    size_t i;\n    int ret = -1;\n\n    if (!(task = iscsi_reportluns_sync(iscsi, 0, 16))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to reportluns: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    full_size = scsi_datain_getfullsize(task);\n\n    if (full_size > task->datain.size) {\n        scsi_free_scsi_task(task);\n        if (!(task = iscsi_reportluns_sync(iscsi, 0, full_size))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to reportluns: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n    }\n\n    if (!(list = scsi_datain_unmarshall(task))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to unmarshall reportluns: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    def->capacity = 0;\n    def->allocation = 0;\n    for (i = 0; i < list->num; i++) {\n        if (virISCSIDirectRefreshVol(pool, iscsi, list->luns[i], portal) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_free_scsi_task",
          "args": [
            "task"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virISCSIDirectRefreshVol",
          "args": [
            "pool",
            "iscsi",
            "list->luns[i]",
            "portal"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectRefreshVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "298-333",
          "snippet": "static int\nvirISCSIDirectRefreshVol(virStoragePoolObjPtr pool,\n                         struct iscsi_context *iscsi,\n                         int lun,\n                         char *portal)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    uint32_t block_size;\n    uint64_t nb_block;\n    g_autoptr(virStorageVolDef) vol = NULL;\n\n    if (virISCSIDirectTestUnitReady(iscsi, lun) < 0)\n        return -1;\n\n    if (VIR_ALLOC(vol) < 0)\n        return -1;\n\n    vol->type = VIR_STORAGE_VOL_NETWORK;\n\n    if (virISCSIDirectGetVolumeCapacity(iscsi, lun, &block_size, &nb_block) < 0)\n        return -1;\n\n    vol->target.capacity = block_size * nb_block;\n    vol->target.allocation = block_size * nb_block;\n    def->capacity += vol->target.capacity;\n    def->allocation += vol->target.allocation;\n\n    if (virISCSIDirectSetVolumeAttributes(pool, vol, lun, portal) < 0)\n        return -1;\n\n    if (virStoragePoolObjAddVol(pool, vol) < 0)\n        return -1;\n    vol = NULL;\n\n    return 0;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectRefreshVol(virStoragePoolObjPtr pool,\n                         struct iscsi_context *iscsi,\n                         int lun,\n                         char *portal)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    uint32_t block_size;\n    uint64_t nb_block;\n    g_autoptr(virStorageVolDef) vol = NULL;\n\n    if (virISCSIDirectTestUnitReady(iscsi, lun) < 0)\n        return -1;\n\n    if (VIR_ALLOC(vol) < 0)\n        return -1;\n\n    vol->type = VIR_STORAGE_VOL_NETWORK;\n\n    if (virISCSIDirectGetVolumeCapacity(iscsi, lun, &block_size, &nb_block) < 0)\n        return -1;\n\n    vol->target.capacity = block_size * nb_block;\n    vol->target.allocation = block_size * nb_block;\n    def->capacity += vol->target.capacity;\n    def->allocation += vol->target.allocation;\n\n    if (virISCSIDirectSetVolumeAttributes(pool, vol, lun, portal) < 0)\n        return -1;\n\n    if (virStoragePoolObjAddVol(pool, vol) < 0)\n        return -1;\n    vol = NULL;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to unmarshall reportluns: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to unmarshall reportluns: %s\""
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scsi_datain_unmarshall",
          "args": [
            "task"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to reportluns: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_reportluns_sync",
          "args": [
            "iscsi",
            "0",
            "full_size"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsi_free_scsi_task",
          "args": [
            "task"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsi_datain_getfullsize",
          "args": [
            "task"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to reportluns: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_reportluns_sync",
          "args": [
            "iscsi",
            "0",
            "16"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectReportLuns(virStoragePoolObjPtr pool,\n                         struct iscsi_context *iscsi,\n                         char *portal)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    struct scsi_task *task = NULL;\n    struct scsi_reportluns_list *list = NULL;\n    int full_size;\n    size_t i;\n    int ret = -1;\n\n    if (!(task = iscsi_reportluns_sync(iscsi, 0, 16))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to reportluns: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    full_size = scsi_datain_getfullsize(task);\n\n    if (full_size > task->datain.size) {\n        scsi_free_scsi_task(task);\n        if (!(task = iscsi_reportluns_sync(iscsi, 0, full_size))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to reportluns: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n    }\n\n    if (!(list = scsi_datain_unmarshall(task))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to unmarshall reportluns: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    def->capacity = 0;\n    def->allocation = 0;\n    for (i = 0; i < list->num; i++) {\n        if (virISCSIDirectRefreshVol(pool, iscsi, list->luns[i], portal) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}"
  },
  {
    "function_name": "virISCSIDirectRefreshVol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "298-333",
    "snippet": "static int\nvirISCSIDirectRefreshVol(virStoragePoolObjPtr pool,\n                         struct iscsi_context *iscsi,\n                         int lun,\n                         char *portal)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    uint32_t block_size;\n    uint64_t nb_block;\n    g_autoptr(virStorageVolDef) vol = NULL;\n\n    if (virISCSIDirectTestUnitReady(iscsi, lun) < 0)\n        return -1;\n\n    if (VIR_ALLOC(vol) < 0)\n        return -1;\n\n    vol->type = VIR_STORAGE_VOL_NETWORK;\n\n    if (virISCSIDirectGetVolumeCapacity(iscsi, lun, &block_size, &nb_block) < 0)\n        return -1;\n\n    vol->target.capacity = block_size * nb_block;\n    vol->target.allocation = block_size * nb_block;\n    def->capacity += vol->target.capacity;\n    def->allocation += vol->target.allocation;\n\n    if (virISCSIDirectSetVolumeAttributes(pool, vol, lun, portal) < 0)\n        return -1;\n\n    if (virStoragePoolObjAddVol(pool, vol) < 0)\n        return -1;\n    vol = NULL;\n\n    return 0;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStoragePoolObjAddVol",
          "args": [
            "pool",
            "vol"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjAddVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "641-679",
          "snippet": "int\nvirStoragePoolObjAddVol(virStoragePoolObjPtr obj,\n                        virStorageVolDefPtr voldef)\n{\n    virStorageVolObjPtr volobj = NULL;\n    virStorageVolObjListPtr volumes = obj->volumes;\n\n    virObjectRWLockWrite(volumes);\n\n    if (!(volobj = virStorageVolObjNew()))\n        goto error;\n\n    if (virHashAddEntry(volumes->objsKey, voldef->key, volobj) < 0)\n        goto error;\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsName, voldef->name, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsPath, voldef->target.path, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        virHashRemoveEntry(volumes->objsName, voldef->name);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    volobj->voldef = voldef;\n    virObjectRWUnlock(volumes);\n    virStorageVolObjEndAPI(&volobj);\n    return 0;\n\n error:\n    virStorageVolObjEndAPI(&volobj);\n    virObjectRWUnlock(volumes);\n    return -1;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirStoragePoolObjAddVol(virStoragePoolObjPtr obj,\n                        virStorageVolDefPtr voldef)\n{\n    virStorageVolObjPtr volobj = NULL;\n    virStorageVolObjListPtr volumes = obj->volumes;\n\n    virObjectRWLockWrite(volumes);\n\n    if (!(volobj = virStorageVolObjNew()))\n        goto error;\n\n    if (virHashAddEntry(volumes->objsKey, voldef->key, volobj) < 0)\n        goto error;\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsName, voldef->name, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsPath, voldef->target.path, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        virHashRemoveEntry(volumes->objsName, voldef->name);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    volobj->voldef = voldef;\n    virObjectRWUnlock(volumes);\n    virStorageVolObjEndAPI(&volobj);\n    return 0;\n\n error:\n    virStorageVolObjEndAPI(&volobj);\n    virObjectRWUnlock(volumes);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virISCSIDirectSetVolumeAttributes",
          "args": [
            "pool",
            "vol",
            "lun",
            "portal"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectSetVolumeAttributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "225-239",
          "snippet": "static int\nvirISCSIDirectSetVolumeAttributes(virStoragePoolObjPtr pool,\n                                  virStorageVolDefPtr vol,\n                                  int lun,\n                                  char *portal)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    vol->name = g_strdup_printf(\"%s%u\", VOL_NAME_PREFIX, lun);\n    vol->key = g_strdup_printf(\"ip-%s-iscsi-%s-lun-%u\", portal,\n                               def->source.devices[0].path, lun);\n    vol->target.path = g_strdup_printf(\"ip-%s-iscsi-%s-lun-%u\", portal,\n                                       def->source.devices[0].path, lun);\n    return 0;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VOL_NAME_PREFIX \"unit:0:0:\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\n#define VOL_NAME_PREFIX \"unit:0:0:\"\n\nstatic int\nvirISCSIDirectSetVolumeAttributes(virStoragePoolObjPtr pool,\n                                  virStorageVolDefPtr vol,\n                                  int lun,\n                                  char *portal)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    vol->name = g_strdup_printf(\"%s%u\", VOL_NAME_PREFIX, lun);\n    vol->key = g_strdup_printf(\"ip-%s-iscsi-%s-lun-%u\", portal,\n                               def->source.devices[0].path, lun);\n    vol->target.path = g_strdup_printf(\"ip-%s-iscsi-%s-lun-%u\", portal,\n                                       def->source.devices[0].path, lun);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virISCSIDirectGetVolumeCapacity",
          "args": [
            "iscsi",
            "lun",
            "&block_size",
            "&nb_block"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectGetVolumeCapacity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "241-296",
          "snippet": "static int\nvirISCSIDirectGetVolumeCapacity(struct iscsi_context *iscsi,\n                                int lun,\n                                uint32_t *block_size,\n                                uint64_t *nb_block)\n{\n    struct scsi_task *task = NULL;\n    struct scsi_inquiry_standard *inq = NULL;\n    int ret = -1;\n\n    if (!(task = iscsi_inquiry_sync(iscsi, lun, 0, 0, 64)) ||\n        task->status != SCSI_STATUS_GOOD) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to send inquiry command: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    if (!(inq = scsi_datain_unmarshall(task))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to unmarshall reply: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    if (inq->device_type == SCSI_INQUIRY_PERIPHERAL_DEVICE_TYPE_DIRECT_ACCESS) {\n        struct scsi_readcapacity16 *rc16 = NULL;\n\n        scsi_free_scsi_task(task);\n        task = NULL;\n\n        if (!(task = iscsi_readcapacity16_sync(iscsi, lun)) ||\n            task->status != SCSI_STATUS_GOOD) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get capacity of lun: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        if (!(rc16 = scsi_datain_unmarshall(task))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to unmarshall reply: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        *block_size  = rc16->block_length;\n        *nb_block = rc16->returned_lba;\n\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectGetVolumeCapacity(struct iscsi_context *iscsi,\n                                int lun,\n                                uint32_t *block_size,\n                                uint64_t *nb_block)\n{\n    struct scsi_task *task = NULL;\n    struct scsi_inquiry_standard *inq = NULL;\n    int ret = -1;\n\n    if (!(task = iscsi_inquiry_sync(iscsi, lun, 0, 0, 64)) ||\n        task->status != SCSI_STATUS_GOOD) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to send inquiry command: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    if (!(inq = scsi_datain_unmarshall(task))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to unmarshall reply: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    if (inq->device_type == SCSI_INQUIRY_PERIPHERAL_DEVICE_TYPE_DIRECT_ACCESS) {\n        struct scsi_readcapacity16 *rc16 = NULL;\n\n        scsi_free_scsi_task(task);\n        task = NULL;\n\n        if (!(task = iscsi_readcapacity16_sync(iscsi, lun)) ||\n            task->status != SCSI_STATUS_GOOD) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get capacity of lun: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        if (!(rc16 = scsi_datain_unmarshall(task))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to unmarshall reply: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        *block_size  = rc16->block_length;\n        *nb_block = rc16->returned_lba;\n\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "vol"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virISCSIDirectTestUnitReady",
          "args": [
            "iscsi",
            "lun"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "virISCSIDirectTestUnitReady",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
          "lines": "184-223",
          "snippet": "static int\nvirISCSIDirectTestUnitReady(struct iscsi_context *iscsi,\n                            int lun)\n{\n    struct scsi_task *task = NULL;\n    int ret = -1;\n    virTimeBackOffVar timebackoff;\n\n    if (virTimeBackOffStart(&timebackoff, 1,\n                            VIR_ISCSI_TEST_UNIT_TIMEOUT) < 0)\n        goto cleanup;\n\n    do {\n        if (!(task = iscsi_testunitready_sync(iscsi, lun))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed testunitready: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        if (task->status != SCSI_STATUS_CHECK_CONDITION ||\n            task->sense.key != SCSI_SENSE_UNIT_ATTENTION ||\n            task->sense.ascq != SCSI_SENSE_ASCQ_BUS_RESET)\n            break;\n\n        scsi_free_scsi_task(task);\n    } while (virTimeBackOffWait(&timebackoff));\n\n    if (task->status != SCSI_STATUS_GOOD) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed testunitready: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_util.h\"",
            "#include \"storage_backend_iscsi_direct.h\"",
            "#include \"virsecret.h\"",
            "#include \"datatypes.h\"",
            "#include <iscsi/scsi-lowlevel.h>",
            "#include <iscsi/iscsi.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_ISCSI_TEST_UNIT_TIMEOUT 30 * 1000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\n#define VIR_ISCSI_TEST_UNIT_TIMEOUT 30 * 1000\n\nstatic int\nvirISCSIDirectTestUnitReady(struct iscsi_context *iscsi,\n                            int lun)\n{\n    struct scsi_task *task = NULL;\n    int ret = -1;\n    virTimeBackOffVar timebackoff;\n\n    if (virTimeBackOffStart(&timebackoff, 1,\n                            VIR_ISCSI_TEST_UNIT_TIMEOUT) < 0)\n        goto cleanup;\n\n    do {\n        if (!(task = iscsi_testunitready_sync(iscsi, lun))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed testunitready: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        if (task->status != SCSI_STATUS_CHECK_CONDITION ||\n            task->sense.key != SCSI_SENSE_UNIT_ATTENTION ||\n            task->sense.ascq != SCSI_SENSE_ASCQ_BUS_RESET)\n            break;\n\n        scsi_free_scsi_task(task);\n    } while (virTimeBackOffWait(&timebackoff));\n\n    if (task->status != SCSI_STATUS_GOOD) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed testunitready: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectRefreshVol(virStoragePoolObjPtr pool,\n                         struct iscsi_context *iscsi,\n                         int lun,\n                         char *portal)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    uint32_t block_size;\n    uint64_t nb_block;\n    g_autoptr(virStorageVolDef) vol = NULL;\n\n    if (virISCSIDirectTestUnitReady(iscsi, lun) < 0)\n        return -1;\n\n    if (VIR_ALLOC(vol) < 0)\n        return -1;\n\n    vol->type = VIR_STORAGE_VOL_NETWORK;\n\n    if (virISCSIDirectGetVolumeCapacity(iscsi, lun, &block_size, &nb_block) < 0)\n        return -1;\n\n    vol->target.capacity = block_size * nb_block;\n    vol->target.allocation = block_size * nb_block;\n    def->capacity += vol->target.capacity;\n    def->allocation += vol->target.allocation;\n\n    if (virISCSIDirectSetVolumeAttributes(pool, vol, lun, portal) < 0)\n        return -1;\n\n    if (virStoragePoolObjAddVol(pool, vol) < 0)\n        return -1;\n    vol = NULL;\n\n    return 0;\n}"
  },
  {
    "function_name": "virISCSIDirectGetVolumeCapacity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "241-296",
    "snippet": "static int\nvirISCSIDirectGetVolumeCapacity(struct iscsi_context *iscsi,\n                                int lun,\n                                uint32_t *block_size,\n                                uint64_t *nb_block)\n{\n    struct scsi_task *task = NULL;\n    struct scsi_inquiry_standard *inq = NULL;\n    int ret = -1;\n\n    if (!(task = iscsi_inquiry_sync(iscsi, lun, 0, 0, 64)) ||\n        task->status != SCSI_STATUS_GOOD) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to send inquiry command: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    if (!(inq = scsi_datain_unmarshall(task))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to unmarshall reply: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    if (inq->device_type == SCSI_INQUIRY_PERIPHERAL_DEVICE_TYPE_DIRECT_ACCESS) {\n        struct scsi_readcapacity16 *rc16 = NULL;\n\n        scsi_free_scsi_task(task);\n        task = NULL;\n\n        if (!(task = iscsi_readcapacity16_sync(iscsi, lun)) ||\n            task->status != SCSI_STATUS_GOOD) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get capacity of lun: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        if (!(rc16 = scsi_datain_unmarshall(task))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to unmarshall reply: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        *block_size  = rc16->block_length;\n        *nb_block = rc16->returned_lba;\n\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_free_scsi_task",
          "args": [
            "task"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to unmarshall reply: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to unmarshall reply: %s\""
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scsi_datain_unmarshall",
          "args": [
            "task"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to get capacity of lun: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_readcapacity16_sync",
          "args": [
            "iscsi",
            "lun"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsi_free_scsi_task",
          "args": [
            "task"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to unmarshall reply: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsi_datain_unmarshall",
          "args": [
            "task"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to send inquiry command: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_inquiry_sync",
          "args": [
            "iscsi",
            "lun",
            "0",
            "0",
            "64"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectGetVolumeCapacity(struct iscsi_context *iscsi,\n                                int lun,\n                                uint32_t *block_size,\n                                uint64_t *nb_block)\n{\n    struct scsi_task *task = NULL;\n    struct scsi_inquiry_standard *inq = NULL;\n    int ret = -1;\n\n    if (!(task = iscsi_inquiry_sync(iscsi, lun, 0, 0, 64)) ||\n        task->status != SCSI_STATUS_GOOD) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to send inquiry command: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    if (!(inq = scsi_datain_unmarshall(task))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to unmarshall reply: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    if (inq->device_type == SCSI_INQUIRY_PERIPHERAL_DEVICE_TYPE_DIRECT_ACCESS) {\n        struct scsi_readcapacity16 *rc16 = NULL;\n\n        scsi_free_scsi_task(task);\n        task = NULL;\n\n        if (!(task = iscsi_readcapacity16_sync(iscsi, lun)) ||\n            task->status != SCSI_STATUS_GOOD) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get capacity of lun: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        if (!(rc16 = scsi_datain_unmarshall(task))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to unmarshall reply: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        *block_size  = rc16->block_length;\n        *nb_block = rc16->returned_lba;\n\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}"
  },
  {
    "function_name": "virISCSIDirectSetVolumeAttributes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "225-239",
    "snippet": "static int\nvirISCSIDirectSetVolumeAttributes(virStoragePoolObjPtr pool,\n                                  virStorageVolDefPtr vol,\n                                  int lun,\n                                  char *portal)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    vol->name = g_strdup_printf(\"%s%u\", VOL_NAME_PREFIX, lun);\n    vol->key = g_strdup_printf(\"ip-%s-iscsi-%s-lun-%u\", portal,\n                               def->source.devices[0].path, lun);\n    vol->target.path = g_strdup_printf(\"ip-%s-iscsi-%s-lun-%u\", portal,\n                                       def->source.devices[0].path, lun);\n    return 0;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VOL_NAME_PREFIX \"unit:0:0:\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"ip-%s-iscsi-%s-lun-%u\"",
            "portal",
            "def->source.devices[0].path",
            "lun"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\n#define VOL_NAME_PREFIX \"unit:0:0:\"\n\nstatic int\nvirISCSIDirectSetVolumeAttributes(virStoragePoolObjPtr pool,\n                                  virStorageVolDefPtr vol,\n                                  int lun,\n                                  char *portal)\n{\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n\n    vol->name = g_strdup_printf(\"%s%u\", VOL_NAME_PREFIX, lun);\n    vol->key = g_strdup_printf(\"ip-%s-iscsi-%s-lun-%u\", portal,\n                               def->source.devices[0].path, lun);\n    vol->target.path = g_strdup_printf(\"ip-%s-iscsi-%s-lun-%u\", portal,\n                                       def->source.devices[0].path, lun);\n    return 0;\n}"
  },
  {
    "function_name": "virISCSIDirectTestUnitReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "184-223",
    "snippet": "static int\nvirISCSIDirectTestUnitReady(struct iscsi_context *iscsi,\n                            int lun)\n{\n    struct scsi_task *task = NULL;\n    int ret = -1;\n    virTimeBackOffVar timebackoff;\n\n    if (virTimeBackOffStart(&timebackoff, 1,\n                            VIR_ISCSI_TEST_UNIT_TIMEOUT) < 0)\n        goto cleanup;\n\n    do {\n        if (!(task = iscsi_testunitready_sync(iscsi, lun))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed testunitready: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        if (task->status != SCSI_STATUS_CHECK_CONDITION ||\n            task->sense.key != SCSI_SENSE_UNIT_ATTENTION ||\n            task->sense.ascq != SCSI_SENSE_ASCQ_BUS_RESET)\n            break;\n\n        scsi_free_scsi_task(task);\n    } while (virTimeBackOffWait(&timebackoff));\n\n    if (task->status != SCSI_STATUS_GOOD) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed testunitready: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIR_ISCSI_TEST_UNIT_TIMEOUT 30 * 1000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_free_scsi_task",
          "args": [
            "task"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed testunitready: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed testunitready: %s\""
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTimeBackOffWait",
          "args": [
            "&timebackoff"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeBackOffWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "379-410",
          "snippet": "bool\nvirTimeBackOffWait(virTimeBackOffVar *var)\n{\n    unsigned long long next, t = 0;\n\n    ignore_value(virTimeMillisNowRaw(&t));\n\n    VIR_DEBUG(\"t=%llu, limit=%llu\", t, var->limit_t);\n\n    if (t > var->limit_t)\n        return 0;               /* ends the while loop */\n\n    /* Compute next wait time. Cap at VIR_TIME_BACKOFF_CAP\n     * to avoid long useless sleeps. */\n    next = var->next;\n    if (var->next < VIR_TIME_BACKOFF_CAP)\n        var->next *= 2;\n    else if (var->next > VIR_TIME_BACKOFF_CAP)\n        var->next = VIR_TIME_BACKOFF_CAP;\n\n    /* If sleeping would take us beyond the limit, then shorten the\n     * sleep.  This is so we always run the body just before the final\n     * timeout.\n     */\n    if (t + next > var->limit_t)\n        next = var->limit_t - t;\n\n    VIR_DEBUG(\"sleeping for %llu ms\", next);\n\n    g_usleep(next * 1000);\n    return 1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_TIME_BACKOFF_CAP 1000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\n#define VIR_TIME_BACKOFF_CAP 1000\n\nbool\nvirTimeBackOffWait(virTimeBackOffVar *var)\n{\n    unsigned long long next, t = 0;\n\n    ignore_value(virTimeMillisNowRaw(&t));\n\n    VIR_DEBUG(\"t=%llu, limit=%llu\", t, var->limit_t);\n\n    if (t > var->limit_t)\n        return 0;               /* ends the while loop */\n\n    /* Compute next wait time. Cap at VIR_TIME_BACKOFF_CAP\n     * to avoid long useless sleeps. */\n    next = var->next;\n    if (var->next < VIR_TIME_BACKOFF_CAP)\n        var->next *= 2;\n    else if (var->next > VIR_TIME_BACKOFF_CAP)\n        var->next = VIR_TIME_BACKOFF_CAP;\n\n    /* If sleeping would take us beyond the limit, then shorten the\n     * sleep.  This is so we always run the body just before the final\n     * timeout.\n     */\n    if (t + next > var->limit_t)\n        next = var->limit_t - t;\n\n    VIR_DEBUG(\"sleeping for %llu ms\", next);\n\n    g_usleep(next * 1000);\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scsi_free_scsi_task",
          "args": [
            "task"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed testunitready: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_testunitready_sync",
          "args": [
            "iscsi",
            "lun"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTimeBackOffStart",
          "args": [
            "&timebackoff",
            "1",
            "VIR_ISCSI_TEST_UNIT_TIMEOUT"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeBackOffStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "335-345",
          "snippet": "int\nvirTimeBackOffStart(virTimeBackOffVar *var,\n                    unsigned long long first, unsigned long long timeout)\n{\n    if (virTimeMillisNow(&var->start_t) < 0)\n        return -1;\n\n    var->next = first;\n    var->limit_t = var->start_t + timeout;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirTimeBackOffStart(virTimeBackOffVar *var,\n                    unsigned long long first, unsigned long long timeout)\n{\n    if (virTimeMillisNow(&var->start_t) < 0)\n        return -1;\n\n    var->next = first;\n    var->limit_t = var->start_t + timeout;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\n#define VIR_ISCSI_TEST_UNIT_TIMEOUT 30 * 1000\n\nstatic int\nvirISCSIDirectTestUnitReady(struct iscsi_context *iscsi,\n                            int lun)\n{\n    struct scsi_task *task = NULL;\n    int ret = -1;\n    virTimeBackOffVar timebackoff;\n\n    if (virTimeBackOffStart(&timebackoff, 1,\n                            VIR_ISCSI_TEST_UNIT_TIMEOUT) < 0)\n        goto cleanup;\n\n    do {\n        if (!(task = iscsi_testunitready_sync(iscsi, lun))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed testunitready: %s\"),\n                           iscsi_get_error(iscsi));\n            goto cleanup;\n        }\n\n        if (task->status != SCSI_STATUS_CHECK_CONDITION ||\n            task->sense.key != SCSI_SENSE_UNIT_ATTENTION ||\n            task->sense.ascq != SCSI_SENSE_ASCQ_BUS_RESET)\n            break;\n\n        scsi_free_scsi_task(task);\n    } while (virTimeBackOffWait(&timebackoff));\n\n    if (task->status != SCSI_STATUS_GOOD) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed testunitready: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    scsi_free_scsi_task(task);\n    return ret;\n}"
  },
  {
    "function_name": "virISCSIDirectConnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "165-182",
    "snippet": "static int\nvirISCSIDirectConnect(struct iscsi_context *iscsi,\n                      const char *portal)\n{\n    if (iscsi_connect_sync(iscsi, portal) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to connect: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (iscsi_login_sync(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to login: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to login: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to login: %s\""
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iscsi_login_sync",
          "args": [
            "iscsi"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to connect: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_connect_sync",
          "args": [
            "iscsi",
            "portal"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectConnect(struct iscsi_context *iscsi,\n                      const char *portal)\n{\n    if (iscsi_connect_sync(iscsi, portal) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to connect: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (iscsi_login_sync(iscsi) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to login: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virISCSIDirectSetContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "137-163",
    "snippet": "static int\nvirISCSIDirectSetContext(struct iscsi_context *iscsi,\n                         const char *target_name,\n                         enum iscsi_session_type session)\n{\n    if (iscsi_init_transport(iscsi, TCP_TRANSPORT) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to init transport: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (session == ISCSI_SESSION_NORMAL) {\n        if (iscsi_set_targetname(iscsi, target_name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to set target name: %s\"),\n                           iscsi_get_error(iscsi));\n            return -1;\n        }\n    }\n    if (iscsi_set_session_type(iscsi, session) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to set session type: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to set session type: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to set session type: %s\""
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iscsi_set_session_type",
          "args": [
            "iscsi",
            "session"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to set target name: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_set_targetname",
          "args": [
            "iscsi",
            "target_name"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to init transport: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_init_transport",
          "args": [
            "iscsi",
            "TCP_TRANSPORT"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirISCSIDirectSetContext(struct iscsi_context *iscsi,\n                         const char *target_name,\n                         enum iscsi_session_type session)\n{\n    if (iscsi_init_transport(iscsi, TCP_TRANSPORT) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to init transport: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    if (session == ISCSI_SESSION_NORMAL) {\n        if (iscsi_set_targetname(iscsi, target_name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to set target name: %s\"),\n                           iscsi_get_error(iscsi));\n            return -1;\n        }\n    }\n    if (iscsi_set_session_type(iscsi, session) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to set session type: %s\"),\n                       iscsi_get_error(iscsi));\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendISCSIDirectSetAuth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "86-135",
    "snippet": "static int\nvirStorageBackendISCSIDirectSetAuth(struct iscsi_context *iscsi,\n                                    virStoragePoolSourcePtr source)\n{\n    unsigned char *secret_value = NULL;\n    size_t secret_size;\n    virStorageAuthDefPtr authdef = source->auth;\n    int ret = -1;\n    virConnectPtr conn = NULL;\n\n    if (!authdef || authdef->authType == VIR_STORAGE_AUTH_TYPE_NONE)\n        return 0;\n\n    VIR_DEBUG(\"username='%s' authType=%d seclookupdef.type=%d\",\n              authdef->username, authdef->authType, authdef->seclookupdef.type);\n\n    if (authdef->authType != VIR_STORAGE_AUTH_TYPE_CHAP) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"iscsi-direct pool only supports 'chap' auth type\"));\n        return ret;\n    }\n\n    if (!(conn = virGetConnectSecret()))\n        return ret;\n\n    if (virSecretGetSecretString(conn, &authdef->seclookupdef,\n                                 VIR_SECRET_USAGE_TYPE_ISCSI,\n                                 &secret_value, &secret_size) < 0)\n        goto cleanup;\n\n    if (VIR_REALLOC_N(secret_value, secret_size + 1) < 0)\n        goto cleanup;\n\n    secret_value[secret_size] = '\\0';\n\n    if (iscsi_set_initiator_username_pwd(iscsi,\n                                         authdef->username,\n                                         (const char *)secret_value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to set credential: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_DISPOSE_N(secret_value, secret_size);\n    virObjectUnref(conn);\n    return ret;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "conn"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DISPOSE_N",
          "args": [
            "secret_value",
            "secret_size"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to set credential: %s\")",
            "iscsi_get_error(iscsi)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iscsi_get_error",
          "args": [
            "iscsi"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to set credential: %s\""
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iscsi_set_initiator_username_pwd",
          "args": [
            "iscsi",
            "authdef->username",
            "(const char *)secret_value"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "secret_value",
            "secret_size + 1"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecretGetSecretString",
          "args": [
            "conn",
            "&authdef->seclookupdef",
            "VIR_SECRET_USAGE_TYPE_ISCSI",
            "&secret_value",
            "&secret_size"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretGetSecretString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsecret.c",
          "lines": "143-195",
          "snippet": "int\nvirSecretGetSecretString(virConnectPtr conn,\n                         virSecretLookupTypeDefPtr seclookupdef,\n                         virSecretUsageType secretUsageType,\n                         uint8_t **secret,\n                         size_t *secret_size)\n{\n    virSecretPtr sec = NULL;\n    int ret = -1;\n\n    switch (seclookupdef->type) {\n    case VIR_SECRET_LOOKUP_TYPE_UUID:\n        sec = conn->secretDriver->secretLookupByUUID(conn, seclookupdef->u.uuid);\n        break;\n\n    case VIR_SECRET_LOOKUP_TYPE_USAGE:\n        sec = conn->secretDriver->secretLookupByUsage(conn, secretUsageType,\n                                                      seclookupdef->u.usage);\n        break;\n    }\n\n    if (!sec)\n        goto cleanup;\n\n    /* NB: NONE is a byproduct of the qemuxml2argvtest test mocking\n     * for UUID lookups. Normal secret XML processing would fail if\n     * the usage type was NONE and since we have no way to set the\n     * expected usage in that environment, let's just accept NONE */\n    if (sec->usageType != VIR_SECRET_USAGE_TYPE_NONE &&\n        sec->usageType != secretUsageType) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(seclookupdef->u.uuid, uuidstr);\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"secret with uuid %s is of type '%s' not \"\n                         \"expected '%s' type\"),\n                       uuidstr, virSecretUsageTypeToString(sec->usageType),\n                       virSecretUsageTypeToString(secretUsageType));\n        goto cleanup;\n    }\n\n    *secret = conn->secretDriver->secretGetValue(sec, secret_size, 0,\n                                                 VIR_SECRET_GET_VALUE_INTERNAL_CALL);\n\n    if (!*secret)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(sec);\n    return ret;\n}",
          "includes": [
            "#include \"viruuid.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruuid.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirSecretGetSecretString(virConnectPtr conn,\n                         virSecretLookupTypeDefPtr seclookupdef,\n                         virSecretUsageType secretUsageType,\n                         uint8_t **secret,\n                         size_t *secret_size)\n{\n    virSecretPtr sec = NULL;\n    int ret = -1;\n\n    switch (seclookupdef->type) {\n    case VIR_SECRET_LOOKUP_TYPE_UUID:\n        sec = conn->secretDriver->secretLookupByUUID(conn, seclookupdef->u.uuid);\n        break;\n\n    case VIR_SECRET_LOOKUP_TYPE_USAGE:\n        sec = conn->secretDriver->secretLookupByUsage(conn, secretUsageType,\n                                                      seclookupdef->u.usage);\n        break;\n    }\n\n    if (!sec)\n        goto cleanup;\n\n    /* NB: NONE is a byproduct of the qemuxml2argvtest test mocking\n     * for UUID lookups. Normal secret XML processing would fail if\n     * the usage type was NONE and since we have no way to set the\n     * expected usage in that environment, let's just accept NONE */\n    if (sec->usageType != VIR_SECRET_USAGE_TYPE_NONE &&\n        sec->usageType != secretUsageType) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(seclookupdef->u.uuid, uuidstr);\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"secret with uuid %s is of type '%s' not \"\n                         \"expected '%s' type\"),\n                       uuidstr, virSecretUsageTypeToString(sec->usageType),\n                       virSecretUsageTypeToString(secretUsageType));\n        goto cleanup;\n    }\n\n    *secret = conn->secretDriver->secretGetValue(sec, secret_size, 0,\n                                                 VIR_SECRET_GET_VALUE_INTERNAL_CALL);\n\n    if (!*secret)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(sec);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetConnectSecret",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "virGetConnectSecret",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "184-187",
          "snippet": "virConnectPtr virGetConnectSecret(void)\n{\n    return virGetConnectGeneric(&connectSecret, \"secret\");\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal connectSecret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirThreadLocal connectSecret;\n\nvirConnectPtr virGetConnectSecret(void)\n{\n    return virGetConnectGeneric(&connectSecret, \"secret\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"iscsi-direct pool only supports 'chap' auth type\")"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"username='%s' authType=%d seclookupdef.type=%d\"",
            "authdef->username",
            "authdef->authType",
            "authdef->seclookupdef.type"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendISCSIDirectSetAuth(struct iscsi_context *iscsi,\n                                    virStoragePoolSourcePtr source)\n{\n    unsigned char *secret_value = NULL;\n    size_t secret_size;\n    virStorageAuthDefPtr authdef = source->auth;\n    int ret = -1;\n    virConnectPtr conn = NULL;\n\n    if (!authdef || authdef->authType == VIR_STORAGE_AUTH_TYPE_NONE)\n        return 0;\n\n    VIR_DEBUG(\"username='%s' authType=%d seclookupdef.type=%d\",\n              authdef->username, authdef->authType, authdef->seclookupdef.type);\n\n    if (authdef->authType != VIR_STORAGE_AUTH_TYPE_CHAP) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"iscsi-direct pool only supports 'chap' auth type\"));\n        return ret;\n    }\n\n    if (!(conn = virGetConnectSecret()))\n        return ret;\n\n    if (virSecretGetSecretString(conn, &authdef->seclookupdef,\n                                 VIR_SECRET_USAGE_TYPE_ISCSI,\n                                 &secret_value, &secret_size) < 0)\n        goto cleanup;\n\n    if (VIR_REALLOC_N(secret_value, secret_size + 1) < 0)\n        goto cleanup;\n\n    secret_value[secret_size] = '\\0';\n\n    if (iscsi_set_initiator_username_pwd(iscsi,\n                                         authdef->username,\n                                         (const char *)secret_value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to set credential: %s\"),\n                       iscsi_get_error(iscsi));\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_DISPOSE_N(secret_value, secret_size);\n    virObjectUnref(conn);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendISCSIDirectPortal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "60-84",
    "snippet": "static char *\nvirStorageBackendISCSIDirectPortal(virStoragePoolSourcePtr source)\n{\n    char *portal = NULL;\n\n    if (source->nhost != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Expected exactly 1 host for the storage pool\"));\n        return NULL;\n    }\n    if (source->hosts[0].port == 0) {\n        portal = g_strdup_printf(\"%s:%d\",\n                                 source->hosts[0].name,\n                                 ISCSI_DEFAULT_TARGET_PORT);\n    } else if (strchr(source->hosts[0].name, ':')) {\n        portal = g_strdup_printf(\"[%s]:%d\",\n                                 source->hosts[0].name,\n                                 source->hosts[0].port);\n    } else {\n        portal = g_strdup_printf(\"%s:%d\",\n                                 source->hosts[0].name,\n                                 source->hosts[0].port);\n    }\n    return portal;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define ISCSI_DEFAULT_TARGET_PORT 3260"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s:%d\"",
            "source->hosts[0].name",
            "source->hosts[0].port"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "source->hosts[0].name",
            "':'"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Expected exactly 1 host for the storage pool\")"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\n#define ISCSI_DEFAULT_TARGET_PORT 3260\n\nstatic char *\nvirStorageBackendISCSIDirectPortal(virStoragePoolSourcePtr source)\n{\n    char *portal = NULL;\n\n    if (source->nhost != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Expected exactly 1 host for the storage pool\"));\n        return NULL;\n    }\n    if (source->hosts[0].port == 0) {\n        portal = g_strdup_printf(\"%s:%d\",\n                                 source->hosts[0].name,\n                                 ISCSI_DEFAULT_TARGET_PORT);\n    } else if (strchr(source->hosts[0].name, ':')) {\n        portal = g_strdup_printf(\"[%s]:%d\",\n                                 source->hosts[0].name,\n                                 source->hosts[0].port);\n    } else {\n        portal = g_strdup_printf(\"%s:%d\",\n                                 source->hosts[0].name,\n                                 source->hosts[0].port);\n    }\n    return portal;\n}"
  },
  {
    "function_name": "virISCSIDirectCreateContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_iscsi_direct.c",
    "lines": "47-58",
    "snippet": "static struct iscsi_context *\nvirISCSIDirectCreateContext(const char* initiator_iqn)\n{\n    struct iscsi_context *iscsi = NULL;\n\n    iscsi = iscsi_create_context(initiator_iqn);\n    if (!iscsi)\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to create iscsi context for %s\"),\n                       initiator_iqn);\n    return iscsi;\n}",
    "includes": [
      "#include \"viruuid.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virobject.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_util.h\"",
      "#include \"storage_backend_iscsi_direct.h\"",
      "#include \"virsecret.h\"",
      "#include \"datatypes.h\"",
      "#include <iscsi/scsi-lowlevel.h>",
      "#include <iscsi/iscsi.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to create iscsi context for %s\")",
            "initiator_iqn"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to create iscsi context for %s\""
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iscsi_create_context",
          "args": [
            "initiator_iqn"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruuid.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_util.h\"\n#include \"storage_backend_iscsi_direct.h\"\n#include \"virsecret.h\"\n#include \"datatypes.h\"\n#include <iscsi/scsi-lowlevel.h>\n#include <iscsi/iscsi.h>\n#include <config.h>\n\nstatic struct iscsi_context *\nvirISCSIDirectCreateContext(const char* initiator_iqn)\n{\n    struct iscsi_context *iscsi = NULL;\n\n    iscsi = iscsi_create_context(initiator_iqn);\n    if (!iscsi)\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to create iscsi context for %s\"),\n                       initiator_iqn);\n    return iscsi;\n}"
  }
]