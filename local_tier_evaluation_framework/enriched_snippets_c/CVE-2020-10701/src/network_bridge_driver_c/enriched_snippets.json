[
  {
    "function_name": "networkRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5862-5872",
    "snippet": "int\nnetworkRegister(void)\n{\n    if (virRegisterConnectDriver(&networkConnectDriver, false) < 0)\n        return -1;\n    if (virSetSharedNetworkDriver(&networkDriver) < 0)\n        return -1;\n    if (virRegisterStateDriver(&networkStateDriver) < 0)\n        return -1;\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriver networkDriver = {\n    .name = \"bridge\",\n    .connectNumOfNetworks = networkConnectNumOfNetworks, /* 0.2.0 */\n    .connectListNetworks = networkConnectListNetworks, /* 0.2.0 */\n    .connectNumOfDefinedNetworks = networkConnectNumOfDefinedNetworks, /* 0.2.0 */\n    .connectListDefinedNetworks = networkConnectListDefinedNetworks, /* 0.2.0 */\n    .connectListAllNetworks = networkConnectListAllNetworks, /* 0.10.2 */\n    .connectNetworkEventRegisterAny = networkConnectNetworkEventRegisterAny, /* 1.2.1 */\n    .connectNetworkEventDeregisterAny = networkConnectNetworkEventDeregisterAny, /* 1.2.1 */\n    .networkLookupByUUID = networkLookupByUUID, /* 0.2.0 */\n    .networkLookupByName = networkLookupByName, /* 0.2.0 */\n    .networkCreateXML = networkCreateXML, /* 0.2.0 */\n    .networkDefineXML = networkDefineXML, /* 0.2.0 */\n    .networkUndefine = networkUndefine, /* 0.2.0 */\n    .networkUpdate = networkUpdate, /* 0.10.2 */\n    .networkCreate = networkCreate, /* 0.2.0 */\n    .networkDestroy = networkDestroy, /* 0.2.0 */\n    .networkGetXMLDesc = networkGetXMLDesc, /* 0.2.0 */\n    .networkGetBridgeName = networkGetBridgeName, /* 0.2.0 */\n    .networkGetAutostart = networkGetAutostart, /* 0.2.1 */\n    .networkSetAutostart = networkSetAutostart, /* 0.2.1 */\n    .networkIsActive = networkIsActive, /* 0.7.3 */\n    .networkIsPersistent = networkIsPersistent, /* 0.7.3 */\n    .networkGetDHCPLeases = networkGetDHCPLeases, /* 1.2.6 */\n    .networkPortLookupByUUID = networkPortLookupByUUID, /* 5.5.0 */\n    .networkPortCreateXML = networkPortCreateXML, /* 5.5.0 */\n    .networkPortGetXMLDesc = networkPortGetXMLDesc, /* 5.5.0 */\n    .networkPortDelete = networkPortDelete, /* 5.5.0 */\n    .networkListAllPorts = networkListAllPorts, /* 5.5.0 */\n    .networkPortGetParameters = networkPortGetParameters, /* 5.5.0 */\n    .networkPortSetParameters = networkPortSetParameters, /* 5.5.0 */\n};",
      "static virConnectDriver networkConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"network\", NULL },\n    .hypervisorDriver = &networkHypervisorDriver,\n    .networkDriver = &networkDriver,\n};",
      "static virStateDriver networkStateDriver = {\n    .name = \"bridge\",\n    .stateInitialize  = networkStateInitialize,\n    .stateCleanup = networkStateCleanup,\n    .stateReload = networkStateReload,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRegisterStateDriver",
          "args": [
            "&networkStateDriver"
          ],
          "line": 5869
        },
        "resolved": true,
        "details": {
          "function_name": "virRegisterStateDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "588-602",
          "snippet": "int\nvirRegisterStateDriver(virStateDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virStateDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->name);\n        return -1;\n    }\n\n    virStateDriverTab[virStateDriverTabCount] = driver;\n    return virStateDriverTabCount++;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_DRIVERS 21"
          ],
          "globals_used": [
            "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
            "static int virStateDriverTabCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirRegisterStateDriver(virStateDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virStateDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->name);\n        return -1;\n    }\n\n    virStateDriverTab[virStateDriverTabCount] = driver;\n    return virStateDriverTabCount++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetSharedNetworkDriver",
          "args": [
            "&networkDriver"
          ],
          "line": 5867
        },
        "resolved": true,
        "details": {
          "function_name": "virSetSharedNetworkDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "357-372",
          "snippet": "int\nvirSetSharedNetworkDriver(virNetworkDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedNetworkDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A network driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as network driver\", driver->name);\n\n    virSharedNetworkDriver = driver;\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverPtr virSharedNetworkDriver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverPtr virSharedNetworkDriver;\n\nint\nvirSetSharedNetworkDriver(virNetworkDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedNetworkDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A network driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as network driver\", driver->name);\n\n    virSharedNetworkDriver = driver;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virRegisterConnectDriver",
          "args": [
            "&networkConnectDriver",
            "false"
          ],
          "line": 5865
        },
        "resolved": true,
        "details": {
          "function_name": "virRegisterConnectDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "515-550",
          "snippet": "int\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_DRIVERS 21"
          ],
          "globals_used": [
            "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
            "static int virConnectDriverTabCount;",
            "static virNetworkDriverPtr virSharedNetworkDriver;",
            "static virInterfaceDriverPtr virSharedInterfaceDriver;",
            "static virStorageDriverPtr virSharedStorageDriver;",
            "static virNodeDeviceDriverPtr virSharedNodeDeviceDriver;",
            "static virSecretDriverPtr virSharedSecretDriver;",
            "static virNWFilterDriverPtr virSharedNWFilterDriver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\nstatic virNetworkDriverPtr virSharedNetworkDriver;\nstatic virInterfaceDriverPtr virSharedInterfaceDriver;\nstatic virStorageDriverPtr virSharedStorageDriver;\nstatic virNodeDeviceDriverPtr virSharedNodeDeviceDriver;\nstatic virSecretDriverPtr virSharedSecretDriver;\nstatic virNWFilterDriverPtr virSharedNWFilterDriver;\n\nint\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriver networkDriver = {\n    .name = \"bridge\",\n    .connectNumOfNetworks = networkConnectNumOfNetworks, /* 0.2.0 */\n    .connectListNetworks = networkConnectListNetworks, /* 0.2.0 */\n    .connectNumOfDefinedNetworks = networkConnectNumOfDefinedNetworks, /* 0.2.0 */\n    .connectListDefinedNetworks = networkConnectListDefinedNetworks, /* 0.2.0 */\n    .connectListAllNetworks = networkConnectListAllNetworks, /* 0.10.2 */\n    .connectNetworkEventRegisterAny = networkConnectNetworkEventRegisterAny, /* 1.2.1 */\n    .connectNetworkEventDeregisterAny = networkConnectNetworkEventDeregisterAny, /* 1.2.1 */\n    .networkLookupByUUID = networkLookupByUUID, /* 0.2.0 */\n    .networkLookupByName = networkLookupByName, /* 0.2.0 */\n    .networkCreateXML = networkCreateXML, /* 0.2.0 */\n    .networkDefineXML = networkDefineXML, /* 0.2.0 */\n    .networkUndefine = networkUndefine, /* 0.2.0 */\n    .networkUpdate = networkUpdate, /* 0.10.2 */\n    .networkCreate = networkCreate, /* 0.2.0 */\n    .networkDestroy = networkDestroy, /* 0.2.0 */\n    .networkGetXMLDesc = networkGetXMLDesc, /* 0.2.0 */\n    .networkGetBridgeName = networkGetBridgeName, /* 0.2.0 */\n    .networkGetAutostart = networkGetAutostart, /* 0.2.1 */\n    .networkSetAutostart = networkSetAutostart, /* 0.2.1 */\n    .networkIsActive = networkIsActive, /* 0.7.3 */\n    .networkIsPersistent = networkIsPersistent, /* 0.7.3 */\n    .networkGetDHCPLeases = networkGetDHCPLeases, /* 1.2.6 */\n    .networkPortLookupByUUID = networkPortLookupByUUID, /* 5.5.0 */\n    .networkPortCreateXML = networkPortCreateXML, /* 5.5.0 */\n    .networkPortGetXMLDesc = networkPortGetXMLDesc, /* 5.5.0 */\n    .networkPortDelete = networkPortDelete, /* 5.5.0 */\n    .networkListAllPorts = networkListAllPorts, /* 5.5.0 */\n    .networkPortGetParameters = networkPortGetParameters, /* 5.5.0 */\n    .networkPortSetParameters = networkPortSetParameters, /* 5.5.0 */\n};\nstatic virConnectDriver networkConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"network\", NULL },\n    .hypervisorDriver = &networkHypervisorDriver,\n    .networkDriver = &networkDriver,\n};\nstatic virStateDriver networkStateDriver = {\n    .name = \"bridge\",\n    .stateInitialize  = networkStateInitialize,\n    .stateCleanup = networkStateCleanup,\n    .stateReload = networkStateReload,\n};\n\nint\nnetworkRegister(void)\n{\n    if (virRegisterConnectDriver(&networkConnectDriver, false) < 0)\n        return -1;\n    if (virSetSharedNetworkDriver(&networkDriver) < 0)\n        return -1;\n    if (virRegisterStateDriver(&networkStateDriver) < 0)\n        return -1;\n    return 0;\n}"
  },
  {
    "function_name": "networkListAllPorts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5768-5800",
    "snippet": "static int\nnetworkListAllPorts(virNetworkPtr net,\n                    virNetworkPortPtr **ports,\n                    unsigned int flags)\n{\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return ret;\n\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkListAllPortsEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    ret = virNetworkObjPortListExport(net, obj, ports,\n                                      virNetworkListAllPortsCheckACL);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 5798
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjPortListExport",
          "args": [
            "net",
            "obj",
            "ports",
            "virNetworkListAllPortsCheckACL"
          ],
          "line": 5794
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjPortListExport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1795-1832",
          "snippet": "int\nvirNetworkObjPortListExport(virNetworkPtr net,\n                            virNetworkObjPtr obj,\n                            virNetworkPortPtr **ports,\n                            virNetworkPortListFilter filter)\n{\n    virNetworkObjPortListExportData data = {\n        net, obj->def, NULL, filter, 0, false,\n    };\n    int ret = -1;\n\n    if (ports) {\n        *ports = NULL;\n\n        if (VIR_ALLOC_N(data.ports, virHashSize(obj->ports) + 1) < 0)\n            goto cleanup;\n    }\n\n    virHashForEach(obj->ports, virNetworkObjPortListExportCallback, &data);\n\n    if (data.error)\n        goto cleanup;\n\n    if (data.ports) {\n        /* trim the array to the final size */\n        ignore_value(VIR_REALLOC_N(data.ports, data.nports + 1));\n        *ports = data.ports;\n        data.ports = NULL;\n    }\n\n    ret = data.nports;\n cleanup:\n    while (data.ports && data.nports)\n        virObjectUnref(data.ports[--data.nports]);\n\n    VIR_FREE(data.ports);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nint\nvirNetworkObjPortListExport(virNetworkPtr net,\n                            virNetworkObjPtr obj,\n                            virNetworkPortPtr **ports,\n                            virNetworkPortListFilter filter)\n{\n    virNetworkObjPortListExportData data = {\n        net, obj->def, NULL, filter, 0, false,\n    };\n    int ret = -1;\n\n    if (ports) {\n        *ports = NULL;\n\n        if (VIR_ALLOC_N(data.ports, virHashSize(obj->ports) + 1) < 0)\n            goto cleanup;\n    }\n\n    virHashForEach(obj->ports, virNetworkObjPortListExportCallback, &data);\n\n    if (data.error)\n        goto cleanup;\n\n    if (data.ports) {\n        /* trim the array to the final size */\n        ignore_value(VIR_REALLOC_N(data.ports, data.nports + 1));\n        *ports = data.ports;\n        data.ports = NULL;\n    }\n\n    ret = data.nports;\n cleanup:\n    while (data.ports && data.nports)\n        virObjectUnref(data.ports[--data.nports]);\n\n    VIR_FREE(data.ports);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"network '%s' is not active\")",
            "def->name"
          ],
          "line": 5788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"network '%s' is not active\""
          ],
          "line": 5789
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 5787
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkListAllPortsEnsureACL",
          "args": [
            "net->conn",
            "def"
          ],
          "line": 5784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 5782
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "net"
          ],
          "line": 5779
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 5777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkListAllPorts(virNetworkPtr net,\n                    virNetworkPortPtr **ports,\n                    unsigned int flags)\n{\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return ret;\n\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkListAllPortsEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    ret = virNetworkObjPortListExport(net, obj, ports,\n                                      virNetworkListAllPortsCheckACL);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkPortGetParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5697-5765",
    "snippet": "static int\nnetworkPortGetParameters(virNetworkPortPtr port,\n                         virTypedParameterPtr *params,\n                         int *nparams,\n                         unsigned int flags)\n{\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virNetworkPortDefPtr portdef;\n    int maxparams = 0;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    *params = NULL;\n    *nparams = 0;\n\n    if (!(obj = networkObjFromNetwork(port->net)))\n        return ret;\n\n    def = virNetworkObjGetDef(obj);\n\n    if (!(portdef = virNetworkObjLookupPort(obj, port->uuid)))\n        goto cleanup;\n\n    if (virNetworkPortGetParametersEnsureACL(port->net->conn, def, portdef) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (portdef->bandwidth) {\n        if ((portdef->bandwidth->in != NULL) &&\n            (virTypedParamsAddUInt(params, nparams, &maxparams,\n                                   VIR_NETWORK_PORT_BANDWIDTH_IN_AVERAGE,\n                                   portdef->bandwidth->in->average) < 0 ||\n             virTypedParamsAddUInt(params, nparams, &maxparams,\n                                   VIR_NETWORK_PORT_BANDWIDTH_IN_PEAK,\n                                   portdef->bandwidth->in->peak) < 0 ||\n             virTypedParamsAddUInt(params, nparams, &maxparams,\n                                   VIR_NETWORK_PORT_BANDWIDTH_IN_FLOOR,\n                                   portdef->bandwidth->in->floor) < 0 ||\n             virTypedParamsAddUInt(params, nparams, &maxparams,\n                                   VIR_NETWORK_PORT_BANDWIDTH_IN_BURST,\n                                   portdef->bandwidth->in->burst) < 0))\n            goto cleanup;\n\n        if ((portdef->bandwidth->out != NULL) &&\n            (virTypedParamsAddUInt(params, nparams, &maxparams,\n                                   VIR_NETWORK_PORT_BANDWIDTH_OUT_AVERAGE,\n                                   portdef->bandwidth->out->average) < 0 ||\n             virTypedParamsAddUInt(params, nparams, &maxparams,\n                                   VIR_NETWORK_PORT_BANDWIDTH_OUT_PEAK,\n                                   portdef->bandwidth->out->peak) < 0 ||\n             virTypedParamsAddUInt(params, nparams, &maxparams,\n                                   VIR_NETWORK_PORT_BANDWIDTH_OUT_BURST,\n                                   portdef->bandwidth->out->burst) < 0))\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 5763
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsAddUInt",
          "args": [
            "params",
            "nparams",
            "&maxparams",
            "VIR_NETWORK_PORT_BANDWIDTH_OUT_BURST",
            "portdef->bandwidth->out->burst"
          ],
          "line": 5755
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsAddUInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam-public.c",
          "lines": "484-510",
          "snippet": "int\nvirTypedParamsAddUInt(virTypedParameterPtr *params,\n                      int *nparams,\n                      int *maxparams,\n                      const char *name,\n                      unsigned int value)\n{\n    size_t max = *maxparams;\n    size_t n = *nparams;\n\n    virResetLastError();\n\n    if (VIR_RESIZE_N(*params, max, n, 1) < 0)\n        goto error;\n    *maxparams = max;\n\n    if (virTypedParameterAssign(*params + n, name,\n                                VIR_TYPED_PARAM_UINT, value) < 0)\n        goto error;\n\n    *nparams += 1;\n    return 0;\n\n error:\n    virDispatchError(NULL);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsAddUInt(virTypedParameterPtr *params,\n                      int *nparams,\n                      int *maxparams,\n                      const char *name,\n                      unsigned int value)\n{\n    size_t max = *maxparams;\n    size_t n = *nparams;\n\n    virResetLastError();\n\n    if (VIR_RESIZE_N(*params, max, n, 1) < 0)\n        goto error;\n    *maxparams = max;\n\n    if (virTypedParameterAssign(*params + n, name,\n                                VIR_TYPED_PARAM_UINT, value) < 0)\n        goto error;\n\n    *nparams += 1;\n    return 0;\n\n error:\n    virDispatchError(NULL);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"network '%s' is not active\")",
            "def->name"
          ],
          "line": 5726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"network '%s' is not active\""
          ],
          "line": 5727
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 5725
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkPortGetParametersEnsureACL",
          "args": [
            "port->net->conn",
            "def",
            "portdef"
          ],
          "line": 5722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjLookupPort",
          "args": [
            "obj",
            "port->uuid"
          ],
          "line": 5719
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjLookupPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1660-1677",
          "snippet": "virNetworkPortDefPtr\nvirNetworkObjLookupPort(virNetworkObjPtr net,\n                        const unsigned char *uuid)\n{\n    virNetworkPortDefPtr ret = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(uuid, uuidstr);\n\n    if (!(ret = virHashLookup(net->ports, uuidstr))) {\n        virReportError(VIR_ERR_NO_NETWORK_PORT,\n                       _(\"Network port with UUID %s does not exist\"),\n                       uuidstr);\n        return NULL;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirNetworkPortDefPtr\nvirNetworkObjLookupPort(virNetworkObjPtr net,\n                        const unsigned char *uuid)\n{\n    virNetworkPortDefPtr ret = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(uuid, uuidstr);\n\n    if (!(ret = virHashLookup(net->ports, uuidstr))) {\n        virReportError(VIR_ERR_NO_NETWORK_PORT,\n                       _(\"Network port with UUID %s does not exist\"),\n                       uuidstr);\n        return NULL;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 5717
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "port->net"
          ],
          "line": 5714
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 5709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkPortGetParameters(virNetworkPortPtr port,\n                         virTypedParameterPtr *params,\n                         int *nparams,\n                         unsigned int flags)\n{\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virNetworkPortDefPtr portdef;\n    int maxparams = 0;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    *params = NULL;\n    *nparams = 0;\n\n    if (!(obj = networkObjFromNetwork(port->net)))\n        return ret;\n\n    def = virNetworkObjGetDef(obj);\n\n    if (!(portdef = virNetworkObjLookupPort(obj, port->uuid)))\n        goto cleanup;\n\n    if (virNetworkPortGetParametersEnsureACL(port->net->conn, def, portdef) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (portdef->bandwidth) {\n        if ((portdef->bandwidth->in != NULL) &&\n            (virTypedParamsAddUInt(params, nparams, &maxparams,\n                                   VIR_NETWORK_PORT_BANDWIDTH_IN_AVERAGE,\n                                   portdef->bandwidth->in->average) < 0 ||\n             virTypedParamsAddUInt(params, nparams, &maxparams,\n                                   VIR_NETWORK_PORT_BANDWIDTH_IN_PEAK,\n                                   portdef->bandwidth->in->peak) < 0 ||\n             virTypedParamsAddUInt(params, nparams, &maxparams,\n                                   VIR_NETWORK_PORT_BANDWIDTH_IN_FLOOR,\n                                   portdef->bandwidth->in->floor) < 0 ||\n             virTypedParamsAddUInt(params, nparams, &maxparams,\n                                   VIR_NETWORK_PORT_BANDWIDTH_IN_BURST,\n                                   portdef->bandwidth->in->burst) < 0))\n            goto cleanup;\n\n        if ((portdef->bandwidth->out != NULL) &&\n            (virTypedParamsAddUInt(params, nparams, &maxparams,\n                                   VIR_NETWORK_PORT_BANDWIDTH_OUT_AVERAGE,\n                                   portdef->bandwidth->out->average) < 0 ||\n             virTypedParamsAddUInt(params, nparams, &maxparams,\n                                   VIR_NETWORK_PORT_BANDWIDTH_OUT_PEAK,\n                                   portdef->bandwidth->out->peak) < 0 ||\n             virTypedParamsAddUInt(params, nparams, &maxparams,\n                                   VIR_NETWORK_PORT_BANDWIDTH_OUT_BURST,\n                                   portdef->bandwidth->out->burst) < 0))\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkPortSetParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5603-5694",
    "snippet": "static int\nnetworkPortSetParameters(virNetworkPortPtr port,\n                         virTypedParameterPtr params,\n                         int nparams,\n                         unsigned int flags)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virNetworkPortDefPtr portdef;\n    virNetDevBandwidthPtr bandwidth = NULL;\n    char *dir = NULL;\n    int ret = -1;\n    size_t i;\n\n    virCheckFlags(0, -1);\n\n    if (!(obj = networkObjFromNetwork(port->net)))\n        return ret;\n\n    def = virNetworkObjGetDef(obj);\n\n    if (!(portdef = virNetworkObjLookupPort(obj, port->uuid)))\n        goto cleanup;\n\n    if (virNetworkPortSetParametersEnsureACL(port->net->conn, def, portdef) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (!(dir = virNetworkObjGetPortStatusDir(obj, driver->stateDir)))\n        goto cleanup;\n\n    if ((VIR_ALLOC(bandwidth) < 0) ||\n        (VIR_ALLOC(bandwidth->in) < 0) ||\n        (VIR_ALLOC(bandwidth->out) < 0))\n        goto cleanup;\n\n    for (i = 0; i < nparams; i++) {\n        virTypedParameterPtr param = &params[i];\n\n        if (STREQ(param->field, VIR_NETWORK_PORT_BANDWIDTH_IN_AVERAGE)) {\n            bandwidth->in->average = param->value.ui;\n        } else if (STREQ(param->field, VIR_NETWORK_PORT_BANDWIDTH_IN_PEAK)) {\n            bandwidth->in->peak = param->value.ui;\n        } else if (STREQ(param->field, VIR_NETWORK_PORT_BANDWIDTH_IN_BURST)) {\n            bandwidth->in->burst = param->value.ui;\n        } else if (STREQ(param->field, VIR_NETWORK_PORT_BANDWIDTH_IN_FLOOR)) {\n            bandwidth->in->floor = param->value.ui;\n        } else if (STREQ(param->field, VIR_NETWORK_PORT_BANDWIDTH_OUT_AVERAGE)) {\n            bandwidth->out->average = param->value.ui;\n        } else if (STREQ(param->field, VIR_NETWORK_PORT_BANDWIDTH_OUT_PEAK)) {\n            bandwidth->out->peak = param->value.ui;\n        } else if (STREQ(param->field, VIR_NETWORK_PORT_BANDWIDTH_OUT_BURST)) {\n            bandwidth->out->burst = param->value.ui;\n        }\n    }\n\n    /* average or floor are mandatory, peak and burst are optional.\n     * So if no average or floor is given, we free inbound/outbound\n     * here which causes inbound/outbound to not be set. */\n    if (!bandwidth->in->average && !bandwidth->in->floor)\n        VIR_FREE(bandwidth->in);\n    if (!bandwidth->out->average)\n        VIR_FREE(bandwidth->out);\n\n    if (networkUpdatePortBandwidth(obj,\n                                   &portdef->mac,\n                                   &portdef->class_id,\n                                   portdef->bandwidth,\n                                   bandwidth) < 0)\n        goto cleanup;\n\n    virNetDevBandwidthFree(portdef->bandwidth);\n    portdef->bandwidth = bandwidth;\n    bandwidth = NULL;\n\n    if (virNetworkPortDefSaveStatus(portdef, dir) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virNetDevBandwidthFree(bandwidth);\n    virNetworkObjEndAPI(&obj);\n    VIR_FREE(dir);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
      "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
      "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);",
      "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dir"
          ],
          "line": 5692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 5691
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthFree",
          "args": [
            "bandwidth"
          ],
          "line": 5690
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "31-40",
          "snippet": "void\nvirNetDevBandwidthFree(virNetDevBandwidthPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->in);\n    VIR_FREE(def->out);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetDevBandwidthFree(virNetDevBandwidthPtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->in);\n    VIR_FREE(def->out);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkPortDefSaveStatus",
          "args": [
            "portdef",
            "dir"
          ],
          "line": 5685
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortDefSaveStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
          "lines": "442-465",
          "snippet": "int\nvirNetworkPortDefSaveStatus(virNetworkPortDef *def,\n                            const char *dir)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    g_autofree char *path = NULL;\n    g_autofree char *xml = NULL;\n\n    virUUIDFormat(def->uuid, uuidstr);\n\n    if (virFileMakePath(dir) < 0)\n        return -1;\n\n    if (!(path = virNetworkPortDefConfigFile(dir, uuidstr)))\n        return -1;\n\n    if (!(xml = virNetworkPortDefFormat(def)))\n        return -1;\n\n    if (virXMLSaveFile(path, uuidstr, \"net-port-create\", xml) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkPortDefSaveStatus(virNetworkPortDef *def,\n                            const char *dir)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    g_autofree char *path = NULL;\n    g_autofree char *xml = NULL;\n\n    virUUIDFormat(def->uuid, uuidstr);\n\n    if (virFileMakePath(dir) < 0)\n        return -1;\n\n    if (!(path = virNetworkPortDefConfigFile(dir, uuidstr)))\n        return -1;\n\n    if (!(xml = virNetworkPortDefFormat(def)))\n        return -1;\n\n    if (virXMLSaveFile(path, uuidstr, \"net-port-create\", xml) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkUpdatePortBandwidth",
          "args": [
            "obj",
            "&portdef->mac",
            "&portdef->class_id",
            "portdef->bandwidth",
            "bandwidth"
          ],
          "line": 5674
        },
        "resolved": true,
        "details": {
          "function_name": "networkUpdatePortBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "5328-5412",
          "snippet": "static int\nnetworkUpdatePortBandwidth(virNetworkObjPtr obj,\n                           virMacAddrPtr mac,\n                           unsigned int *class_id,\n                           virNetDevBandwidthPtr oldBandwidth,\n                           virNetDevBandwidthPtr newBandwidth)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr def;\n    unsigned long long tmp_floor_sum;\n    unsigned long long new_rate = 0;\n    unsigned long long old_floor, new_floor;\n    int plug_ret;\n\n    old_floor = new_floor = 0;\n\n    if (oldBandwidth && oldBandwidth->in)\n        old_floor = oldBandwidth->in->floor;\n    if (newBandwidth && newBandwidth->in)\n        new_floor = newBandwidth->in->floor;\n\n    if (new_floor == old_floor)\n        return 0;\n\n    def = virNetworkObjGetDef(obj);\n\n    if ((plug_ret = networkCheckBandwidth(obj, newBandwidth, oldBandwidth,\n                                          mac, &new_rate)) < 0) {\n        /* helper reported error */\n        return -1;\n    }\n\n    if (plug_ret > 0) {\n        /* no QoS needs to be set; claim success */\n        return 0;\n    }\n\n    /* Okay, there are three possible scenarios: */\n\n    if (old_floor > 0 && new_floor > 0) {\n        /* Either we just need to update @floor .. */\n\n        if (virNetDevBandwidthUpdateRate(def->bridge,\n                                         *class_id,\n                                         def->bandwidth,\n                                         new_floor) < 0)\n            return -1;\n\n        tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n        tmp_floor_sum -= old_floor;\n        tmp_floor_sum += new_floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n        new_rate -= tmp_floor_sum;\n\n        if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                         def->bandwidth, new_rate) < 0 ||\n            virNetworkObjSaveStatus(driver->stateDir,\n                                    obj, network_driver->xmlopt) < 0) {\n            /* Ouch, rollback */\n            tmp_floor_sum -= new_floor;\n            tmp_floor_sum += old_floor;\n            virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n\n            ignore_value(virNetDevBandwidthUpdateRate(def->bridge,\n                                                      *class_id,\n                                                      def->bandwidth,\n                                                      old_floor));\n            return -1;\n        }\n    } else if (new_floor > 0) {\n        /* .. or we need to plug in new .. */\n\n        if (networkPlugBandwidthImpl(obj, mac, newBandwidth,\n                                     class_id,\n                                     new_rate) < 0)\n            return -1;\n    } else {\n        /* .. or unplug old. */\n\n        if (networkUnplugBandwidth(obj, oldBandwidth, class_id) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
            "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
            "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\n\nstatic int\nnetworkUpdatePortBandwidth(virNetworkObjPtr obj,\n                           virMacAddrPtr mac,\n                           unsigned int *class_id,\n                           virNetDevBandwidthPtr oldBandwidth,\n                           virNetDevBandwidthPtr newBandwidth)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr def;\n    unsigned long long tmp_floor_sum;\n    unsigned long long new_rate = 0;\n    unsigned long long old_floor, new_floor;\n    int plug_ret;\n\n    old_floor = new_floor = 0;\n\n    if (oldBandwidth && oldBandwidth->in)\n        old_floor = oldBandwidth->in->floor;\n    if (newBandwidth && newBandwidth->in)\n        new_floor = newBandwidth->in->floor;\n\n    if (new_floor == old_floor)\n        return 0;\n\n    def = virNetworkObjGetDef(obj);\n\n    if ((plug_ret = networkCheckBandwidth(obj, newBandwidth, oldBandwidth,\n                                          mac, &new_rate)) < 0) {\n        /* helper reported error */\n        return -1;\n    }\n\n    if (plug_ret > 0) {\n        /* no QoS needs to be set; claim success */\n        return 0;\n    }\n\n    /* Okay, there are three possible scenarios: */\n\n    if (old_floor > 0 && new_floor > 0) {\n        /* Either we just need to update @floor .. */\n\n        if (virNetDevBandwidthUpdateRate(def->bridge,\n                                         *class_id,\n                                         def->bandwidth,\n                                         new_floor) < 0)\n            return -1;\n\n        tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n        tmp_floor_sum -= old_floor;\n        tmp_floor_sum += new_floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n        new_rate -= tmp_floor_sum;\n\n        if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                         def->bandwidth, new_rate) < 0 ||\n            virNetworkObjSaveStatus(driver->stateDir,\n                                    obj, network_driver->xmlopt) < 0) {\n            /* Ouch, rollback */\n            tmp_floor_sum -= new_floor;\n            tmp_floor_sum += old_floor;\n            virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n\n            ignore_value(virNetDevBandwidthUpdateRate(def->bridge,\n                                                      *class_id,\n                                                      def->bandwidth,\n                                                      old_floor));\n            return -1;\n        }\n    } else if (new_floor > 0) {\n        /* .. or we need to plug in new .. */\n\n        if (networkPlugBandwidthImpl(obj, mac, newBandwidth,\n                                     class_id,\n                                     new_rate) < 0)\n            return -1;\n    } else {\n        /* .. or unplug old. */\n\n        if (networkUnplugBandwidth(obj, oldBandwidth, class_id) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "bandwidth->out"
          ],
          "line": 5672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "bandwidth->in"
          ],
          "line": 5670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "param->field",
            "VIR_NETWORK_PORT_BANDWIDTH_OUT_BURST"
          ],
          "line": 5661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "param->field",
            "VIR_NETWORK_PORT_BANDWIDTH_OUT_PEAK"
          ],
          "line": 5659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "param->field",
            "VIR_NETWORK_PORT_BANDWIDTH_OUT_AVERAGE"
          ],
          "line": 5657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "param->field",
            "VIR_NETWORK_PORT_BANDWIDTH_IN_FLOOR"
          ],
          "line": 5655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "param->field",
            "VIR_NETWORK_PORT_BANDWIDTH_IN_BURST"
          ],
          "line": 5653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "param->field",
            "VIR_NETWORK_PORT_BANDWIDTH_IN_PEAK"
          ],
          "line": 5651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "param->field",
            "VIR_NETWORK_PORT_BANDWIDTH_IN_AVERAGE"
          ],
          "line": 5649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "bandwidth->out"
          ],
          "line": 5643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "bandwidth->in"
          ],
          "line": 5642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "bandwidth"
          ],
          "line": 5641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetPortStatusDir",
          "args": [
            "obj",
            "driver->stateDir"
          ],
          "line": 5638
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetPortStatusDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1619-1626",
          "snippet": "char *\nvirNetworkObjGetPortStatusDir(virNetworkObjPtr net,\n                              const char *stateDir)\n{\n    char *ret;\n    ret = g_strdup_printf(\"%s/%s/ports\", stateDir, net->def->name);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetworkObjLoadAllPorts(virNetworkObjPtr net,\n                          const char *stateDir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirNetworkObjLoadAllPorts(virNetworkObjPtr net,\n                          const char *stateDir);\n\nchar *\nvirNetworkObjGetPortStatusDir(virNetworkObjPtr net,\n                              const char *stateDir)\n{\n    char *ret;\n    ret = g_strdup_printf(\"%s/%s/ports\", stateDir, net->def->name);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"network '%s' is not active\")",
            "def->name"
          ],
          "line": 5632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"network '%s' is not active\""
          ],
          "line": 5633
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 5631
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkPortSetParametersEnsureACL",
          "args": [
            "port->net->conn",
            "def",
            "portdef"
          ],
          "line": 5628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjLookupPort",
          "args": [
            "obj",
            "port->uuid"
          ],
          "line": 5625
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjLookupPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1660-1677",
          "snippet": "virNetworkPortDefPtr\nvirNetworkObjLookupPort(virNetworkObjPtr net,\n                        const unsigned char *uuid)\n{\n    virNetworkPortDefPtr ret = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(uuid, uuidstr);\n\n    if (!(ret = virHashLookup(net->ports, uuidstr))) {\n        virReportError(VIR_ERR_NO_NETWORK_PORT,\n                       _(\"Network port with UUID %s does not exist\"),\n                       uuidstr);\n        return NULL;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirNetworkPortDefPtr\nvirNetworkObjLookupPort(virNetworkObjPtr net,\n                        const unsigned char *uuid)\n{\n    virNetworkPortDefPtr ret = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(uuid, uuidstr);\n\n    if (!(ret = virHashLookup(net->ports, uuidstr))) {\n        virReportError(VIR_ERR_NO_NETWORK_PORT,\n                       _(\"Network port with UUID %s does not exist\"),\n                       uuidstr);\n        return NULL;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 5623
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "port->net"
          ],
          "line": 5620
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 5618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 5609
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkPortSetParameters(virNetworkPortPtr port,\n                         virTypedParameterPtr params,\n                         int nparams,\n                         unsigned int flags)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virNetworkPortDefPtr portdef;\n    virNetDevBandwidthPtr bandwidth = NULL;\n    char *dir = NULL;\n    int ret = -1;\n    size_t i;\n\n    virCheckFlags(0, -1);\n\n    if (!(obj = networkObjFromNetwork(port->net)))\n        return ret;\n\n    def = virNetworkObjGetDef(obj);\n\n    if (!(portdef = virNetworkObjLookupPort(obj, port->uuid)))\n        goto cleanup;\n\n    if (virNetworkPortSetParametersEnsureACL(port->net->conn, def, portdef) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (!(dir = virNetworkObjGetPortStatusDir(obj, driver->stateDir)))\n        goto cleanup;\n\n    if ((VIR_ALLOC(bandwidth) < 0) ||\n        (VIR_ALLOC(bandwidth->in) < 0) ||\n        (VIR_ALLOC(bandwidth->out) < 0))\n        goto cleanup;\n\n    for (i = 0; i < nparams; i++) {\n        virTypedParameterPtr param = &params[i];\n\n        if (STREQ(param->field, VIR_NETWORK_PORT_BANDWIDTH_IN_AVERAGE)) {\n            bandwidth->in->average = param->value.ui;\n        } else if (STREQ(param->field, VIR_NETWORK_PORT_BANDWIDTH_IN_PEAK)) {\n            bandwidth->in->peak = param->value.ui;\n        } else if (STREQ(param->field, VIR_NETWORK_PORT_BANDWIDTH_IN_BURST)) {\n            bandwidth->in->burst = param->value.ui;\n        } else if (STREQ(param->field, VIR_NETWORK_PORT_BANDWIDTH_IN_FLOOR)) {\n            bandwidth->in->floor = param->value.ui;\n        } else if (STREQ(param->field, VIR_NETWORK_PORT_BANDWIDTH_OUT_AVERAGE)) {\n            bandwidth->out->average = param->value.ui;\n        } else if (STREQ(param->field, VIR_NETWORK_PORT_BANDWIDTH_OUT_PEAK)) {\n            bandwidth->out->peak = param->value.ui;\n        } else if (STREQ(param->field, VIR_NETWORK_PORT_BANDWIDTH_OUT_BURST)) {\n            bandwidth->out->burst = param->value.ui;\n        }\n    }\n\n    /* average or floor are mandatory, peak and burst are optional.\n     * So if no average or floor is given, we free inbound/outbound\n     * here which causes inbound/outbound to not be set. */\n    if (!bandwidth->in->average && !bandwidth->in->floor)\n        VIR_FREE(bandwidth->in);\n    if (!bandwidth->out->average)\n        VIR_FREE(bandwidth->out);\n\n    if (networkUpdatePortBandwidth(obj,\n                                   &portdef->mac,\n                                   &portdef->class_id,\n                                   portdef->bandwidth,\n                                   bandwidth) < 0)\n        goto cleanup;\n\n    virNetDevBandwidthFree(portdef->bandwidth);\n    portdef->bandwidth = bandwidth;\n    bandwidth = NULL;\n\n    if (virNetworkPortDefSaveStatus(portdef, dir) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virNetDevBandwidthFree(bandwidth);\n    virNetworkObjEndAPI(&obj);\n    VIR_FREE(dir);\n    return ret;\n}"
  },
  {
    "function_name": "networkPortDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5561-5600",
    "snippet": "static int\nnetworkPortDelete(virNetworkPortPtr port,\n                  unsigned int flags)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virNetworkPortDefPtr portdef;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (!(obj = networkObjFromNetwork(port->net)))\n        return ret;\n\n    def = virNetworkObjGetDef(obj);\n\n    if (!(portdef = virNetworkObjLookupPort(obj, port->uuid)))\n        goto cleanup;\n\n    if (virNetworkPortDeleteEnsureACL(port->net->conn, def, portdef) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (networkReleasePort(obj, portdef) < 0)\n        goto cleanup;\n\n    virNetworkObjDeletePort(obj, port->uuid, driver->stateDir);\n\n    ret = 0;\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
      "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 5598
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjDeletePort",
          "args": [
            "obj",
            "port->uuid",
            "driver->stateDir"
          ],
          "line": 5594
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjDeletePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1680-1708",
          "snippet": "int\nvirNetworkObjDeletePort(virNetworkObjPtr net,\n                        const unsigned char *uuid,\n                        const char *stateDir)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    g_autofree char *dir = NULL;\n    virNetworkPortDefPtr portdef;\n\n    virUUIDFormat(uuid, uuidstr);\n\n    if (!(portdef = virHashLookup(net->ports, uuidstr))) {\n        virReportError(VIR_ERR_NO_NETWORK_PORT,\n                       _(\"Network port with UUID %s does not exist\"),\n                       uuidstr);\n        return -1;\n    }\n\n    if (!(dir = virNetworkObjGetPortStatusDir(net, stateDir)))\n        return -1;\n\n    if (virNetworkPortDefDeleteStatus(portdef, dir) < 0)\n        return -1;\n\n    if (virHashRemoveEntry(net->ports, uuidstr) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetworkObjLoadAllPorts(virNetworkObjPtr net,\n                          const char *stateDir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirNetworkObjLoadAllPorts(virNetworkObjPtr net,\n                          const char *stateDir);\n\nint\nvirNetworkObjDeletePort(virNetworkObjPtr net,\n                        const unsigned char *uuid,\n                        const char *stateDir)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    g_autofree char *dir = NULL;\n    virNetworkPortDefPtr portdef;\n\n    virUUIDFormat(uuid, uuidstr);\n\n    if (!(portdef = virHashLookup(net->ports, uuidstr))) {\n        virReportError(VIR_ERR_NO_NETWORK_PORT,\n                       _(\"Network port with UUID %s does not exist\"),\n                       uuidstr);\n        return -1;\n    }\n\n    if (!(dir = virNetworkObjGetPortStatusDir(net, stateDir)))\n        return -1;\n\n    if (virNetworkPortDefDeleteStatus(portdef, dir) < 0)\n        return -1;\n\n    if (virHashRemoveEntry(net->ports, uuidstr) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkReleasePort",
          "args": [
            "obj",
            "portdef"
          ],
          "line": 5591
        },
        "resolved": true,
        "details": {
          "function_name": "networkReleasePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "4938-5037",
          "snippet": "static int\nnetworkReleasePort(virNetworkObjPtr obj,\n                   virNetworkPortDefPtr port)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr netdef;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n\n    netdef = virNetworkObjGetDef(obj);\n\n    switch ((virNetworkPortPlugType)port->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        VIR_DEBUG(\"Releasing network device with no plug type\");\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        if (networkUnplugBandwidth(obj, port->bandwidth,\n                                   &port->class_id) < 0)\n            return -1;\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (netdef->forward.nifs == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a direct mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        }\n\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n                STREQ(port->plug.direct.linkdev, netdef->forward.ifs[i].device.dev)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have dev='%s' \"\n                             \"in use by domain\"),\n                           netdef->name, port->plug.direct.linkdev);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n        if (netdef->forward.nifs == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a hostdev mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        }\n\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI &&\n                virPCIDeviceAddressEqual(&port->plug.hostdevpci.addr,\n                                         &netdef->forward.ifs[i].device.pci)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have \"\n                             \"PCI device %04x:%02x:%02x.%x in use by domain\"),\n                           netdef->name,\n                           port->plug.hostdevpci.addr.domain,\n                           port->plug.hostdevpci.addr.bus,\n                           port->plug.hostdevpci.addr.slot,\n                           port->plug.hostdevpci.addr.function);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, port->plugtype);\n        return -1;\n    }\n\n    virNetworkObjMacMgrDel(obj, driver->dnsmasqStateDir, port->ownername, &port->mac);\n\n    netdef->connections--;\n    if (dev)\n        dev->connections--;\n    /* finally we can call the 'unplugged' hook script if any */\n    networkRunHook(obj, port, VIR_HOOK_NETWORK_OP_PORT_DELETED,\n                   VIR_HOOK_SUBOP_BEGIN);\n    networkLogAllocation(netdef, dev, &port->mac, false);\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
            "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
            "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);",
            "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkReleasePort(virNetworkObjPtr obj,\n                   virNetworkPortDefPtr port)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr netdef;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n\n    netdef = virNetworkObjGetDef(obj);\n\n    switch ((virNetworkPortPlugType)port->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        VIR_DEBUG(\"Releasing network device with no plug type\");\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        if (networkUnplugBandwidth(obj, port->bandwidth,\n                                   &port->class_id) < 0)\n            return -1;\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (netdef->forward.nifs == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a direct mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        }\n\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n                STREQ(port->plug.direct.linkdev, netdef->forward.ifs[i].device.dev)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have dev='%s' \"\n                             \"in use by domain\"),\n                           netdef->name, port->plug.direct.linkdev);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n        if (netdef->forward.nifs == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a hostdev mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        }\n\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI &&\n                virPCIDeviceAddressEqual(&port->plug.hostdevpci.addr,\n                                         &netdef->forward.ifs[i].device.pci)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have \"\n                             \"PCI device %04x:%02x:%02x.%x in use by domain\"),\n                           netdef->name,\n                           port->plug.hostdevpci.addr.domain,\n                           port->plug.hostdevpci.addr.bus,\n                           port->plug.hostdevpci.addr.slot,\n                           port->plug.hostdevpci.addr.function);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, port->plugtype);\n        return -1;\n    }\n\n    virNetworkObjMacMgrDel(obj, driver->dnsmasqStateDir, port->ownername, &port->mac);\n\n    netdef->connections--;\n    if (dev)\n        dev->connections--;\n    /* finally we can call the 'unplugged' hook script if any */\n    networkRunHook(obj, port, VIR_HOOK_NETWORK_OP_PORT_DELETED,\n                   VIR_HOOK_SUBOP_BEGIN);\n    networkLogAllocation(netdef, dev, &port->mac, false);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"network '%s' is not active\")",
            "def->name"
          ],
          "line": 5585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"network '%s' is not active\""
          ],
          "line": 5586
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 5584
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkPortDeleteEnsureACL",
          "args": [
            "port->net->conn",
            "def",
            "portdef"
          ],
          "line": 5581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjLookupPort",
          "args": [
            "obj",
            "port->uuid"
          ],
          "line": 5578
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjLookupPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1660-1677",
          "snippet": "virNetworkPortDefPtr\nvirNetworkObjLookupPort(virNetworkObjPtr net,\n                        const unsigned char *uuid)\n{\n    virNetworkPortDefPtr ret = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(uuid, uuidstr);\n\n    if (!(ret = virHashLookup(net->ports, uuidstr))) {\n        virReportError(VIR_ERR_NO_NETWORK_PORT,\n                       _(\"Network port with UUID %s does not exist\"),\n                       uuidstr);\n        return NULL;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirNetworkPortDefPtr\nvirNetworkObjLookupPort(virNetworkObjPtr net,\n                        const unsigned char *uuid)\n{\n    virNetworkPortDefPtr ret = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(uuid, uuidstr);\n\n    if (!(ret = virHashLookup(net->ports, uuidstr))) {\n        virReportError(VIR_ERR_NO_NETWORK_PORT,\n                       _(\"Network port with UUID %s does not exist\"),\n                       uuidstr);\n        return NULL;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 5576
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "port->net"
          ],
          "line": 5573
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 5571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 5565
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkPortDelete(virNetworkPortPtr port,\n                  unsigned int flags)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virNetworkPortDefPtr portdef;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (!(obj = networkObjFromNetwork(port->net)))\n        return ret;\n\n    def = virNetworkObjGetDef(obj);\n\n    if (!(portdef = virNetworkObjLookupPort(obj, port->uuid)))\n        goto cleanup;\n\n    if (virNetworkPortDeleteEnsureACL(port->net->conn, def, portdef) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (networkReleasePort(obj, portdef) < 0)\n        goto cleanup;\n\n    virNetworkObjDeletePort(obj, port->uuid, driver->stateDir);\n\n    ret = 0;\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkPortGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5523-5558",
    "snippet": "static char *\nnetworkPortGetXMLDesc(virNetworkPortPtr port,\n                      unsigned int flags)\n{\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virNetworkPortDefPtr portdef = NULL;\n    char *ret = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (!(obj = networkObjFromNetwork(port->net)))\n        return ret;\n\n    def = virNetworkObjGetDef(obj);\n\n    if (!(portdef = virNetworkObjLookupPort(obj, port->uuid)))\n        goto cleanup;\n\n    if (virNetworkPortGetXMLDescEnsureACL(port->net->conn, def, portdef) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n   if (!(ret = virNetworkPortDefFormat(portdef)))\n       goto cleanup;\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 5556
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkPortDefFormat",
          "args": [
            "portdef"
          ],
          "line": 5552
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
          "lines": "324-335",
          "snippet": "char *\nvirNetworkPortDefFormat(const virNetworkPortDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkPortDefFormatBuf(&buf, def) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNetworkPortDefFormat(const virNetworkPortDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkPortDefFormatBuf(&buf, def) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"network '%s' is not active\")",
            "def->name"
          ],
          "line": 5546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"network '%s' is not active\""
          ],
          "line": 5547
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 5545
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkPortGetXMLDescEnsureACL",
          "args": [
            "port->net->conn",
            "def",
            "portdef"
          ],
          "line": 5542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjLookupPort",
          "args": [
            "obj",
            "port->uuid"
          ],
          "line": 5539
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjLookupPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1660-1677",
          "snippet": "virNetworkPortDefPtr\nvirNetworkObjLookupPort(virNetworkObjPtr net,\n                        const unsigned char *uuid)\n{\n    virNetworkPortDefPtr ret = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(uuid, uuidstr);\n\n    if (!(ret = virHashLookup(net->ports, uuidstr))) {\n        virReportError(VIR_ERR_NO_NETWORK_PORT,\n                       _(\"Network port with UUID %s does not exist\"),\n                       uuidstr);\n        return NULL;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirNetworkPortDefPtr\nvirNetworkObjLookupPort(virNetworkObjPtr net,\n                        const unsigned char *uuid)\n{\n    virNetworkPortDefPtr ret = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(uuid, uuidstr);\n\n    if (!(ret = virHashLookup(net->ports, uuidstr))) {\n        virReportError(VIR_ERR_NO_NETWORK_PORT,\n                       _(\"Network port with UUID %s does not exist\"),\n                       uuidstr);\n        return NULL;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 5537
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "port->net"
          ],
          "line": 5534
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 5532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic char *\nnetworkPortGetXMLDesc(virNetworkPortPtr port,\n                      unsigned int flags)\n{\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virNetworkPortDefPtr portdef = NULL;\n    char *ret = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (!(obj = networkObjFromNetwork(port->net)))\n        return ret;\n\n    def = virNetworkObjGetDef(obj);\n\n    if (!(portdef = virNetworkObjLookupPort(obj, port->uuid)))\n        goto cleanup;\n\n    if (virNetworkPortGetXMLDescEnsureACL(port->net->conn, def, portdef) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n   if (!(ret = virNetworkPortDefFormat(portdef)))\n       goto cleanup;\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkPortCreateXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5452-5520",
    "snippet": "static virNetworkPortPtr\nnetworkPortCreateXML(virNetworkPtr net,\n                     const char *xmldesc,\n                     unsigned int flags)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    g_autoptr(virNetworkPortDef) portdef = NULL;\n    virNetworkPortPtr ret = NULL;\n    int rc;\n\n    virCheckFlags(VIR_NETWORK_PORT_CREATE_RECLAIM, NULL);\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return ret;\n\n    def = virNetworkObjGetDef(obj);\n\n    if (!(portdef = virNetworkPortDefParseString(xmldesc)))\n        goto cleanup;\n\n    if (virNetworkPortCreateXMLEnsureACL(net->conn, def, portdef) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (portdef->plugtype == VIR_NETWORK_PORT_PLUG_TYPE_NONE) {\n        if (flags & VIR_NETWORK_PORT_CREATE_RECLAIM) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"Port reclaim requested but plug type is none\"));\n            goto cleanup;\n        }\n    } else {\n        if (!(flags & VIR_NETWORK_PORT_CREATE_RECLAIM)) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"Port reclaim not requested but plug type is not none\"));\n            goto cleanup;\n        }\n    }\n\n    if (flags & VIR_NETWORK_PORT_CREATE_RECLAIM)\n        rc = networkNotifyPort(obj, portdef);\n    else\n        rc = networkAllocatePort(obj, portdef);\n    if (rc < 0)\n        goto cleanup;\n\n    if (virNetworkObjAddPort(obj, portdef, driver->stateDir) < 0) {\n        virErrorPtr save_err;\n\n        virErrorPreserveLast(&save_err);\n        ignore_value(networkReleasePort(obj, portdef));\n        virErrorRestore(&save_err);\n\n        goto cleanup;\n    }\n\n    ret = virGetNetworkPort(net, portdef->uuid);\n    portdef = NULL;\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 5518
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetNetworkPort",
          "args": [
            "net",
            "portdef->uuid"
          ],
          "line": 5515
        },
        "resolved": true,
        "details": {
          "function_name": "virGetNetworkPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "402-424",
          "snippet": "virNetworkPortPtr\nvirGetNetworkPort(virNetworkPtr net, const unsigned char *uuid)\n{\n    virNetworkPortPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckNetworkGoto(net, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkPortClass)))\n        goto error;\n\n    ret->net = virObjectRef(net);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virNetworkPortClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virNetworkPortClass;\n\nvirNetworkPortPtr\nvirGetNetworkPort(virNetworkPtr net, const unsigned char *uuid)\n{\n    virNetworkPortPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckNetworkGoto(net, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkPortClass)))\n        goto error;\n\n    ret->net = virObjectRef(net);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&save_err"
          ],
          "line": 5510
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "networkReleasePort(obj, portdef)"
          ],
          "line": 5509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkReleasePort",
          "args": [
            "obj",
            "portdef"
          ],
          "line": 5509
        },
        "resolved": true,
        "details": {
          "function_name": "networkReleasePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "4938-5037",
          "snippet": "static int\nnetworkReleasePort(virNetworkObjPtr obj,\n                   virNetworkPortDefPtr port)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr netdef;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n\n    netdef = virNetworkObjGetDef(obj);\n\n    switch ((virNetworkPortPlugType)port->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        VIR_DEBUG(\"Releasing network device with no plug type\");\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        if (networkUnplugBandwidth(obj, port->bandwidth,\n                                   &port->class_id) < 0)\n            return -1;\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (netdef->forward.nifs == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a direct mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        }\n\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n                STREQ(port->plug.direct.linkdev, netdef->forward.ifs[i].device.dev)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have dev='%s' \"\n                             \"in use by domain\"),\n                           netdef->name, port->plug.direct.linkdev);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n        if (netdef->forward.nifs == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a hostdev mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        }\n\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI &&\n                virPCIDeviceAddressEqual(&port->plug.hostdevpci.addr,\n                                         &netdef->forward.ifs[i].device.pci)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have \"\n                             \"PCI device %04x:%02x:%02x.%x in use by domain\"),\n                           netdef->name,\n                           port->plug.hostdevpci.addr.domain,\n                           port->plug.hostdevpci.addr.bus,\n                           port->plug.hostdevpci.addr.slot,\n                           port->plug.hostdevpci.addr.function);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, port->plugtype);\n        return -1;\n    }\n\n    virNetworkObjMacMgrDel(obj, driver->dnsmasqStateDir, port->ownername, &port->mac);\n\n    netdef->connections--;\n    if (dev)\n        dev->connections--;\n    /* finally we can call the 'unplugged' hook script if any */\n    networkRunHook(obj, port, VIR_HOOK_NETWORK_OP_PORT_DELETED,\n                   VIR_HOOK_SUBOP_BEGIN);\n    networkLogAllocation(netdef, dev, &port->mac, false);\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
            "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
            "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);",
            "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkReleasePort(virNetworkObjPtr obj,\n                   virNetworkPortDefPtr port)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr netdef;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n\n    netdef = virNetworkObjGetDef(obj);\n\n    switch ((virNetworkPortPlugType)port->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        VIR_DEBUG(\"Releasing network device with no plug type\");\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        if (networkUnplugBandwidth(obj, port->bandwidth,\n                                   &port->class_id) < 0)\n            return -1;\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (netdef->forward.nifs == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a direct mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        }\n\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n                STREQ(port->plug.direct.linkdev, netdef->forward.ifs[i].device.dev)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have dev='%s' \"\n                             \"in use by domain\"),\n                           netdef->name, port->plug.direct.linkdev);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n        if (netdef->forward.nifs == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a hostdev mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        }\n\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI &&\n                virPCIDeviceAddressEqual(&port->plug.hostdevpci.addr,\n                                         &netdef->forward.ifs[i].device.pci)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have \"\n                             \"PCI device %04x:%02x:%02x.%x in use by domain\"),\n                           netdef->name,\n                           port->plug.hostdevpci.addr.domain,\n                           port->plug.hostdevpci.addr.bus,\n                           port->plug.hostdevpci.addr.slot,\n                           port->plug.hostdevpci.addr.function);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, port->plugtype);\n        return -1;\n    }\n\n    virNetworkObjMacMgrDel(obj, driver->dnsmasqStateDir, port->ownername, &port->mac);\n\n    netdef->connections--;\n    if (dev)\n        dev->connections--;\n    /* finally we can call the 'unplugged' hook script if any */\n    networkRunHook(obj, port, VIR_HOOK_NETWORK_OP_PORT_DELETED,\n                   VIR_HOOK_SUBOP_BEGIN);\n    networkLogAllocation(netdef, dev, &port->mac, false);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&save_err"
          ],
          "line": 5508
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjAddPort",
          "args": [
            "obj",
            "portdef",
            "driver->stateDir"
          ],
          "line": 5505
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjAddPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1628-1657",
          "snippet": "int\nvirNetworkObjAddPort(virNetworkObjPtr net,\n                     virNetworkPortDefPtr portdef,\n                     const char *stateDir)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    g_autofree char *dir = NULL;\n\n    virUUIDFormat(portdef->uuid, uuidstr);\n\n    if (virHashLookup(net->ports, uuidstr)) {\n        virReportError(VIR_ERR_NETWORK_PORT_EXIST,\n                       _(\"Network port with UUID %s already exists\"),\n                       uuidstr);\n        return -1;\n    }\n\n    if (!(dir = virNetworkObjGetPortStatusDir(net, stateDir)))\n        return -1;\n\n    if (virHashAddEntry(net->ports, uuidstr, portdef) < 0)\n        return -1;\n\n    if (virNetworkPortDefSaveStatus(portdef, dir) < 0) {\n        virHashRemoveEntry(net->ports, uuidstr);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetworkObjLoadAllPorts(virNetworkObjPtr net,\n                          const char *stateDir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirNetworkObjLoadAllPorts(virNetworkObjPtr net,\n                          const char *stateDir);\n\nint\nvirNetworkObjAddPort(virNetworkObjPtr net,\n                     virNetworkPortDefPtr portdef,\n                     const char *stateDir)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    g_autofree char *dir = NULL;\n\n    virUUIDFormat(portdef->uuid, uuidstr);\n\n    if (virHashLookup(net->ports, uuidstr)) {\n        virReportError(VIR_ERR_NETWORK_PORT_EXIST,\n                       _(\"Network port with UUID %s already exists\"),\n                       uuidstr);\n        return -1;\n    }\n\n    if (!(dir = virNetworkObjGetPortStatusDir(net, stateDir)))\n        return -1;\n\n    if (virHashAddEntry(net->ports, uuidstr, portdef) < 0)\n        return -1;\n\n    if (virNetworkPortDefSaveStatus(portdef, dir) < 0) {\n        virHashRemoveEntry(net->ports, uuidstr);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkAllocatePort",
          "args": [
            "obj",
            "portdef"
          ],
          "line": 5501
        },
        "resolved": true,
        "details": {
          "function_name": "networkAllocatePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "4485-4771",
          "snippet": "static int\nnetworkAllocatePort(virNetworkObjPtr obj,\n                    virNetworkPortDefPtr port)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr netdef = NULL;\n    virPortGroupDefPtr portgroup = NULL;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n    virNetDevVPortProfilePtr portprofile = NULL;\n\n    netdef = virNetworkObjGetDef(obj);\n    VIR_DEBUG(\"Allocating port from net %s\", netdef->name);\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       netdef->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Interface port group %s\", port->group);\n    /* portgroup can be present for any type of network, in particular\n     * for bandwidth information, so we need to check for that and\n     * fill it in appropriately for all forward types.\n     */\n    portgroup = virPortGroupFindByName(netdef, port->group);\n\n    if (!port->bandwidth) {\n        if (portgroup && portgroup->bandwidth &&\n            virNetDevBandwidthCopy(&port->bandwidth,\n                                   portgroup->bandwidth) < 0)\n            return -1;\n    }\n\n    if (port->vlan.nTags == 0) {\n        virNetDevVlanPtr vlan = NULL;\n        if (portgroup && portgroup->vlan.nTags > 0)\n            vlan = &portgroup->vlan;\n        else if (netdef->vlan.nTags > 0)\n            vlan = &netdef->vlan;\n\n        if (vlan && virNetDevVlanCopy(&port->vlan, vlan) < 0)\n            return -1;\n    }\n\n    if (!port->trustGuestRxFilters) {\n        if (portgroup && portgroup->trustGuestRxFilters)\n            port->trustGuestRxFilters = portgroup->trustGuestRxFilters;\n        else if (netdef->trustGuestRxFilters)\n            port->trustGuestRxFilters = netdef->trustGuestRxFilters;\n    }\n\n    if (port->isolatedPort == VIR_TRISTATE_BOOL_ABSENT)\n        port->isolatedPort = netdef->isolatedPort;\n\n    /* merge virtualports from interface, network, and portgroup to\n     * arrive at actual virtualport to use\n     */\n    if (virNetDevVPortProfileMerge3(&portprofile,\n                                    port->virtPortProfile,\n                                    netdef->virtPortProfile,\n                                    portgroup\n                                    ? portgroup->virtPortProfile : NULL) < 0) {\n                return -1;\n    }\n    if (portprofile) {\n        VIR_FREE(port->virtPortProfile);\n        port->virtPortProfile = portprofile;\n    }\n\n    VIR_DEBUG(\"Processing forward type %d\", netdef->forward.type);\n    switch ((virNetworkForwardType) netdef->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* for these forward types, the actual net type really *is*\n         * NETWORK; we just keep the info from the portgroup in\n         * iface->data.network.actual\n         */\n        port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_NETWORK;\n\n        port->plug.bridge.brname = g_strdup(netdef->bridge);\n        port->plug.bridge.macTableManager = netdef->macTableManager;\n\n        if (port->virtPortProfile) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"<virtualport type='%s'> not supported for network \"\n                             \"'%s' which uses IP forwarding\"),\n                           virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                           netdef->name);\n            return -1;\n        }\n\n        break;\n\n    case VIR_NETWORK_FORWARD_HOSTDEV: {\n        port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI;\n\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* pick first dev with 0 connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].connections == 0) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' requires exclusive access \"\n                             \"to interfaces, but none are available\"),\n                           netdef->name);\n            return -1;\n        }\n        port->plug.hostdevpci.addr = dev->device.pci;\n        port->plug.hostdevpci.driver = netdef->forward.driverName;\n        port->plug.hostdevpci.managed = netdef->forward.managed;\n\n        if (port->virtPortProfile) {\n            /* make sure type is supported for hostdev connections */\n            if (port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBG &&\n                port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBH) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"<virtualport type='%s'> not supported for network \"\n                                 \"'%s' which uses an SR-IOV Virtual Function \"\n                                 \"via PCI passthrough\"),\n                               virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                               netdef->name);\n                return -1;\n            }\n        }\n        break;\n    }\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (netdef->bridge) {\n            /* <forward type='bridge'/> <bridge name='xxx'/>\n             * is VIR_DOMAIN_NET_TYPE_BRIDGE\n             */\n\n            port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE;\n            port->plug.bridge.brname = g_strdup(netdef->bridge);\n            port->plug.bridge.macTableManager = netdef->macTableManager;\n\n            if (port->virtPortProfile) {\n                /* only type='openvswitch' is allowed for bridges */\n                if (port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"<virtualport type='%s'> not supported for network \"\n                                     \"'%s' which uses a bridge device\"),\n                                   virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                                   netdef->name);\n                    return -1;\n                }\n            }\n\n            break;\n        }\n\n        /* intentionally fall through to the direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        /* <forward type='bridge|private|vepa|passthrough'> are all\n         * VIR_DOMAIN_NET_TYPE_DIRECT.\n         */\n\n        /* Set type=direct and appropriate <source mode='xxx'/> */\n        port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_DIRECT;\n\n        /* NO need to check the value returned from virNetDevMacVLanModeTypeFromString\n         * it must be valid for these forward type(bridge|private|vepa|passthrough)\n         */\n        port->plug.direct.mode =\n            virNetDevMacVLanModeTypeFromString(virNetworkForwardTypeToString(netdef->forward.type));\n\n        if (port->virtPortProfile) {\n            /* make sure type is supported for macvtap connections */\n            if (port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBG &&\n                port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBH) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"<virtualport type='%s'> not supported for network \"\n                                 \"'%s' which uses a macvtap device\"),\n                               virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                               netdef->name);\n                return -1;\n            }\n        }\n\n        /* If there is only a single device, just return it (caller will detect\n         * any error if exclusive use is required but could not be acquired).\n         */\n        if ((netdef->forward.nifs <= 0) && (netdef->forward.npfs <= 0)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a direct mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        } else {\n            /* pick an interface from the pool */\n\n            if (networkCreateInterfacePool(netdef) < 0)\n                return -1;\n\n            /* PASSTHROUGH mode, and PRIVATE Mode + 802.1Qbh both\n             * require exclusive access to a device, so current\n             * connections count must be 0.  Other modes can share, so\n             * just search for the one with the lowest number of\n             * connections.\n             */\n            if ((netdef->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH) ||\n                ((netdef->forward.type == VIR_NETWORK_FORWARD_PRIVATE) &&\n                 port->virtPortProfile &&\n                 (port->virtPortProfile->virtPortType\n                  == VIR_NETDEV_VPORT_PROFILE_8021QBH))) {\n\n                /* pick first dev with 0 connections */\n                for (i = 0; i < netdef->forward.nifs; i++) {\n                    if (netdef->forward.ifs[i].connections == 0) {\n                        dev = &netdef->forward.ifs[i];\n                        break;\n                    }\n                }\n            } else {\n                /* pick least used dev */\n                dev = &netdef->forward.ifs[0];\n                for (i = 1; i < netdef->forward.nifs; i++) {\n                    if (netdef->forward.ifs[i].connections < dev->connections)\n                        dev = &netdef->forward.ifs[i];\n                }\n            }\n            /* dev points at the physical device we want to use */\n            if (!dev) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"network '%s' requires exclusive access \"\n                                 \"to interfaces, but none are available\"),\n                               netdef->name);\n                return -1;\n            }\n            port->plug.direct.linkdev = g_strdup(dev->device.dev);\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, netdef->forward.type);\n        return -1;\n    }\n\n\n    if (networkPlugBandwidth(obj, &port->mac, port->bandwidth,\n                             &port->class_id) < 0)\n        return -1;\n\n    if (virNetworkObjMacMgrAdd(obj, driver->dnsmasqStateDir,\n                               port->ownername, &port->mac) < 0)\n        return -1;\n\n    if (virNetDevVPortProfileCheckComplete(port->virtPortProfile, true) < 0)\n        return -1;\n\n    netdef->connections++;\n    if (dev)\n        dev->connections++;\n    /* finally we can call the 'plugged' hook script if any */\n    if (networkRunHook(obj, port,\n                       VIR_HOOK_NETWORK_OP_PORT_CREATED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0) {\n        /* adjust for failure */\n        netdef->connections--;\n        if (dev)\n            dev->connections--;\n        return -1;\n    }\n    networkLogAllocation(netdef, dev, &port->mac, true);\n\n    VIR_DEBUG(\"Port allocated\");\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
            "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
            "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);",
            "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkAllocatePort(virNetworkObjPtr obj,\n                    virNetworkPortDefPtr port)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr netdef = NULL;\n    virPortGroupDefPtr portgroup = NULL;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n    virNetDevVPortProfilePtr portprofile = NULL;\n\n    netdef = virNetworkObjGetDef(obj);\n    VIR_DEBUG(\"Allocating port from net %s\", netdef->name);\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       netdef->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Interface port group %s\", port->group);\n    /* portgroup can be present for any type of network, in particular\n     * for bandwidth information, so we need to check for that and\n     * fill it in appropriately for all forward types.\n     */\n    portgroup = virPortGroupFindByName(netdef, port->group);\n\n    if (!port->bandwidth) {\n        if (portgroup && portgroup->bandwidth &&\n            virNetDevBandwidthCopy(&port->bandwidth,\n                                   portgroup->bandwidth) < 0)\n            return -1;\n    }\n\n    if (port->vlan.nTags == 0) {\n        virNetDevVlanPtr vlan = NULL;\n        if (portgroup && portgroup->vlan.nTags > 0)\n            vlan = &portgroup->vlan;\n        else if (netdef->vlan.nTags > 0)\n            vlan = &netdef->vlan;\n\n        if (vlan && virNetDevVlanCopy(&port->vlan, vlan) < 0)\n            return -1;\n    }\n\n    if (!port->trustGuestRxFilters) {\n        if (portgroup && portgroup->trustGuestRxFilters)\n            port->trustGuestRxFilters = portgroup->trustGuestRxFilters;\n        else if (netdef->trustGuestRxFilters)\n            port->trustGuestRxFilters = netdef->trustGuestRxFilters;\n    }\n\n    if (port->isolatedPort == VIR_TRISTATE_BOOL_ABSENT)\n        port->isolatedPort = netdef->isolatedPort;\n\n    /* merge virtualports from interface, network, and portgroup to\n     * arrive at actual virtualport to use\n     */\n    if (virNetDevVPortProfileMerge3(&portprofile,\n                                    port->virtPortProfile,\n                                    netdef->virtPortProfile,\n                                    portgroup\n                                    ? portgroup->virtPortProfile : NULL) < 0) {\n                return -1;\n    }\n    if (portprofile) {\n        VIR_FREE(port->virtPortProfile);\n        port->virtPortProfile = portprofile;\n    }\n\n    VIR_DEBUG(\"Processing forward type %d\", netdef->forward.type);\n    switch ((virNetworkForwardType) netdef->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* for these forward types, the actual net type really *is*\n         * NETWORK; we just keep the info from the portgroup in\n         * iface->data.network.actual\n         */\n        port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_NETWORK;\n\n        port->plug.bridge.brname = g_strdup(netdef->bridge);\n        port->plug.bridge.macTableManager = netdef->macTableManager;\n\n        if (port->virtPortProfile) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"<virtualport type='%s'> not supported for network \"\n                             \"'%s' which uses IP forwarding\"),\n                           virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                           netdef->name);\n            return -1;\n        }\n\n        break;\n\n    case VIR_NETWORK_FORWARD_HOSTDEV: {\n        port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI;\n\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* pick first dev with 0 connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].connections == 0) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' requires exclusive access \"\n                             \"to interfaces, but none are available\"),\n                           netdef->name);\n            return -1;\n        }\n        port->plug.hostdevpci.addr = dev->device.pci;\n        port->plug.hostdevpci.driver = netdef->forward.driverName;\n        port->plug.hostdevpci.managed = netdef->forward.managed;\n\n        if (port->virtPortProfile) {\n            /* make sure type is supported for hostdev connections */\n            if (port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBG &&\n                port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBH) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"<virtualport type='%s'> not supported for network \"\n                                 \"'%s' which uses an SR-IOV Virtual Function \"\n                                 \"via PCI passthrough\"),\n                               virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                               netdef->name);\n                return -1;\n            }\n        }\n        break;\n    }\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (netdef->bridge) {\n            /* <forward type='bridge'/> <bridge name='xxx'/>\n             * is VIR_DOMAIN_NET_TYPE_BRIDGE\n             */\n\n            port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE;\n            port->plug.bridge.brname = g_strdup(netdef->bridge);\n            port->plug.bridge.macTableManager = netdef->macTableManager;\n\n            if (port->virtPortProfile) {\n                /* only type='openvswitch' is allowed for bridges */\n                if (port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"<virtualport type='%s'> not supported for network \"\n                                     \"'%s' which uses a bridge device\"),\n                                   virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                                   netdef->name);\n                    return -1;\n                }\n            }\n\n            break;\n        }\n\n        /* intentionally fall through to the direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        /* <forward type='bridge|private|vepa|passthrough'> are all\n         * VIR_DOMAIN_NET_TYPE_DIRECT.\n         */\n\n        /* Set type=direct and appropriate <source mode='xxx'/> */\n        port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_DIRECT;\n\n        /* NO need to check the value returned from virNetDevMacVLanModeTypeFromString\n         * it must be valid for these forward type(bridge|private|vepa|passthrough)\n         */\n        port->plug.direct.mode =\n            virNetDevMacVLanModeTypeFromString(virNetworkForwardTypeToString(netdef->forward.type));\n\n        if (port->virtPortProfile) {\n            /* make sure type is supported for macvtap connections */\n            if (port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBG &&\n                port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBH) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"<virtualport type='%s'> not supported for network \"\n                                 \"'%s' which uses a macvtap device\"),\n                               virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                               netdef->name);\n                return -1;\n            }\n        }\n\n        /* If there is only a single device, just return it (caller will detect\n         * any error if exclusive use is required but could not be acquired).\n         */\n        if ((netdef->forward.nifs <= 0) && (netdef->forward.npfs <= 0)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a direct mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        } else {\n            /* pick an interface from the pool */\n\n            if (networkCreateInterfacePool(netdef) < 0)\n                return -1;\n\n            /* PASSTHROUGH mode, and PRIVATE Mode + 802.1Qbh both\n             * require exclusive access to a device, so current\n             * connections count must be 0.  Other modes can share, so\n             * just search for the one with the lowest number of\n             * connections.\n             */\n            if ((netdef->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH) ||\n                ((netdef->forward.type == VIR_NETWORK_FORWARD_PRIVATE) &&\n                 port->virtPortProfile &&\n                 (port->virtPortProfile->virtPortType\n                  == VIR_NETDEV_VPORT_PROFILE_8021QBH))) {\n\n                /* pick first dev with 0 connections */\n                for (i = 0; i < netdef->forward.nifs; i++) {\n                    if (netdef->forward.ifs[i].connections == 0) {\n                        dev = &netdef->forward.ifs[i];\n                        break;\n                    }\n                }\n            } else {\n                /* pick least used dev */\n                dev = &netdef->forward.ifs[0];\n                for (i = 1; i < netdef->forward.nifs; i++) {\n                    if (netdef->forward.ifs[i].connections < dev->connections)\n                        dev = &netdef->forward.ifs[i];\n                }\n            }\n            /* dev points at the physical device we want to use */\n            if (!dev) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"network '%s' requires exclusive access \"\n                                 \"to interfaces, but none are available\"),\n                               netdef->name);\n                return -1;\n            }\n            port->plug.direct.linkdev = g_strdup(dev->device.dev);\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, netdef->forward.type);\n        return -1;\n    }\n\n\n    if (networkPlugBandwidth(obj, &port->mac, port->bandwidth,\n                             &port->class_id) < 0)\n        return -1;\n\n    if (virNetworkObjMacMgrAdd(obj, driver->dnsmasqStateDir,\n                               port->ownername, &port->mac) < 0)\n        return -1;\n\n    if (virNetDevVPortProfileCheckComplete(port->virtPortProfile, true) < 0)\n        return -1;\n\n    netdef->connections++;\n    if (dev)\n        dev->connections++;\n    /* finally we can call the 'plugged' hook script if any */\n    if (networkRunHook(obj, port,\n                       VIR_HOOK_NETWORK_OP_PORT_CREATED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0) {\n        /* adjust for failure */\n        netdef->connections--;\n        if (dev)\n            dev->connections--;\n        return -1;\n    }\n    networkLogAllocation(netdef, dev, &port->mac, true);\n\n    VIR_DEBUG(\"Port allocated\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkNotifyPort",
          "args": [
            "obj",
            "portdef"
          ],
          "line": 5499
        },
        "resolved": true,
        "details": {
          "function_name": "networkNotifyPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "4783-4924",
          "snippet": "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port)\n{\n    virNetworkDefPtr netdef;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n\n    netdef = virNetworkObjGetDef(obj);\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       netdef->name);\n        return -1;\n    }\n\n    switch (port->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpectedly got a network port without a plug\"));\n        return -1;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        /* see if we're connected to the correct bridge */\n        if (!netdef->bridge) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unexpectedly got a network port without a network bridge\"));\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* find the matching interface and increment its connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n                STREQ(port->plug.direct.linkdev,\n                      netdef->forward.ifs[i].device.dev)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        /* dev points at the physical device we want to use */\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have dev='%s' \"\n                             \"in use by network port '%s'\"),\n                           netdef->name, port->plug.direct.linkdev,\n                           port->uuid);\n            return -1;\n        }\n\n        /* PASSTHROUGH mode and PRIVATE Mode + 802.1Qbh both require\n         * exclusive access to a device, so current connections count\n         * must be 0 in those cases.\n         */\n        if ((dev->connections > 0) &&\n            ((netdef->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH) ||\n             ((netdef->forward.type == VIR_NETWORK_FORWARD_PRIVATE) &&\n              port->virtPortProfile &&\n              (port->virtPortProfile->virtPortType == VIR_NETDEV_VPORT_PROFILE_8021QBH)))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' claims dev='%s' is already in \"\n                             \"use by a different port\"),\n                           netdef->name, port->plug.direct.linkdev);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* find the matching interface and increment its connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI &&\n                virPCIDeviceAddressEqual(&port->plug.hostdevpci.addr,\n                                         &netdef->forward.ifs[i].device.pci)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        /* dev points at the physical device we want to use */\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have \"\n                             \"PCI device %04x:%02x:%02x.%x in use by network port\"),\n                           netdef->name,\n                           port->plug.hostdevpci.addr.domain,\n                           port->plug.hostdevpci.addr.bus,\n                           port->plug.hostdevpci.addr.slot,\n                           port->plug.hostdevpci.addr.function);\n            return -1;\n        }\n\n        /* PASSTHROUGH mode, PRIVATE Mode + 802.1Qbh, and hostdev (PCI\n         * passthrough) all require exclusive access to a device, so\n         * current connections count must be 0 in those cases.\n         */\n        if ((dev->connections > 0) &&\n            netdef->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' claims the PCI device at \"\n                             \"domain=%d bus=%d slot=%d function=%d \"\n                             \"is already in use by a different network port\"),\n                           netdef->name,\n                           dev->device.pci.domain, dev->device.pci.bus,\n                           dev->device.pci.slot, dev->device.pci.function);\n            return -1;\n        }\n\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, port->plugtype);\n        return -1;\n    }\n\n    netdef->connections++;\n    if (dev)\n        dev->connections++;\n    /* finally we can call the 'plugged' hook script if any */\n    if (networkRunHook(obj, port, VIR_HOOK_NETWORK_OP_PORT_CREATED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0) {\n        /* adjust for failure */\n        if (dev)\n            dev->connections--;\n        netdef->connections--;\n        return -1;\n    }\n    networkLogAllocation(netdef, dev, &port->mac, true);\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port)\n{\n    virNetworkDefPtr netdef;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n\n    netdef = virNetworkObjGetDef(obj);\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       netdef->name);\n        return -1;\n    }\n\n    switch (port->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpectedly got a network port without a plug\"));\n        return -1;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        /* see if we're connected to the correct bridge */\n        if (!netdef->bridge) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unexpectedly got a network port without a network bridge\"));\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* find the matching interface and increment its connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n                STREQ(port->plug.direct.linkdev,\n                      netdef->forward.ifs[i].device.dev)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        /* dev points at the physical device we want to use */\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have dev='%s' \"\n                             \"in use by network port '%s'\"),\n                           netdef->name, port->plug.direct.linkdev,\n                           port->uuid);\n            return -1;\n        }\n\n        /* PASSTHROUGH mode and PRIVATE Mode + 802.1Qbh both require\n         * exclusive access to a device, so current connections count\n         * must be 0 in those cases.\n         */\n        if ((dev->connections > 0) &&\n            ((netdef->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH) ||\n             ((netdef->forward.type == VIR_NETWORK_FORWARD_PRIVATE) &&\n              port->virtPortProfile &&\n              (port->virtPortProfile->virtPortType == VIR_NETDEV_VPORT_PROFILE_8021QBH)))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' claims dev='%s' is already in \"\n                             \"use by a different port\"),\n                           netdef->name, port->plug.direct.linkdev);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* find the matching interface and increment its connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI &&\n                virPCIDeviceAddressEqual(&port->plug.hostdevpci.addr,\n                                         &netdef->forward.ifs[i].device.pci)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        /* dev points at the physical device we want to use */\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have \"\n                             \"PCI device %04x:%02x:%02x.%x in use by network port\"),\n                           netdef->name,\n                           port->plug.hostdevpci.addr.domain,\n                           port->plug.hostdevpci.addr.bus,\n                           port->plug.hostdevpci.addr.slot,\n                           port->plug.hostdevpci.addr.function);\n            return -1;\n        }\n\n        /* PASSTHROUGH mode, PRIVATE Mode + 802.1Qbh, and hostdev (PCI\n         * passthrough) all require exclusive access to a device, so\n         * current connections count must be 0 in those cases.\n         */\n        if ((dev->connections > 0) &&\n            netdef->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' claims the PCI device at \"\n                             \"domain=%d bus=%d slot=%d function=%d \"\n                             \"is already in use by a different network port\"),\n                           netdef->name,\n                           dev->device.pci.domain, dev->device.pci.bus,\n                           dev->device.pci.slot, dev->device.pci.function);\n            return -1;\n        }\n\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, port->plugtype);\n        return -1;\n    }\n\n    netdef->connections++;\n    if (dev)\n        dev->connections++;\n    /* finally we can call the 'plugged' hook script if any */\n    if (networkRunHook(obj, port, VIR_HOOK_NETWORK_OP_PORT_CREATED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0) {\n        /* adjust for failure */\n        if (dev)\n            dev->connections--;\n        netdef->connections--;\n        return -1;\n    }\n    networkLogAllocation(netdef, dev, &port->mac, true);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Port reclaim not requested but plug type is not none\")"
          ],
          "line": 5492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Port reclaim not requested but plug type is not none\""
          ],
          "line": 5493
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Port reclaim requested but plug type is none\")"
          ],
          "line": 5486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"network '%s' is not active\")",
            "def->name"
          ],
          "line": 5478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 5477
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkPortCreateXMLEnsureACL",
          "args": [
            "net->conn",
            "def",
            "portdef"
          ],
          "line": 5474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkPortDefParseString",
          "args": [
            "xmldesc"
          ],
          "line": 5471
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
          "lines": "310-314",
          "snippet": "virNetworkPortDefPtr\nvirNetworkPortDefParseString(const char *xmlStr)\n{\n    return virNetworkPortDefParse(xmlStr, NULL);\n}",
          "includes": [
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkPortDefPtr\nvirNetworkPortDefParseString(const char *xmlStr)\n{\n    return virNetworkPortDefParse(xmlStr, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 5469
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "net"
          ],
          "line": 5466
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_NETWORK_PORT_CREATE_RECLAIM",
            "NULL"
          ],
          "line": 5464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 5457
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkPortPtr\nnetworkPortCreateXML(virNetworkPtr net,\n                     const char *xmldesc,\n                     unsigned int flags)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    g_autoptr(virNetworkPortDef) portdef = NULL;\n    virNetworkPortPtr ret = NULL;\n    int rc;\n\n    virCheckFlags(VIR_NETWORK_PORT_CREATE_RECLAIM, NULL);\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return ret;\n\n    def = virNetworkObjGetDef(obj);\n\n    if (!(portdef = virNetworkPortDefParseString(xmldesc)))\n        goto cleanup;\n\n    if (virNetworkPortCreateXMLEnsureACL(net->conn, def, portdef) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (portdef->plugtype == VIR_NETWORK_PORT_PLUG_TYPE_NONE) {\n        if (flags & VIR_NETWORK_PORT_CREATE_RECLAIM) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"Port reclaim requested but plug type is none\"));\n            goto cleanup;\n        }\n    } else {\n        if (!(flags & VIR_NETWORK_PORT_CREATE_RECLAIM)) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"Port reclaim not requested but plug type is not none\"));\n            goto cleanup;\n        }\n    }\n\n    if (flags & VIR_NETWORK_PORT_CREATE_RECLAIM)\n        rc = networkNotifyPort(obj, portdef);\n    else\n        rc = networkAllocatePort(obj, portdef);\n    if (rc < 0)\n        goto cleanup;\n\n    if (virNetworkObjAddPort(obj, portdef, driver->stateDir) < 0) {\n        virErrorPtr save_err;\n\n        virErrorPreserveLast(&save_err);\n        ignore_value(networkReleasePort(obj, portdef));\n        virErrorRestore(&save_err);\n\n        goto cleanup;\n    }\n\n    ret = virGetNetworkPort(net, portdef->uuid);\n    portdef = NULL;\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkPortLookupByUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5415-5449",
    "snippet": "static virNetworkPortPtr\nnetworkPortLookupByUUID(virNetworkPtr net,\n                        const unsigned char *uuid)\n{\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virNetworkPortDefPtr portdef = NULL;\n    virNetworkPortPtr ret = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virUUIDFormat(uuid, uuidstr);\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return ret;\n\n    def = virNetworkObjGetDef(obj);\n\n    if (!(portdef = virNetworkObjLookupPort(obj, uuid)))\n        goto cleanup;\n\n    if (virNetworkPortLookupByUUIDEnsureACL(net->conn, def, portdef) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    ret = virGetNetworkPort(net, uuid);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 5447
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetNetworkPort",
          "args": [
            "net",
            "uuid"
          ],
          "line": 5444
        },
        "resolved": true,
        "details": {
          "function_name": "virGetNetworkPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "402-424",
          "snippet": "virNetworkPortPtr\nvirGetNetworkPort(virNetworkPtr net, const unsigned char *uuid)\n{\n    virNetworkPortPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckNetworkGoto(net, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkPortClass)))\n        goto error;\n\n    ret->net = virObjectRef(net);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virNetworkPortClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virNetworkPortClass;\n\nvirNetworkPortPtr\nvirGetNetworkPort(virNetworkPtr net, const unsigned char *uuid)\n{\n    virNetworkPortPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckNetworkGoto(net, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkPortClass)))\n        goto error;\n\n    ret->net = virObjectRef(net);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"network '%s' is not active\")",
            "def->name"
          ],
          "line": 5438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"network '%s' is not active\""
          ],
          "line": 5439
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 5437
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkPortLookupByUUIDEnsureACL",
          "args": [
            "net->conn",
            "def",
            "portdef"
          ],
          "line": 5434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjLookupPort",
          "args": [
            "obj",
            "uuid"
          ],
          "line": 5431
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjLookupPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1660-1677",
          "snippet": "virNetworkPortDefPtr\nvirNetworkObjLookupPort(virNetworkObjPtr net,\n                        const unsigned char *uuid)\n{\n    virNetworkPortDefPtr ret = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(uuid, uuidstr);\n\n    if (!(ret = virHashLookup(net->ports, uuidstr))) {\n        virReportError(VIR_ERR_NO_NETWORK_PORT,\n                       _(\"Network port with UUID %s does not exist\"),\n                       uuidstr);\n        return NULL;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirNetworkPortDefPtr\nvirNetworkObjLookupPort(virNetworkObjPtr net,\n                        const unsigned char *uuid)\n{\n    virNetworkPortDefPtr ret = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(uuid, uuidstr);\n\n    if (!(ret = virHashLookup(net->ports, uuidstr))) {\n        virReportError(VIR_ERR_NO_NETWORK_PORT,\n                       _(\"Network port with UUID %s does not exist\"),\n                       uuidstr);\n        return NULL;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 5429
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "net"
          ],
          "line": 5426
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "uuidstr"
          ],
          "line": 5424
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic virNetworkPortPtr\nnetworkPortLookupByUUID(virNetworkPtr net,\n                        const unsigned char *uuid)\n{\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virNetworkPortDefPtr portdef = NULL;\n    virNetworkPortPtr ret = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virUUIDFormat(uuid, uuidstr);\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return ret;\n\n    def = virNetworkObjGetDef(obj);\n\n    if (!(portdef = virNetworkObjLookupPort(obj, uuid)))\n        goto cleanup;\n\n    if (virNetworkPortLookupByUUIDEnsureACL(net->conn, def, portdef) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    ret = virGetNetworkPort(net, uuid);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkUpdatePortBandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5328-5412",
    "snippet": "static int\nnetworkUpdatePortBandwidth(virNetworkObjPtr obj,\n                           virMacAddrPtr mac,\n                           unsigned int *class_id,\n                           virNetDevBandwidthPtr oldBandwidth,\n                           virNetDevBandwidthPtr newBandwidth)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr def;\n    unsigned long long tmp_floor_sum;\n    unsigned long long new_rate = 0;\n    unsigned long long old_floor, new_floor;\n    int plug_ret;\n\n    old_floor = new_floor = 0;\n\n    if (oldBandwidth && oldBandwidth->in)\n        old_floor = oldBandwidth->in->floor;\n    if (newBandwidth && newBandwidth->in)\n        new_floor = newBandwidth->in->floor;\n\n    if (new_floor == old_floor)\n        return 0;\n\n    def = virNetworkObjGetDef(obj);\n\n    if ((plug_ret = networkCheckBandwidth(obj, newBandwidth, oldBandwidth,\n                                          mac, &new_rate)) < 0) {\n        /* helper reported error */\n        return -1;\n    }\n\n    if (plug_ret > 0) {\n        /* no QoS needs to be set; claim success */\n        return 0;\n    }\n\n    /* Okay, there are three possible scenarios: */\n\n    if (old_floor > 0 && new_floor > 0) {\n        /* Either we just need to update @floor .. */\n\n        if (virNetDevBandwidthUpdateRate(def->bridge,\n                                         *class_id,\n                                         def->bandwidth,\n                                         new_floor) < 0)\n            return -1;\n\n        tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n        tmp_floor_sum -= old_floor;\n        tmp_floor_sum += new_floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n        new_rate -= tmp_floor_sum;\n\n        if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                         def->bandwidth, new_rate) < 0 ||\n            virNetworkObjSaveStatus(driver->stateDir,\n                                    obj, network_driver->xmlopt) < 0) {\n            /* Ouch, rollback */\n            tmp_floor_sum -= new_floor;\n            tmp_floor_sum += old_floor;\n            virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n\n            ignore_value(virNetDevBandwidthUpdateRate(def->bridge,\n                                                      *class_id,\n                                                      def->bandwidth,\n                                                      old_floor));\n            return -1;\n        }\n    } else if (new_floor > 0) {\n        /* .. or we need to plug in new .. */\n\n        if (networkPlugBandwidthImpl(obj, mac, newBandwidth,\n                                     class_id,\n                                     new_rate) < 0)\n            return -1;\n    } else {\n        /* .. or unplug old. */\n\n        if (networkUnplugBandwidth(obj, oldBandwidth, class_id) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverStatePtr network_driver;",
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
      "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
      "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkUnplugBandwidth",
          "args": [
            "obj",
            "oldBandwidth",
            "class_id"
          ],
          "line": 5407
        },
        "resolved": true,
        "details": {
          "function_name": "networkUnplugBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "5257-5309",
          "snippet": "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    int ret = 0;\n    unsigned long long new_rate;\n\n    if (class_id && *class_id) {\n        if (!def->bandwidth || !def->bandwidth->in) {\n            VIR_WARN(\"Network %s has no bandwidth but unplug requested\",\n                     def->name);\n            return 0;\n        }\n        /* we must remove class from bridge */\n        new_rate = def->bandwidth->in->average;\n\n        if (def->bandwidth->in->peak > 0)\n            new_rate = def->bandwidth->in->peak;\n\n        ret = virNetDevBandwidthUnplug(def->bridge, *class_id);\n        if (ret < 0)\n            return ret;\n        /* update sum of 'floor'-s of attached NICs */\n        tmp_floor_sum -= ifaceBand->in->floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n\n        /* return class ID */\n        ignore_value(virBitmapClearBit(classIdMap, *class_id));\n        /* update status file */\n        if (virNetworkObjSaveStatus(driver->stateDir,\n                                    obj, network_driver->xmlopt) < 0) {\n            tmp_floor_sum += ifaceBand->in->floor;\n            virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n            ignore_value(virBitmapSetBit(classIdMap, *class_id));\n            return ret;\n        }\n        /* update rate for non guaranteed NICs */\n        new_rate -= tmp_floor_sum;\n        if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                         def->bandwidth, new_rate) < 0)\n            VIR_WARN(\"Unable to update rate for 1:2 class on %s bridge\",\n                     def->bridge);\n        /* no class is associated any longer */\n        *class_id = 0;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
            "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
            "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\n\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    int ret = 0;\n    unsigned long long new_rate;\n\n    if (class_id && *class_id) {\n        if (!def->bandwidth || !def->bandwidth->in) {\n            VIR_WARN(\"Network %s has no bandwidth but unplug requested\",\n                     def->name);\n            return 0;\n        }\n        /* we must remove class from bridge */\n        new_rate = def->bandwidth->in->average;\n\n        if (def->bandwidth->in->peak > 0)\n            new_rate = def->bandwidth->in->peak;\n\n        ret = virNetDevBandwidthUnplug(def->bridge, *class_id);\n        if (ret < 0)\n            return ret;\n        /* update sum of 'floor'-s of attached NICs */\n        tmp_floor_sum -= ifaceBand->in->floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n\n        /* return class ID */\n        ignore_value(virBitmapClearBit(classIdMap, *class_id));\n        /* update status file */\n        if (virNetworkObjSaveStatus(driver->stateDir,\n                                    obj, network_driver->xmlopt) < 0) {\n            tmp_floor_sum += ifaceBand->in->floor;\n            virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n            ignore_value(virBitmapSetBit(classIdMap, *class_id));\n            return ret;\n        }\n        /* update rate for non guaranteed NICs */\n        new_rate -= tmp_floor_sum;\n        if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                         def->bandwidth, new_rate) < 0)\n            VIR_WARN(\"Unable to update rate for 1:2 class on %s bridge\",\n                     def->bridge);\n        /* no class is associated any longer */\n        *class_id = 0;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkPlugBandwidthImpl",
          "args": [
            "obj",
            "mac",
            "newBandwidth",
            "class_id",
            "new_rate"
          ],
          "line": 5400
        },
        "resolved": true,
        "details": {
          "function_name": "networkPlugBandwidthImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "5175-5225",
          "snippet": "static int\nnetworkPlugBandwidthImpl(virNetworkObjPtr obj,\n                         virMacAddrPtr mac,\n                         virNetDevBandwidthPtr ifaceBand,\n                         unsigned int *class_id,\n                         unsigned long long new_rate)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    ssize_t next_id = 0;\n    int plug_ret;\n\n    /* generate new class_id */\n    if ((next_id = networkNextClassID(obj)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not generate next class ID\"));\n        return -1;\n    }\n\n    plug_ret = virNetDevBandwidthPlug(def->bridge, def->bandwidth,\n                                      mac, ifaceBand, next_id);\n    if (plug_ret < 0) {\n        ignore_value(virNetDevBandwidthUnplug(def->bridge, next_id));\n        return -1;\n    }\n\n    /* QoS was set, generate new class ID */\n    *class_id = next_id;\n    /* update sum of 'floor'-s of attached NICs */\n    tmp_floor_sum += ifaceBand->in->floor;\n    virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n    /* update status file */\n    if (virNetworkObjSaveStatus(driver->stateDir, obj, network_driver->xmlopt) < 0) {\n        ignore_value(virBitmapClearBit(classIdMap, next_id));\n        tmp_floor_sum -= ifaceBand->in->floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n        *class_id = 0;\n        ignore_value(virNetDevBandwidthUnplug(def->bridge, next_id));\n        return -1;\n    }\n    /* update rate for non guaranteed NICs */\n    new_rate -= tmp_floor_sum;\n    if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                     def->bandwidth, new_rate) < 0)\n        VIR_WARN(\"Unable to update rate for 1:2 class on %s bridge\",\n                 def->bridge);\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
            "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
            "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\n\nstatic int\nnetworkPlugBandwidthImpl(virNetworkObjPtr obj,\n                         virMacAddrPtr mac,\n                         virNetDevBandwidthPtr ifaceBand,\n                         unsigned int *class_id,\n                         unsigned long long new_rate)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    ssize_t next_id = 0;\n    int plug_ret;\n\n    /* generate new class_id */\n    if ((next_id = networkNextClassID(obj)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not generate next class ID\"));\n        return -1;\n    }\n\n    plug_ret = virNetDevBandwidthPlug(def->bridge, def->bandwidth,\n                                      mac, ifaceBand, next_id);\n    if (plug_ret < 0) {\n        ignore_value(virNetDevBandwidthUnplug(def->bridge, next_id));\n        return -1;\n    }\n\n    /* QoS was set, generate new class ID */\n    *class_id = next_id;\n    /* update sum of 'floor'-s of attached NICs */\n    tmp_floor_sum += ifaceBand->in->floor;\n    virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n    /* update status file */\n    if (virNetworkObjSaveStatus(driver->stateDir, obj, network_driver->xmlopt) < 0) {\n        ignore_value(virBitmapClearBit(classIdMap, next_id));\n        tmp_floor_sum -= ifaceBand->in->floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n        *class_id = 0;\n        ignore_value(virNetDevBandwidthUnplug(def->bridge, next_id));\n        return -1;\n    }\n    /* update rate for non guaranteed NICs */\n    new_rate -= tmp_floor_sum;\n    if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                     def->bandwidth, new_rate) < 0)\n        VIR_WARN(\"Unable to update rate for 1:2 class on %s bridge\",\n                 def->bridge);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevBandwidthUpdateRate(def->bridge,\n                                                      *class_id,\n                                                      def->bandwidth,\n                                                      old_floor)"
          ],
          "line": 5391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthUpdateRate",
          "args": [
            "def->bridge",
            "*class_id",
            "def->bandwidth",
            "old_floor"
          ],
          "line": 5391
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthUpdateRate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "682-717",
          "snippet": "int\nvirNetDevBandwidthUpdateRate(const char *ifname,\n                             unsigned int id,\n                             virNetDevBandwidthPtr bandwidth,\n                             unsigned long long new_rate)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *rate = NULL;\n    char *ceil = NULL;\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    rate = g_strdup_printf(\"%llukbps\", new_rate);\n    ceil = g_strdup_printf(\"%llukbps\", bandwidth->in->peak ?\n                           bandwidth->in->peak :\n                           bandwidth->in->average);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"change\", \"dev\", ifname,\n                         \"classid\", class_id, \"htb\", \"rate\", rate,\n                         \"ceil\", ceil, NULL);\n    virNetDevBandwidthCmdAddOptimalQuantum(cmd, bandwidth->in);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(class_id);\n    VIR_FREE(rate);\n    VIR_FREE(ceil);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthUpdateRate(const char *ifname,\n                             unsigned int id,\n                             virNetDevBandwidthPtr bandwidth,\n                             unsigned long long new_rate)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *rate = NULL;\n    char *ceil = NULL;\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    rate = g_strdup_printf(\"%llukbps\", new_rate);\n    ceil = g_strdup_printf(\"%llukbps\", bandwidth->in->peak ?\n                           bandwidth->in->peak :\n                           bandwidth->in->average);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"change\", \"dev\", ifname,\n                         \"classid\", class_id, \"htb\", \"rate\", rate,\n                         \"ceil\", ceil, NULL);\n    virNetDevBandwidthCmdAddOptimalQuantum(cmd, bandwidth->in);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(class_id);\n    VIR_FREE(rate);\n    VIR_FREE(ceil);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetFloorSum",
          "args": [
            "obj",
            "tmp_floor_sum"
          ],
          "line": 5389
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetFloorSum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "258-263",
          "snippet": "void\nvirNetworkObjSetFloorSum(virNetworkObjPtr obj,\n                         unsigned long long floor_sum)\n{\n    obj->floor_sum = floor_sum;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetFloorSum(virNetworkObjPtr obj,\n                         unsigned long long floor_sum)\n{\n    obj->floor_sum = floor_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSaveStatus",
          "args": [
            "driver->stateDir",
            "obj",
            "network_driver->xmlopt"
          ],
          "line": 5384
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSaveStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "851-870",
          "snippet": "int\nvirNetworkObjSaveStatus(const char *statusDir,\n                        virNetworkObjPtr obj,\n                        virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    int flags = 0;\n    char *xml;\n\n    if (!(xml = virNetworkObjFormat(obj, xmlopt, flags)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(statusDir, obj->def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nint\nvirNetworkObjSaveStatus(const char *statusDir,\n                        virNetworkObjPtr obj,\n                        virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    int flags = 0;\n    char *xml;\n\n    if (!(xml = virNetworkObjFormat(obj, xmlopt, flags)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(statusDir, obj->def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetFloorSum",
          "args": [
            "obj"
          ],
          "line": 5376
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetFloorSum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "251-255",
          "snippet": "unsigned long long\nvirNetworkObjGetFloorSum(virNetworkObjPtr obj)\n{\n    return obj->floor_sum;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nunsigned long long\nvirNetworkObjGetFloorSum(virNetworkObjPtr obj)\n{\n    return obj->floor_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkCheckBandwidth",
          "args": [
            "obj",
            "newBandwidth",
            "oldBandwidth",
            "mac",
            "&new_rate"
          ],
          "line": 5354
        },
        "resolved": true,
        "details": {
          "function_name": "networkCheckBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "5060-5146",
          "snippet": "static int\nnetworkCheckBandwidth(virNetworkObjPtr obj,\n                      virNetDevBandwidthPtr ifaceBand,\n                      virNetDevBandwidthPtr oldBandwidth,\n                      virMacAddrPtr ifaceMac,\n                      unsigned long long *new_rate)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetDevBandwidthPtr netBand = def->bandwidth;\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    unsigned long long tmp_new_rate = 0;\n    char ifmac[VIR_MAC_STRING_BUFLEN];\n\n    virMacAddrFormat(ifaceMac, ifmac);\n\n    if (virNetDevBandwidthHasFloor(ifaceBand) &&\n        !virNetDevBandwidthSupportsFloor(def->forward.type)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Invalid use of 'floor' on interface with MAC address %s \"\n                         \"- 'floor' is only supported for interface type 'network' with forward type 'nat', 'route', 'open' or none\"),\n                       ifmac);\n        return -1;\n    }\n\n    if (virNetDevBandwidthHasFloor(ifaceBand) &&\n        !(netBand && netBand->in)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Invalid use of 'floor' on interface with MAC \"\n                         \"address %s - network '%s' has no inbound QoS set\"),\n                       ifmac, def->name);\n        return -1;\n    }\n\n    if (!netBand || !netBand->in) {\n        VIR_DEBUG(\"No network bandwidth controls present\");\n        /* no QoS required, claim success */\n        return 1;\n    }\n    if (!virNetDevBandwidthHasFloor(ifaceBand) &&\n        !virNetDevBandwidthHasFloor(oldBandwidth)) {\n\n        VIR_DEBUG(\"No old/new interface bandwidth floor\");\n        /* no QoS required, claim success */\n        return 1;\n    }\n\n    tmp_new_rate = netBand->in->average;\n    if (oldBandwidth && oldBandwidth->in)\n        tmp_floor_sum -= oldBandwidth->in->floor;\n    if (ifaceBand && ifaceBand->in)\n        tmp_floor_sum += ifaceBand->in->floor;\n\n    /* check against peak */\n    if (netBand->in->peak) {\n        tmp_new_rate = netBand->in->peak;\n        if (tmp_floor_sum > netBand->in->peak) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Cannot plug '%s' interface into '%s' because \"\n                             \"new combined inbound floor=%llu would overcommit \"\n                             \"peak=%llu on network '%s'\"),\n                           ifmac,\n                           def->bridge,\n                           tmp_floor_sum,\n                           netBand->in->peak,\n                           def->name);\n            return -1;\n        }\n    } else if (tmp_floor_sum > netBand->in->average) {\n        /* tmp_floor_sum can be between 'average' and 'peak' iff 'peak' is set.\n         * Otherwise, tmp_floor_sum must be below 'average'. */\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Cannot plug '%s' interface into '%s' because \"\n                         \"new combined inbound floor=%llu would overcommit \"\n                         \"average=%llu on network '%s'\"),\n                       ifmac,\n                       def->bridge,\n                       tmp_floor_sum,\n                       netBand->in->average,\n                       def->name);\n        return -1;\n    }\n\n    if (new_rate)\n        *new_rate = tmp_new_rate;\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkCheckBandwidth(virNetworkObjPtr obj,\n                      virNetDevBandwidthPtr ifaceBand,\n                      virNetDevBandwidthPtr oldBandwidth,\n                      virMacAddrPtr ifaceMac,\n                      unsigned long long *new_rate)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetDevBandwidthPtr netBand = def->bandwidth;\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    unsigned long long tmp_new_rate = 0;\n    char ifmac[VIR_MAC_STRING_BUFLEN];\n\n    virMacAddrFormat(ifaceMac, ifmac);\n\n    if (virNetDevBandwidthHasFloor(ifaceBand) &&\n        !virNetDevBandwidthSupportsFloor(def->forward.type)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Invalid use of 'floor' on interface with MAC address %s \"\n                         \"- 'floor' is only supported for interface type 'network' with forward type 'nat', 'route', 'open' or none\"),\n                       ifmac);\n        return -1;\n    }\n\n    if (virNetDevBandwidthHasFloor(ifaceBand) &&\n        !(netBand && netBand->in)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Invalid use of 'floor' on interface with MAC \"\n                         \"address %s - network '%s' has no inbound QoS set\"),\n                       ifmac, def->name);\n        return -1;\n    }\n\n    if (!netBand || !netBand->in) {\n        VIR_DEBUG(\"No network bandwidth controls present\");\n        /* no QoS required, claim success */\n        return 1;\n    }\n    if (!virNetDevBandwidthHasFloor(ifaceBand) &&\n        !virNetDevBandwidthHasFloor(oldBandwidth)) {\n\n        VIR_DEBUG(\"No old/new interface bandwidth floor\");\n        /* no QoS required, claim success */\n        return 1;\n    }\n\n    tmp_new_rate = netBand->in->average;\n    if (oldBandwidth && oldBandwidth->in)\n        tmp_floor_sum -= oldBandwidth->in->floor;\n    if (ifaceBand && ifaceBand->in)\n        tmp_floor_sum += ifaceBand->in->floor;\n\n    /* check against peak */\n    if (netBand->in->peak) {\n        tmp_new_rate = netBand->in->peak;\n        if (tmp_floor_sum > netBand->in->peak) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Cannot plug '%s' interface into '%s' because \"\n                             \"new combined inbound floor=%llu would overcommit \"\n                             \"peak=%llu on network '%s'\"),\n                           ifmac,\n                           def->bridge,\n                           tmp_floor_sum,\n                           netBand->in->peak,\n                           def->name);\n            return -1;\n        }\n    } else if (tmp_floor_sum > netBand->in->average) {\n        /* tmp_floor_sum can be between 'average' and 'peak' iff 'peak' is set.\n         * Otherwise, tmp_floor_sum must be below 'average'. */\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Cannot plug '%s' interface into '%s' because \"\n                         \"new combined inbound floor=%llu would overcommit \"\n                         \"average=%llu on network '%s'\"),\n                       ifmac,\n                       def->bridge,\n                       tmp_floor_sum,\n                       netBand->in->average,\n                       def->name);\n        return -1;\n    }\n\n    if (new_rate)\n        *new_rate = tmp_new_rate;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 5352
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 5335
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\n\nstatic int\nnetworkUpdatePortBandwidth(virNetworkObjPtr obj,\n                           virMacAddrPtr mac,\n                           unsigned int *class_id,\n                           virNetDevBandwidthPtr oldBandwidth,\n                           virNetDevBandwidthPtr newBandwidth)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr def;\n    unsigned long long tmp_floor_sum;\n    unsigned long long new_rate = 0;\n    unsigned long long old_floor, new_floor;\n    int plug_ret;\n\n    old_floor = new_floor = 0;\n\n    if (oldBandwidth && oldBandwidth->in)\n        old_floor = oldBandwidth->in->floor;\n    if (newBandwidth && newBandwidth->in)\n        new_floor = newBandwidth->in->floor;\n\n    if (new_floor == old_floor)\n        return 0;\n\n    def = virNetworkObjGetDef(obj);\n\n    if ((plug_ret = networkCheckBandwidth(obj, newBandwidth, oldBandwidth,\n                                          mac, &new_rate)) < 0) {\n        /* helper reported error */\n        return -1;\n    }\n\n    if (plug_ret > 0) {\n        /* no QoS needs to be set; claim success */\n        return 0;\n    }\n\n    /* Okay, there are three possible scenarios: */\n\n    if (old_floor > 0 && new_floor > 0) {\n        /* Either we just need to update @floor .. */\n\n        if (virNetDevBandwidthUpdateRate(def->bridge,\n                                         *class_id,\n                                         def->bandwidth,\n                                         new_floor) < 0)\n            return -1;\n\n        tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n        tmp_floor_sum -= old_floor;\n        tmp_floor_sum += new_floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n        new_rate -= tmp_floor_sum;\n\n        if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                         def->bandwidth, new_rate) < 0 ||\n            virNetworkObjSaveStatus(driver->stateDir,\n                                    obj, network_driver->xmlopt) < 0) {\n            /* Ouch, rollback */\n            tmp_floor_sum -= new_floor;\n            tmp_floor_sum += old_floor;\n            virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n\n            ignore_value(virNetDevBandwidthUpdateRate(def->bridge,\n                                                      *class_id,\n                                                      def->bandwidth,\n                                                      old_floor));\n            return -1;\n        }\n    } else if (new_floor > 0) {\n        /* .. or we need to plug in new .. */\n\n        if (networkPlugBandwidthImpl(obj, mac, newBandwidth,\n                                     class_id,\n                                     new_rate) < 0)\n            return -1;\n    } else {\n        /* .. or unplug old. */\n\n        if (networkUnplugBandwidth(obj, oldBandwidth, class_id) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "networkNetworkObjTaint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5312-5325",
    "snippet": "static void\nnetworkNetworkObjTaint(virNetworkObjPtr obj,\n                       virNetworkTaintFlags taint)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n\n    if (virNetworkObjTaint(obj, taint)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n        virUUIDFormat(def->uuid, uuidstr);\n\n        VIR_WARN(\"Network name='%s' uuid=%s is tainted: %s\",\n                 def->name, uuidstr, virNetworkTaintTypeToString(taint));\n    }\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkNetworkObjTaint(virNetworkObjPtr obj,\n                       virNetworkTaintFlags taint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Network name='%s' uuid=%s is tainted: %s\"",
            "def->name",
            "uuidstr",
            "virNetworkTaintTypeToString(taint)"
          ],
          "line": 5322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkTaintTypeToString",
          "args": [
            "taint"
          ],
          "line": 5323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "def->uuid",
            "uuidstr"
          ],
          "line": 5320
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjTaint",
          "args": [
            "obj",
            "taint"
          ],
          "line": 5318
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjTaint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "459-470",
          "snippet": "bool\nvirNetworkObjTaint(virNetworkObjPtr obj,\n                   virNetworkTaintFlags taint)\n{\n    unsigned int flag = (1 << taint);\n\n    if (obj->taint & flag)\n        return false;\n\n    obj->taint |= flag;\n    return true;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjTaint(virNetworkObjPtr obj,\n                   virNetworkTaintFlags taint)\n{\n    unsigned int flag = (1 << taint);\n\n    if (obj->taint & flag)\n        return false;\n\n    obj->taint |= flag;\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 5316
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkNetworkObjTaint(virNetworkObjPtr obj,\n                       virNetworkTaintFlags taint);\n\nstatic void\nnetworkNetworkObjTaint(virNetworkObjPtr obj,\n                       virNetworkTaintFlags taint)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n\n    if (virNetworkObjTaint(obj, taint)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n        virUUIDFormat(def->uuid, uuidstr);\n\n        VIR_WARN(\"Network name='%s' uuid=%s is tainted: %s\",\n                 def->name, uuidstr, virNetworkTaintTypeToString(taint));\n    }\n}"
  },
  {
    "function_name": "networkUnplugBandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5257-5309",
    "snippet": "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    int ret = 0;\n    unsigned long long new_rate;\n\n    if (class_id && *class_id) {\n        if (!def->bandwidth || !def->bandwidth->in) {\n            VIR_WARN(\"Network %s has no bandwidth but unplug requested\",\n                     def->name);\n            return 0;\n        }\n        /* we must remove class from bridge */\n        new_rate = def->bandwidth->in->average;\n\n        if (def->bandwidth->in->peak > 0)\n            new_rate = def->bandwidth->in->peak;\n\n        ret = virNetDevBandwidthUnplug(def->bridge, *class_id);\n        if (ret < 0)\n            return ret;\n        /* update sum of 'floor'-s of attached NICs */\n        tmp_floor_sum -= ifaceBand->in->floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n\n        /* return class ID */\n        ignore_value(virBitmapClearBit(classIdMap, *class_id));\n        /* update status file */\n        if (virNetworkObjSaveStatus(driver->stateDir,\n                                    obj, network_driver->xmlopt) < 0) {\n            tmp_floor_sum += ifaceBand->in->floor;\n            virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n            ignore_value(virBitmapSetBit(classIdMap, *class_id));\n            return ret;\n        }\n        /* update rate for non guaranteed NICs */\n        new_rate -= tmp_floor_sum;\n        if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                         def->bandwidth, new_rate) < 0)\n            VIR_WARN(\"Unable to update rate for 1:2 class on %s bridge\",\n                     def->bridge);\n        /* no class is associated any longer */\n        *class_id = 0;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverStatePtr network_driver;",
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
      "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
      "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to update rate for 1:2 class on %s bridge\"",
            "def->bridge"
          ],
          "line": 5302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthUpdateRate",
          "args": [
            "def->bridge",
            "2",
            "def->bandwidth",
            "new_rate"
          ],
          "line": 5300
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthUpdateRate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "682-717",
          "snippet": "int\nvirNetDevBandwidthUpdateRate(const char *ifname,\n                             unsigned int id,\n                             virNetDevBandwidthPtr bandwidth,\n                             unsigned long long new_rate)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *rate = NULL;\n    char *ceil = NULL;\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    rate = g_strdup_printf(\"%llukbps\", new_rate);\n    ceil = g_strdup_printf(\"%llukbps\", bandwidth->in->peak ?\n                           bandwidth->in->peak :\n                           bandwidth->in->average);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"change\", \"dev\", ifname,\n                         \"classid\", class_id, \"htb\", \"rate\", rate,\n                         \"ceil\", ceil, NULL);\n    virNetDevBandwidthCmdAddOptimalQuantum(cmd, bandwidth->in);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(class_id);\n    VIR_FREE(rate);\n    VIR_FREE(ceil);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthUpdateRate(const char *ifname,\n                             unsigned int id,\n                             virNetDevBandwidthPtr bandwidth,\n                             unsigned long long new_rate)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *rate = NULL;\n    char *ceil = NULL;\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    rate = g_strdup_printf(\"%llukbps\", new_rate);\n    ceil = g_strdup_printf(\"%llukbps\", bandwidth->in->peak ?\n                           bandwidth->in->peak :\n                           bandwidth->in->average);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"change\", \"dev\", ifname,\n                         \"classid\", class_id, \"htb\", \"rate\", rate,\n                         \"ceil\", ceil, NULL);\n    virNetDevBandwidthCmdAddOptimalQuantum(cmd, bandwidth->in);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(class_id);\n    VIR_FREE(rate);\n    VIR_FREE(ceil);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(classIdMap, *class_id)"
          ],
          "line": 5295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "classIdMap",
            "*class_id"
          ],
          "line": 5295
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetFloorSum",
          "args": [
            "obj",
            "tmp_floor_sum"
          ],
          "line": 5294
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetFloorSum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "258-263",
          "snippet": "void\nvirNetworkObjSetFloorSum(virNetworkObjPtr obj,\n                         unsigned long long floor_sum)\n{\n    obj->floor_sum = floor_sum;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetFloorSum(virNetworkObjPtr obj,\n                         unsigned long long floor_sum)\n{\n    obj->floor_sum = floor_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSaveStatus",
          "args": [
            "driver->stateDir",
            "obj",
            "network_driver->xmlopt"
          ],
          "line": 5291
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSaveStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "851-870",
          "snippet": "int\nvirNetworkObjSaveStatus(const char *statusDir,\n                        virNetworkObjPtr obj,\n                        virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    int flags = 0;\n    char *xml;\n\n    if (!(xml = virNetworkObjFormat(obj, xmlopt, flags)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(statusDir, obj->def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nint\nvirNetworkObjSaveStatus(const char *statusDir,\n                        virNetworkObjPtr obj,\n                        virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    int flags = 0;\n    char *xml;\n\n    if (!(xml = virNetworkObjFormat(obj, xmlopt, flags)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(statusDir, obj->def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapClearBit(classIdMap, *class_id)"
          ],
          "line": 5289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapClearBit",
          "args": [
            "classIdMap",
            "*class_id"
          ],
          "line": 5289
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapClearBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "265-277",
          "snippet": "int\nvirBitmapClearBitExpand(virBitmapPtr bitmap,\n                        size_t b)\n{\n    if (bitmap->nbits <= b) {\n        if (virBitmapExpand(bitmap, b) < 0)\n            return -1;\n    } else {\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] &= ~VIR_BITMAP_BIT(b);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapClearBitExpand(virBitmapPtr bitmap,\n                        size_t b)\n{\n    if (bitmap->nbits <= b) {\n        if (virBitmapExpand(bitmap, b) < 0)\n            return -1;\n    } else {\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] &= ~VIR_BITMAP_BIT(b);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthUnplug",
          "args": [
            "def->bridge",
            "*class_id"
          ],
          "line": 5281
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthUnplug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "620-666",
          "snippet": "int\nvirNetDevBandwidthUnplug(const char *brname,\n                         unsigned int id)\n{\n    int ret = -1;\n    int cmd_ret = 0;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *qdisc_id = NULL;\n\n    if (id <= 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invalid class ID %d\"), id);\n        return -1;\n    }\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    qdisc_id = g_strdup_printf(\"%x:\", id);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", brname,\n                         \"handle\", qdisc_id, NULL);\n\n    /* Don't threat tc errors as fatal, but\n     * try to remove as much as possible */\n    if (virCommandRun(cmd, &cmd_ret) < 0)\n        goto cleanup;\n\n    if (virNetDevBandwidthManipulateFilter(brname, NULL, id,\n                                           NULL, true, false) < 0)\n        goto cleanup;\n\n    virCommandFree(cmd);\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"del\", \"dev\", brname,\n                         \"classid\", class_id, NULL);\n\n    if (virCommandRun(cmd, &cmd_ret) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(qdisc_id);\n    VIR_FREE(class_id);\n    virCommandFree(cmd);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthUnplug(const char *brname,\n                         unsigned int id)\n{\n    int ret = -1;\n    int cmd_ret = 0;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *qdisc_id = NULL;\n\n    if (id <= 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invalid class ID %d\"), id);\n        return -1;\n    }\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    qdisc_id = g_strdup_printf(\"%x:\", id);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", brname,\n                         \"handle\", qdisc_id, NULL);\n\n    /* Don't threat tc errors as fatal, but\n     * try to remove as much as possible */\n    if (virCommandRun(cmd, &cmd_ret) < 0)\n        goto cleanup;\n\n    if (virNetDevBandwidthManipulateFilter(brname, NULL, id,\n                                           NULL, true, false) < 0)\n        goto cleanup;\n\n    virCommandFree(cmd);\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"del\", \"dev\", brname,\n                         \"classid\", class_id, NULL);\n\n    if (virCommandRun(cmd, &cmd_ret) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(qdisc_id);\n    VIR_FREE(class_id);\n    virCommandFree(cmd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Network %s has no bandwidth but unplug requested\"",
            "def->name"
          ],
          "line": 5271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 5265
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetFloorSum",
          "args": [
            "obj"
          ],
          "line": 5264
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetFloorSum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "251-255",
          "snippet": "unsigned long long\nvirNetworkObjGetFloorSum(virNetworkObjPtr obj)\n{\n    return obj->floor_sum;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nunsigned long long\nvirNetworkObjGetFloorSum(virNetworkObjPtr obj)\n{\n    return obj->floor_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetClassIdMap",
          "args": [
            "obj"
          ],
          "line": 5263
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetClassIdMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "237-241",
          "snippet": "virBitmapPtr\nvirNetworkObjGetClassIdMap(virNetworkObjPtr obj)\n{\n    return obj->classIdMap;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirBitmapPtr\nvirNetworkObjGetClassIdMap(virNetworkObjPtr obj)\n{\n    return obj->classIdMap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 5262
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\n\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    int ret = 0;\n    unsigned long long new_rate;\n\n    if (class_id && *class_id) {\n        if (!def->bandwidth || !def->bandwidth->in) {\n            VIR_WARN(\"Network %s has no bandwidth but unplug requested\",\n                     def->name);\n            return 0;\n        }\n        /* we must remove class from bridge */\n        new_rate = def->bandwidth->in->average;\n\n        if (def->bandwidth->in->peak > 0)\n            new_rate = def->bandwidth->in->peak;\n\n        ret = virNetDevBandwidthUnplug(def->bridge, *class_id);\n        if (ret < 0)\n            return ret;\n        /* update sum of 'floor'-s of attached NICs */\n        tmp_floor_sum -= ifaceBand->in->floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n\n        /* return class ID */\n        ignore_value(virBitmapClearBit(classIdMap, *class_id));\n        /* update status file */\n        if (virNetworkObjSaveStatus(driver->stateDir,\n                                    obj, network_driver->xmlopt) < 0) {\n            tmp_floor_sum += ifaceBand->in->floor;\n            virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n            ignore_value(virBitmapSetBit(classIdMap, *class_id));\n            return ret;\n        }\n        /* update rate for non guaranteed NICs */\n        new_rate -= tmp_floor_sum;\n        if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                         def->bandwidth, new_rate) < 0)\n            VIR_WARN(\"Unable to update rate for 1:2 class on %s bridge\",\n                     def->bridge);\n        /* no class is associated any longer */\n        *class_id = 0;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "networkPlugBandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5228-5254",
    "snippet": "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id)\n{\n    int plug_ret;\n    unsigned long long new_rate = 0;\n    char ifmac[VIR_MAC_STRING_BUFLEN];\n\n    if ((plug_ret = networkCheckBandwidth(obj, ifaceBand, NULL,\n                                          mac, &new_rate)) < 0) {\n        /* helper reported error */\n        return -1;\n    }\n\n    if (plug_ret > 0)\n        /* no QoS needs to be set; claim success */\n        return 0;\n\n    virMacAddrFormat(mac, ifmac);\n\n    if (networkPlugBandwidthImpl(obj, mac, ifaceBand, class_id, new_rate) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
      "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkPlugBandwidthImpl",
          "args": [
            "obj",
            "mac",
            "ifaceBand",
            "class_id",
            "new_rate"
          ],
          "line": 5250
        },
        "resolved": true,
        "details": {
          "function_name": "networkPlugBandwidthImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "5175-5225",
          "snippet": "static int\nnetworkPlugBandwidthImpl(virNetworkObjPtr obj,\n                         virMacAddrPtr mac,\n                         virNetDevBandwidthPtr ifaceBand,\n                         unsigned int *class_id,\n                         unsigned long long new_rate)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    ssize_t next_id = 0;\n    int plug_ret;\n\n    /* generate new class_id */\n    if ((next_id = networkNextClassID(obj)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not generate next class ID\"));\n        return -1;\n    }\n\n    plug_ret = virNetDevBandwidthPlug(def->bridge, def->bandwidth,\n                                      mac, ifaceBand, next_id);\n    if (plug_ret < 0) {\n        ignore_value(virNetDevBandwidthUnplug(def->bridge, next_id));\n        return -1;\n    }\n\n    /* QoS was set, generate new class ID */\n    *class_id = next_id;\n    /* update sum of 'floor'-s of attached NICs */\n    tmp_floor_sum += ifaceBand->in->floor;\n    virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n    /* update status file */\n    if (virNetworkObjSaveStatus(driver->stateDir, obj, network_driver->xmlopt) < 0) {\n        ignore_value(virBitmapClearBit(classIdMap, next_id));\n        tmp_floor_sum -= ifaceBand->in->floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n        *class_id = 0;\n        ignore_value(virNetDevBandwidthUnplug(def->bridge, next_id));\n        return -1;\n    }\n    /* update rate for non guaranteed NICs */\n    new_rate -= tmp_floor_sum;\n    if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                     def->bandwidth, new_rate) < 0)\n        VIR_WARN(\"Unable to update rate for 1:2 class on %s bridge\",\n                 def->bridge);\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
            "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
            "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\n\nstatic int\nnetworkPlugBandwidthImpl(virNetworkObjPtr obj,\n                         virMacAddrPtr mac,\n                         virNetDevBandwidthPtr ifaceBand,\n                         unsigned int *class_id,\n                         unsigned long long new_rate)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    ssize_t next_id = 0;\n    int plug_ret;\n\n    /* generate new class_id */\n    if ((next_id = networkNextClassID(obj)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not generate next class ID\"));\n        return -1;\n    }\n\n    plug_ret = virNetDevBandwidthPlug(def->bridge, def->bandwidth,\n                                      mac, ifaceBand, next_id);\n    if (plug_ret < 0) {\n        ignore_value(virNetDevBandwidthUnplug(def->bridge, next_id));\n        return -1;\n    }\n\n    /* QoS was set, generate new class ID */\n    *class_id = next_id;\n    /* update sum of 'floor'-s of attached NICs */\n    tmp_floor_sum += ifaceBand->in->floor;\n    virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n    /* update status file */\n    if (virNetworkObjSaveStatus(driver->stateDir, obj, network_driver->xmlopt) < 0) {\n        ignore_value(virBitmapClearBit(classIdMap, next_id));\n        tmp_floor_sum -= ifaceBand->in->floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n        *class_id = 0;\n        ignore_value(virNetDevBandwidthUnplug(def->bridge, next_id));\n        return -1;\n    }\n    /* update rate for non guaranteed NICs */\n    new_rate -= tmp_floor_sum;\n    if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                     def->bandwidth, new_rate) < 0)\n        VIR_WARN(\"Unable to update rate for 1:2 class on %s bridge\",\n                 def->bridge);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "mac",
            "ifmac"
          ],
          "line": 5248
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkCheckBandwidth",
          "args": [
            "obj",
            "ifaceBand",
            "NULL",
            "mac",
            "&new_rate"
          ],
          "line": 5238
        },
        "resolved": true,
        "details": {
          "function_name": "networkCheckBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "5060-5146",
          "snippet": "static int\nnetworkCheckBandwidth(virNetworkObjPtr obj,\n                      virNetDevBandwidthPtr ifaceBand,\n                      virNetDevBandwidthPtr oldBandwidth,\n                      virMacAddrPtr ifaceMac,\n                      unsigned long long *new_rate)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetDevBandwidthPtr netBand = def->bandwidth;\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    unsigned long long tmp_new_rate = 0;\n    char ifmac[VIR_MAC_STRING_BUFLEN];\n\n    virMacAddrFormat(ifaceMac, ifmac);\n\n    if (virNetDevBandwidthHasFloor(ifaceBand) &&\n        !virNetDevBandwidthSupportsFloor(def->forward.type)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Invalid use of 'floor' on interface with MAC address %s \"\n                         \"- 'floor' is only supported for interface type 'network' with forward type 'nat', 'route', 'open' or none\"),\n                       ifmac);\n        return -1;\n    }\n\n    if (virNetDevBandwidthHasFloor(ifaceBand) &&\n        !(netBand && netBand->in)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Invalid use of 'floor' on interface with MAC \"\n                         \"address %s - network '%s' has no inbound QoS set\"),\n                       ifmac, def->name);\n        return -1;\n    }\n\n    if (!netBand || !netBand->in) {\n        VIR_DEBUG(\"No network bandwidth controls present\");\n        /* no QoS required, claim success */\n        return 1;\n    }\n    if (!virNetDevBandwidthHasFloor(ifaceBand) &&\n        !virNetDevBandwidthHasFloor(oldBandwidth)) {\n\n        VIR_DEBUG(\"No old/new interface bandwidth floor\");\n        /* no QoS required, claim success */\n        return 1;\n    }\n\n    tmp_new_rate = netBand->in->average;\n    if (oldBandwidth && oldBandwidth->in)\n        tmp_floor_sum -= oldBandwidth->in->floor;\n    if (ifaceBand && ifaceBand->in)\n        tmp_floor_sum += ifaceBand->in->floor;\n\n    /* check against peak */\n    if (netBand->in->peak) {\n        tmp_new_rate = netBand->in->peak;\n        if (tmp_floor_sum > netBand->in->peak) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Cannot plug '%s' interface into '%s' because \"\n                             \"new combined inbound floor=%llu would overcommit \"\n                             \"peak=%llu on network '%s'\"),\n                           ifmac,\n                           def->bridge,\n                           tmp_floor_sum,\n                           netBand->in->peak,\n                           def->name);\n            return -1;\n        }\n    } else if (tmp_floor_sum > netBand->in->average) {\n        /* tmp_floor_sum can be between 'average' and 'peak' iff 'peak' is set.\n         * Otherwise, tmp_floor_sum must be below 'average'. */\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Cannot plug '%s' interface into '%s' because \"\n                         \"new combined inbound floor=%llu would overcommit \"\n                         \"average=%llu on network '%s'\"),\n                       ifmac,\n                       def->bridge,\n                       tmp_floor_sum,\n                       netBand->in->average,\n                       def->name);\n        return -1;\n    }\n\n    if (new_rate)\n        *new_rate = tmp_new_rate;\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkCheckBandwidth(virNetworkObjPtr obj,\n                      virNetDevBandwidthPtr ifaceBand,\n                      virNetDevBandwidthPtr oldBandwidth,\n                      virMacAddrPtr ifaceMac,\n                      unsigned long long *new_rate)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetDevBandwidthPtr netBand = def->bandwidth;\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    unsigned long long tmp_new_rate = 0;\n    char ifmac[VIR_MAC_STRING_BUFLEN];\n\n    virMacAddrFormat(ifaceMac, ifmac);\n\n    if (virNetDevBandwidthHasFloor(ifaceBand) &&\n        !virNetDevBandwidthSupportsFloor(def->forward.type)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Invalid use of 'floor' on interface with MAC address %s \"\n                         \"- 'floor' is only supported for interface type 'network' with forward type 'nat', 'route', 'open' or none\"),\n                       ifmac);\n        return -1;\n    }\n\n    if (virNetDevBandwidthHasFloor(ifaceBand) &&\n        !(netBand && netBand->in)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Invalid use of 'floor' on interface with MAC \"\n                         \"address %s - network '%s' has no inbound QoS set\"),\n                       ifmac, def->name);\n        return -1;\n    }\n\n    if (!netBand || !netBand->in) {\n        VIR_DEBUG(\"No network bandwidth controls present\");\n        /* no QoS required, claim success */\n        return 1;\n    }\n    if (!virNetDevBandwidthHasFloor(ifaceBand) &&\n        !virNetDevBandwidthHasFloor(oldBandwidth)) {\n\n        VIR_DEBUG(\"No old/new interface bandwidth floor\");\n        /* no QoS required, claim success */\n        return 1;\n    }\n\n    tmp_new_rate = netBand->in->average;\n    if (oldBandwidth && oldBandwidth->in)\n        tmp_floor_sum -= oldBandwidth->in->floor;\n    if (ifaceBand && ifaceBand->in)\n        tmp_floor_sum += ifaceBand->in->floor;\n\n    /* check against peak */\n    if (netBand->in->peak) {\n        tmp_new_rate = netBand->in->peak;\n        if (tmp_floor_sum > netBand->in->peak) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Cannot plug '%s' interface into '%s' because \"\n                             \"new combined inbound floor=%llu would overcommit \"\n                             \"peak=%llu on network '%s'\"),\n                           ifmac,\n                           def->bridge,\n                           tmp_floor_sum,\n                           netBand->in->peak,\n                           def->name);\n            return -1;\n        }\n    } else if (tmp_floor_sum > netBand->in->average) {\n        /* tmp_floor_sum can be between 'average' and 'peak' iff 'peak' is set.\n         * Otherwise, tmp_floor_sum must be below 'average'. */\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Cannot plug '%s' interface into '%s' because \"\n                         \"new combined inbound floor=%llu would overcommit \"\n                         \"average=%llu on network '%s'\"),\n                       ifmac,\n                       def->bridge,\n                       tmp_floor_sum,\n                       netBand->in->average,\n                       def->name);\n        return -1;\n    }\n\n    if (new_rate)\n        *new_rate = tmp_new_rate;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\n\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id)\n{\n    int plug_ret;\n    unsigned long long new_rate = 0;\n    char ifmac[VIR_MAC_STRING_BUFLEN];\n\n    if ((plug_ret = networkCheckBandwidth(obj, ifaceBand, NULL,\n                                          mac, &new_rate)) < 0) {\n        /* helper reported error */\n        return -1;\n    }\n\n    if (plug_ret > 0)\n        /* no QoS needs to be set; claim success */\n        return 0;\n\n    virMacAddrFormat(mac, ifmac);\n\n    if (networkPlugBandwidthImpl(obj, mac, ifaceBand, class_id, new_rate) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "networkPlugBandwidthImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5175-5225",
    "snippet": "static int\nnetworkPlugBandwidthImpl(virNetworkObjPtr obj,\n                         virMacAddrPtr mac,\n                         virNetDevBandwidthPtr ifaceBand,\n                         unsigned int *class_id,\n                         unsigned long long new_rate)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    ssize_t next_id = 0;\n    int plug_ret;\n\n    /* generate new class_id */\n    if ((next_id = networkNextClassID(obj)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not generate next class ID\"));\n        return -1;\n    }\n\n    plug_ret = virNetDevBandwidthPlug(def->bridge, def->bandwidth,\n                                      mac, ifaceBand, next_id);\n    if (plug_ret < 0) {\n        ignore_value(virNetDevBandwidthUnplug(def->bridge, next_id));\n        return -1;\n    }\n\n    /* QoS was set, generate new class ID */\n    *class_id = next_id;\n    /* update sum of 'floor'-s of attached NICs */\n    tmp_floor_sum += ifaceBand->in->floor;\n    virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n    /* update status file */\n    if (virNetworkObjSaveStatus(driver->stateDir, obj, network_driver->xmlopt) < 0) {\n        ignore_value(virBitmapClearBit(classIdMap, next_id));\n        tmp_floor_sum -= ifaceBand->in->floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n        *class_id = 0;\n        ignore_value(virNetDevBandwidthUnplug(def->bridge, next_id));\n        return -1;\n    }\n    /* update rate for non guaranteed NICs */\n    new_rate -= tmp_floor_sum;\n    if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                     def->bandwidth, new_rate) < 0)\n        VIR_WARN(\"Unable to update rate for 1:2 class on %s bridge\",\n                 def->bridge);\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverStatePtr network_driver;",
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
      "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
      "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to update rate for 1:2 class on %s bridge\"",
            "def->bridge"
          ],
          "line": 5221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthUpdateRate",
          "args": [
            "def->bridge",
            "2",
            "def->bandwidth",
            "new_rate"
          ],
          "line": 5219
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthUpdateRate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "682-717",
          "snippet": "int\nvirNetDevBandwidthUpdateRate(const char *ifname,\n                             unsigned int id,\n                             virNetDevBandwidthPtr bandwidth,\n                             unsigned long long new_rate)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *rate = NULL;\n    char *ceil = NULL;\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    rate = g_strdup_printf(\"%llukbps\", new_rate);\n    ceil = g_strdup_printf(\"%llukbps\", bandwidth->in->peak ?\n                           bandwidth->in->peak :\n                           bandwidth->in->average);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"change\", \"dev\", ifname,\n                         \"classid\", class_id, \"htb\", \"rate\", rate,\n                         \"ceil\", ceil, NULL);\n    virNetDevBandwidthCmdAddOptimalQuantum(cmd, bandwidth->in);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(class_id);\n    VIR_FREE(rate);\n    VIR_FREE(ceil);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthUpdateRate(const char *ifname,\n                             unsigned int id,\n                             virNetDevBandwidthPtr bandwidth,\n                             unsigned long long new_rate)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *rate = NULL;\n    char *ceil = NULL;\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    rate = g_strdup_printf(\"%llukbps\", new_rate);\n    ceil = g_strdup_printf(\"%llukbps\", bandwidth->in->peak ?\n                           bandwidth->in->peak :\n                           bandwidth->in->average);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"change\", \"dev\", ifname,\n                         \"classid\", class_id, \"htb\", \"rate\", rate,\n                         \"ceil\", ceil, NULL);\n    virNetDevBandwidthCmdAddOptimalQuantum(cmd, bandwidth->in);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(class_id);\n    VIR_FREE(rate);\n    VIR_FREE(ceil);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevBandwidthUnplug(def->bridge, next_id)"
          ],
          "line": 5214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthUnplug",
          "args": [
            "def->bridge",
            "next_id"
          ],
          "line": 5214
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthUnplug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "620-666",
          "snippet": "int\nvirNetDevBandwidthUnplug(const char *brname,\n                         unsigned int id)\n{\n    int ret = -1;\n    int cmd_ret = 0;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *qdisc_id = NULL;\n\n    if (id <= 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invalid class ID %d\"), id);\n        return -1;\n    }\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    qdisc_id = g_strdup_printf(\"%x:\", id);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", brname,\n                         \"handle\", qdisc_id, NULL);\n\n    /* Don't threat tc errors as fatal, but\n     * try to remove as much as possible */\n    if (virCommandRun(cmd, &cmd_ret) < 0)\n        goto cleanup;\n\n    if (virNetDevBandwidthManipulateFilter(brname, NULL, id,\n                                           NULL, true, false) < 0)\n        goto cleanup;\n\n    virCommandFree(cmd);\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"del\", \"dev\", brname,\n                         \"classid\", class_id, NULL);\n\n    if (virCommandRun(cmd, &cmd_ret) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(qdisc_id);\n    VIR_FREE(class_id);\n    virCommandFree(cmd);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthUnplug(const char *brname,\n                         unsigned int id)\n{\n    int ret = -1;\n    int cmd_ret = 0;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *qdisc_id = NULL;\n\n    if (id <= 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invalid class ID %d\"), id);\n        return -1;\n    }\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    qdisc_id = g_strdup_printf(\"%x:\", id);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", brname,\n                         \"handle\", qdisc_id, NULL);\n\n    /* Don't threat tc errors as fatal, but\n     * try to remove as much as possible */\n    if (virCommandRun(cmd, &cmd_ret) < 0)\n        goto cleanup;\n\n    if (virNetDevBandwidthManipulateFilter(brname, NULL, id,\n                                           NULL, true, false) < 0)\n        goto cleanup;\n\n    virCommandFree(cmd);\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"del\", \"dev\", brname,\n                         \"classid\", class_id, NULL);\n\n    if (virCommandRun(cmd, &cmd_ret) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(qdisc_id);\n    VIR_FREE(class_id);\n    virCommandFree(cmd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetFloorSum",
          "args": [
            "obj",
            "tmp_floor_sum"
          ],
          "line": 5212
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetFloorSum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "258-263",
          "snippet": "void\nvirNetworkObjSetFloorSum(virNetworkObjPtr obj,\n                         unsigned long long floor_sum)\n{\n    obj->floor_sum = floor_sum;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetFloorSum(virNetworkObjPtr obj,\n                         unsigned long long floor_sum)\n{\n    obj->floor_sum = floor_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapClearBit(classIdMap, next_id)"
          ],
          "line": 5210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapClearBit",
          "args": [
            "classIdMap",
            "next_id"
          ],
          "line": 5210
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapClearBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "265-277",
          "snippet": "int\nvirBitmapClearBitExpand(virBitmapPtr bitmap,\n                        size_t b)\n{\n    if (bitmap->nbits <= b) {\n        if (virBitmapExpand(bitmap, b) < 0)\n            return -1;\n    } else {\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] &= ~VIR_BITMAP_BIT(b);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapClearBitExpand(virBitmapPtr bitmap,\n                        size_t b)\n{\n    if (bitmap->nbits <= b) {\n        if (virBitmapExpand(bitmap, b) < 0)\n            return -1;\n    } else {\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] &= ~VIR_BITMAP_BIT(b);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSaveStatus",
          "args": [
            "driver->stateDir",
            "obj",
            "network_driver->xmlopt"
          ],
          "line": 5209
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSaveStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "851-870",
          "snippet": "int\nvirNetworkObjSaveStatus(const char *statusDir,\n                        virNetworkObjPtr obj,\n                        virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    int flags = 0;\n    char *xml;\n\n    if (!(xml = virNetworkObjFormat(obj, xmlopt, flags)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(statusDir, obj->def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nint\nvirNetworkObjSaveStatus(const char *statusDir,\n                        virNetworkObjPtr obj,\n                        virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    int flags = 0;\n    char *xml;\n\n    if (!(xml = virNetworkObjFormat(obj, xmlopt, flags)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(statusDir, obj->def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevBandwidthUnplug(def->bridge, next_id)"
          ],
          "line": 5199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthPlug",
          "args": [
            "def->bridge",
            "def->bandwidth",
            "mac",
            "ifaceBand",
            "next_id"
          ],
          "line": 5196
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthPlug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "541-609",
          "snippet": "int\nvirNetDevBandwidthPlug(const char *brname,\n                       virNetDevBandwidthPtr net_bandwidth,\n                       const virMacAddr *ifmac_ptr,\n                       virNetDevBandwidthPtr bandwidth,\n                       unsigned int id)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *qdisc_id = NULL;\n    char *floor = NULL;\n    char *ceil = NULL;\n    char ifmacStr[VIR_MAC_STRING_BUFLEN];\n\n    if (id <= 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invalid class ID %d\"), id);\n        return -1;\n    }\n\n    virMacAddrFormat(ifmac_ptr, ifmacStr);\n\n    if (!net_bandwidth || !net_bandwidth->in) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Bridge '%s' has no QoS set, therefore \"\n                         \"unable to set 'floor' on '%s'\"),\n                       brname, ifmacStr);\n        return -1;\n    }\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    qdisc_id = g_strdup_printf(\"%x:\", id);\n    floor = g_strdup_printf(\"%llukbps\", bandwidth->in->floor);\n    ceil = g_strdup_printf(\"%llukbps\", net_bandwidth->in->peak ?\n                           net_bandwidth->in->peak :\n                           net_bandwidth->in->average);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", brname, \"parent\", \"1:1\",\n                         \"classid\", class_id, \"htb\", \"rate\", floor,\n                         \"ceil\", ceil, NULL);\n    virNetDevBandwidthCmdAddOptimalQuantum(cmd, bandwidth->in);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    virCommandFree(cmd);\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", brname, \"parent\",\n                         class_id, \"handle\", qdisc_id, \"sfq\", \"perturb\",\n                         \"10\", NULL);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virNetDevBandwidthManipulateFilter(brname, ifmac_ptr, id,\n                                           class_id, false, true) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(ceil);\n    VIR_FREE(floor);\n    VIR_FREE(qdisc_id);\n    VIR_FREE(class_id);\n    virCommandFree(cmd);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthPlug(const char *brname,\n                       virNetDevBandwidthPtr net_bandwidth,\n                       const virMacAddr *ifmac_ptr,\n                       virNetDevBandwidthPtr bandwidth,\n                       unsigned int id)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char *class_id = NULL;\n    char *qdisc_id = NULL;\n    char *floor = NULL;\n    char *ceil = NULL;\n    char ifmacStr[VIR_MAC_STRING_BUFLEN];\n\n    if (id <= 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Invalid class ID %d\"), id);\n        return -1;\n    }\n\n    virMacAddrFormat(ifmac_ptr, ifmacStr);\n\n    if (!net_bandwidth || !net_bandwidth->in) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Bridge '%s' has no QoS set, therefore \"\n                         \"unable to set 'floor' on '%s'\"),\n                       brname, ifmacStr);\n        return -1;\n    }\n\n    class_id = g_strdup_printf(\"1:%x\", id);\n    qdisc_id = g_strdup_printf(\"%x:\", id);\n    floor = g_strdup_printf(\"%llukbps\", bandwidth->in->floor);\n    ceil = g_strdup_printf(\"%llukbps\", net_bandwidth->in->peak ?\n                           net_bandwidth->in->peak :\n                           net_bandwidth->in->average);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", brname, \"parent\", \"1:1\",\n                         \"classid\", class_id, \"htb\", \"rate\", floor,\n                         \"ceil\", ceil, NULL);\n    virNetDevBandwidthCmdAddOptimalQuantum(cmd, bandwidth->in);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    virCommandFree(cmd);\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", brname, \"parent\",\n                         class_id, \"handle\", qdisc_id, \"sfq\", \"perturb\",\n                         \"10\", NULL);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virNetDevBandwidthManipulateFilter(brname, ifmac_ptr, id,\n                                           class_id, false, true) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(ceil);\n    VIR_FREE(floor);\n    VIR_FREE(qdisc_id);\n    VIR_FREE(class_id);\n    virCommandFree(cmd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not generate next class ID\")"
          ],
          "line": 5191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not generate next class ID\""
          ],
          "line": 5192
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkNextClassID",
          "args": [
            "obj"
          ],
          "line": 5190
        },
        "resolved": true,
        "details": {
          "function_name": "networkNextClassID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "5159-5172",
          "snippet": "static ssize_t\nnetworkNextClassID(virNetworkObjPtr obj)\n{\n    ssize_t ret = 0;\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n\n    if ((ret = virBitmapNextClearBit(classIdMap, -1)) < 0)\n        ret = virBitmapSize(classIdMap);\n\n    if (virBitmapSetBitExpand(classIdMap, ret) < 0)\n        return -1;\n\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic ssize_t\nnetworkNextClassID(virNetworkObjPtr obj)\n{\n    ssize_t ret = 0;\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n\n    if ((ret = virBitmapNextClearBit(classIdMap, -1)) < 0)\n        ret = virBitmapSize(classIdMap);\n\n    if (virBitmapSetBitExpand(classIdMap, ret) < 0)\n        return -1;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetFloorSum",
          "args": [
            "obj"
          ],
          "line": 5185
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetFloorSum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "251-255",
          "snippet": "unsigned long long\nvirNetworkObjGetFloorSum(virNetworkObjPtr obj)\n{\n    return obj->floor_sum;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nunsigned long long\nvirNetworkObjGetFloorSum(virNetworkObjPtr obj)\n{\n    return obj->floor_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetClassIdMap",
          "args": [
            "obj"
          ],
          "line": 5184
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetClassIdMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "237-241",
          "snippet": "virBitmapPtr\nvirNetworkObjGetClassIdMap(virNetworkObjPtr obj)\n{\n    return obj->classIdMap;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirBitmapPtr\nvirNetworkObjGetClassIdMap(virNetworkObjPtr obj)\n{\n    return obj->classIdMap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 5183
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 5182
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\n\nstatic int\nnetworkPlugBandwidthImpl(virNetworkObjPtr obj,\n                         virMacAddrPtr mac,\n                         virNetDevBandwidthPtr ifaceBand,\n                         unsigned int *class_id,\n                         unsigned long long new_rate)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    ssize_t next_id = 0;\n    int plug_ret;\n\n    /* generate new class_id */\n    if ((next_id = networkNextClassID(obj)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not generate next class ID\"));\n        return -1;\n    }\n\n    plug_ret = virNetDevBandwidthPlug(def->bridge, def->bandwidth,\n                                      mac, ifaceBand, next_id);\n    if (plug_ret < 0) {\n        ignore_value(virNetDevBandwidthUnplug(def->bridge, next_id));\n        return -1;\n    }\n\n    /* QoS was set, generate new class ID */\n    *class_id = next_id;\n    /* update sum of 'floor'-s of attached NICs */\n    tmp_floor_sum += ifaceBand->in->floor;\n    virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n    /* update status file */\n    if (virNetworkObjSaveStatus(driver->stateDir, obj, network_driver->xmlopt) < 0) {\n        ignore_value(virBitmapClearBit(classIdMap, next_id));\n        tmp_floor_sum -= ifaceBand->in->floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n        *class_id = 0;\n        ignore_value(virNetDevBandwidthUnplug(def->bridge, next_id));\n        return -1;\n    }\n    /* update rate for non guaranteed NICs */\n    new_rate -= tmp_floor_sum;\n    if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                     def->bandwidth, new_rate) < 0)\n        VIR_WARN(\"Unable to update rate for 1:2 class on %s bridge\",\n                 def->bridge);\n\n    return 0;\n}"
  },
  {
    "function_name": "networkNextClassID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5159-5172",
    "snippet": "static ssize_t\nnetworkNextClassID(virNetworkObjPtr obj)\n{\n    ssize_t ret = 0;\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n\n    if ((ret = virBitmapNextClearBit(classIdMap, -1)) < 0)\n        ret = virBitmapSize(classIdMap);\n\n    if (virBitmapSetBitExpand(classIdMap, ret) < 0)\n        return -1;\n\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapSetBitExpand",
          "args": [
            "classIdMap",
            "ret"
          ],
          "line": 5168
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapSize",
          "args": [
            "classIdMap"
          ],
          "line": 5166
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "882-886",
          "snippet": "size_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nsize_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNextClearBit",
          "args": [
            "classIdMap",
            "-1"
          ],
          "line": 5165
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextClearBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1078-1113",
          "snippet": "ssize_t\nvirBitmapNextClearBit(virBitmapPtr bitmap,\n                      ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = ~bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = ~bitmap->map[nl];\n\n    if (nl == bitmap->map_len - 1) {\n        /* Ensure tail bits are ignored.  */\n        int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n        if (tail)\n            bits &= -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n    }\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextClearBit(virBitmapPtr bitmap,\n                      ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = ~bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = ~bitmap->map[nl];\n\n    if (nl == bitmap->map_len - 1) {\n        /* Ensure tail bits are ignored.  */\n        int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n        if (tail)\n            bits &= -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n    }\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetClassIdMap",
          "args": [
            "obj"
          ],
          "line": 5163
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetClassIdMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "237-241",
          "snippet": "virBitmapPtr\nvirNetworkObjGetClassIdMap(virNetworkObjPtr obj)\n{\n    return obj->classIdMap;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirBitmapPtr\nvirNetworkObjGetClassIdMap(virNetworkObjPtr obj)\n{\n    return obj->classIdMap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic ssize_t\nnetworkNextClassID(virNetworkObjPtr obj)\n{\n    ssize_t ret = 0;\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n\n    if ((ret = virBitmapNextClearBit(classIdMap, -1)) < 0)\n        ret = virBitmapSize(classIdMap);\n\n    if (virBitmapSetBitExpand(classIdMap, ret) < 0)\n        return -1;\n\n    return ret;\n}"
  },
  {
    "function_name": "networkCheckBandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "5060-5146",
    "snippet": "static int\nnetworkCheckBandwidth(virNetworkObjPtr obj,\n                      virNetDevBandwidthPtr ifaceBand,\n                      virNetDevBandwidthPtr oldBandwidth,\n                      virMacAddrPtr ifaceMac,\n                      unsigned long long *new_rate)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetDevBandwidthPtr netBand = def->bandwidth;\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    unsigned long long tmp_new_rate = 0;\n    char ifmac[VIR_MAC_STRING_BUFLEN];\n\n    virMacAddrFormat(ifaceMac, ifmac);\n\n    if (virNetDevBandwidthHasFloor(ifaceBand) &&\n        !virNetDevBandwidthSupportsFloor(def->forward.type)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Invalid use of 'floor' on interface with MAC address %s \"\n                         \"- 'floor' is only supported for interface type 'network' with forward type 'nat', 'route', 'open' or none\"),\n                       ifmac);\n        return -1;\n    }\n\n    if (virNetDevBandwidthHasFloor(ifaceBand) &&\n        !(netBand && netBand->in)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Invalid use of 'floor' on interface with MAC \"\n                         \"address %s - network '%s' has no inbound QoS set\"),\n                       ifmac, def->name);\n        return -1;\n    }\n\n    if (!netBand || !netBand->in) {\n        VIR_DEBUG(\"No network bandwidth controls present\");\n        /* no QoS required, claim success */\n        return 1;\n    }\n    if (!virNetDevBandwidthHasFloor(ifaceBand) &&\n        !virNetDevBandwidthHasFloor(oldBandwidth)) {\n\n        VIR_DEBUG(\"No old/new interface bandwidth floor\");\n        /* no QoS required, claim success */\n        return 1;\n    }\n\n    tmp_new_rate = netBand->in->average;\n    if (oldBandwidth && oldBandwidth->in)\n        tmp_floor_sum -= oldBandwidth->in->floor;\n    if (ifaceBand && ifaceBand->in)\n        tmp_floor_sum += ifaceBand->in->floor;\n\n    /* check against peak */\n    if (netBand->in->peak) {\n        tmp_new_rate = netBand->in->peak;\n        if (tmp_floor_sum > netBand->in->peak) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Cannot plug '%s' interface into '%s' because \"\n                             \"new combined inbound floor=%llu would overcommit \"\n                             \"peak=%llu on network '%s'\"),\n                           ifmac,\n                           def->bridge,\n                           tmp_floor_sum,\n                           netBand->in->peak,\n                           def->name);\n            return -1;\n        }\n    } else if (tmp_floor_sum > netBand->in->average) {\n        /* tmp_floor_sum can be between 'average' and 'peak' iff 'peak' is set.\n         * Otherwise, tmp_floor_sum must be below 'average'. */\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Cannot plug '%s' interface into '%s' because \"\n                         \"new combined inbound floor=%llu would overcommit \"\n                         \"average=%llu on network '%s'\"),\n                       ifmac,\n                       def->bridge,\n                       tmp_floor_sum,\n                       netBand->in->average,\n                       def->name);\n        return -1;\n    }\n\n    if (new_rate)\n        *new_rate = tmp_new_rate;\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"Cannot plug '%s' interface into '%s' because \"\n                         \"new combined inbound floor=%llu would overcommit \"\n                         \"average=%llu on network '%s'\")",
            "ifmac",
            "def->bridge",
            "tmp_floor_sum",
            "netBand->in->average",
            "def->name"
          ],
          "line": 5130
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot plug '%s' interface into '%s' because \"\n                         \"new combined inbound floor=%llu would overcommit \"\n                         \"average=%llu on network '%s'\""
          ],
          "line": 5131
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No old/new interface bandwidth floor\""
          ],
          "line": 5101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthHasFloor",
          "args": [
            "oldBandwidth"
          ],
          "line": 5099
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthHasFloor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_bandwidth_conf.c",
          "lines": "325-329",
          "snippet": "bool\nvirNetDevBandwidthHasFloor(const virNetDevBandwidth *b)\n{\n    return b && b->in && b->in->floor != 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include <config.h>\n\nbool\nvirNetDevBandwidthHasFloor(const virNetDevBandwidth *b)\n{\n    return b && b->in && b->in->floor != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No network bandwidth controls present\""
          ],
          "line": 5094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "_(\"Invalid use of 'floor' on interface with MAC \"\n                         \"address %s - network '%s' has no inbound QoS set\")",
            "ifmac",
            "def->name"
          ],
          "line": 5086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "_(\"Invalid use of 'floor' on interface with MAC address %s \"\n                         \"- 'floor' is only supported for interface type 'network' with forward type 'nat', 'route', 'open' or none\")",
            "ifmac"
          ],
          "line": 5077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthSupportsFloor",
          "args": [
            "def->forward.type"
          ],
          "line": 5076
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthSupportsFloor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_bandwidth_conf.c",
          "lines": "332-349",
          "snippet": "bool virNetDevBandwidthSupportsFloor(virNetworkForwardType type)\n{\n    switch (type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        return true;\n    case VIR_NETWORK_FORWARD_BRIDGE:\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n    case VIR_NETWORK_FORWARD_LAST:\n        break;\n    }\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include <config.h>\n\nbool virNetDevBandwidthSupportsFloor(virNetworkForwardType type)\n{\n    switch (type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        return true;\n    case VIR_NETWORK_FORWARD_BRIDGE:\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n    case VIR_NETWORK_FORWARD_LAST:\n        break;\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "ifaceMac",
            "ifmac"
          ],
          "line": 5073
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetFloorSum",
          "args": [
            "obj"
          ],
          "line": 5069
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetFloorSum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "251-255",
          "snippet": "unsigned long long\nvirNetworkObjGetFloorSum(virNetworkObjPtr obj)\n{\n    return obj->floor_sum;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nunsigned long long\nvirNetworkObjGetFloorSum(virNetworkObjPtr obj)\n{\n    return obj->floor_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 5067
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkCheckBandwidth(virNetworkObjPtr obj,\n                      virNetDevBandwidthPtr ifaceBand,\n                      virNetDevBandwidthPtr oldBandwidth,\n                      virMacAddrPtr ifaceMac,\n                      unsigned long long *new_rate)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetDevBandwidthPtr netBand = def->bandwidth;\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    unsigned long long tmp_new_rate = 0;\n    char ifmac[VIR_MAC_STRING_BUFLEN];\n\n    virMacAddrFormat(ifaceMac, ifmac);\n\n    if (virNetDevBandwidthHasFloor(ifaceBand) &&\n        !virNetDevBandwidthSupportsFloor(def->forward.type)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Invalid use of 'floor' on interface with MAC address %s \"\n                         \"- 'floor' is only supported for interface type 'network' with forward type 'nat', 'route', 'open' or none\"),\n                       ifmac);\n        return -1;\n    }\n\n    if (virNetDevBandwidthHasFloor(ifaceBand) &&\n        !(netBand && netBand->in)) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Invalid use of 'floor' on interface with MAC \"\n                         \"address %s - network '%s' has no inbound QoS set\"),\n                       ifmac, def->name);\n        return -1;\n    }\n\n    if (!netBand || !netBand->in) {\n        VIR_DEBUG(\"No network bandwidth controls present\");\n        /* no QoS required, claim success */\n        return 1;\n    }\n    if (!virNetDevBandwidthHasFloor(ifaceBand) &&\n        !virNetDevBandwidthHasFloor(oldBandwidth)) {\n\n        VIR_DEBUG(\"No old/new interface bandwidth floor\");\n        /* no QoS required, claim success */\n        return 1;\n    }\n\n    tmp_new_rate = netBand->in->average;\n    if (oldBandwidth && oldBandwidth->in)\n        tmp_floor_sum -= oldBandwidth->in->floor;\n    if (ifaceBand && ifaceBand->in)\n        tmp_floor_sum += ifaceBand->in->floor;\n\n    /* check against peak */\n    if (netBand->in->peak) {\n        tmp_new_rate = netBand->in->peak;\n        if (tmp_floor_sum > netBand->in->peak) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"Cannot plug '%s' interface into '%s' because \"\n                             \"new combined inbound floor=%llu would overcommit \"\n                             \"peak=%llu on network '%s'\"),\n                           ifmac,\n                           def->bridge,\n                           tmp_floor_sum,\n                           netBand->in->peak,\n                           def->name);\n            return -1;\n        }\n    } else if (tmp_floor_sum > netBand->in->average) {\n        /* tmp_floor_sum can be between 'average' and 'peak' iff 'peak' is set.\n         * Otherwise, tmp_floor_sum must be below 'average'. */\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Cannot plug '%s' interface into '%s' because \"\n                         \"new combined inbound floor=%llu would overcommit \"\n                         \"average=%llu on network '%s'\"),\n                       ifmac,\n                       def->bridge,\n                       tmp_floor_sum,\n                       netBand->in->average,\n                       def->name);\n        return -1;\n    }\n\n    if (new_rate)\n        *new_rate = tmp_new_rate;\n\n    return 0;\n}"
  },
  {
    "function_name": "networkReleasePort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "4938-5037",
    "snippet": "static int\nnetworkReleasePort(virNetworkObjPtr obj,\n                   virNetworkPortDefPtr port)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr netdef;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n\n    netdef = virNetworkObjGetDef(obj);\n\n    switch ((virNetworkPortPlugType)port->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        VIR_DEBUG(\"Releasing network device with no plug type\");\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        if (networkUnplugBandwidth(obj, port->bandwidth,\n                                   &port->class_id) < 0)\n            return -1;\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (netdef->forward.nifs == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a direct mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        }\n\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n                STREQ(port->plug.direct.linkdev, netdef->forward.ifs[i].device.dev)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have dev='%s' \"\n                             \"in use by domain\"),\n                           netdef->name, port->plug.direct.linkdev);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n        if (netdef->forward.nifs == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a hostdev mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        }\n\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI &&\n                virPCIDeviceAddressEqual(&port->plug.hostdevpci.addr,\n                                         &netdef->forward.ifs[i].device.pci)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have \"\n                             \"PCI device %04x:%02x:%02x.%x in use by domain\"),\n                           netdef->name,\n                           port->plug.hostdevpci.addr.domain,\n                           port->plug.hostdevpci.addr.bus,\n                           port->plug.hostdevpci.addr.slot,\n                           port->plug.hostdevpci.addr.function);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, port->plugtype);\n        return -1;\n    }\n\n    virNetworkObjMacMgrDel(obj, driver->dnsmasqStateDir, port->ownername, &port->mac);\n\n    netdef->connections--;\n    if (dev)\n        dev->connections--;\n    /* finally we can call the 'unplugged' hook script if any */\n    networkRunHook(obj, port, VIR_HOOK_NETWORK_OP_PORT_DELETED,\n                   VIR_HOOK_SUBOP_BEGIN);\n    networkLogAllocation(netdef, dev, &port->mac, false);\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
      "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
      "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);",
      "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkLogAllocation",
          "args": [
            "netdef",
            "dev",
            "&port->mac",
            "false"
          ],
          "line": 5034
        },
        "resolved": true,
        "details": {
          "function_name": "networkLogAllocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "4436-4464",
          "snippet": "static void\nnetworkLogAllocation(virNetworkDefPtr netdef,\n                     virNetworkForwardIfDefPtr dev,\n                     virMacAddrPtr mac,\n                     bool inUse)\n{\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    const char *verb = inUse ? \"using\" : \"releasing\";\n\n    virMacAddrFormat(mac, macStr);\n    if (!dev) {\n        VIR_INFO(\"MAC %s %s network %s (%d connections)\",\n                 macStr, verb, netdef->name, netdef->connections);\n    } else {\n        if (dev->type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI) {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %04x:%02x:%02x.%x (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.pci.domain, dev->device.pci.bus,\n                     dev->device.pci.slot, dev->device.pci.function,\n                     dev->connections);\n        } else {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %s (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.dev, dev->connections);\n        }\n    }\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkLogAllocation(virNetworkDefPtr netdef,\n                     virNetworkForwardIfDefPtr dev,\n                     virMacAddrPtr mac,\n                     bool inUse)\n{\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    const char *verb = inUse ? \"using\" : \"releasing\";\n\n    virMacAddrFormat(mac, macStr);\n    if (!dev) {\n        VIR_INFO(\"MAC %s %s network %s (%d connections)\",\n                 macStr, verb, netdef->name, netdef->connections);\n    } else {\n        if (dev->type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI) {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %04x:%02x:%02x.%x (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.pci.domain, dev->device.pci.bus,\n                     dev->device.pci.slot, dev->device.pci.function,\n                     dev->connections);\n        } else {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %s (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.dev, dev->connections);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRunHook",
          "args": [
            "obj",
            "port",
            "VIR_HOOK_NETWORK_OP_PORT_DELETED",
            "VIR_HOOK_SUBOP_BEGIN"
          ],
          "line": 5032
        },
        "resolved": true,
        "details": {
          "function_name": "networkRunHook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "316-364",
          "snippet": "static int\nnetworkRunHook(virNetworkObjPtr obj,\n               virNetworkPortDefPtr port,\n               int op,\n               int sub_op)\n{\n    virNetworkDefPtr def;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xml = NULL;\n    int hookret;\n    int ret = -1;\n\n    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {\n        if (!obj) {\n            VIR_DEBUG(\"Not running hook as @obj is NULL\");\n            ret = 0;\n            goto cleanup;\n        }\n        def = virNetworkObjGetDef(obj);\n\n        virBufferAddLit(&buf, \"<hookData>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        if (virNetworkDefFormatBuf(&buf, def, network_driver->xmlopt, 0) < 0)\n            goto cleanup;\n        if (port && virNetworkPortDefFormatBuf(&buf, port) < 0)\n            goto cleanup;\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</hookData>\");\n\n        xml = virBufferContentAndReset(&buf);\n        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, def->name,\n                              op, sub_op, NULL, xml, NULL);\n\n        /*\n         * If the script raised an error, pass it to the callee.\n         */\n        if (hookret < 0)\n            goto cleanup;\n\n        networkNetworkObjTaint(obj, VIR_NETWORK_TAINT_HOOK);\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n    VIR_FREE(xml);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkRunHook(virNetworkObjPtr obj,\n               virNetworkPortDefPtr port,\n               int op,\n               int sub_op)\n{\n    virNetworkDefPtr def;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xml = NULL;\n    int hookret;\n    int ret = -1;\n\n    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {\n        if (!obj) {\n            VIR_DEBUG(\"Not running hook as @obj is NULL\");\n            ret = 0;\n            goto cleanup;\n        }\n        def = virNetworkObjGetDef(obj);\n\n        virBufferAddLit(&buf, \"<hookData>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        if (virNetworkDefFormatBuf(&buf, def, network_driver->xmlopt, 0) < 0)\n            goto cleanup;\n        if (port && virNetworkPortDefFormatBuf(&buf, port) < 0)\n            goto cleanup;\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</hookData>\");\n\n        xml = virBufferContentAndReset(&buf);\n        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, def->name,\n                              op, sub_op, NULL, xml, NULL);\n\n        /*\n         * If the script raised an error, pass it to the callee.\n         */\n        if (hookret < 0)\n            goto cleanup;\n\n        networkNetworkObjTaint(obj, VIR_NETWORK_TAINT_HOOK);\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n    VIR_FREE(xml);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjMacMgrDel",
          "args": [
            "obj",
            "driver->dnsmasqStateDir",
            "port->ownername",
            "&port->mac"
          ],
          "line": 5026
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjMacMgrDel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "313-341",
          "snippet": "int\nvirNetworkObjMacMgrDel(virNetworkObjPtr obj,\n                       const char *dnsmasqStateDir,\n                       const char *domain,\n                       const virMacAddr *mac)\n{\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    char *file = NULL;\n    int ret = -1;\n\n    if (!obj->macmap)\n        return 0;\n\n    virMacAddrFormat(mac, macStr);\n\n    if (!(file = virMacMapFileName(dnsmasqStateDir, obj->def->bridge)))\n        goto cleanup;\n\n    if (virMacMapRemove(obj->macmap, domain, macStr) < 0)\n        goto cleanup;\n\n    if (virMacMapWriteFile(obj->macmap, file) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(file);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nint\nvirNetworkObjMacMgrDel(virNetworkObjPtr obj,\n                       const char *dnsmasqStateDir,\n                       const char *domain,\n                       const virMacAddr *mac)\n{\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    char *file = NULL;\n    int ret = -1;\n\n    if (!obj->macmap)\n        return 0;\n\n    virMacAddrFormat(mac, macStr);\n\n    if (!(file = virMacMapFileName(dnsmasqStateDir, obj->def->bridge)))\n        goto cleanup;\n\n    if (virMacMapRemove(obj->macmap, domain, macStr) < 0)\n        goto cleanup;\n\n    if (virMacMapWriteFile(obj->macmap, file) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(file);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkPortPlugType",
            "port->plugtype"
          ],
          "line": 5022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"network '%s' doesn't have \"\n                             \"PCI device %04x:%02x:%02x.%x in use by domain\")",
            "netdef->name",
            "port->plug.hostdevpci.addr.domain",
            "port->plug.hostdevpci.addr.bus",
            "port->plug.hostdevpci.addr.slot",
            "port->plug.hostdevpci.addr.function"
          ],
          "line": 5008
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"network '%s' doesn't have \"\n                             \"PCI device %04x:%02x:%02x.%x in use by domain\""
          ],
          "line": 5009
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressEqual",
          "args": [
            "&port->plug.hostdevpci.addr",
            "&netdef->forward.ifs[i].device.pci"
          ],
          "line": 5000
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1324-1335",
          "snippet": "bool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"network '%s' uses a hostdev mode, but \"\n                             \"has no forward dev and no interface pool\")",
            "netdef->name"
          ],
          "line": 4990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"network '%s' doesn't have dev='%s' \"\n                             \"in use by domain\")",
            "netdef->name",
            "port->plug.direct.linkdev"
          ],
          "line": 4980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "port->plug.direct.linkdev",
            "netdef->forward.ifs[i].device.dev"
          ],
          "line": 4973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"network '%s' uses a direct mode, but \"\n                             \"has no forward dev and no interface pool\")",
            "netdef->name"
          ],
          "line": 4963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkUnplugBandwidth",
          "args": [
            "obj",
            "port->bandwidth",
            "&port->class_id"
          ],
          "line": 4956
        },
        "resolved": true,
        "details": {
          "function_name": "networkUnplugBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "5257-5309",
          "snippet": "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    int ret = 0;\n    unsigned long long new_rate;\n\n    if (class_id && *class_id) {\n        if (!def->bandwidth || !def->bandwidth->in) {\n            VIR_WARN(\"Network %s has no bandwidth but unplug requested\",\n                     def->name);\n            return 0;\n        }\n        /* we must remove class from bridge */\n        new_rate = def->bandwidth->in->average;\n\n        if (def->bandwidth->in->peak > 0)\n            new_rate = def->bandwidth->in->peak;\n\n        ret = virNetDevBandwidthUnplug(def->bridge, *class_id);\n        if (ret < 0)\n            return ret;\n        /* update sum of 'floor'-s of attached NICs */\n        tmp_floor_sum -= ifaceBand->in->floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n\n        /* return class ID */\n        ignore_value(virBitmapClearBit(classIdMap, *class_id));\n        /* update status file */\n        if (virNetworkObjSaveStatus(driver->stateDir,\n                                    obj, network_driver->xmlopt) < 0) {\n            tmp_floor_sum += ifaceBand->in->floor;\n            virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n            ignore_value(virBitmapSetBit(classIdMap, *class_id));\n            return ret;\n        }\n        /* update rate for non guaranteed NICs */\n        new_rate -= tmp_floor_sum;\n        if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                         def->bandwidth, new_rate) < 0)\n            VIR_WARN(\"Unable to update rate for 1:2 class on %s bridge\",\n                     def->bridge);\n        /* no class is associated any longer */\n        *class_id = 0;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
            "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
            "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\n\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBitmapPtr classIdMap = virNetworkObjGetClassIdMap(obj);\n    unsigned long long tmp_floor_sum = virNetworkObjGetFloorSum(obj);\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    int ret = 0;\n    unsigned long long new_rate;\n\n    if (class_id && *class_id) {\n        if (!def->bandwidth || !def->bandwidth->in) {\n            VIR_WARN(\"Network %s has no bandwidth but unplug requested\",\n                     def->name);\n            return 0;\n        }\n        /* we must remove class from bridge */\n        new_rate = def->bandwidth->in->average;\n\n        if (def->bandwidth->in->peak > 0)\n            new_rate = def->bandwidth->in->peak;\n\n        ret = virNetDevBandwidthUnplug(def->bridge, *class_id);\n        if (ret < 0)\n            return ret;\n        /* update sum of 'floor'-s of attached NICs */\n        tmp_floor_sum -= ifaceBand->in->floor;\n        virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n\n        /* return class ID */\n        ignore_value(virBitmapClearBit(classIdMap, *class_id));\n        /* update status file */\n        if (virNetworkObjSaveStatus(driver->stateDir,\n                                    obj, network_driver->xmlopt) < 0) {\n            tmp_floor_sum += ifaceBand->in->floor;\n            virNetworkObjSetFloorSum(obj, tmp_floor_sum);\n            ignore_value(virBitmapSetBit(classIdMap, *class_id));\n            return ret;\n        }\n        /* update rate for non guaranteed NICs */\n        new_rate -= tmp_floor_sum;\n        if (virNetDevBandwidthUpdateRate(def->bridge, 2,\n                                         def->bandwidth, new_rate) < 0)\n            VIR_WARN(\"Unable to update rate for 1:2 class on %s bridge\",\n                     def->bridge);\n        /* no class is associated any longer */\n        *class_id = 0;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Releasing network device with no plug type\""
          ],
          "line": 4951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 4947
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 4942
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkReleasePort(virNetworkObjPtr obj,\n                   virNetworkPortDefPtr port)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr netdef;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n\n    netdef = virNetworkObjGetDef(obj);\n\n    switch ((virNetworkPortPlugType)port->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        VIR_DEBUG(\"Releasing network device with no plug type\");\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        if (networkUnplugBandwidth(obj, port->bandwidth,\n                                   &port->class_id) < 0)\n            return -1;\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (netdef->forward.nifs == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a direct mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        }\n\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n                STREQ(port->plug.direct.linkdev, netdef->forward.ifs[i].device.dev)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have dev='%s' \"\n                             \"in use by domain\"),\n                           netdef->name, port->plug.direct.linkdev);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n        if (netdef->forward.nifs == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a hostdev mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        }\n\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI &&\n                virPCIDeviceAddressEqual(&port->plug.hostdevpci.addr,\n                                         &netdef->forward.ifs[i].device.pci)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have \"\n                             \"PCI device %04x:%02x:%02x.%x in use by domain\"),\n                           netdef->name,\n                           port->plug.hostdevpci.addr.domain,\n                           port->plug.hostdevpci.addr.bus,\n                           port->plug.hostdevpci.addr.slot,\n                           port->plug.hostdevpci.addr.function);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, port->plugtype);\n        return -1;\n    }\n\n    virNetworkObjMacMgrDel(obj, driver->dnsmasqStateDir, port->ownername, &port->mac);\n\n    netdef->connections--;\n    if (dev)\n        dev->connections--;\n    /* finally we can call the 'unplugged' hook script if any */\n    networkRunHook(obj, port, VIR_HOOK_NETWORK_OP_PORT_DELETED,\n                   VIR_HOOK_SUBOP_BEGIN);\n    networkLogAllocation(netdef, dev, &port->mac, false);\n\n    return 0;\n}"
  },
  {
    "function_name": "networkNotifyPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "4783-4924",
    "snippet": "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port)\n{\n    virNetworkDefPtr netdef;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n\n    netdef = virNetworkObjGetDef(obj);\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       netdef->name);\n        return -1;\n    }\n\n    switch (port->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpectedly got a network port without a plug\"));\n        return -1;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        /* see if we're connected to the correct bridge */\n        if (!netdef->bridge) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unexpectedly got a network port without a network bridge\"));\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* find the matching interface and increment its connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n                STREQ(port->plug.direct.linkdev,\n                      netdef->forward.ifs[i].device.dev)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        /* dev points at the physical device we want to use */\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have dev='%s' \"\n                             \"in use by network port '%s'\"),\n                           netdef->name, port->plug.direct.linkdev,\n                           port->uuid);\n            return -1;\n        }\n\n        /* PASSTHROUGH mode and PRIVATE Mode + 802.1Qbh both require\n         * exclusive access to a device, so current connections count\n         * must be 0 in those cases.\n         */\n        if ((dev->connections > 0) &&\n            ((netdef->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH) ||\n             ((netdef->forward.type == VIR_NETWORK_FORWARD_PRIVATE) &&\n              port->virtPortProfile &&\n              (port->virtPortProfile->virtPortType == VIR_NETDEV_VPORT_PROFILE_8021QBH)))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' claims dev='%s' is already in \"\n                             \"use by a different port\"),\n                           netdef->name, port->plug.direct.linkdev);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* find the matching interface and increment its connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI &&\n                virPCIDeviceAddressEqual(&port->plug.hostdevpci.addr,\n                                         &netdef->forward.ifs[i].device.pci)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        /* dev points at the physical device we want to use */\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have \"\n                             \"PCI device %04x:%02x:%02x.%x in use by network port\"),\n                           netdef->name,\n                           port->plug.hostdevpci.addr.domain,\n                           port->plug.hostdevpci.addr.bus,\n                           port->plug.hostdevpci.addr.slot,\n                           port->plug.hostdevpci.addr.function);\n            return -1;\n        }\n\n        /* PASSTHROUGH mode, PRIVATE Mode + 802.1Qbh, and hostdev (PCI\n         * passthrough) all require exclusive access to a device, so\n         * current connections count must be 0 in those cases.\n         */\n        if ((dev->connections > 0) &&\n            netdef->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' claims the PCI device at \"\n                             \"domain=%d bus=%d slot=%d function=%d \"\n                             \"is already in use by a different network port\"),\n                           netdef->name,\n                           dev->device.pci.domain, dev->device.pci.bus,\n                           dev->device.pci.slot, dev->device.pci.function);\n            return -1;\n        }\n\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, port->plugtype);\n        return -1;\n    }\n\n    netdef->connections++;\n    if (dev)\n        dev->connections++;\n    /* finally we can call the 'plugged' hook script if any */\n    if (networkRunHook(obj, port, VIR_HOOK_NETWORK_OP_PORT_CREATED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0) {\n        /* adjust for failure */\n        if (dev)\n            dev->connections--;\n        netdef->connections--;\n        return -1;\n    }\n    networkLogAllocation(netdef, dev, &port->mac, true);\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkLogAllocation",
          "args": [
            "netdef",
            "dev",
            "&port->mac",
            "true"
          ],
          "line": 4921
        },
        "resolved": true,
        "details": {
          "function_name": "networkLogAllocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "4436-4464",
          "snippet": "static void\nnetworkLogAllocation(virNetworkDefPtr netdef,\n                     virNetworkForwardIfDefPtr dev,\n                     virMacAddrPtr mac,\n                     bool inUse)\n{\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    const char *verb = inUse ? \"using\" : \"releasing\";\n\n    virMacAddrFormat(mac, macStr);\n    if (!dev) {\n        VIR_INFO(\"MAC %s %s network %s (%d connections)\",\n                 macStr, verb, netdef->name, netdef->connections);\n    } else {\n        if (dev->type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI) {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %04x:%02x:%02x.%x (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.pci.domain, dev->device.pci.bus,\n                     dev->device.pci.slot, dev->device.pci.function,\n                     dev->connections);\n        } else {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %s (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.dev, dev->connections);\n        }\n    }\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkLogAllocation(virNetworkDefPtr netdef,\n                     virNetworkForwardIfDefPtr dev,\n                     virMacAddrPtr mac,\n                     bool inUse)\n{\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    const char *verb = inUse ? \"using\" : \"releasing\";\n\n    virMacAddrFormat(mac, macStr);\n    if (!dev) {\n        VIR_INFO(\"MAC %s %s network %s (%d connections)\",\n                 macStr, verb, netdef->name, netdef->connections);\n    } else {\n        if (dev->type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI) {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %04x:%02x:%02x.%x (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.pci.domain, dev->device.pci.bus,\n                     dev->device.pci.slot, dev->device.pci.function,\n                     dev->connections);\n        } else {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %s (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.dev, dev->connections);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRunHook",
          "args": [
            "obj",
            "port",
            "VIR_HOOK_NETWORK_OP_PORT_CREATED",
            "VIR_HOOK_SUBOP_BEGIN"
          ],
          "line": 4913
        },
        "resolved": true,
        "details": {
          "function_name": "networkRunHook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "316-364",
          "snippet": "static int\nnetworkRunHook(virNetworkObjPtr obj,\n               virNetworkPortDefPtr port,\n               int op,\n               int sub_op)\n{\n    virNetworkDefPtr def;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xml = NULL;\n    int hookret;\n    int ret = -1;\n\n    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {\n        if (!obj) {\n            VIR_DEBUG(\"Not running hook as @obj is NULL\");\n            ret = 0;\n            goto cleanup;\n        }\n        def = virNetworkObjGetDef(obj);\n\n        virBufferAddLit(&buf, \"<hookData>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        if (virNetworkDefFormatBuf(&buf, def, network_driver->xmlopt, 0) < 0)\n            goto cleanup;\n        if (port && virNetworkPortDefFormatBuf(&buf, port) < 0)\n            goto cleanup;\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</hookData>\");\n\n        xml = virBufferContentAndReset(&buf);\n        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, def->name,\n                              op, sub_op, NULL, xml, NULL);\n\n        /*\n         * If the script raised an error, pass it to the callee.\n         */\n        if (hookret < 0)\n            goto cleanup;\n\n        networkNetworkObjTaint(obj, VIR_NETWORK_TAINT_HOOK);\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n    VIR_FREE(xml);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkRunHook(virNetworkObjPtr obj,\n               virNetworkPortDefPtr port,\n               int op,\n               int sub_op)\n{\n    virNetworkDefPtr def;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xml = NULL;\n    int hookret;\n    int ret = -1;\n\n    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {\n        if (!obj) {\n            VIR_DEBUG(\"Not running hook as @obj is NULL\");\n            ret = 0;\n            goto cleanup;\n        }\n        def = virNetworkObjGetDef(obj);\n\n        virBufferAddLit(&buf, \"<hookData>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        if (virNetworkDefFormatBuf(&buf, def, network_driver->xmlopt, 0) < 0)\n            goto cleanup;\n        if (port && virNetworkPortDefFormatBuf(&buf, port) < 0)\n            goto cleanup;\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</hookData>\");\n\n        xml = virBufferContentAndReset(&buf);\n        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, def->name,\n                              op, sub_op, NULL, xml, NULL);\n\n        /*\n         * If the script raised an error, pass it to the callee.\n         */\n        if (hookret < 0)\n            goto cleanup;\n\n        networkNetworkObjTaint(obj, VIR_NETWORK_TAINT_HOOK);\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n    VIR_FREE(xml);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkPortPlugType",
            "port->plugtype"
          ],
          "line": 4905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"network '%s' claims the PCI device at \"\n                             \"domain=%d bus=%d slot=%d function=%d \"\n                             \"is already in use by a different network port\")",
            "netdef->name",
            "dev->device.pci.domain",
            "dev->device.pci.bus",
            "dev->device.pci.slot",
            "dev->device.pci.function"
          ],
          "line": 4891
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"network '%s' claims the PCI device at \"\n                             \"domain=%d bus=%d slot=%d function=%d \"\n                             \"is already in use by a different network port\""
          ],
          "line": 4892
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressEqual",
          "args": [
            "&port->plug.hostdevpci.addr",
            "&netdef->forward.ifs[i].device.pci"
          ],
          "line": 4866
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1324-1335",
          "snippet": "bool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkCreateInterfacePool",
          "args": [
            "netdef"
          ],
          "line": 4859
        },
        "resolved": true,
        "details": {
          "function_name": "networkCreateInterfacePool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2760-2863",
          "snippet": "static int\nnetworkCreateInterfacePool(virNetworkDefPtr netdef)\n{\n    size_t numVirtFns = 0;\n    unsigned int maxVirtFns = 0;\n    char **vfNames = NULL;\n    virPCIDeviceAddressPtr *virtFns;\n\n    int ret = -1;\n    size_t i;\n\n    if (netdef->forward.npfs == 0 || netdef->forward.nifs > 0)\n       return 0;\n\n    if ((virNetDevGetVirtualFunctions(netdef->forward.pfs->dev, &vfNames,\n                                      &virtFns, &numVirtFns, &maxVirtFns)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get Virtual functions on %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(netdef->forward.ifs, numVirtFns) < 0)\n        goto cleanup;\n\n    for (i = 0; i < numVirtFns; i++) {\n        virPCIDeviceAddressPtr thisVirtFn = virtFns[i];\n        const char *thisName = vfNames[i];\n        virNetworkForwardIfDefPtr thisIf\n            = &netdef->forward.ifs[netdef->forward.nifs];\n\n        switch ((virNetworkForwardType) netdef->forward.type) {\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n            if (thisName) {\n                thisIf->device.dev = g_strdup(thisName);\n                thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n                netdef->forward.nifs++;\n            } else {\n                VIR_WARN(\"VF %zu of SRIOV PF %s couldn't be added to the \"\n                         \"interface pool because it isn't bound \"\n                         \"to a network driver - possibly in use elsewhere\",\n                         i, netdef->forward.pfs->dev);\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            /* VF's are always PCI devices */\n            thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI;\n            thisIf->device.pci.domain = thisVirtFn->domain;\n            thisIf->device.pci.bus = thisVirtFn->bus;\n            thisIf->device.pci.slot = thisVirtFn->slot;\n            thisIf->device.pci.function = thisVirtFn->function;\n            netdef->forward.nifs++;\n            break;\n\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n        case VIR_NETWORK_FORWARD_OPEN:\n            /* by definition these will never be encountered here */\n            break;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, netdef->forward.type);\n            goto cleanup;\n        }\n    }\n\n    if (netdef->forward.nifs == 0) {\n        /* If we don't get at least one interface in the pool, declare\n         * failure\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No usable Vf's present on SRIOV PF %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        /* free all the entries made before error */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n                VIR_FREE(netdef->forward.ifs[i].device.dev);\n        }\n        netdef->forward.nifs = 0;\n    }\n    if (netdef->forward.nifs == 0)\n        VIR_FREE(netdef->forward.ifs);\n\n    for (i = 0; i < numVirtFns; i++) {\n        VIR_FREE(vfNames[i]);\n        VIR_FREE(virtFns[i]);\n    }\n    VIR_FREE(vfNames);\n    VIR_FREE(virtFns);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkCreateInterfacePool(virNetworkDefPtr netdef)\n{\n    size_t numVirtFns = 0;\n    unsigned int maxVirtFns = 0;\n    char **vfNames = NULL;\n    virPCIDeviceAddressPtr *virtFns;\n\n    int ret = -1;\n    size_t i;\n\n    if (netdef->forward.npfs == 0 || netdef->forward.nifs > 0)\n       return 0;\n\n    if ((virNetDevGetVirtualFunctions(netdef->forward.pfs->dev, &vfNames,\n                                      &virtFns, &numVirtFns, &maxVirtFns)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get Virtual functions on %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(netdef->forward.ifs, numVirtFns) < 0)\n        goto cleanup;\n\n    for (i = 0; i < numVirtFns; i++) {\n        virPCIDeviceAddressPtr thisVirtFn = virtFns[i];\n        const char *thisName = vfNames[i];\n        virNetworkForwardIfDefPtr thisIf\n            = &netdef->forward.ifs[netdef->forward.nifs];\n\n        switch ((virNetworkForwardType) netdef->forward.type) {\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n            if (thisName) {\n                thisIf->device.dev = g_strdup(thisName);\n                thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n                netdef->forward.nifs++;\n            } else {\n                VIR_WARN(\"VF %zu of SRIOV PF %s couldn't be added to the \"\n                         \"interface pool because it isn't bound \"\n                         \"to a network driver - possibly in use elsewhere\",\n                         i, netdef->forward.pfs->dev);\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            /* VF's are always PCI devices */\n            thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI;\n            thisIf->device.pci.domain = thisVirtFn->domain;\n            thisIf->device.pci.bus = thisVirtFn->bus;\n            thisIf->device.pci.slot = thisVirtFn->slot;\n            thisIf->device.pci.function = thisVirtFn->function;\n            netdef->forward.nifs++;\n            break;\n\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n        case VIR_NETWORK_FORWARD_OPEN:\n            /* by definition these will never be encountered here */\n            break;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, netdef->forward.type);\n            goto cleanup;\n        }\n    }\n\n    if (netdef->forward.nifs == 0) {\n        /* If we don't get at least one interface in the pool, declare\n         * failure\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No usable Vf's present on SRIOV PF %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        /* free all the entries made before error */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n                VIR_FREE(netdef->forward.ifs[i].device.dev);\n        }\n        netdef->forward.nifs = 0;\n    }\n    if (netdef->forward.nifs == 0)\n        VIR_FREE(netdef->forward.ifs);\n\n    for (i = 0; i < numVirtFns; i++) {\n        VIR_FREE(vfNames[i]);\n        VIR_FREE(virtFns[i]);\n    }\n    VIR_FREE(vfNames);\n    VIR_FREE(virtFns);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"network '%s' claims dev='%s' is already in \"\n                             \"use by a different port\")",
            "netdef->name",
            "port->plug.direct.linkdev"
          ],
          "line": 4849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"network '%s' doesn't have dev='%s' \"\n                             \"in use by network port '%s'\")",
            "netdef->name",
            "port->plug.direct.linkdev",
            "port->uuid"
          ],
          "line": 4832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "port->plug.direct.linkdev",
            "netdef->forward.ifs[i].device.dev"
          ],
          "line": 4824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unexpectedly got a network port without a network bridge\")"
          ],
          "line": 4810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unexpectedly got a network port without a plug\")"
          ],
          "line": 4802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"network '%s' is not active\")",
            "netdef->name"
          ],
          "line": 4794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 4793
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 4791
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port)\n{\n    virNetworkDefPtr netdef;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n\n    netdef = virNetworkObjGetDef(obj);\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       netdef->name);\n        return -1;\n    }\n\n    switch (port->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpectedly got a network port without a plug\"));\n        return -1;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        /* see if we're connected to the correct bridge */\n        if (!netdef->bridge) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unexpectedly got a network port without a network bridge\"));\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* find the matching interface and increment its connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n                STREQ(port->plug.direct.linkdev,\n                      netdef->forward.ifs[i].device.dev)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        /* dev points at the physical device we want to use */\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have dev='%s' \"\n                             \"in use by network port '%s'\"),\n                           netdef->name, port->plug.direct.linkdev,\n                           port->uuid);\n            return -1;\n        }\n\n        /* PASSTHROUGH mode and PRIVATE Mode + 802.1Qbh both require\n         * exclusive access to a device, so current connections count\n         * must be 0 in those cases.\n         */\n        if ((dev->connections > 0) &&\n            ((netdef->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH) ||\n             ((netdef->forward.type == VIR_NETWORK_FORWARD_PRIVATE) &&\n              port->virtPortProfile &&\n              (port->virtPortProfile->virtPortType == VIR_NETDEV_VPORT_PROFILE_8021QBH)))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' claims dev='%s' is already in \"\n                             \"use by a different port\"),\n                           netdef->name, port->plug.direct.linkdev);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* find the matching interface and increment its connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI &&\n                virPCIDeviceAddressEqual(&port->plug.hostdevpci.addr,\n                                         &netdef->forward.ifs[i].device.pci)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        /* dev points at the physical device we want to use */\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have \"\n                             \"PCI device %04x:%02x:%02x.%x in use by network port\"),\n                           netdef->name,\n                           port->plug.hostdevpci.addr.domain,\n                           port->plug.hostdevpci.addr.bus,\n                           port->plug.hostdevpci.addr.slot,\n                           port->plug.hostdevpci.addr.function);\n            return -1;\n        }\n\n        /* PASSTHROUGH mode, PRIVATE Mode + 802.1Qbh, and hostdev (PCI\n         * passthrough) all require exclusive access to a device, so\n         * current connections count must be 0 in those cases.\n         */\n        if ((dev->connections > 0) &&\n            netdef->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' claims the PCI device at \"\n                             \"domain=%d bus=%d slot=%d function=%d \"\n                             \"is already in use by a different network port\"),\n                           netdef->name,\n                           dev->device.pci.domain, dev->device.pci.bus,\n                           dev->device.pci.slot, dev->device.pci.function);\n            return -1;\n        }\n\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, port->plugtype);\n        return -1;\n    }\n\n    netdef->connections++;\n    if (dev)\n        dev->connections++;\n    /* finally we can call the 'plugged' hook script if any */\n    if (networkRunHook(obj, port, VIR_HOOK_NETWORK_OP_PORT_CREATED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0) {\n        /* adjust for failure */\n        if (dev)\n            dev->connections--;\n        netdef->connections--;\n        return -1;\n    }\n    networkLogAllocation(netdef, dev, &port->mac, true);\n\n    return 0;\n}"
  },
  {
    "function_name": "networkAllocatePort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "4485-4771",
    "snippet": "static int\nnetworkAllocatePort(virNetworkObjPtr obj,\n                    virNetworkPortDefPtr port)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr netdef = NULL;\n    virPortGroupDefPtr portgroup = NULL;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n    virNetDevVPortProfilePtr portprofile = NULL;\n\n    netdef = virNetworkObjGetDef(obj);\n    VIR_DEBUG(\"Allocating port from net %s\", netdef->name);\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       netdef->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Interface port group %s\", port->group);\n    /* portgroup can be present for any type of network, in particular\n     * for bandwidth information, so we need to check for that and\n     * fill it in appropriately for all forward types.\n     */\n    portgroup = virPortGroupFindByName(netdef, port->group);\n\n    if (!port->bandwidth) {\n        if (portgroup && portgroup->bandwidth &&\n            virNetDevBandwidthCopy(&port->bandwidth,\n                                   portgroup->bandwidth) < 0)\n            return -1;\n    }\n\n    if (port->vlan.nTags == 0) {\n        virNetDevVlanPtr vlan = NULL;\n        if (portgroup && portgroup->vlan.nTags > 0)\n            vlan = &portgroup->vlan;\n        else if (netdef->vlan.nTags > 0)\n            vlan = &netdef->vlan;\n\n        if (vlan && virNetDevVlanCopy(&port->vlan, vlan) < 0)\n            return -1;\n    }\n\n    if (!port->trustGuestRxFilters) {\n        if (portgroup && portgroup->trustGuestRxFilters)\n            port->trustGuestRxFilters = portgroup->trustGuestRxFilters;\n        else if (netdef->trustGuestRxFilters)\n            port->trustGuestRxFilters = netdef->trustGuestRxFilters;\n    }\n\n    if (port->isolatedPort == VIR_TRISTATE_BOOL_ABSENT)\n        port->isolatedPort = netdef->isolatedPort;\n\n    /* merge virtualports from interface, network, and portgroup to\n     * arrive at actual virtualport to use\n     */\n    if (virNetDevVPortProfileMerge3(&portprofile,\n                                    port->virtPortProfile,\n                                    netdef->virtPortProfile,\n                                    portgroup\n                                    ? portgroup->virtPortProfile : NULL) < 0) {\n                return -1;\n    }\n    if (portprofile) {\n        VIR_FREE(port->virtPortProfile);\n        port->virtPortProfile = portprofile;\n    }\n\n    VIR_DEBUG(\"Processing forward type %d\", netdef->forward.type);\n    switch ((virNetworkForwardType) netdef->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* for these forward types, the actual net type really *is*\n         * NETWORK; we just keep the info from the portgroup in\n         * iface->data.network.actual\n         */\n        port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_NETWORK;\n\n        port->plug.bridge.brname = g_strdup(netdef->bridge);\n        port->plug.bridge.macTableManager = netdef->macTableManager;\n\n        if (port->virtPortProfile) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"<virtualport type='%s'> not supported for network \"\n                             \"'%s' which uses IP forwarding\"),\n                           virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                           netdef->name);\n            return -1;\n        }\n\n        break;\n\n    case VIR_NETWORK_FORWARD_HOSTDEV: {\n        port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI;\n\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* pick first dev with 0 connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].connections == 0) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' requires exclusive access \"\n                             \"to interfaces, but none are available\"),\n                           netdef->name);\n            return -1;\n        }\n        port->plug.hostdevpci.addr = dev->device.pci;\n        port->plug.hostdevpci.driver = netdef->forward.driverName;\n        port->plug.hostdevpci.managed = netdef->forward.managed;\n\n        if (port->virtPortProfile) {\n            /* make sure type is supported for hostdev connections */\n            if (port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBG &&\n                port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBH) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"<virtualport type='%s'> not supported for network \"\n                                 \"'%s' which uses an SR-IOV Virtual Function \"\n                                 \"via PCI passthrough\"),\n                               virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                               netdef->name);\n                return -1;\n            }\n        }\n        break;\n    }\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (netdef->bridge) {\n            /* <forward type='bridge'/> <bridge name='xxx'/>\n             * is VIR_DOMAIN_NET_TYPE_BRIDGE\n             */\n\n            port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE;\n            port->plug.bridge.brname = g_strdup(netdef->bridge);\n            port->plug.bridge.macTableManager = netdef->macTableManager;\n\n            if (port->virtPortProfile) {\n                /* only type='openvswitch' is allowed for bridges */\n                if (port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"<virtualport type='%s'> not supported for network \"\n                                     \"'%s' which uses a bridge device\"),\n                                   virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                                   netdef->name);\n                    return -1;\n                }\n            }\n\n            break;\n        }\n\n        /* intentionally fall through to the direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        /* <forward type='bridge|private|vepa|passthrough'> are all\n         * VIR_DOMAIN_NET_TYPE_DIRECT.\n         */\n\n        /* Set type=direct and appropriate <source mode='xxx'/> */\n        port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_DIRECT;\n\n        /* NO need to check the value returned from virNetDevMacVLanModeTypeFromString\n         * it must be valid for these forward type(bridge|private|vepa|passthrough)\n         */\n        port->plug.direct.mode =\n            virNetDevMacVLanModeTypeFromString(virNetworkForwardTypeToString(netdef->forward.type));\n\n        if (port->virtPortProfile) {\n            /* make sure type is supported for macvtap connections */\n            if (port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBG &&\n                port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBH) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"<virtualport type='%s'> not supported for network \"\n                                 \"'%s' which uses a macvtap device\"),\n                               virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                               netdef->name);\n                return -1;\n            }\n        }\n\n        /* If there is only a single device, just return it (caller will detect\n         * any error if exclusive use is required but could not be acquired).\n         */\n        if ((netdef->forward.nifs <= 0) && (netdef->forward.npfs <= 0)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a direct mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        } else {\n            /* pick an interface from the pool */\n\n            if (networkCreateInterfacePool(netdef) < 0)\n                return -1;\n\n            /* PASSTHROUGH mode, and PRIVATE Mode + 802.1Qbh both\n             * require exclusive access to a device, so current\n             * connections count must be 0.  Other modes can share, so\n             * just search for the one with the lowest number of\n             * connections.\n             */\n            if ((netdef->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH) ||\n                ((netdef->forward.type == VIR_NETWORK_FORWARD_PRIVATE) &&\n                 port->virtPortProfile &&\n                 (port->virtPortProfile->virtPortType\n                  == VIR_NETDEV_VPORT_PROFILE_8021QBH))) {\n\n                /* pick first dev with 0 connections */\n                for (i = 0; i < netdef->forward.nifs; i++) {\n                    if (netdef->forward.ifs[i].connections == 0) {\n                        dev = &netdef->forward.ifs[i];\n                        break;\n                    }\n                }\n            } else {\n                /* pick least used dev */\n                dev = &netdef->forward.ifs[0];\n                for (i = 1; i < netdef->forward.nifs; i++) {\n                    if (netdef->forward.ifs[i].connections < dev->connections)\n                        dev = &netdef->forward.ifs[i];\n                }\n            }\n            /* dev points at the physical device we want to use */\n            if (!dev) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"network '%s' requires exclusive access \"\n                                 \"to interfaces, but none are available\"),\n                               netdef->name);\n                return -1;\n            }\n            port->plug.direct.linkdev = g_strdup(dev->device.dev);\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, netdef->forward.type);\n        return -1;\n    }\n\n\n    if (networkPlugBandwidth(obj, &port->mac, port->bandwidth,\n                             &port->class_id) < 0)\n        return -1;\n\n    if (virNetworkObjMacMgrAdd(obj, driver->dnsmasqStateDir,\n                               port->ownername, &port->mac) < 0)\n        return -1;\n\n    if (virNetDevVPortProfileCheckComplete(port->virtPortProfile, true) < 0)\n        return -1;\n\n    netdef->connections++;\n    if (dev)\n        dev->connections++;\n    /* finally we can call the 'plugged' hook script if any */\n    if (networkRunHook(obj, port,\n                       VIR_HOOK_NETWORK_OP_PORT_CREATED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0) {\n        /* adjust for failure */\n        netdef->connections--;\n        if (dev)\n            dev->connections--;\n        return -1;\n    }\n    networkLogAllocation(netdef, dev, &port->mac, true);\n\n    VIR_DEBUG(\"Port allocated\");\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);",
      "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
      "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);",
      "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Port allocated\""
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkLogAllocation",
          "args": [
            "netdef",
            "dev",
            "&port->mac",
            "true"
          ],
          "line": 4766
        },
        "resolved": true,
        "details": {
          "function_name": "networkLogAllocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "4436-4464",
          "snippet": "static void\nnetworkLogAllocation(virNetworkDefPtr netdef,\n                     virNetworkForwardIfDefPtr dev,\n                     virMacAddrPtr mac,\n                     bool inUse)\n{\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    const char *verb = inUse ? \"using\" : \"releasing\";\n\n    virMacAddrFormat(mac, macStr);\n    if (!dev) {\n        VIR_INFO(\"MAC %s %s network %s (%d connections)\",\n                 macStr, verb, netdef->name, netdef->connections);\n    } else {\n        if (dev->type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI) {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %04x:%02x:%02x.%x (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.pci.domain, dev->device.pci.bus,\n                     dev->device.pci.slot, dev->device.pci.function,\n                     dev->connections);\n        } else {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %s (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.dev, dev->connections);\n        }\n    }\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkLogAllocation(virNetworkDefPtr netdef,\n                     virNetworkForwardIfDefPtr dev,\n                     virMacAddrPtr mac,\n                     bool inUse)\n{\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    const char *verb = inUse ? \"using\" : \"releasing\";\n\n    virMacAddrFormat(mac, macStr);\n    if (!dev) {\n        VIR_INFO(\"MAC %s %s network %s (%d connections)\",\n                 macStr, verb, netdef->name, netdef->connections);\n    } else {\n        if (dev->type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI) {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %04x:%02x:%02x.%x (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.pci.domain, dev->device.pci.bus,\n                     dev->device.pci.slot, dev->device.pci.function,\n                     dev->connections);\n        } else {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %s (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.dev, dev->connections);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRunHook",
          "args": [
            "obj",
            "port",
            "VIR_HOOK_NETWORK_OP_PORT_CREATED",
            "VIR_HOOK_SUBOP_BEGIN"
          ],
          "line": 4757
        },
        "resolved": true,
        "details": {
          "function_name": "networkRunHook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "316-364",
          "snippet": "static int\nnetworkRunHook(virNetworkObjPtr obj,\n               virNetworkPortDefPtr port,\n               int op,\n               int sub_op)\n{\n    virNetworkDefPtr def;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xml = NULL;\n    int hookret;\n    int ret = -1;\n\n    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {\n        if (!obj) {\n            VIR_DEBUG(\"Not running hook as @obj is NULL\");\n            ret = 0;\n            goto cleanup;\n        }\n        def = virNetworkObjGetDef(obj);\n\n        virBufferAddLit(&buf, \"<hookData>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        if (virNetworkDefFormatBuf(&buf, def, network_driver->xmlopt, 0) < 0)\n            goto cleanup;\n        if (port && virNetworkPortDefFormatBuf(&buf, port) < 0)\n            goto cleanup;\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</hookData>\");\n\n        xml = virBufferContentAndReset(&buf);\n        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, def->name,\n                              op, sub_op, NULL, xml, NULL);\n\n        /*\n         * If the script raised an error, pass it to the callee.\n         */\n        if (hookret < 0)\n            goto cleanup;\n\n        networkNetworkObjTaint(obj, VIR_NETWORK_TAINT_HOOK);\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n    VIR_FREE(xml);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkRunHook(virNetworkObjPtr obj,\n               virNetworkPortDefPtr port,\n               int op,\n               int sub_op)\n{\n    virNetworkDefPtr def;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xml = NULL;\n    int hookret;\n    int ret = -1;\n\n    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {\n        if (!obj) {\n            VIR_DEBUG(\"Not running hook as @obj is NULL\");\n            ret = 0;\n            goto cleanup;\n        }\n        def = virNetworkObjGetDef(obj);\n\n        virBufferAddLit(&buf, \"<hookData>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        if (virNetworkDefFormatBuf(&buf, def, network_driver->xmlopt, 0) < 0)\n            goto cleanup;\n        if (port && virNetworkPortDefFormatBuf(&buf, port) < 0)\n            goto cleanup;\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</hookData>\");\n\n        xml = virBufferContentAndReset(&buf);\n        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, def->name,\n                              op, sub_op, NULL, xml, NULL);\n\n        /*\n         * If the script raised an error, pass it to the callee.\n         */\n        if (hookret < 0)\n            goto cleanup;\n\n        networkNetworkObjTaint(obj, VIR_NETWORK_TAINT_HOOK);\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n    VIR_FREE(xml);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileCheckComplete",
          "args": [
            "port->virtPortProfile",
            "true"
          ],
          "line": 4750
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileCheckComplete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "152-218",
          "snippet": "int\nvirNetDevVPortProfileCheckComplete(virNetDevVPortProfilePtr virtport,\n                                   bool generateMissing)\n{\n    const char *missing = NULL;\n\n    if (!virtport || virtport->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)\n        return 0;\n\n    switch (virtport->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        if (!virtport->managerID_specified) {\n            missing = \"managerid\";\n        } else if (!virtport->typeID_specified) {\n            missing = \"typeid\";\n        } else if (!virtport->typeIDVersion_specified) {\n            missing = \"typeidversion\";\n        } else if (!virtport->instanceID_specified) {\n            if (generateMissing) {\n                if (virUUIDGenerate(virtport->instanceID) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"cannot generate a random uuid for instanceid\"));\n                    return -1;\n                }\n                virtport->instanceID_specified = true;\n            } else {\n                missing = \"instanceid\";\n            }\n        }\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (!virtport->profileID[0])\n            missing = \"profileid\";\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n        /* profileid is optional for openvswitch */\n        if (!virtport->interfaceID_specified) {\n            if (generateMissing) {\n                if (virUUIDGenerate(virtport->interfaceID) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"cannot generate a random uuid for interfaceid\"));\n                    return -1;\n                }\n                virtport->interfaceID_specified = true;\n            } else {\n                missing = \"interfaceid\";\n            }\n        }\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_MIDONET:\n       if (!virtport->interfaceID_specified)\n          missing = \"interfaceid\";\n       break;\n    }\n\n    if (missing) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"missing %s in <virtualport type='%s'>\"), missing,\n                       virNetDevVPortTypeToString(virtport->virtPortType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint\nvirNetDevVPortProfileCheckComplete(virNetDevVPortProfilePtr virtport,\n                                   bool generateMissing)\n{\n    const char *missing = NULL;\n\n    if (!virtport || virtport->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)\n        return 0;\n\n    switch (virtport->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        if (!virtport->managerID_specified) {\n            missing = \"managerid\";\n        } else if (!virtport->typeID_specified) {\n            missing = \"typeid\";\n        } else if (!virtport->typeIDVersion_specified) {\n            missing = \"typeidversion\";\n        } else if (!virtport->instanceID_specified) {\n            if (generateMissing) {\n                if (virUUIDGenerate(virtport->instanceID) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"cannot generate a random uuid for instanceid\"));\n                    return -1;\n                }\n                virtport->instanceID_specified = true;\n            } else {\n                missing = \"instanceid\";\n            }\n        }\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (!virtport->profileID[0])\n            missing = \"profileid\";\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n        /* profileid is optional for openvswitch */\n        if (!virtport->interfaceID_specified) {\n            if (generateMissing) {\n                if (virUUIDGenerate(virtport->interfaceID) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"cannot generate a random uuid for interfaceid\"));\n                    return -1;\n                }\n                virtport->interfaceID_specified = true;\n            } else {\n                missing = \"interfaceid\";\n            }\n        }\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_MIDONET:\n       if (!virtport->interfaceID_specified)\n          missing = \"interfaceid\";\n       break;\n    }\n\n    if (missing) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"missing %s in <virtualport type='%s'>\"), missing,\n                       virNetDevVPortTypeToString(virtport->virtPortType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjMacMgrAdd",
          "args": [
            "obj",
            "driver->dnsmasqStateDir",
            "port->ownername",
            "&port->mac"
          ],
          "line": 4746
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjMacMgrAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "282-310",
          "snippet": "int\nvirNetworkObjMacMgrAdd(virNetworkObjPtr obj,\n                       const char *dnsmasqStateDir,\n                       const char *domain,\n                       const virMacAddr *mac)\n{\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    char *file = NULL;\n    int ret = -1;\n\n    if (!obj->macmap)\n        return 0;\n\n    virMacAddrFormat(mac, macStr);\n\n    if (!(file = virMacMapFileName(dnsmasqStateDir, obj->def->bridge)))\n        goto cleanup;\n\n    if (virMacMapAdd(obj->macmap, domain, macStr) < 0)\n        goto cleanup;\n\n    if (virMacMapWriteFile(obj->macmap, file) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(file);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nint\nvirNetworkObjMacMgrAdd(virNetworkObjPtr obj,\n                       const char *dnsmasqStateDir,\n                       const char *domain,\n                       const virMacAddr *mac)\n{\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    char *file = NULL;\n    int ret = -1;\n\n    if (!obj->macmap)\n        return 0;\n\n    virMacAddrFormat(mac, macStr);\n\n    if (!(file = virMacMapFileName(dnsmasqStateDir, obj->def->bridge)))\n        goto cleanup;\n\n    if (virMacMapAdd(obj->macmap, domain, macStr) < 0)\n        goto cleanup;\n\n    if (virMacMapWriteFile(obj->macmap, file) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(file);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkPlugBandwidth",
          "args": [
            "obj",
            "&port->mac",
            "port->bandwidth",
            "&port->class_id"
          ],
          "line": 4742
        },
        "resolved": true,
        "details": {
          "function_name": "networkPlugBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "5228-5254",
          "snippet": "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id)\n{\n    int plug_ret;\n    unsigned long long new_rate = 0;\n    char ifmac[VIR_MAC_STRING_BUFLEN];\n\n    if ((plug_ret = networkCheckBandwidth(obj, ifaceBand, NULL,\n                                          mac, &new_rate)) < 0) {\n        /* helper reported error */\n        return -1;\n    }\n\n    if (plug_ret > 0)\n        /* no QoS needs to be set; claim success */\n        return 0;\n\n    virMacAddrFormat(mac, ifmac);\n\n    if (networkPlugBandwidthImpl(obj, mac, ifaceBand, class_id, new_rate) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);",
            "static int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\n\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id)\n{\n    int plug_ret;\n    unsigned long long new_rate = 0;\n    char ifmac[VIR_MAC_STRING_BUFLEN];\n\n    if ((plug_ret = networkCheckBandwidth(obj, ifaceBand, NULL,\n                                          mac, &new_rate)) < 0) {\n        /* helper reported error */\n        return -1;\n    }\n\n    if (plug_ret > 0)\n        /* no QoS needs to be set; claim success */\n        return 0;\n\n    virMacAddrFormat(mac, ifmac);\n\n    if (networkPlugBandwidthImpl(obj, mac, ifaceBand, class_id, new_rate) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkForwardType",
            "netdef->forward.type"
          ],
          "line": 4737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dev->device.dev"
          ],
          "line": 4731
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"network '%s' requires exclusive access \"\n                                 \"to interfaces, but none are available\")",
            "netdef->name"
          ],
          "line": 4725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkCreateInterfacePool",
          "args": [
            "netdef"
          ],
          "line": 4693
        },
        "resolved": true,
        "details": {
          "function_name": "networkCreateInterfacePool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2760-2863",
          "snippet": "static int\nnetworkCreateInterfacePool(virNetworkDefPtr netdef)\n{\n    size_t numVirtFns = 0;\n    unsigned int maxVirtFns = 0;\n    char **vfNames = NULL;\n    virPCIDeviceAddressPtr *virtFns;\n\n    int ret = -1;\n    size_t i;\n\n    if (netdef->forward.npfs == 0 || netdef->forward.nifs > 0)\n       return 0;\n\n    if ((virNetDevGetVirtualFunctions(netdef->forward.pfs->dev, &vfNames,\n                                      &virtFns, &numVirtFns, &maxVirtFns)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get Virtual functions on %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(netdef->forward.ifs, numVirtFns) < 0)\n        goto cleanup;\n\n    for (i = 0; i < numVirtFns; i++) {\n        virPCIDeviceAddressPtr thisVirtFn = virtFns[i];\n        const char *thisName = vfNames[i];\n        virNetworkForwardIfDefPtr thisIf\n            = &netdef->forward.ifs[netdef->forward.nifs];\n\n        switch ((virNetworkForwardType) netdef->forward.type) {\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n            if (thisName) {\n                thisIf->device.dev = g_strdup(thisName);\n                thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n                netdef->forward.nifs++;\n            } else {\n                VIR_WARN(\"VF %zu of SRIOV PF %s couldn't be added to the \"\n                         \"interface pool because it isn't bound \"\n                         \"to a network driver - possibly in use elsewhere\",\n                         i, netdef->forward.pfs->dev);\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            /* VF's are always PCI devices */\n            thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI;\n            thisIf->device.pci.domain = thisVirtFn->domain;\n            thisIf->device.pci.bus = thisVirtFn->bus;\n            thisIf->device.pci.slot = thisVirtFn->slot;\n            thisIf->device.pci.function = thisVirtFn->function;\n            netdef->forward.nifs++;\n            break;\n\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n        case VIR_NETWORK_FORWARD_OPEN:\n            /* by definition these will never be encountered here */\n            break;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, netdef->forward.type);\n            goto cleanup;\n        }\n    }\n\n    if (netdef->forward.nifs == 0) {\n        /* If we don't get at least one interface in the pool, declare\n         * failure\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No usable Vf's present on SRIOV PF %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        /* free all the entries made before error */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n                VIR_FREE(netdef->forward.ifs[i].device.dev);\n        }\n        netdef->forward.nifs = 0;\n    }\n    if (netdef->forward.nifs == 0)\n        VIR_FREE(netdef->forward.ifs);\n\n    for (i = 0; i < numVirtFns; i++) {\n        VIR_FREE(vfNames[i]);\n        VIR_FREE(virtFns[i]);\n    }\n    VIR_FREE(vfNames);\n    VIR_FREE(virtFns);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkCreateInterfacePool(virNetworkDefPtr netdef)\n{\n    size_t numVirtFns = 0;\n    unsigned int maxVirtFns = 0;\n    char **vfNames = NULL;\n    virPCIDeviceAddressPtr *virtFns;\n\n    int ret = -1;\n    size_t i;\n\n    if (netdef->forward.npfs == 0 || netdef->forward.nifs > 0)\n       return 0;\n\n    if ((virNetDevGetVirtualFunctions(netdef->forward.pfs->dev, &vfNames,\n                                      &virtFns, &numVirtFns, &maxVirtFns)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get Virtual functions on %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(netdef->forward.ifs, numVirtFns) < 0)\n        goto cleanup;\n\n    for (i = 0; i < numVirtFns; i++) {\n        virPCIDeviceAddressPtr thisVirtFn = virtFns[i];\n        const char *thisName = vfNames[i];\n        virNetworkForwardIfDefPtr thisIf\n            = &netdef->forward.ifs[netdef->forward.nifs];\n\n        switch ((virNetworkForwardType) netdef->forward.type) {\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n            if (thisName) {\n                thisIf->device.dev = g_strdup(thisName);\n                thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n                netdef->forward.nifs++;\n            } else {\n                VIR_WARN(\"VF %zu of SRIOV PF %s couldn't be added to the \"\n                         \"interface pool because it isn't bound \"\n                         \"to a network driver - possibly in use elsewhere\",\n                         i, netdef->forward.pfs->dev);\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            /* VF's are always PCI devices */\n            thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI;\n            thisIf->device.pci.domain = thisVirtFn->domain;\n            thisIf->device.pci.bus = thisVirtFn->bus;\n            thisIf->device.pci.slot = thisVirtFn->slot;\n            thisIf->device.pci.function = thisVirtFn->function;\n            netdef->forward.nifs++;\n            break;\n\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n        case VIR_NETWORK_FORWARD_OPEN:\n            /* by definition these will never be encountered here */\n            break;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, netdef->forward.type);\n            goto cleanup;\n        }\n    }\n\n    if (netdef->forward.nifs == 0) {\n        /* If we don't get at least one interface in the pool, declare\n         * failure\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No usable Vf's present on SRIOV PF %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        /* free all the entries made before error */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n                VIR_FREE(netdef->forward.ifs[i].device.dev);\n        }\n        netdef->forward.nifs = 0;\n    }\n    if (netdef->forward.nifs == 0)\n        VIR_FREE(netdef->forward.ifs);\n\n    for (i = 0; i < numVirtFns; i++) {\n        VIR_FREE(vfNames[i]);\n        VIR_FREE(virtFns[i]);\n    }\n    VIR_FREE(vfNames);\n    VIR_FREE(virtFns);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"network '%s' uses a direct mode, but \"\n                             \"has no forward dev and no interface pool\")",
            "netdef->name"
          ],
          "line": 4685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"<virtualport type='%s'> not supported for network \"\n                                 \"'%s' which uses a macvtap device\")",
            "virNetDevVPortTypeToString(port->virtPortProfile->virtPortType)",
            "netdef->name"
          ],
          "line": 4672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeToString",
          "args": [
            "port->virtPortProfile->virtPortType"
          ],
          "line": 4675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevMacVLanModeTypeFromString",
          "args": [
            "virNetworkForwardTypeToString(netdef->forward.type)"
          ],
          "line": 4666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "netdef->forward.type"
          ],
          "line": 4666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"<virtualport type='%s'> not supported for network \"\n                                     \"'%s' which uses a bridge device\")",
            "virNetDevVPortTypeToString(port->virtPortProfile->virtPortType)",
            "netdef->name"
          ],
          "line": 4635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeToString",
          "args": [
            "port->virtPortProfile->virtPortType"
          ],
          "line": 4638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"<virtualport type='%s'> not supported for network \"\n                                 \"'%s' which uses an SR-IOV Virtual Function \"\n                                 \"via PCI passthrough\")",
            "virNetDevVPortTypeToString(port->virtPortProfile->virtPortType)",
            "netdef->name"
          ],
          "line": 4610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeToString",
          "args": [
            "port->virtPortProfile->virtPortType"
          ],
          "line": 4614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"network '%s' requires exclusive access \"\n                             \"to interfaces, but none are available\")",
            "netdef->name"
          ],
          "line": 4596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"<virtualport type='%s'> not supported for network \"\n                             \"'%s' which uses IP forwarding\")",
            "virNetDevVPortTypeToString(port->virtPortProfile->virtPortType)",
            "netdef->name"
          ],
          "line": 4572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeToString",
          "args": [
            "port->virtPortProfile->virtPortType"
          ],
          "line": 4575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Processing forward type %d\"",
            "netdef->forward.type"
          ],
          "line": 4556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "port->virtPortProfile"
          ],
          "line": 4552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileMerge3",
          "args": [
            "&portprofile",
            "port->virtPortProfile",
            "netdef->virtPortProfile",
            "portgroup\n                                    ? portgroup->virtPortProfile : NULL"
          ],
          "line": 4544
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileMerge3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "423-458",
          "snippet": "int virNetDevVPortProfileMerge3(virNetDevVPortProfilePtr *result,\n                                const virNetDevVPortProfile *fromInterface,\n                                const virNetDevVPortProfile *fromNetwork,\n                                const virNetDevVPortProfile *fromPortgroup)\n{\n    int ret = -1;\n    *result = NULL;\n\n    if ((!fromInterface || (fromInterface->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) &&\n        (!fromNetwork   || (fromNetwork->virtPortType   == VIR_NETDEV_VPORT_PROFILE_NONE)) &&\n        (!fromPortgroup || (fromPortgroup->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE))) {\n        return 0;\n    }\n\n    /* at least one of the source profiles is non-empty */\n    if (VIR_ALLOC(*result) < 0)\n        return ret;\n\n    /* start with the interface's profile. There are no pointers in a\n     * virtualPortProfile, so a shallow copy is sufficient.\n     */\n    if (fromInterface)\n        **result = *fromInterface;\n\n    if (virNetDevVPortProfileMerge(*result, fromNetwork) < 0)\n        goto error;\n    if (virNetDevVPortProfileMerge(*result, fromPortgroup) < 0)\n        goto error;\n\n    ret = 0;\n\n error:\n    if (ret < 0)\n        VIR_FREE(*result);\n    return ret;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint virNetDevVPortProfileMerge3(virNetDevVPortProfilePtr *result,\n                                const virNetDevVPortProfile *fromInterface,\n                                const virNetDevVPortProfile *fromNetwork,\n                                const virNetDevVPortProfile *fromPortgroup)\n{\n    int ret = -1;\n    *result = NULL;\n\n    if ((!fromInterface || (fromInterface->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) &&\n        (!fromNetwork   || (fromNetwork->virtPortType   == VIR_NETDEV_VPORT_PROFILE_NONE)) &&\n        (!fromPortgroup || (fromPortgroup->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE))) {\n        return 0;\n    }\n\n    /* at least one of the source profiles is non-empty */\n    if (VIR_ALLOC(*result) < 0)\n        return ret;\n\n    /* start with the interface's profile. There are no pointers in a\n     * virtualPortProfile, so a shallow copy is sufficient.\n     */\n    if (fromInterface)\n        **result = *fromInterface;\n\n    if (virNetDevVPortProfileMerge(*result, fromNetwork) < 0)\n        goto error;\n    if (virNetDevVPortProfileMerge(*result, fromPortgroup) < 0)\n        goto error;\n\n    ret = 0;\n\n error:\n    if (ret < 0)\n        VIR_FREE(*result);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVlanCopy",
          "args": [
            "&port->vlan",
            "vlan"
          ],
          "line": 4527
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVlanCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvlan.c",
          "lines": "80-95",
          "snippet": "int\nvirNetDevVlanCopy(virNetDevVlanPtr dst, const virNetDevVlan *src)\n{\n    if (!src || src->nTags == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(dst->tag, src->nTags) < 0)\n        return -1;\n\n    dst->trunk = src->trunk;\n    dst->nTags = src->nTags;\n    dst->nativeMode = src->nativeMode;\n    dst->nativeTag = src->nativeTag;\n    memcpy(dst->tag, src->tag, src->nTags * sizeof(*src->tag));\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virnetdevvlan.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirNetDevVlanCopy(virNetDevVlanPtr dst, const virNetDevVlan *src)\n{\n    if (!src || src->nTags == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(dst->tag, src->nTags) < 0)\n        return -1;\n\n    dst->trunk = src->trunk;\n    dst->nTags = src->nTags;\n    dst->nativeMode = src->nativeMode;\n    dst->nativeTag = src->nativeTag;\n    memcpy(dst->tag, src->tag, src->nTags * sizeof(*src->tag));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthCopy",
          "args": [
            "&port->bandwidth",
            "portgroup->bandwidth"
          ],
          "line": 4515
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "441-478",
          "snippet": "int\nvirNetDevBandwidthCopy(virNetDevBandwidthPtr *dest,\n                       const virNetDevBandwidth *src)\n{\n    int ret = -1;\n\n    *dest = NULL;\n    if (!src) {\n        /* nothing to be copied */\n        return 0;\n    }\n\n    if (VIR_ALLOC(*dest) < 0)\n        goto cleanup;\n\n    if (src->in) {\n        if (VIR_ALLOC((*dest)->in) < 0)\n            goto cleanup;\n        memcpy((*dest)->in, src->in, sizeof(*src->in));\n    }\n\n    if (src->out) {\n        if (VIR_ALLOC((*dest)->out) < 0) {\n            VIR_FREE((*dest)->in);\n            goto cleanup;\n        }\n        memcpy((*dest)->out, src->out, sizeof(*src->out));\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virNetDevBandwidthFree(*dest);\n        *dest = NULL;\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthCopy(virNetDevBandwidthPtr *dest,\n                       const virNetDevBandwidth *src)\n{\n    int ret = -1;\n\n    *dest = NULL;\n    if (!src) {\n        /* nothing to be copied */\n        return 0;\n    }\n\n    if (VIR_ALLOC(*dest) < 0)\n        goto cleanup;\n\n    if (src->in) {\n        if (VIR_ALLOC((*dest)->in) < 0)\n            goto cleanup;\n        memcpy((*dest)->in, src->in, sizeof(*src->in));\n    }\n\n    if (src->out) {\n        if (VIR_ALLOC((*dest)->out) < 0) {\n            VIR_FREE((*dest)->in);\n            goto cleanup;\n        }\n        memcpy((*dest)->out, src->out, sizeof(*src->out));\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virNetDevBandwidthFree(*dest);\n        *dest = NULL;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPortGroupFindByName",
          "args": [
            "netdef",
            "port->group"
          ],
          "line": 4511
        },
        "resolved": true,
        "details": {
          "function_name": "virPortGroupFindByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2701-2716",
          "snippet": "virPortGroupDefPtr\nvirPortGroupFindByName(virNetworkDefPtr net,\n                       const char *portgroup)\n{\n    size_t i;\n    for (i = 0; i < net->nPortGroups; i++) {\n        if (portgroup) {\n            if (STREQ(portgroup, net->portGroups[i].name))\n                return &net->portGroups[i];\n        } else {\n            if (net->portGroups[i].isDefault)\n                return &net->portGroups[i];\n        }\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirPortGroupDefPtr\nvirPortGroupFindByName(virNetworkDefPtr net,\n                       const char *portgroup)\n{\n    size_t i;\n    for (i = 0; i < net->nPortGroups; i++) {\n        if (portgroup) {\n            if (STREQ(portgroup, net->portGroups[i].name))\n                return &net->portGroups[i];\n        } else {\n            if (net->portGroups[i].isDefault)\n                return &net->portGroups[i];\n        }\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Interface port group %s\"",
            "port->group"
          ],
          "line": 4506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"network '%s' is not active\")",
            "netdef->name"
          ],
          "line": 4500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 4499
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Allocating port from net %s\"",
            "netdef->name"
          ],
          "line": 4497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 4496
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 4489
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\nstatic int\nnetworkPlugBandwidth(virNetworkObjPtr obj,\n                     virMacAddrPtr mac,\n                     virNetDevBandwidthPtr ifaceBand,\n                     unsigned int *class_id);\nstatic int\nnetworkUnplugBandwidth(virNetworkObjPtr obj,\n                       virNetDevBandwidthPtr ifaceBand,\n                       unsigned int *class_id);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkAllocatePort(virNetworkObjPtr obj,\n                    virNetworkPortDefPtr port)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr netdef = NULL;\n    virPortGroupDefPtr portgroup = NULL;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n    virNetDevVPortProfilePtr portprofile = NULL;\n\n    netdef = virNetworkObjGetDef(obj);\n    VIR_DEBUG(\"Allocating port from net %s\", netdef->name);\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       netdef->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Interface port group %s\", port->group);\n    /* portgroup can be present for any type of network, in particular\n     * for bandwidth information, so we need to check for that and\n     * fill it in appropriately for all forward types.\n     */\n    portgroup = virPortGroupFindByName(netdef, port->group);\n\n    if (!port->bandwidth) {\n        if (portgroup && portgroup->bandwidth &&\n            virNetDevBandwidthCopy(&port->bandwidth,\n                                   portgroup->bandwidth) < 0)\n            return -1;\n    }\n\n    if (port->vlan.nTags == 0) {\n        virNetDevVlanPtr vlan = NULL;\n        if (portgroup && portgroup->vlan.nTags > 0)\n            vlan = &portgroup->vlan;\n        else if (netdef->vlan.nTags > 0)\n            vlan = &netdef->vlan;\n\n        if (vlan && virNetDevVlanCopy(&port->vlan, vlan) < 0)\n            return -1;\n    }\n\n    if (!port->trustGuestRxFilters) {\n        if (portgroup && portgroup->trustGuestRxFilters)\n            port->trustGuestRxFilters = portgroup->trustGuestRxFilters;\n        else if (netdef->trustGuestRxFilters)\n            port->trustGuestRxFilters = netdef->trustGuestRxFilters;\n    }\n\n    if (port->isolatedPort == VIR_TRISTATE_BOOL_ABSENT)\n        port->isolatedPort = netdef->isolatedPort;\n\n    /* merge virtualports from interface, network, and portgroup to\n     * arrive at actual virtualport to use\n     */\n    if (virNetDevVPortProfileMerge3(&portprofile,\n                                    port->virtPortProfile,\n                                    netdef->virtPortProfile,\n                                    portgroup\n                                    ? portgroup->virtPortProfile : NULL) < 0) {\n                return -1;\n    }\n    if (portprofile) {\n        VIR_FREE(port->virtPortProfile);\n        port->virtPortProfile = portprofile;\n    }\n\n    VIR_DEBUG(\"Processing forward type %d\", netdef->forward.type);\n    switch ((virNetworkForwardType) netdef->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* for these forward types, the actual net type really *is*\n         * NETWORK; we just keep the info from the portgroup in\n         * iface->data.network.actual\n         */\n        port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_NETWORK;\n\n        port->plug.bridge.brname = g_strdup(netdef->bridge);\n        port->plug.bridge.macTableManager = netdef->macTableManager;\n\n        if (port->virtPortProfile) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"<virtualport type='%s'> not supported for network \"\n                             \"'%s' which uses IP forwarding\"),\n                           virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                           netdef->name);\n            return -1;\n        }\n\n        break;\n\n    case VIR_NETWORK_FORWARD_HOSTDEV: {\n        port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI;\n\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* pick first dev with 0 connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].connections == 0) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' requires exclusive access \"\n                             \"to interfaces, but none are available\"),\n                           netdef->name);\n            return -1;\n        }\n        port->plug.hostdevpci.addr = dev->device.pci;\n        port->plug.hostdevpci.driver = netdef->forward.driverName;\n        port->plug.hostdevpci.managed = netdef->forward.managed;\n\n        if (port->virtPortProfile) {\n            /* make sure type is supported for hostdev connections */\n            if (port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBG &&\n                port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBH) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"<virtualport type='%s'> not supported for network \"\n                                 \"'%s' which uses an SR-IOV Virtual Function \"\n                                 \"via PCI passthrough\"),\n                               virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                               netdef->name);\n                return -1;\n            }\n        }\n        break;\n    }\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (netdef->bridge) {\n            /* <forward type='bridge'/> <bridge name='xxx'/>\n             * is VIR_DOMAIN_NET_TYPE_BRIDGE\n             */\n\n            port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE;\n            port->plug.bridge.brname = g_strdup(netdef->bridge);\n            port->plug.bridge.macTableManager = netdef->macTableManager;\n\n            if (port->virtPortProfile) {\n                /* only type='openvswitch' is allowed for bridges */\n                if (port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"<virtualport type='%s'> not supported for network \"\n                                     \"'%s' which uses a bridge device\"),\n                                   virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                                   netdef->name);\n                    return -1;\n                }\n            }\n\n            break;\n        }\n\n        /* intentionally fall through to the direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        /* <forward type='bridge|private|vepa|passthrough'> are all\n         * VIR_DOMAIN_NET_TYPE_DIRECT.\n         */\n\n        /* Set type=direct and appropriate <source mode='xxx'/> */\n        port->plugtype = VIR_NETWORK_PORT_PLUG_TYPE_DIRECT;\n\n        /* NO need to check the value returned from virNetDevMacVLanModeTypeFromString\n         * it must be valid for these forward type(bridge|private|vepa|passthrough)\n         */\n        port->plug.direct.mode =\n            virNetDevMacVLanModeTypeFromString(virNetworkForwardTypeToString(netdef->forward.type));\n\n        if (port->virtPortProfile) {\n            /* make sure type is supported for macvtap connections */\n            if (port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBG &&\n                port->virtPortProfile->virtPortType != VIR_NETDEV_VPORT_PROFILE_8021QBH) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"<virtualport type='%s'> not supported for network \"\n                                 \"'%s' which uses a macvtap device\"),\n                               virNetDevVPortTypeToString(port->virtPortProfile->virtPortType),\n                               netdef->name);\n                return -1;\n            }\n        }\n\n        /* If there is only a single device, just return it (caller will detect\n         * any error if exclusive use is required but could not be acquired).\n         */\n        if ((netdef->forward.nifs <= 0) && (netdef->forward.npfs <= 0)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' uses a direct mode, but \"\n                             \"has no forward dev and no interface pool\"),\n                           netdef->name);\n            return -1;\n        } else {\n            /* pick an interface from the pool */\n\n            if (networkCreateInterfacePool(netdef) < 0)\n                return -1;\n\n            /* PASSTHROUGH mode, and PRIVATE Mode + 802.1Qbh both\n             * require exclusive access to a device, so current\n             * connections count must be 0.  Other modes can share, so\n             * just search for the one with the lowest number of\n             * connections.\n             */\n            if ((netdef->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH) ||\n                ((netdef->forward.type == VIR_NETWORK_FORWARD_PRIVATE) &&\n                 port->virtPortProfile &&\n                 (port->virtPortProfile->virtPortType\n                  == VIR_NETDEV_VPORT_PROFILE_8021QBH))) {\n\n                /* pick first dev with 0 connections */\n                for (i = 0; i < netdef->forward.nifs; i++) {\n                    if (netdef->forward.ifs[i].connections == 0) {\n                        dev = &netdef->forward.ifs[i];\n                        break;\n                    }\n                }\n            } else {\n                /* pick least used dev */\n                dev = &netdef->forward.ifs[0];\n                for (i = 1; i < netdef->forward.nifs; i++) {\n                    if (netdef->forward.ifs[i].connections < dev->connections)\n                        dev = &netdef->forward.ifs[i];\n                }\n            }\n            /* dev points at the physical device we want to use */\n            if (!dev) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"network '%s' requires exclusive access \"\n                                 \"to interfaces, but none are available\"),\n                               netdef->name);\n                return -1;\n            }\n            port->plug.direct.linkdev = g_strdup(dev->device.dev);\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, netdef->forward.type);\n        return -1;\n    }\n\n\n    if (networkPlugBandwidth(obj, &port->mac, port->bandwidth,\n                             &port->class_id) < 0)\n        return -1;\n\n    if (virNetworkObjMacMgrAdd(obj, driver->dnsmasqStateDir,\n                               port->ownername, &port->mac) < 0)\n        return -1;\n\n    if (virNetDevVPortProfileCheckComplete(port->virtPortProfile, true) < 0)\n        return -1;\n\n    netdef->connections++;\n    if (dev)\n        dev->connections++;\n    /* finally we can call the 'plugged' hook script if any */\n    if (networkRunHook(obj, port,\n                       VIR_HOOK_NETWORK_OP_PORT_CREATED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0) {\n        /* adjust for failure */\n        netdef->connections--;\n        if (dev)\n            dev->connections--;\n        return -1;\n    }\n    networkLogAllocation(netdef, dev, &port->mac, true);\n\n    VIR_DEBUG(\"Port allocated\");\n\n    return 0;\n}"
  },
  {
    "function_name": "networkLogAllocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "4436-4464",
    "snippet": "static void\nnetworkLogAllocation(virNetworkDefPtr netdef,\n                     virNetworkForwardIfDefPtr dev,\n                     virMacAddrPtr mac,\n                     bool inUse)\n{\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    const char *verb = inUse ? \"using\" : \"releasing\";\n\n    virMacAddrFormat(mac, macStr);\n    if (!dev) {\n        VIR_INFO(\"MAC %s %s network %s (%d connections)\",\n                 macStr, verb, netdef->name, netdef->connections);\n    } else {\n        if (dev->type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI) {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %04x:%02x:%02x.%x (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.pci.domain, dev->device.pci.bus,\n                     dev->device.pci.slot, dev->device.pci.function,\n                     dev->connections);\n        } else {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %s (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.dev, dev->connections);\n        }\n    }\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %s (%d connections)\"",
            "macStr",
            "verb",
            "netdef->name",
            "netdef->connections",
            "dev->device.dev",
            "dev->connections"
          ],
          "line": 4458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %04x:%02x:%02x.%x (%d connections)\"",
            "macStr",
            "verb",
            "netdef->name",
            "netdef->connections",
            "dev->device.pci.domain",
            "dev->device.pci.bus",
            "dev->device.pci.slot",
            "dev->device.pci.function",
            "dev->connections"
          ],
          "line": 4451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"MAC %s %s network %s (%d connections)\"",
            "macStr",
            "verb",
            "netdef->name",
            "netdef->connections"
          ],
          "line": 4447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "mac",
            "macStr"
          ],
          "line": 4445
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkLogAllocation(virNetworkDefPtr netdef,\n                     virNetworkForwardIfDefPtr dev,\n                     virMacAddrPtr mac,\n                     bool inUse)\n{\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    const char *verb = inUse ? \"using\" : \"releasing\";\n\n    virMacAddrFormat(mac, macStr);\n    if (!dev) {\n        VIR_INFO(\"MAC %s %s network %s (%d connections)\",\n                 macStr, verb, netdef->name, netdef->connections);\n    } else {\n        if (dev->type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI) {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %04x:%02x:%02x.%x (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.pci.domain, dev->device.pci.bus,\n                     dev->device.pci.slot, dev->device.pci.function,\n                     dev->connections);\n        } else {\n            VIR_INFO(\"MAC %s %s network %s (%d connections) \"\n                     \"physical device %s (%d connections)\",\n                     macStr, verb, netdef->name, netdef->connections,\n                     dev->device.dev, dev->connections);\n        }\n    }\n}"
  },
  {
    "function_name": "networkGetDHCPLeases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "4240-4431",
    "snippet": "static int\nnetworkGetDHCPLeases(virNetworkPtr net,\n                     const char *mac,\n                     virNetworkDHCPLeasePtr **leases,\n                     unsigned int flags)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    size_t i, j;\n    size_t nleases = 0;\n    int rv = -1;\n    size_t size = 0;\n    int custom_lease_file_len = 0;\n    bool need_results = !!leases;\n    long long currtime = 0;\n    long long expirytime_tmp = -1;\n    bool ipv6 = false;\n    char *lease_entries = NULL;\n    char *custom_lease_file = NULL;\n    const char *ip_tmp = NULL;\n    const char *mac_tmp = NULL;\n    virJSONValuePtr lease_tmp = NULL;\n    virJSONValuePtr leases_array = NULL;\n    virNetworkIPDefPtr ipdef_tmp = NULL;\n    virNetworkDHCPLeasePtr lease = NULL;\n    virNetworkDHCPLeasePtr *leases_ret = NULL;\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virMacAddr mac_addr;\n\n    virCheckFlags(0, -1);\n\n    /* only to check if the MAC is valid */\n    if (mac && virMacAddrParse(mac, &mac_addr) < 0) {\n        virReportError(VIR_ERR_INVALID_MAC, \"%s\", mac);\n        return -1;\n    }\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return -1;\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkGetDHCPLeasesEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    /* Retrieve custom leases file location */\n    custom_lease_file = networkDnsmasqLeaseFileNameCustom(driver, def->bridge);\n\n    /* Read entire contents */\n    if ((custom_lease_file_len = virFileReadAllQuiet(custom_lease_file,\n                                                     VIR_NETWORK_DHCP_LEASE_FILE_SIZE_MAX,\n                                                     &lease_entries)) < 0) {\n        /* Not all networks are guaranteed to have leases file.\n         * Only those which run dnsmasq. Therefore, if we failed\n         * to read the leases file, don't report error. Return 0\n         * leases instead. */\n        if (errno == ENOENT) {\n            rv = 0;\n        } else {\n            virReportSystemError(errno,\n                                 _(\"Unable to read leases file: %s\"),\n                                 custom_lease_file);\n        }\n        goto error;\n    }\n\n    if (custom_lease_file_len) {\n        if (!(leases_array = virJSONValueFromString(lease_entries))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"invalid json in file: %s\"), custom_lease_file);\n            goto error;\n        }\n\n        if (!virJSONValueIsArray(leases_array)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed lease_entries array\"));\n            goto error;\n        }\n        size = virJSONValueArraySize(leases_array);\n    }\n\n    currtime = (long long)time(NULL);\n\n    for (i = 0; i < size; i++) {\n        if (!(lease_tmp = virJSONValueArrayGet(leases_array, i))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to parse json\"));\n            goto error;\n        }\n\n        if (!(mac_tmp = virJSONValueObjectGetString(lease_tmp, \"mac-address\"))) {\n            /* leaseshelper program guarantees that lease will be stored only if\n             * mac-address is known otherwise not */\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"found lease without mac-address\"));\n            goto error;\n        }\n\n        if (mac && virMacAddrCompare(mac, mac_tmp))\n            continue;\n\n        if (virJSONValueObjectGetNumberLong(lease_tmp, \"expiry-time\", &expirytime_tmp) < 0) {\n            /* A lease cannot be present without expiry-time */\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"found lease without expiry-time\"));\n            goto error;\n        }\n\n        /* Do not report expired lease */\n        if (expirytime_tmp < currtime)\n            continue;\n\n        if (need_results) {\n            if (VIR_ALLOC(lease) < 0)\n                goto error;\n\n            lease->expirytime = expirytime_tmp;\n\n            if (!(ip_tmp = virJSONValueObjectGetString(lease_tmp, \"ip-address\"))) {\n                /* A lease without ip-address makes no sense */\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"found lease without ip-address\"));\n                goto error;\n            }\n\n            /* Unlike IPv4, IPv6 uses ':' instead of '.' as separator */\n            ipv6 = strchr(ip_tmp, ':') ? true : false;\n            lease->type = ipv6 ? VIR_IP_ADDR_TYPE_IPV6 : VIR_IP_ADDR_TYPE_IPV4;\n\n            /* Obtain prefix */\n            for (j = 0; j < def->nips; j++) {\n                ipdef_tmp = &def->ips[j];\n\n                if (ipv6 && VIR_SOCKET_ADDR_IS_FAMILY(&ipdef_tmp->address,\n                                                      AF_INET6)) {\n                    lease->prefix = ipdef_tmp->prefix;\n                    break;\n                }\n                if (!ipv6 && VIR_SOCKET_ADDR_IS_FAMILY(&ipdef_tmp->address,\n                                                      AF_INET)) {\n                    lease->prefix = virSocketAddrGetIPPrefix(&ipdef_tmp->address,\n                                                             &ipdef_tmp->netmask,\n                                                             ipdef_tmp->prefix);\n                    break;\n                }\n            }\n\n            lease->mac = g_strdup(mac_tmp);\n            lease->ipaddr = g_strdup(ip_tmp);\n            lease->iface = g_strdup(def->bridge);\n\n            /* Fields that can be NULL */\n            lease->iaid = g_strdup(virJSONValueObjectGetString(lease_tmp, \"iaid\"));\n            lease->clientid = g_strdup(virJSONValueObjectGetString(lease_tmp, \"client-id\"));\n            lease->hostname = g_strdup(virJSONValueObjectGetString(lease_tmp, \"hostname\"));\n\n            if (VIR_INSERT_ELEMENT(leases_ret, nleases, nleases, lease) < 0)\n                goto error;\n\n        } else {\n            nleases++;\n        }\n\n        VIR_FREE(lease);\n    }\n\n    if (leases_ret) {\n        /* NULL terminated array */\n        ignore_value(VIR_REALLOC_N(leases_ret, nleases + 1));\n        *leases = leases_ret;\n        leases_ret = NULL;\n    }\n\n    rv = nleases;\n\n cleanup:\n    VIR_FREE(lease);\n    VIR_FREE(lease_entries);\n    VIR_FREE(custom_lease_file);\n    virJSONValueFree(leases_array);\n\n    virNetworkObjEndAPI(&obj);\n\n    return rv;\n\n error:\n    if (leases_ret) {\n        for (i = 0; i < nleases; i++)\n            virNetworkDHCPLeaseFree(leases_ret[i]);\n        VIR_FREE(leases_ret);\n    }\n    goto cleanup;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define VIR_NETWORK_DHCP_LEASE_FILE_SIZE_MAX (32 * 1024 * 1024)"
    ],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "leases_ret"
          ],
          "line": 4428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDHCPLeaseFree",
          "args": [
            "leases_ret[i]"
          ],
          "line": 4427
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDHCPLeaseFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-network.c",
          "lines": "1239-1251",
          "snippet": "void\nvirNetworkDHCPLeaseFree(virNetworkDHCPLeasePtr lease)\n{\n    if (!lease)\n        return;\n    VIR_FREE(lease->iface);\n    VIR_FREE(lease->mac);\n    VIR_FREE(lease->iaid);\n    VIR_FREE(lease->ipaddr);\n    VIR_FREE(lease->hostname);\n    VIR_FREE(lease->clientid);\n    VIR_FREE(lease);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirNetworkDHCPLeaseFree(virNetworkDHCPLeasePtr lease)\n{\n    if (!lease)\n        return;\n    VIR_FREE(lease->iface);\n    VIR_FREE(lease->mac);\n    VIR_FREE(lease->iaid);\n    VIR_FREE(lease->ipaddr);\n    VIR_FREE(lease->hostname);\n    VIR_FREE(lease->clientid);\n    VIR_FREE(lease);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 4420
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "leases_array"
          ],
          "line": 4418
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "custom_lease_file"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "lease_entries"
          ],
          "line": 4416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "lease"
          ],
          "line": 4415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "VIR_REALLOC_N(leases_ret, nleases + 1)"
          ],
          "line": 4407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "leases_ret",
            "nleases + 1"
          ],
          "line": 4407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "lease"
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INSERT_ELEMENT",
          "args": [
            "leases_ret",
            "nleases",
            "nleases",
            "lease"
          ],
          "line": 4395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "virJSONValueObjectGetString(lease_tmp, \"hostname\")"
          ],
          "line": 4393
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "lease_tmp",
            "\"hostname\""
          ],
          "line": 4393
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetIPPrefix",
          "args": [
            "&ipdef_tmp->address",
            "&ipdef_tmp->netmask",
            "ipdef_tmp->prefix"
          ],
          "line": 4379
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetIPPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1152-1198",
          "snippet": "int\nvirSocketAddrGetIPPrefix(const virSocketAddr *address,\n                         const virSocketAddr *netmask,\n                         int prefix)\n{\n    if (prefix > 0) {\n        return prefix;\n    } else if (netmask && VIR_SOCKET_ADDR_VALID(netmask)) {\n        return virSocketAddrGetNumNetmaskBits(netmask);\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET)) {\n        /* Return the natural prefix for the network's ip address.\n         * On Linux we could use the IN_CLASSx() macros, but those\n         * aren't guaranteed on all platforms, so we just deal with\n         * the bits ourselves.\n         */\n        unsigned char octet\n            = ntohl(address->data.inet4.sin_addr.s_addr) >> 24;\n\n        /* If address is 0.0.0.0, we surely want to have 0 prefix for\n         * the default route. */\n        if (address->data.inet4.sin_addr.s_addr == 0)\n            return 0;\n\n        if ((octet & 0x80) == 0) {\n            /* Class A network */\n            return 8;\n        } else if ((octet & 0xC0) == 0x80) {\n            /* Class B network */\n            return 16;\n        } else if ((octet & 0xE0) == 0xC0) {\n            /* Class C network */\n            return 24;\n        }\n        return -1;\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET6)) {\n        if (virSocketAddrIsWildcard(address))\n            return 0;\n        return 64;\n    }\n\n    /* When none of the three (address/netmask/prefix) is given, 0 is\n     * returned rather than error, because this is a valid\n     * expectation, e.g. for the address/prefix used for a default\n     * route (the destination of a default route is 0.0.0.0/0).\n     */\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrGetIPPrefix(const virSocketAddr *address,\n                         const virSocketAddr *netmask,\n                         int prefix)\n{\n    if (prefix > 0) {\n        return prefix;\n    } else if (netmask && VIR_SOCKET_ADDR_VALID(netmask)) {\n        return virSocketAddrGetNumNetmaskBits(netmask);\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET)) {\n        /* Return the natural prefix for the network's ip address.\n         * On Linux we could use the IN_CLASSx() macros, but those\n         * aren't guaranteed on all platforms, so we just deal with\n         * the bits ourselves.\n         */\n        unsigned char octet\n            = ntohl(address->data.inet4.sin_addr.s_addr) >> 24;\n\n        /* If address is 0.0.0.0, we surely want to have 0 prefix for\n         * the default route. */\n        if (address->data.inet4.sin_addr.s_addr == 0)\n            return 0;\n\n        if ((octet & 0x80) == 0) {\n            /* Class A network */\n            return 8;\n        } else if ((octet & 0xC0) == 0x80) {\n            /* Class B network */\n            return 16;\n        } else if ((octet & 0xE0) == 0xC0) {\n            /* Class C network */\n            return 24;\n        }\n        return -1;\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET6)) {\n        if (virSocketAddrIsWildcard(address))\n            return 0;\n        return 64;\n    }\n\n    /* When none of the three (address/netmask/prefix) is given, 0 is\n     * returned rather than error, because this is a valid\n     * expectation, e.g. for the address/prefix used for a default\n     * route (the destination of a default route is 0.0.0.0/0).\n     */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef_tmp->address",
            "AF_INET"
          ],
          "line": 4377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef_tmp->address",
            "AF_INET6"
          ],
          "line": 4372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ip_tmp",
            "':'"
          ],
          "line": 4365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"found lease without ip-address\")"
          ],
          "line": 4359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "lease"
          ],
          "line": 4352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"found lease without expiry-time\")"
          ],
          "line": 4342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetNumberLong",
          "args": [
            "lease_tmp",
            "\"expiry-time\"",
            "&expirytime_tmp"
          ],
          "line": 4340
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetNumberLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1359-1370",
          "snippet": "int\nvirJSONValueObjectGetNumberLong(virJSONValuePtr object,\n                                const char *key,\n                                long long *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberLong(val, value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectGetNumberLong(virJSONValuePtr object,\n                                const char *key,\n                                long long *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberLong(val, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrCompare",
          "args": [
            "mac",
            "mac_tmp"
          ],
          "line": 4337
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrCompare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "34-60",
          "snippet": "int\nvirMacAddrCompare(const char *p, const char *q)\n{\n    unsigned char c, d;\n    do {\n        while (*p == '0' && g_ascii_isxdigit(p[1]))\n            ++p;\n        while (*q == '0' && g_ascii_isxdigit(q[1]))\n            ++q;\n        c = g_ascii_tolower(*p);\n        d = g_ascii_tolower(*q);\n\n        if (c == 0 || d == 0)\n            break;\n\n        ++p;\n        ++q;\n    } while (c == d);\n\n    if (UCHAR_MAX <= INT_MAX)\n        return c - d;\n\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return c > d ? 1 : c < d ? -1 : 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrCompare(const char *p, const char *q)\n{\n    unsigned char c, d;\n    do {\n        while (*p == '0' && g_ascii_isxdigit(p[1]))\n            ++p;\n        while (*q == '0' && g_ascii_isxdigit(q[1]))\n            ++q;\n        c = g_ascii_tolower(*p);\n        d = g_ascii_tolower(*q);\n\n        if (c == 0 || d == 0)\n            break;\n\n        ++p;\n        ++q;\n    } while (c == d);\n\n    if (UCHAR_MAX <= INT_MAX)\n        return c - d;\n\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return c > d ? 1 : c < d ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"found lease without mac-address\")"
          ],
          "line": 4332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to parse json\")"
          ],
          "line": 4324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayGet",
          "args": [
            "leases_array",
            "i"
          ],
          "line": 4323
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1024-1035",
          "snippet": "virJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 4320
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobCleanStorageSourceRuntime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "636-647",
          "snippet": "static void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArraySize",
          "args": [
            "leases_array"
          ],
          "line": 4317
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArraySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1017-1021",
          "snippet": "size_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nsize_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Malformed lease_entries array\")"
          ],
          "line": 4313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueIsArray",
          "args": [
            "leases_array"
          ],
          "line": 4312
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueIsArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1010-1014",
          "snippet": "bool\nvirJSONValueIsArray(virJSONValuePtr array)\n{\n    return array->type == VIR_JSON_TYPE_ARRAY;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nbool\nvirJSONValueIsArray(virJSONValuePtr array)\n{\n    return array->type == VIR_JSON_TYPE_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"invalid json in file: %s\")",
            "custom_lease_file"
          ],
          "line": 4307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueFromString",
          "args": [
            "lease_entries"
          ],
          "line": 4306
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFromString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1993-1999",
          "snippet": "virJSONValuePtr\nvirJSONValueFromString(const char *jsonstring G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"No JSON parser implementation is available\"));\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueFromString(const char *jsonstring G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"No JSON parser implementation is available\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to read leases file: %s\")",
            "custom_lease_file"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadAllQuiet",
          "args": [
            "custom_lease_file",
            "VIR_NETWORK_DHCP_LEASE_FILE_SIZE_MAX",
            "&lease_entries"
          ],
          "line": 4288
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkDnsmasqLeaseFileNameCustom",
          "args": [
            "driver",
            "def->bridge"
          ],
          "line": 4285
        },
        "resolved": true,
        "details": {
          "function_name": "networkDnsmasqLeaseFileNameCustom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "378-386",
          "snippet": "static char *\nnetworkDnsmasqLeaseFileNameCustom(virNetworkDriverStatePtr driver,\n                                  const char *bridge)\n{\n    char *leasefile;\n\n    leasefile = g_strdup_printf(\"%s/%s.status\", driver->dnsmasqStateDir, bridge);\n    return leasefile;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic char *\nnetworkDnsmasqLeaseFileNameCustom(virNetworkDriverStatePtr driver,\n                                  const char *bridge)\n{\n    char *leasefile;\n\n    leasefile = g_strdup_printf(\"%s/%s.status\", driver->dnsmasqStateDir, bridge);\n    return leasefile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkGetDHCPLeasesEnsureACL",
          "args": [
            "net->conn",
            "def"
          ],
          "line": 4281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 4279
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "net"
          ],
          "line": 4277
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_MAC",
            "\"%s\"",
            "mac"
          ],
          "line": 4273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrParse",
          "args": [
            "mac",
            "&mac_addr"
          ],
          "line": 4272
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "205-218",
          "snippet": "int\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 4269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 4246
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_NETWORK_DHCP_LEASE_FILE_SIZE_MAX (32 * 1024 * 1024)\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkGetDHCPLeases(virNetworkPtr net,\n                     const char *mac,\n                     virNetworkDHCPLeasePtr **leases,\n                     unsigned int flags)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    size_t i, j;\n    size_t nleases = 0;\n    int rv = -1;\n    size_t size = 0;\n    int custom_lease_file_len = 0;\n    bool need_results = !!leases;\n    long long currtime = 0;\n    long long expirytime_tmp = -1;\n    bool ipv6 = false;\n    char *lease_entries = NULL;\n    char *custom_lease_file = NULL;\n    const char *ip_tmp = NULL;\n    const char *mac_tmp = NULL;\n    virJSONValuePtr lease_tmp = NULL;\n    virJSONValuePtr leases_array = NULL;\n    virNetworkIPDefPtr ipdef_tmp = NULL;\n    virNetworkDHCPLeasePtr lease = NULL;\n    virNetworkDHCPLeasePtr *leases_ret = NULL;\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virMacAddr mac_addr;\n\n    virCheckFlags(0, -1);\n\n    /* only to check if the MAC is valid */\n    if (mac && virMacAddrParse(mac, &mac_addr) < 0) {\n        virReportError(VIR_ERR_INVALID_MAC, \"%s\", mac);\n        return -1;\n    }\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return -1;\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkGetDHCPLeasesEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    /* Retrieve custom leases file location */\n    custom_lease_file = networkDnsmasqLeaseFileNameCustom(driver, def->bridge);\n\n    /* Read entire contents */\n    if ((custom_lease_file_len = virFileReadAllQuiet(custom_lease_file,\n                                                     VIR_NETWORK_DHCP_LEASE_FILE_SIZE_MAX,\n                                                     &lease_entries)) < 0) {\n        /* Not all networks are guaranteed to have leases file.\n         * Only those which run dnsmasq. Therefore, if we failed\n         * to read the leases file, don't report error. Return 0\n         * leases instead. */\n        if (errno == ENOENT) {\n            rv = 0;\n        } else {\n            virReportSystemError(errno,\n                                 _(\"Unable to read leases file: %s\"),\n                                 custom_lease_file);\n        }\n        goto error;\n    }\n\n    if (custom_lease_file_len) {\n        if (!(leases_array = virJSONValueFromString(lease_entries))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"invalid json in file: %s\"), custom_lease_file);\n            goto error;\n        }\n\n        if (!virJSONValueIsArray(leases_array)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed lease_entries array\"));\n            goto error;\n        }\n        size = virJSONValueArraySize(leases_array);\n    }\n\n    currtime = (long long)time(NULL);\n\n    for (i = 0; i < size; i++) {\n        if (!(lease_tmp = virJSONValueArrayGet(leases_array, i))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to parse json\"));\n            goto error;\n        }\n\n        if (!(mac_tmp = virJSONValueObjectGetString(lease_tmp, \"mac-address\"))) {\n            /* leaseshelper program guarantees that lease will be stored only if\n             * mac-address is known otherwise not */\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"found lease without mac-address\"));\n            goto error;\n        }\n\n        if (mac && virMacAddrCompare(mac, mac_tmp))\n            continue;\n\n        if (virJSONValueObjectGetNumberLong(lease_tmp, \"expiry-time\", &expirytime_tmp) < 0) {\n            /* A lease cannot be present without expiry-time */\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"found lease without expiry-time\"));\n            goto error;\n        }\n\n        /* Do not report expired lease */\n        if (expirytime_tmp < currtime)\n            continue;\n\n        if (need_results) {\n            if (VIR_ALLOC(lease) < 0)\n                goto error;\n\n            lease->expirytime = expirytime_tmp;\n\n            if (!(ip_tmp = virJSONValueObjectGetString(lease_tmp, \"ip-address\"))) {\n                /* A lease without ip-address makes no sense */\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"found lease without ip-address\"));\n                goto error;\n            }\n\n            /* Unlike IPv4, IPv6 uses ':' instead of '.' as separator */\n            ipv6 = strchr(ip_tmp, ':') ? true : false;\n            lease->type = ipv6 ? VIR_IP_ADDR_TYPE_IPV6 : VIR_IP_ADDR_TYPE_IPV4;\n\n            /* Obtain prefix */\n            for (j = 0; j < def->nips; j++) {\n                ipdef_tmp = &def->ips[j];\n\n                if (ipv6 && VIR_SOCKET_ADDR_IS_FAMILY(&ipdef_tmp->address,\n                                                      AF_INET6)) {\n                    lease->prefix = ipdef_tmp->prefix;\n                    break;\n                }\n                if (!ipv6 && VIR_SOCKET_ADDR_IS_FAMILY(&ipdef_tmp->address,\n                                                      AF_INET)) {\n                    lease->prefix = virSocketAddrGetIPPrefix(&ipdef_tmp->address,\n                                                             &ipdef_tmp->netmask,\n                                                             ipdef_tmp->prefix);\n                    break;\n                }\n            }\n\n            lease->mac = g_strdup(mac_tmp);\n            lease->ipaddr = g_strdup(ip_tmp);\n            lease->iface = g_strdup(def->bridge);\n\n            /* Fields that can be NULL */\n            lease->iaid = g_strdup(virJSONValueObjectGetString(lease_tmp, \"iaid\"));\n            lease->clientid = g_strdup(virJSONValueObjectGetString(lease_tmp, \"client-id\"));\n            lease->hostname = g_strdup(virJSONValueObjectGetString(lease_tmp, \"hostname\"));\n\n            if (VIR_INSERT_ELEMENT(leases_ret, nleases, nleases, lease) < 0)\n                goto error;\n\n        } else {\n            nleases++;\n        }\n\n        VIR_FREE(lease);\n    }\n\n    if (leases_ret) {\n        /* NULL terminated array */\n        ignore_value(VIR_REALLOC_N(leases_ret, nleases + 1));\n        *leases = leases_ret;\n        leases_ret = NULL;\n    }\n\n    rv = nleases;\n\n cleanup:\n    VIR_FREE(lease);\n    VIR_FREE(lease_entries);\n    VIR_FREE(custom_lease_file);\n    virJSONValueFree(leases_array);\n\n    virNetworkObjEndAPI(&obj);\n\n    return rv;\n\n error:\n    if (leases_ret) {\n        for (i = 0; i < nleases; i++)\n            virNetworkDHCPLeaseFree(leases_ret[i]);\n        VIR_FREE(leases_ret);\n    }\n    goto cleanup;\n}"
  },
  {
    "function_name": "networkSetAutostart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "4169-4237",
    "snippet": "static int\nnetworkSetAutostart(virNetworkPtr net,\n                    int autostart)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    char *configFile = NULL, *autostartLink = NULL;\n    bool new_autostart;\n    bool cur_autostart;\n    int ret = -1;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        goto cleanup;\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkSetAutostartEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsPersistent(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"cannot set autostart for transient network\"));\n        goto cleanup;\n    }\n\n    new_autostart = (autostart != 0);\n    cur_autostart = virNetworkObjIsAutostart(obj);\n    if (cur_autostart != new_autostart) {\n        if ((configFile = virNetworkConfigFile(driver->networkConfigDir,\n                                               def->name)) == NULL)\n            goto cleanup;\n        if ((autostartLink = virNetworkConfigFile(driver->networkAutostartDir,\n                                                  def->name)) == NULL)\n            goto cleanup;\n\n        if (new_autostart) {\n            if (virFileMakePath(driver->networkAutostartDir) < 0) {\n                virReportSystemError(errno,\n                                     _(\"cannot create autostart directory '%s'\"),\n                                     driver->networkAutostartDir);\n                goto cleanup;\n            }\n\n            if (symlink(configFile, autostartLink) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Failed to create symlink '%s' to '%s'\"),\n                                     autostartLink, configFile);\n                goto cleanup;\n            }\n        } else {\n            if (unlink(autostartLink) < 0 && errno != ENOENT && errno != ENOTDIR) {\n                virReportSystemError(errno,\n                                     _(\"Failed to delete symlink '%s'\"),\n                                     autostartLink);\n                goto cleanup;\n            }\n        }\n\n        virNetworkObjSetAutostart(obj, new_autostart);\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(configFile);\n    VIR_FREE(autostartLink);\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 4235
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "autostartLink"
          ],
          "line": 4234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "configFile"
          ],
          "line": 4233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetAutostart",
          "args": [
            "obj",
            "new_autostart"
          ],
          "line": 4227
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetAutostart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "199-204",
          "snippet": "void\nvirNetworkObjSetAutostart(virNetworkObjPtr obj,\n                          bool autostart)\n{\n    obj->autostart = autostart;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetAutostart(virNetworkObjPtr obj,\n                          bool autostart)\n{\n    obj->autostart = autostart;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to delete symlink '%s'\")",
            "autostartLink"
          ],
          "line": 4220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to delete symlink '%s'\""
          ],
          "line": 4221
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "autostartLink"
          ],
          "line": 4219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to create symlink '%s' to '%s'\")",
            "autostartLink",
            "configFile"
          ],
          "line": 4213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlink",
          "args": [
            "configFile",
            "autostartLink"
          ],
          "line": 4212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot create autostart directory '%s'\")",
            "driver->networkAutostartDir"
          ],
          "line": 4206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "driver->networkAutostartDir"
          ],
          "line": 4205
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkConfigFile",
          "args": [
            "driver->networkAutostartDir",
            "def->name"
          ],
          "line": 4200
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkConfigFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2770-2778",
          "snippet": "char *\nvirNetworkConfigFile(const char *dir,\n                     const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNetworkConfigFile(const char *dir,\n                     const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsAutostart",
          "args": [
            "obj"
          ],
          "line": 4195
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsAutostart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "192-196",
          "snippet": "bool\nvirNetworkObjIsAutostart(virNetworkObjPtr obj)\n{\n    return obj->autostart;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsAutostart(virNetworkObjPtr obj)\n{\n    return obj->autostart;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"cannot set autostart for transient network\")"
          ],
          "line": 4189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsPersistent",
          "args": [
            "obj"
          ],
          "line": 4188
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsPersistent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "185-189",
          "snippet": "bool\nvirNetworkObjIsPersistent(virNetworkObjPtr obj)\n{\n    return obj->persistent;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsPersistent(virNetworkObjPtr obj)\n{\n    return obj->persistent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkSetAutostartEnsureACL",
          "args": [
            "net->conn",
            "def"
          ],
          "line": 4185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 4183
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "net"
          ],
          "line": 4181
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 4173
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkSetAutostart(virNetworkPtr net,\n                    int autostart)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    char *configFile = NULL, *autostartLink = NULL;\n    bool new_autostart;\n    bool cur_autostart;\n    int ret = -1;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        goto cleanup;\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkSetAutostartEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsPersistent(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"cannot set autostart for transient network\"));\n        goto cleanup;\n    }\n\n    new_autostart = (autostart != 0);\n    cur_autostart = virNetworkObjIsAutostart(obj);\n    if (cur_autostart != new_autostart) {\n        if ((configFile = virNetworkConfigFile(driver->networkConfigDir,\n                                               def->name)) == NULL)\n            goto cleanup;\n        if ((autostartLink = virNetworkConfigFile(driver->networkAutostartDir,\n                                                  def->name)) == NULL)\n            goto cleanup;\n\n        if (new_autostart) {\n            if (virFileMakePath(driver->networkAutostartDir) < 0) {\n                virReportSystemError(errno,\n                                     _(\"cannot create autostart directory '%s'\"),\n                                     driver->networkAutostartDir);\n                goto cleanup;\n            }\n\n            if (symlink(configFile, autostartLink) < 0) {\n                virReportSystemError(errno,\n                                     _(\"Failed to create symlink '%s' to '%s'\"),\n                                     autostartLink, configFile);\n                goto cleanup;\n            }\n        } else {\n            if (unlink(autostartLink) < 0 && errno != ENOENT && errno != ENOTDIR) {\n                virReportSystemError(errno,\n                                     _(\"Failed to delete symlink '%s'\"),\n                                     autostartLink);\n                goto cleanup;\n            }\n        }\n\n        virNetworkObjSetAutostart(obj, new_autostart);\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(configFile);\n    VIR_FREE(autostartLink);\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkGetAutostart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "4147-4166",
    "snippet": "static int\nnetworkGetAutostart(virNetworkPtr net,\n                    int *autostart)\n{\n    virNetworkObjPtr obj;\n    int ret = -1;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return ret;\n\n    if (virNetworkGetAutostartEnsureACL(net->conn, virNetworkObjGetDef(obj)) < 0)\n        goto cleanup;\n\n    *autostart = virNetworkObjIsAutostart(obj) ? 1 : 0;\n    ret = 0;\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 4164
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsAutostart",
          "args": [
            "obj"
          ],
          "line": 4160
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsAutostart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "192-196",
          "snippet": "bool\nvirNetworkObjIsAutostart(virNetworkObjPtr obj)\n{\n    return obj->autostart;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsAutostart(virNetworkObjPtr obj)\n{\n    return obj->autostart;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkGetAutostartEnsureACL",
          "args": [
            "net->conn",
            "virNetworkObjGetDef(obj)"
          ],
          "line": 4157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 4157
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "net"
          ],
          "line": 4154
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkGetAutostart(virNetworkPtr net,\n                    int *autostart)\n{\n    virNetworkObjPtr obj;\n    int ret = -1;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return ret;\n\n    if (virNetworkGetAutostartEnsureACL(net->conn, virNetworkObjGetDef(obj)) < 0)\n        goto cleanup;\n\n    *autostart = virNetworkObjIsAutostart(obj) ? 1 : 0;\n    ret = 0;\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkGetBridgeName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "4118-4144",
    "snippet": "static char *\nnetworkGetBridgeName(virNetworkPtr net)\n{\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    char *bridge = NULL;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return bridge;\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkGetBridgeNameEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    if (!(def->bridge)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"network '%s' does not have a bridge name.\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    bridge = g_strdup(def->bridge);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return bridge;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 4142
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "def->bridge"
          ],
          "line": 4139
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"network '%s' does not have a bridge name.\")",
            "def->name"
          ],
          "line": 4133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkGetBridgeNameEnsureACL",
          "args": [
            "net->conn",
            "def"
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 4127
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "net"
          ],
          "line": 4125
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic char *\nnetworkGetBridgeName(virNetworkPtr net)\n{\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    char *bridge = NULL;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return bridge;\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkGetBridgeNameEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    if (!(def->bridge)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"network '%s' does not have a bridge name.\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    bridge = g_strdup(def->bridge);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return bridge;\n}"
  },
  {
    "function_name": "networkGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "4085-4115",
    "snippet": "static char *\nnetworkGetXMLDesc(virNetworkPtr net,\n                  unsigned int flags)\n{\n    virNetworkObjPtr obj;\n    virNetworkDefPtr curDef;\n    virNetworkDefPtr def;\n    virNetworkDefPtr newDef;\n    char *ret = NULL;\n\n    virCheckFlags(VIR_NETWORK_XML_INACTIVE, NULL);\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return ret;\n    def = virNetworkObjGetDef(obj);\n    newDef = virNetworkObjGetNewDef(obj);\n\n    if (virNetworkGetXMLDescEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    if ((flags & VIR_NETWORK_XML_INACTIVE) && newDef)\n        curDef = newDef;\n    else\n        curDef = def;\n\n    ret = virNetworkDefFormat(curDef, network_driver->xmlopt, flags);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverStatePtr network_driver;",
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 4113
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefFormat",
          "args": [
            "curDef",
            "network_driver->xmlopt",
            "flags"
          ],
          "line": 4110
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2673-2688",
          "snippet": "char *\nvirNetworkDefFormat(const virNetworkDef *def,\n                    virNetworkXMLOptionPtr xmlopt,\n                    unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkDefFormatBuf(&buf, def, xmlopt, flags) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNetworkDefFormat(const virNetworkDef *def,\n                    virNetworkXMLOptionPtr xmlopt,\n                    unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkDefFormatBuf(&buf, def, xmlopt, flags) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkGetXMLDescEnsureACL",
          "args": [
            "net->conn",
            "def"
          ],
          "line": 4102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetNewDef",
          "args": [
            "obj"
          ],
          "line": 4100
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetNewDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "163-167",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetNewDef(virNetworkObjPtr obj)\n{\n    return obj->newDef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetNewDef(virNetworkObjPtr obj)\n{\n    return obj->newDef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 4099
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "net"
          ],
          "line": 4097
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_NETWORK_XML_INACTIVE",
            "NULL"
          ],
          "line": 4095
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic char *\nnetworkGetXMLDesc(virNetworkPtr net,\n                  unsigned int flags)\n{\n    virNetworkObjPtr obj;\n    virNetworkDefPtr curDef;\n    virNetworkDefPtr def;\n    virNetworkDefPtr newDef;\n    char *ret = NULL;\n\n    virCheckFlags(VIR_NETWORK_XML_INACTIVE, NULL);\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return ret;\n    def = virNetworkObjGetDef(obj);\n    newDef = virNetworkObjGetNewDef(obj);\n\n    if (virNetworkGetXMLDescEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    if ((flags & VIR_NETWORK_XML_INACTIVE) && newDef)\n        curDef = newDef;\n    else\n        curDef = def;\n\n    ret = virNetworkDefFormat(curDef, network_driver->xmlopt, flags);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkDestroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "4036-4082",
    "snippet": "static int\nnetworkDestroy(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    int ret = -1;\n    virObjectEventPtr event = NULL;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        goto cleanup;\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkDestroyEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if ((ret = networkShutdownNetwork(driver, obj)) < 0)\n        goto cleanup;\n\n    virNetworkObjDeleteAllPorts(obj, driver->stateDir);\n\n    /* @def replaced in virNetworkObjUnsetDefTransient */\n    def = virNetworkObjGetDef(obj);\n\n    event = virNetworkEventLifecycleNew(def->name,\n                                        def->uuid,\n                                        VIR_NETWORK_EVENT_STOPPED,\n                                        0);\n\n    if (!virNetworkObjIsPersistent(obj) &&\n        networkRemoveInactive(driver, obj) < 0) {\n        ret = -1;\n        goto cleanup;\n    }\n\n cleanup:\n    virObjectEventStateQueue(driver->networkEventState, event);\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 4080
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->networkEventState",
            "event"
          ],
          "line": 4079
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRemoveInactive",
          "args": [
            "driver",
            "obj"
          ],
          "line": 4073
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveInactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "423-497",
          "snippet": "static int\nnetworkRemoveInactive(virNetworkDriverStatePtr driver,\n                      virNetworkObjPtr obj)\n{\n    char *leasefile = NULL;\n    char *customleasefile = NULL;\n    char *radvdconfigfile = NULL;\n    char *configfile = NULL;\n    char *radvdpidbase = NULL;\n    char *statusfile = NULL;\n    char *macMapFile = NULL;\n    dnsmasqContext *dctx = NULL;\n    virNetworkDefPtr def = virNetworkObjGetPersistentDef(obj);\n\n    int ret = -1;\n\n    /* remove the (possibly) existing dnsmasq and radvd files */\n    if (!(dctx = dnsmasqContextNew(def->name,\n                                   driver->dnsmasqStateDir))) {\n        goto cleanup;\n    }\n\n    if (!(leasefile = networkDnsmasqLeaseFileNameDefault(driver, def->name)))\n        goto cleanup;\n\n    if (!(customleasefile = networkDnsmasqLeaseFileNameCustom(driver, def->bridge)))\n        goto cleanup;\n\n    if (!(radvdconfigfile = networkRadvdConfigFileName(driver, def->name)))\n        goto cleanup;\n\n    if (!(radvdpidbase = networkRadvdPidfileBasename(def->name)))\n        goto cleanup;\n\n    if (!(configfile = networkDnsmasqConfigFileName(driver, def->name)))\n        goto cleanup;\n\n    if (!(statusfile = virNetworkConfigFile(driver->stateDir, def->name)))\n        goto cleanup;\n\n    if (!(macMapFile = virMacMapFileName(driver->dnsmasqStateDir, def->bridge)))\n        goto cleanup;\n\n    /* dnsmasq */\n    dnsmasqDelete(dctx);\n    unlink(leasefile);\n    unlink(customleasefile);\n    unlink(configfile);\n\n    /* MAC map manager */\n    unlink(macMapFile);\n\n    /* radvd */\n    unlink(radvdconfigfile);\n    virPidFileDelete(driver->pidDir, radvdpidbase);\n\n    /* remove status file */\n    unlink(statusfile);\n\n    /* remove the network definition */\n    virNetworkObjRemoveInactive(driver->networks, obj);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(leasefile);\n    VIR_FREE(configfile);\n    VIR_FREE(customleasefile);\n    VIR_FREE(radvdconfigfile);\n    VIR_FREE(radvdpidbase);\n    VIR_FREE(statusfile);\n    VIR_FREE(macMapFile);\n    dnsmasqContextFree(dctx);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRemoveInactive(virNetworkDriverStatePtr driver,\n                      virNetworkObjPtr obj)\n{\n    char *leasefile = NULL;\n    char *customleasefile = NULL;\n    char *radvdconfigfile = NULL;\n    char *configfile = NULL;\n    char *radvdpidbase = NULL;\n    char *statusfile = NULL;\n    char *macMapFile = NULL;\n    dnsmasqContext *dctx = NULL;\n    virNetworkDefPtr def = virNetworkObjGetPersistentDef(obj);\n\n    int ret = -1;\n\n    /* remove the (possibly) existing dnsmasq and radvd files */\n    if (!(dctx = dnsmasqContextNew(def->name,\n                                   driver->dnsmasqStateDir))) {\n        goto cleanup;\n    }\n\n    if (!(leasefile = networkDnsmasqLeaseFileNameDefault(driver, def->name)))\n        goto cleanup;\n\n    if (!(customleasefile = networkDnsmasqLeaseFileNameCustom(driver, def->bridge)))\n        goto cleanup;\n\n    if (!(radvdconfigfile = networkRadvdConfigFileName(driver, def->name)))\n        goto cleanup;\n\n    if (!(radvdpidbase = networkRadvdPidfileBasename(def->name)))\n        goto cleanup;\n\n    if (!(configfile = networkDnsmasqConfigFileName(driver, def->name)))\n        goto cleanup;\n\n    if (!(statusfile = virNetworkConfigFile(driver->stateDir, def->name)))\n        goto cleanup;\n\n    if (!(macMapFile = virMacMapFileName(driver->dnsmasqStateDir, def->bridge)))\n        goto cleanup;\n\n    /* dnsmasq */\n    dnsmasqDelete(dctx);\n    unlink(leasefile);\n    unlink(customleasefile);\n    unlink(configfile);\n\n    /* MAC map manager */\n    unlink(macMapFile);\n\n    /* radvd */\n    unlink(radvdconfigfile);\n    virPidFileDelete(driver->pidDir, radvdpidbase);\n\n    /* remove status file */\n    unlink(statusfile);\n\n    /* remove the network definition */\n    virNetworkObjRemoveInactive(driver->networks, obj);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(leasefile);\n    VIR_FREE(configfile);\n    VIR_FREE(customleasefile);\n    VIR_FREE(radvdconfigfile);\n    VIR_FREE(radvdpidbase);\n    VIR_FREE(statusfile);\n    VIR_FREE(macMapFile);\n    dnsmasqContextFree(dctx);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsPersistent",
          "args": [
            "obj"
          ],
          "line": 4072
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsPersistent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "185-189",
          "snippet": "bool\nvirNetworkObjIsPersistent(virNetworkObjPtr obj)\n{\n    return obj->persistent;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsPersistent(virNetworkObjPtr obj)\n{\n    return obj->persistent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkEventLifecycleNew",
          "args": [
            "def->name",
            "def->uuid",
            "VIR_NETWORK_EVENT_STOPPED",
            "0"
          ],
          "line": 4067
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkEventLifecycleNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_event.c",
          "lines": "214-237",
          "snippet": "virObjectEventPtr\nvirNetworkEventLifecycleNew(const char *name,\n                            const unsigned char *uuid,\n                            int type,\n                            int detail)\n{\n    virNetworkEventLifecyclePtr event;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (virNetworkEventsInitialize() < 0)\n        return NULL;\n\n    virUUIDFormat(uuid, uuidstr);\n    if (!(event = virObjectEventNew(virNetworkEventLifecycleClass,\n                                    virNetworkEventDispatchDefaultFunc,\n                                    VIR_NETWORK_EVENT_ID_LIFECYCLE,\n                                    0, name, uuid, uuidstr)))\n        return NULL;\n\n    event->type = type;\n    event->detail = detail;\n\n    return (virObjectEventPtr)event;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetworkEventLifecycleClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include <config.h>\n\nstatic virClassPtr virNetworkEventLifecycleClass;\n\nvirObjectEventPtr\nvirNetworkEventLifecycleNew(const char *name,\n                            const unsigned char *uuid,\n                            int type,\n                            int detail)\n{\n    virNetworkEventLifecyclePtr event;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (virNetworkEventsInitialize() < 0)\n        return NULL;\n\n    virUUIDFormat(uuid, uuidstr);\n    if (!(event = virObjectEventNew(virNetworkEventLifecycleClass,\n                                    virNetworkEventDispatchDefaultFunc,\n                                    VIR_NETWORK_EVENT_ID_LIFECYCLE,\n                                    0, name, uuid, uuidstr)))\n        return NULL;\n\n    event->type = type;\n    event->detail = detail;\n\n    return (virObjectEventPtr)event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 4065
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjDeleteAllPorts",
          "args": [
            "obj",
            "driver->stateDir"
          ],
          "line": 4062
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjDeleteAllPorts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1711-1749",
          "snippet": "int\nvirNetworkObjDeleteAllPorts(virNetworkObjPtr net,\n                            const char *stateDir)\n{\n    g_autofree char *dir = NULL;\n    DIR *dh = NULL;\n    struct dirent *de;\n    int rc;\n    int ret = -1;\n\n    if (!(dir = virNetworkObjGetPortStatusDir(net, stateDir)))\n        goto cleanup;\n\n    if ((rc = virDirOpenIfExists(&dh, dir)) <= 0) {\n        ret = rc;\n        goto cleanup;\n    }\n\n    while ((rc = virDirRead(dh, &de, dir)) > 0) {\n        char *file = NULL;\n\n        if (!virStringStripSuffix(de->d_name, \".xml\"))\n            continue;\n\n        file = g_strdup_printf(\"%s/%s.xml\", dir, de->d_name);\n\n        if (unlink(file) < 0 && errno != ENOENT)\n            VIR_WARN(\"Unable to delete %s\", file);\n\n        VIR_FREE(file);\n    }\n\n    virHashRemoveAll(net->ports);\n\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dh);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetworkObjLoadAllPorts(virNetworkObjPtr net,\n                          const char *stateDir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirNetworkObjLoadAllPorts(virNetworkObjPtr net,\n                          const char *stateDir);\n\nint\nvirNetworkObjDeleteAllPorts(virNetworkObjPtr net,\n                            const char *stateDir)\n{\n    g_autofree char *dir = NULL;\n    DIR *dh = NULL;\n    struct dirent *de;\n    int rc;\n    int ret = -1;\n\n    if (!(dir = virNetworkObjGetPortStatusDir(net, stateDir)))\n        goto cleanup;\n\n    if ((rc = virDirOpenIfExists(&dh, dir)) <= 0) {\n        ret = rc;\n        goto cleanup;\n    }\n\n    while ((rc = virDirRead(dh, &de, dir)) > 0) {\n        char *file = NULL;\n\n        if (!virStringStripSuffix(de->d_name, \".xml\"))\n            continue;\n\n        file = g_strdup_printf(\"%s/%s.xml\", dir, de->d_name);\n\n        if (unlink(file) < 0 && errno != ENOENT)\n            VIR_WARN(\"Unable to delete %s\", file);\n\n        VIR_FREE(file);\n    }\n\n    virHashRemoveAll(net->ports);\n\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dh);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkShutdownNetwork",
          "args": [
            "driver",
            "obj"
          ],
          "line": 4059
        },
        "resolved": true,
        "details": {
          "function_name": "networkShutdownNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2989-3049",
          "snippet": "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = 0;\n    char *stateFile;\n\n    VIR_INFO(\"Shutting down network '%s'\", def->name);\n\n    if (!virNetworkObjIsActive(obj))\n        return 0;\n\n    stateFile = virNetworkConfigFile(driver->stateDir, def->name);\n    if (!stateFile)\n        return -1;\n\n    unlink(stateFile);\n    VIR_FREE(stateFile);\n\n    switch ((virNetworkForwardType) def->forward.type) {\n\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        ret = networkShutdownNetworkVirtual(driver, obj);\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            ret = networkShutdownNetworkBridge(obj);\n            break;\n        }\n        /* intentionally fall through to the macvtap/direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         * (since that is macvtap bridge mode).\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        ret = networkShutdownNetworkExternal(obj);\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    /* now that we know it's stopped call the hook if present */\n    networkRunHook(obj, NULL, VIR_HOOK_NETWORK_OP_STOPPED,\n                   VIR_HOOK_SUBOP_END);\n\n    virNetworkObjSetActive(obj, false);\n    virNetworkObjUnsetDefTransient(obj);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = 0;\n    char *stateFile;\n\n    VIR_INFO(\"Shutting down network '%s'\", def->name);\n\n    if (!virNetworkObjIsActive(obj))\n        return 0;\n\n    stateFile = virNetworkConfigFile(driver->stateDir, def->name);\n    if (!stateFile)\n        return -1;\n\n    unlink(stateFile);\n    VIR_FREE(stateFile);\n\n    switch ((virNetworkForwardType) def->forward.type) {\n\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        ret = networkShutdownNetworkVirtual(driver, obj);\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            ret = networkShutdownNetworkBridge(obj);\n            break;\n        }\n        /* intentionally fall through to the macvtap/direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         * (since that is macvtap bridge mode).\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        ret = networkShutdownNetworkExternal(obj);\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    /* now that we know it's stopped call the hook if present */\n    networkRunHook(obj, NULL, VIR_HOOK_NETWORK_OP_STOPPED,\n                   VIR_HOOK_SUBOP_END);\n\n    virNetworkObjSetActive(obj, false);\n    virNetworkObjUnsetDefTransient(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"network '%s' is not active\")",
            "def->name"
          ],
          "line": 4053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"network '%s' is not active\""
          ],
          "line": 4054
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 4052
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDestroyEnsureACL",
          "args": [
            "net->conn",
            "def"
          ],
          "line": 4049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "net"
          ],
          "line": 4045
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 4039
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkDestroy(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    int ret = -1;\n    virObjectEventPtr event = NULL;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        goto cleanup;\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkDestroyEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if ((ret = networkShutdownNetwork(driver, obj)) < 0)\n        goto cleanup;\n\n    virNetworkObjDeleteAllPorts(obj, driver->stateDir);\n\n    /* @def replaced in virNetworkObjUnsetDefTransient */\n    def = virNetworkObjGetDef(obj);\n\n    event = virNetworkEventLifecycleNew(def->name,\n                                        def->uuid,\n                                        VIR_NETWORK_EVENT_STOPPED,\n                                        0);\n\n    if (!virNetworkObjIsPersistent(obj) &&\n        networkRemoveInactive(driver, obj) < 0) {\n        ret = -1;\n        goto cleanup;\n    }\n\n cleanup:\n    virObjectEventStateQueue(driver->networkEventState, event);\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "4005-4033",
    "snippet": "static int\nnetworkCreate(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    int ret = -1;\n    virObjectEventPtr event = NULL;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        goto cleanup;\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkCreateEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    if ((ret = networkStartNetwork(driver, obj)) < 0)\n        goto cleanup;\n\n    event = virNetworkEventLifecycleNew(def->name,\n                                        def->uuid,\n                                        VIR_NETWORK_EVENT_STARTED,\n                                        0);\n\n cleanup:\n    virObjectEventStateQueue(driver->networkEventState, event);\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 4031
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->networkEventState",
            "event"
          ],
          "line": 4030
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkEventLifecycleNew",
          "args": [
            "def->name",
            "def->uuid",
            "VIR_NETWORK_EVENT_STARTED",
            "0"
          ],
          "line": 4024
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkEventLifecycleNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_event.c",
          "lines": "214-237",
          "snippet": "virObjectEventPtr\nvirNetworkEventLifecycleNew(const char *name,\n                            const unsigned char *uuid,\n                            int type,\n                            int detail)\n{\n    virNetworkEventLifecyclePtr event;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (virNetworkEventsInitialize() < 0)\n        return NULL;\n\n    virUUIDFormat(uuid, uuidstr);\n    if (!(event = virObjectEventNew(virNetworkEventLifecycleClass,\n                                    virNetworkEventDispatchDefaultFunc,\n                                    VIR_NETWORK_EVENT_ID_LIFECYCLE,\n                                    0, name, uuid, uuidstr)))\n        return NULL;\n\n    event->type = type;\n    event->detail = detail;\n\n    return (virObjectEventPtr)event;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetworkEventLifecycleClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include <config.h>\n\nstatic virClassPtr virNetworkEventLifecycleClass;\n\nvirObjectEventPtr\nvirNetworkEventLifecycleNew(const char *name,\n                            const unsigned char *uuid,\n                            int type,\n                            int detail)\n{\n    virNetworkEventLifecyclePtr event;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (virNetworkEventsInitialize() < 0)\n        return NULL;\n\n    virUUIDFormat(uuid, uuidstr);\n    if (!(event = virObjectEventNew(virNetworkEventLifecycleClass,\n                                    virNetworkEventDispatchDefaultFunc,\n                                    VIR_NETWORK_EVENT_ID_LIFECYCLE,\n                                    0, name, uuid, uuidstr)))\n        return NULL;\n\n    event->type = type;\n    event->detail = detail;\n\n    return (virObjectEventPtr)event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkStartNetwork",
          "args": [
            "driver",
            "obj"
          ],
          "line": 4021
        },
        "resolved": true,
        "details": {
          "function_name": "networkStartNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2890-2986",
          "snippet": "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n\n    VIR_DEBUG(\"driver=%p, network=%p\", driver, obj);\n\n    if (virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"network is already active\"));\n        return ret;\n    }\n\n    VIR_DEBUG(\"Beginning network startup process\");\n\n    virNetworkObjDeleteAllPorts(obj, driver->stateDir);\n\n    VIR_DEBUG(\"Setting current network def as transient\");\n    if (virNetworkObjSetDefTransient(obj, true, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices.\n     * If the script raised an error abort the launch. */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_START,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    switch ((virNetworkForwardType) def->forward.type) {\n\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        if (networkStartNetworkVirtual(driver, obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            if (networkStartNetworkBridge(obj) < 0)\n                goto cleanup;\n            break;\n        }\n        /* intentionally fall through to the macvtap/direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         * (since that is macvtap bridge mode).\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        if (networkStartNetworkExternal(obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto cleanup;\n    }\n\n    virNetworkObjSetFloorSum(obj, 0);\n\n    /* finally we can call the 'started' hook script if any */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_STARTED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    /* Persist the live configuration now that anything autogenerated\n     * is setup.\n     */\n    VIR_DEBUG(\"Writing network status to disk\");\n    if (virNetworkObjSaveStatus(driver->stateDir,\n                                obj, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    virNetworkObjSetActive(obj, true);\n    VIR_INFO(\"Network '%s' started up\", def->name);\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virErrorPtr save_err;\n\n        virErrorPreserveLast(&save_err);\n        virNetworkObjUnsetDefTransient(obj);\n        networkShutdownNetwork(driver, obj);\n        virErrorRestore(&save_err);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n\n    VIR_DEBUG(\"driver=%p, network=%p\", driver, obj);\n\n    if (virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"network is already active\"));\n        return ret;\n    }\n\n    VIR_DEBUG(\"Beginning network startup process\");\n\n    virNetworkObjDeleteAllPorts(obj, driver->stateDir);\n\n    VIR_DEBUG(\"Setting current network def as transient\");\n    if (virNetworkObjSetDefTransient(obj, true, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices.\n     * If the script raised an error abort the launch. */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_START,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    switch ((virNetworkForwardType) def->forward.type) {\n\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        if (networkStartNetworkVirtual(driver, obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            if (networkStartNetworkBridge(obj) < 0)\n                goto cleanup;\n            break;\n        }\n        /* intentionally fall through to the macvtap/direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         * (since that is macvtap bridge mode).\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        if (networkStartNetworkExternal(obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto cleanup;\n    }\n\n    virNetworkObjSetFloorSum(obj, 0);\n\n    /* finally we can call the 'started' hook script if any */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_STARTED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    /* Persist the live configuration now that anything autogenerated\n     * is setup.\n     */\n    VIR_DEBUG(\"Writing network status to disk\");\n    if (virNetworkObjSaveStatus(driver->stateDir,\n                                obj, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    virNetworkObjSetActive(obj, true);\n    VIR_INFO(\"Network '%s' started up\", def->name);\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virErrorPtr save_err;\n\n        virErrorPreserveLast(&save_err);\n        virNetworkObjUnsetDefTransient(obj);\n        networkShutdownNetwork(driver, obj);\n        virErrorRestore(&save_err);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkCreateEnsureACL",
          "args": [
            "net->conn",
            "def"
          ],
          "line": 4018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 4016
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "net"
          ],
          "line": 4014
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 4008
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkCreate(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    int ret = -1;\n    virObjectEventPtr event = NULL;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        goto cleanup;\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkCreateEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    if ((ret = networkStartNetwork(driver, obj)) < 0)\n        goto cleanup;\n\n    event = virNetworkEventLifecycleNew(def->name,\n                                        def->uuid,\n                                        VIR_NETWORK_EVENT_STARTED,\n                                        0);\n\n cleanup:\n    virObjectEventStateQueue(driver->networkEventState, event);\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkUpdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3809-4002",
    "snippet": "static int\nnetworkUpdate(virNetworkPtr net,\n              unsigned int command,\n              unsigned int section,\n              int parentIndex,\n              const char *xml,\n              unsigned int flags)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj = NULL;\n    virNetworkDefPtr def;\n    int isActive, ret = -1;\n    size_t i;\n    virNetworkIPDefPtr ipdef;\n    bool oldDhcpActive = false;\n    bool needFirewallRefresh = false;\n\n\n    virCheckFlags(VIR_NETWORK_UPDATE_AFFECT_LIVE |\n                  VIR_NETWORK_UPDATE_AFFECT_CONFIG,\n                  -1);\n\n    if (!(obj = networkObjFromNetwork(net)))\n        goto cleanup;\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkUpdateEnsureACL(net->conn, def, flags) < 0)\n        goto cleanup;\n\n    /* see if we are listening for dhcp pre-modification */\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipdef->nranges || ipdef->nhosts) {\n            oldDhcpActive = true;\n            break;\n        }\n    }\n\n    /* VIR_NETWORK_UPDATE_AFFECT_CURRENT means \"change LIVE if network\n     * is active, else change CONFIG\n     */\n    isActive = virNetworkObjIsActive(obj);\n    if ((flags & (VIR_NETWORK_UPDATE_AFFECT_LIVE |\n                  VIR_NETWORK_UPDATE_AFFECT_CONFIG)) ==\n        VIR_NETWORK_UPDATE_AFFECT_CURRENT) {\n        if (isActive)\n            flags |= VIR_NETWORK_UPDATE_AFFECT_LIVE;\n        else\n            flags |= VIR_NETWORK_UPDATE_AFFECT_CONFIG;\n    }\n\n    if (isActive && (flags & VIR_NETWORK_UPDATE_AFFECT_LIVE)) {\n        /* Take care of anything that must be done before updating the\n         * live NetworkDef.\n         */\n        switch ((virNetworkForwardType) def->forward.type) {\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n            switch (section) {\n            case VIR_NETWORK_SECTION_FORWARD:\n            case VIR_NETWORK_SECTION_FORWARD_INTERFACE:\n            case VIR_NETWORK_SECTION_IP:\n            case VIR_NETWORK_SECTION_IP_DHCP_RANGE:\n            case VIR_NETWORK_SECTION_IP_DHCP_HOST:\n                /* these could affect the firewall rules, so remove the\n                 * old rules (and remember to load new ones after the\n                 * update).\n                 */\n                networkRemoveFirewallRules(def);\n                needFirewallRefresh = true;\n                break;\n            default:\n                break;\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_OPEN:\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            break;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n            goto cleanup;\n        }\n    }\n\n    /* update the network config in memory/on disk */\n    if (virNetworkObjUpdate(obj, command, section,\n                            parentIndex, xml,\n                            network_driver->xmlopt, flags) < 0) {\n        if (needFirewallRefresh)\n            ignore_value(networkAddFirewallRules(def));\n        goto cleanup;\n    }\n\n    /* @def is replaced */\n    def = virNetworkObjGetDef(obj);\n\n    if (needFirewallRefresh && networkAddFirewallRules(def) < 0)\n        goto cleanup;\n\n    if (flags & VIR_NETWORK_UPDATE_AFFECT_CONFIG) {\n        /* save updated persistent config to disk */\n        if (virNetworkSaveConfig(driver->networkConfigDir,\n                                 virNetworkObjGetPersistentDef(obj),\n                                 network_driver->xmlopt) < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (isActive && (flags & VIR_NETWORK_UPDATE_AFFECT_LIVE)) {\n        /* rewrite dnsmasq host files, restart dnsmasq, update iptables\n         * rules, etc, according to which section was modified. Note that\n         * some sections require multiple actions, so a single switch\n         * statement is inadequate.\n         */\n        if (section == VIR_NETWORK_SECTION_BRIDGE ||\n            section == VIR_NETWORK_SECTION_DOMAIN ||\n            section == VIR_NETWORK_SECTION_IP ||\n            section == VIR_NETWORK_SECTION_IP_DHCP_RANGE ||\n            section == VIR_NETWORK_SECTION_DNS_TXT ||\n            section == VIR_NETWORK_SECTION_DNS_SRV) {\n            /* these sections all change things on the dnsmasq\n             * commandline (i.e. in the .conf file), so we need to\n             * kill and restart dnsmasq, because dnsmasq sets its uid\n             * to \"nobody\" after it starts, and is unable to re-read\n             * the conf file (owned by root, mode 600)\n             */\n            if (networkRestartDhcpDaemon(driver, obj) < 0)\n                goto cleanup;\n\n        } else if (section == VIR_NETWORK_SECTION_IP_DHCP_HOST) {\n            /* if we previously weren't listening for dhcp and now we\n             * are (or vice-versa) then we need to do a restart,\n             * otherwise we just need to do a refresh (redo the config\n             * files and send SIGHUP)\n             */\n            bool newDhcpActive = false;\n\n            for (i = 0; (ipdef = virNetworkDefGetIPByIndex(def, AF_INET, i));\n                 i++) {\n                if (ipdef->nranges || ipdef->nhosts) {\n                    newDhcpActive = true;\n                    break;\n                }\n            }\n\n            if ((newDhcpActive != oldDhcpActive &&\n                 networkRestartDhcpDaemon(driver, obj) < 0) ||\n                networkRefreshDhcpDaemon(driver, obj) < 0) {\n                goto cleanup;\n            }\n\n        } else if (section == VIR_NETWORK_SECTION_DNS_HOST) {\n            /* this section only changes data in an external file\n             * (not the .conf file) so we can just update the config\n             * files and send SIGHUP to dnsmasq.\n             */\n            if (networkRefreshDhcpDaemon(driver, obj) < 0)\n                goto cleanup;\n\n        }\n\n        if (section == VIR_NETWORK_SECTION_IP) {\n            /* only a change in IP addresses will affect radvd, and all of radvd's\n             * config is stored in the conf file which will be re-read with a SIGHUP.\n             */\n            if (networkRefreshRadvd(driver, obj) < 0)\n                goto cleanup;\n        }\n\n        /* save current network state to disk */\n        if ((ret = virNetworkObjSaveStatus(driver->stateDir,\n                                           obj, network_driver->xmlopt)) < 0)\n            goto cleanup;\n    }\n\n    /* call the 'updated' network hook script */\n    if (networkRunHook(obj, NULL, VIR_HOOK_NETWORK_OP_UPDATED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverStatePtr network_driver;",
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 4000
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRunHook",
          "args": [
            "obj",
            "NULL",
            "VIR_HOOK_NETWORK_OP_UPDATED",
            "VIR_HOOK_SUBOP_BEGIN"
          ],
          "line": 3994
        },
        "resolved": true,
        "details": {
          "function_name": "networkRunHook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "316-364",
          "snippet": "static int\nnetworkRunHook(virNetworkObjPtr obj,\n               virNetworkPortDefPtr port,\n               int op,\n               int sub_op)\n{\n    virNetworkDefPtr def;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xml = NULL;\n    int hookret;\n    int ret = -1;\n\n    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {\n        if (!obj) {\n            VIR_DEBUG(\"Not running hook as @obj is NULL\");\n            ret = 0;\n            goto cleanup;\n        }\n        def = virNetworkObjGetDef(obj);\n\n        virBufferAddLit(&buf, \"<hookData>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        if (virNetworkDefFormatBuf(&buf, def, network_driver->xmlopt, 0) < 0)\n            goto cleanup;\n        if (port && virNetworkPortDefFormatBuf(&buf, port) < 0)\n            goto cleanup;\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</hookData>\");\n\n        xml = virBufferContentAndReset(&buf);\n        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, def->name,\n                              op, sub_op, NULL, xml, NULL);\n\n        /*\n         * If the script raised an error, pass it to the callee.\n         */\n        if (hookret < 0)\n            goto cleanup;\n\n        networkNetworkObjTaint(obj, VIR_NETWORK_TAINT_HOOK);\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n    VIR_FREE(xml);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkRunHook(virNetworkObjPtr obj,\n               virNetworkPortDefPtr port,\n               int op,\n               int sub_op)\n{\n    virNetworkDefPtr def;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xml = NULL;\n    int hookret;\n    int ret = -1;\n\n    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {\n        if (!obj) {\n            VIR_DEBUG(\"Not running hook as @obj is NULL\");\n            ret = 0;\n            goto cleanup;\n        }\n        def = virNetworkObjGetDef(obj);\n\n        virBufferAddLit(&buf, \"<hookData>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        if (virNetworkDefFormatBuf(&buf, def, network_driver->xmlopt, 0) < 0)\n            goto cleanup;\n        if (port && virNetworkPortDefFormatBuf(&buf, port) < 0)\n            goto cleanup;\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</hookData>\");\n\n        xml = virBufferContentAndReset(&buf);\n        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, def->name,\n                              op, sub_op, NULL, xml, NULL);\n\n        /*\n         * If the script raised an error, pass it to the callee.\n         */\n        if (hookret < 0)\n            goto cleanup;\n\n        networkNetworkObjTaint(obj, VIR_NETWORK_TAINT_HOOK);\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n    VIR_FREE(xml);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSaveStatus",
          "args": [
            "driver->stateDir",
            "obj",
            "network_driver->xmlopt"
          ],
          "line": 3988
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSaveStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "851-870",
          "snippet": "int\nvirNetworkObjSaveStatus(const char *statusDir,\n                        virNetworkObjPtr obj,\n                        virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    int flags = 0;\n    char *xml;\n\n    if (!(xml = virNetworkObjFormat(obj, xmlopt, flags)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(statusDir, obj->def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nint\nvirNetworkObjSaveStatus(const char *statusDir,\n                        virNetworkObjPtr obj,\n                        virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    int flags = 0;\n    char *xml;\n\n    if (!(xml = virNetworkObjFormat(obj, xmlopt, flags)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(statusDir, obj->def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRefreshRadvd",
          "args": [
            "driver",
            "obj"
          ],
          "line": 3983
        },
        "resolved": true,
        "details": {
          "function_name": "networkRefreshRadvd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2063-2104",
          "snippet": "static int\nnetworkRefreshRadvd(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    dnsmasqCapsPtr dnsmasq_caps = networkGetDnsmasqCaps(driver);\n    char *radvdpidbase;\n    pid_t radvdPid;\n\n    /* Is dnsmasq handling RA? */\n    if (DNSMASQ_RA_SUPPORT(dnsmasq_caps)) {\n        virObjectUnref(dnsmasq_caps);\n        radvdPid = virNetworkObjGetRadvdPid(obj);\n        if (radvdPid <= 0)\n            return 0;\n        /* radvd should not be running but in case it is */\n        if ((networkKillDaemon(radvdPid, \"radvd\", def->name) >= 0) &&\n            ((radvdpidbase = networkRadvdPidfileBasename(def->name))\n             != NULL)) {\n            virPidFileDelete(driver->pidDir, radvdpidbase);\n            VIR_FREE(radvdpidbase);\n        }\n        virNetworkObjSetRadvdPid(obj, -1);\n        return 0;\n    }\n    virObjectUnref(dnsmasq_caps);\n\n    /* if there's no running radvd, just start it */\n    radvdPid = virNetworkObjGetRadvdPid(obj);\n    if (radvdPid <= 0 || (kill(radvdPid, 0) < 0))\n        return networkStartRadvd(driver, obj);\n\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* no IPv6 addresses, so we don't need to run radvd */\n        return 0;\n    }\n\n    if (networkRadvdConfWrite(driver, obj, NULL) < 0)\n        return -1;\n\n    return kill(radvdPid, SIGHUP);\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRefreshRadvd(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    dnsmasqCapsPtr dnsmasq_caps = networkGetDnsmasqCaps(driver);\n    char *radvdpidbase;\n    pid_t radvdPid;\n\n    /* Is dnsmasq handling RA? */\n    if (DNSMASQ_RA_SUPPORT(dnsmasq_caps)) {\n        virObjectUnref(dnsmasq_caps);\n        radvdPid = virNetworkObjGetRadvdPid(obj);\n        if (radvdPid <= 0)\n            return 0;\n        /* radvd should not be running but in case it is */\n        if ((networkKillDaemon(radvdPid, \"radvd\", def->name) >= 0) &&\n            ((radvdpidbase = networkRadvdPidfileBasename(def->name))\n             != NULL)) {\n            virPidFileDelete(driver->pidDir, radvdpidbase);\n            VIR_FREE(radvdpidbase);\n        }\n        virNetworkObjSetRadvdPid(obj, -1);\n        return 0;\n    }\n    virObjectUnref(dnsmasq_caps);\n\n    /* if there's no running radvd, just start it */\n    radvdPid = virNetworkObjGetRadvdPid(obj);\n    if (radvdPid <= 0 || (kill(radvdPid, 0) < 0))\n        return networkStartRadvd(driver, obj);\n\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* no IPv6 addresses, so we don't need to run radvd */\n        return 0;\n    }\n\n    if (networkRadvdConfWrite(driver, obj, NULL) < 0)\n        return -1;\n\n    return kill(radvdPid, SIGHUP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRefreshDhcpDaemon",
          "args": [
            "driver",
            "obj"
          ],
          "line": 3974
        },
        "resolved": true,
        "details": {
          "function_name": "networkRefreshDhcpDaemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1758-1821",
          "snippet": "static int\nnetworkRefreshDhcpDaemon(virNetworkDriverStatePtr driver,\n                         virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n    size_t i;\n    pid_t dnsmasqPid;\n    virNetworkIPDefPtr ipdef, ipv4def, ipv6def;\n    dnsmasqContext *dctx = NULL;\n\n    /* if no IP addresses specified, nothing to do */\n    if (!virNetworkDefGetIPByIndex(def, AF_UNSPEC, 0))\n        return 0;\n\n    /* if there's no running dnsmasq, just start it */\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    if (dnsmasqPid <= 0 || (kill(dnsmasqPid, 0) < 0))\n        return networkStartDhcpDaemon(driver, obj);\n\n    VIR_INFO(\"Refreshing dnsmasq for network %s\", def->bridge);\n    if (!(dctx = dnsmasqContextNew(def->name,\n                                   driver->dnsmasqStateDir))) {\n        goto cleanup;\n    }\n\n    /* Look for first IPv4 address that has dhcp defined.\n     * We only support dhcp-host config on one IPv4 subnetwork\n     * and on one IPv6 subnetwork.\n     */\n    ipv4def = NULL;\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (!ipv4def && (ipdef->nranges || ipdef->nhosts))\n            ipv4def = ipdef;\n    }\n\n    ipv6def = NULL;\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i));\n         i++) {\n        if (!ipv6def && (ipdef->nranges || ipdef->nhosts))\n            ipv6def = ipdef;\n    }\n\n    if (ipv4def && (networkBuildDnsmasqDhcpHostsList(dctx, ipv4def) < 0))\n        goto cleanup;\n\n    if (ipv6def && (networkBuildDnsmasqDhcpHostsList(dctx, ipv6def) < 0))\n        goto cleanup;\n\n    if (networkBuildDnsmasqHostsList(dctx, &def->dns) < 0)\n        goto cleanup;\n\n    if ((ret = dnsmasqSave(dctx)) < 0)\n        goto cleanup;\n\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    ret = kill(dnsmasqPid, SIGHUP);\n cleanup:\n    dnsmasqContextFree(dctx);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRefreshDhcpDaemon(virNetworkDriverStatePtr driver,\n                         virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n    size_t i;\n    pid_t dnsmasqPid;\n    virNetworkIPDefPtr ipdef, ipv4def, ipv6def;\n    dnsmasqContext *dctx = NULL;\n\n    /* if no IP addresses specified, nothing to do */\n    if (!virNetworkDefGetIPByIndex(def, AF_UNSPEC, 0))\n        return 0;\n\n    /* if there's no running dnsmasq, just start it */\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    if (dnsmasqPid <= 0 || (kill(dnsmasqPid, 0) < 0))\n        return networkStartDhcpDaemon(driver, obj);\n\n    VIR_INFO(\"Refreshing dnsmasq for network %s\", def->bridge);\n    if (!(dctx = dnsmasqContextNew(def->name,\n                                   driver->dnsmasqStateDir))) {\n        goto cleanup;\n    }\n\n    /* Look for first IPv4 address that has dhcp defined.\n     * We only support dhcp-host config on one IPv4 subnetwork\n     * and on one IPv6 subnetwork.\n     */\n    ipv4def = NULL;\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (!ipv4def && (ipdef->nranges || ipdef->nhosts))\n            ipv4def = ipdef;\n    }\n\n    ipv6def = NULL;\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i));\n         i++) {\n        if (!ipv6def && (ipdef->nranges || ipdef->nhosts))\n            ipv6def = ipdef;\n    }\n\n    if (ipv4def && (networkBuildDnsmasqDhcpHostsList(dctx, ipv4def) < 0))\n        goto cleanup;\n\n    if (ipv6def && (networkBuildDnsmasqDhcpHostsList(dctx, ipv6def) < 0))\n        goto cleanup;\n\n    if (networkBuildDnsmasqHostsList(dctx, &def->dns) < 0)\n        goto cleanup;\n\n    if ((ret = dnsmasqSave(dctx)) < 0)\n        goto cleanup;\n\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    ret = kill(dnsmasqPid, SIGHUP);\n cleanup:\n    dnsmasqContextFree(dctx);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRestartDhcpDaemon",
          "args": [
            "driver",
            "obj"
          ],
          "line": 3964
        },
        "resolved": true,
        "details": {
          "function_name": "networkRestartDhcpDaemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1831-1845",
          "snippet": "static int\nnetworkRestartDhcpDaemon(virNetworkDriverStatePtr driver,\n                         virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    pid_t dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n\n    /* if there is a running dnsmasq, kill it */\n    if (dnsmasqPid > 0) {\n        networkKillDaemon(dnsmasqPid, \"dnsmasq\", def->name);\n        virNetworkObjSetDnsmasqPid(obj, -1);\n    }\n    /* now start dnsmasq if it should be started */\n    return networkStartDhcpDaemon(driver, obj);\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRestartDhcpDaemon(virNetworkDriverStatePtr driver,\n                         virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    pid_t dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n\n    /* if there is a running dnsmasq, kill it */\n    if (dnsmasqPid > 0) {\n        networkKillDaemon(dnsmasqPid, \"dnsmasq\", def->name);\n        virNetworkObjSetDnsmasqPid(obj, -1);\n    }\n    /* now start dnsmasq if it should be started */\n    return networkStartDhcpDaemon(driver, obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET",
            "i"
          ],
          "line": 3955
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkSaveConfig",
          "args": [
            "driver->networkConfigDir",
            "virNetworkObjGetPersistentDef(obj)",
            "network_driver->xmlopt"
          ],
          "line": 3919
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkSaveConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2749-2767",
          "snippet": "int\nvirNetworkSaveConfig(const char *configDir,\n                     virNetworkDefPtr def,\n                     virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    char *xml;\n\n    if (!(xml = virNetworkDefFormat(def, xmlopt, VIR_NETWORK_XML_INACTIVE)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(configDir, def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkSaveConfig(const char *configDir,\n                     virNetworkDefPtr def,\n                     virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    char *xml;\n\n    if (!(xml = virNetworkDefFormat(def, xmlopt, VIR_NETWORK_XML_INACTIVE)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(configDir, def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetPersistentDef",
          "args": [
            "obj"
          ],
          "line": 3920
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetPersistentDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "716-723",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetPersistentDef(virNetworkObjPtr obj)\n{\n    if (obj->newDef)\n        return obj->newDef;\n    else\n        return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetPersistentDef(virNetworkObjPtr obj)\n{\n    if (obj->newDef)\n        return obj->newDef;\n    else\n        return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkAddFirewallRules",
          "args": [
            "def"
          ],
          "line": 3914
        },
        "resolved": true,
        "details": {
          "function_name": "networkAddFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_nop.c",
          "lines": "38-41",
          "snippet": "int networkAddFirewallRules(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nint networkAddFirewallRules(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 3912
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "networkAddFirewallRules(def)"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjUpdate",
          "args": [
            "obj",
            "command",
            "section",
            "parentIndex",
            "xml",
            "network_driver->xmlopt",
            "flags"
          ],
          "line": 3903
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1241-1314",
          "snippet": "int\nvirNetworkObjUpdate(virNetworkObjPtr obj,\n                    unsigned int command, /* virNetworkUpdateCommand */\n                    unsigned int section, /* virNetworkUpdateSection */\n                    int parentIndex,\n                    const char *xml,\n                    virNetworkXMLOptionPtr xmlopt,\n                    unsigned int flags)  /* virNetworkUpdateFlags */\n{\n    int ret = -1;\n    virNetworkDefPtr livedef = NULL, configdef = NULL;\n\n    /* normalize config data, and check for common invalid requests. */\n    if (virNetworkObjConfigChangeSetup(obj, xmlopt, flags) < 0)\n       goto cleanup;\n\n    if (flags & VIR_NETWORK_UPDATE_AFFECT_LIVE) {\n        virNetworkDefPtr checkdef;\n\n        /* work on a copy of the def */\n        if (!(livedef = virNetworkDefCopy(obj->def, xmlopt, 0)))\n            goto cleanup;\n        if (virNetworkDefUpdateSection(livedef, command, section,\n                                       parentIndex, xml, flags) < 0) {\n            goto cleanup;\n        }\n        /* run a final format/parse cycle to make sure we didn't\n         * add anything illegal to the def\n         */\n        if (!(checkdef = virNetworkDefCopy(livedef, xmlopt, 0)))\n            goto cleanup;\n        virNetworkDefFree(checkdef);\n    }\n\n    if (flags & VIR_NETWORK_UPDATE_AFFECT_CONFIG) {\n        virNetworkDefPtr checkdef;\n\n        /* work on a copy of the def */\n        if (!(configdef = virNetworkDefCopy(virNetworkObjGetPersistentDef(obj),\n                                            xmlopt,\n                                            VIR_NETWORK_XML_INACTIVE))) {\n            goto cleanup;\n        }\n        if (virNetworkDefUpdateSection(configdef, command, section,\n                                       parentIndex, xml, flags) < 0) {\n            goto cleanup;\n        }\n        if (!(checkdef = virNetworkDefCopy(configdef,\n                                           xmlopt,\n                                           VIR_NETWORK_XML_INACTIVE))) {\n            goto cleanup;\n        }\n        virNetworkDefFree(checkdef);\n    }\n\n    if (configdef) {\n        /* successfully modified copy, now replace original */\n        if (virNetworkObjReplacePersistentDef(obj, configdef) < 0)\n           goto cleanup;\n        configdef = NULL;\n    }\n    if (livedef) {\n        /* successfully modified copy, now replace original */\n        virNetworkDefFree(obj->def);\n        obj->def = livedef;\n        livedef = NULL;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDefFree(livedef);\n    virNetworkDefFree(configdef);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nint\nvirNetworkObjUpdate(virNetworkObjPtr obj,\n                    unsigned int command, /* virNetworkUpdateCommand */\n                    unsigned int section, /* virNetworkUpdateSection */\n                    int parentIndex,\n                    const char *xml,\n                    virNetworkXMLOptionPtr xmlopt,\n                    unsigned int flags)  /* virNetworkUpdateFlags */\n{\n    int ret = -1;\n    virNetworkDefPtr livedef = NULL, configdef = NULL;\n\n    /* normalize config data, and check for common invalid requests. */\n    if (virNetworkObjConfigChangeSetup(obj, xmlopt, flags) < 0)\n       goto cleanup;\n\n    if (flags & VIR_NETWORK_UPDATE_AFFECT_LIVE) {\n        virNetworkDefPtr checkdef;\n\n        /* work on a copy of the def */\n        if (!(livedef = virNetworkDefCopy(obj->def, xmlopt, 0)))\n            goto cleanup;\n        if (virNetworkDefUpdateSection(livedef, command, section,\n                                       parentIndex, xml, flags) < 0) {\n            goto cleanup;\n        }\n        /* run a final format/parse cycle to make sure we didn't\n         * add anything illegal to the def\n         */\n        if (!(checkdef = virNetworkDefCopy(livedef, xmlopt, 0)))\n            goto cleanup;\n        virNetworkDefFree(checkdef);\n    }\n\n    if (flags & VIR_NETWORK_UPDATE_AFFECT_CONFIG) {\n        virNetworkDefPtr checkdef;\n\n        /* work on a copy of the def */\n        if (!(configdef = virNetworkDefCopy(virNetworkObjGetPersistentDef(obj),\n                                            xmlopt,\n                                            VIR_NETWORK_XML_INACTIVE))) {\n            goto cleanup;\n        }\n        if (virNetworkDefUpdateSection(configdef, command, section,\n                                       parentIndex, xml, flags) < 0) {\n            goto cleanup;\n        }\n        if (!(checkdef = virNetworkDefCopy(configdef,\n                                           xmlopt,\n                                           VIR_NETWORK_XML_INACTIVE))) {\n            goto cleanup;\n        }\n        virNetworkDefFree(checkdef);\n    }\n\n    if (configdef) {\n        /* successfully modified copy, now replace original */\n        if (virNetworkObjReplacePersistentDef(obj, configdef) < 0)\n           goto cleanup;\n        configdef = NULL;\n    }\n    if (livedef) {\n        /* successfully modified copy, now replace original */\n        virNetworkDefFree(obj->def);\n        obj->def = livedef;\n        livedef = NULL;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDefFree(livedef);\n    virNetworkDefFree(configdef);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkForwardType",
            "def->forward.type"
          ],
          "line": 3897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkRemoveFirewallRules",
          "args": [
            "def"
          ],
          "line": 3879
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_nop.c",
          "lines": "43-45",
          "snippet": "void networkRemoveFirewallRules(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nvoid networkRemoveFirewallRules(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 3851
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkUpdateEnsureACL",
          "args": [
            "net->conn",
            "def",
            "flags"
          ],
          "line": 3835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "net"
          ],
          "line": 3831
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_NETWORK_UPDATE_AFFECT_LIVE |\n                  VIR_NETWORK_UPDATE_AFFECT_CONFIG",
            "-1"
          ],
          "line": 3827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 3817
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkUpdate(virNetworkPtr net,\n              unsigned int command,\n              unsigned int section,\n              int parentIndex,\n              const char *xml,\n              unsigned int flags)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj = NULL;\n    virNetworkDefPtr def;\n    int isActive, ret = -1;\n    size_t i;\n    virNetworkIPDefPtr ipdef;\n    bool oldDhcpActive = false;\n    bool needFirewallRefresh = false;\n\n\n    virCheckFlags(VIR_NETWORK_UPDATE_AFFECT_LIVE |\n                  VIR_NETWORK_UPDATE_AFFECT_CONFIG,\n                  -1);\n\n    if (!(obj = networkObjFromNetwork(net)))\n        goto cleanup;\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkUpdateEnsureACL(net->conn, def, flags) < 0)\n        goto cleanup;\n\n    /* see if we are listening for dhcp pre-modification */\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (ipdef->nranges || ipdef->nhosts) {\n            oldDhcpActive = true;\n            break;\n        }\n    }\n\n    /* VIR_NETWORK_UPDATE_AFFECT_CURRENT means \"change LIVE if network\n     * is active, else change CONFIG\n     */\n    isActive = virNetworkObjIsActive(obj);\n    if ((flags & (VIR_NETWORK_UPDATE_AFFECT_LIVE |\n                  VIR_NETWORK_UPDATE_AFFECT_CONFIG)) ==\n        VIR_NETWORK_UPDATE_AFFECT_CURRENT) {\n        if (isActive)\n            flags |= VIR_NETWORK_UPDATE_AFFECT_LIVE;\n        else\n            flags |= VIR_NETWORK_UPDATE_AFFECT_CONFIG;\n    }\n\n    if (isActive && (flags & VIR_NETWORK_UPDATE_AFFECT_LIVE)) {\n        /* Take care of anything that must be done before updating the\n         * live NetworkDef.\n         */\n        switch ((virNetworkForwardType) def->forward.type) {\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n            switch (section) {\n            case VIR_NETWORK_SECTION_FORWARD:\n            case VIR_NETWORK_SECTION_FORWARD_INTERFACE:\n            case VIR_NETWORK_SECTION_IP:\n            case VIR_NETWORK_SECTION_IP_DHCP_RANGE:\n            case VIR_NETWORK_SECTION_IP_DHCP_HOST:\n                /* these could affect the firewall rules, so remove the\n                 * old rules (and remember to load new ones after the\n                 * update).\n                 */\n                networkRemoveFirewallRules(def);\n                needFirewallRefresh = true;\n                break;\n            default:\n                break;\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_OPEN:\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            break;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n            goto cleanup;\n        }\n    }\n\n    /* update the network config in memory/on disk */\n    if (virNetworkObjUpdate(obj, command, section,\n                            parentIndex, xml,\n                            network_driver->xmlopt, flags) < 0) {\n        if (needFirewallRefresh)\n            ignore_value(networkAddFirewallRules(def));\n        goto cleanup;\n    }\n\n    /* @def is replaced */\n    def = virNetworkObjGetDef(obj);\n\n    if (needFirewallRefresh && networkAddFirewallRules(def) < 0)\n        goto cleanup;\n\n    if (flags & VIR_NETWORK_UPDATE_AFFECT_CONFIG) {\n        /* save updated persistent config to disk */\n        if (virNetworkSaveConfig(driver->networkConfigDir,\n                                 virNetworkObjGetPersistentDef(obj),\n                                 network_driver->xmlopt) < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (isActive && (flags & VIR_NETWORK_UPDATE_AFFECT_LIVE)) {\n        /* rewrite dnsmasq host files, restart dnsmasq, update iptables\n         * rules, etc, according to which section was modified. Note that\n         * some sections require multiple actions, so a single switch\n         * statement is inadequate.\n         */\n        if (section == VIR_NETWORK_SECTION_BRIDGE ||\n            section == VIR_NETWORK_SECTION_DOMAIN ||\n            section == VIR_NETWORK_SECTION_IP ||\n            section == VIR_NETWORK_SECTION_IP_DHCP_RANGE ||\n            section == VIR_NETWORK_SECTION_DNS_TXT ||\n            section == VIR_NETWORK_SECTION_DNS_SRV) {\n            /* these sections all change things on the dnsmasq\n             * commandline (i.e. in the .conf file), so we need to\n             * kill and restart dnsmasq, because dnsmasq sets its uid\n             * to \"nobody\" after it starts, and is unable to re-read\n             * the conf file (owned by root, mode 600)\n             */\n            if (networkRestartDhcpDaemon(driver, obj) < 0)\n                goto cleanup;\n\n        } else if (section == VIR_NETWORK_SECTION_IP_DHCP_HOST) {\n            /* if we previously weren't listening for dhcp and now we\n             * are (or vice-versa) then we need to do a restart,\n             * otherwise we just need to do a refresh (redo the config\n             * files and send SIGHUP)\n             */\n            bool newDhcpActive = false;\n\n            for (i = 0; (ipdef = virNetworkDefGetIPByIndex(def, AF_INET, i));\n                 i++) {\n                if (ipdef->nranges || ipdef->nhosts) {\n                    newDhcpActive = true;\n                    break;\n                }\n            }\n\n            if ((newDhcpActive != oldDhcpActive &&\n                 networkRestartDhcpDaemon(driver, obj) < 0) ||\n                networkRefreshDhcpDaemon(driver, obj) < 0) {\n                goto cleanup;\n            }\n\n        } else if (section == VIR_NETWORK_SECTION_DNS_HOST) {\n            /* this section only changes data in an external file\n             * (not the .conf file) so we can just update the config\n             * files and send SIGHUP to dnsmasq.\n             */\n            if (networkRefreshDhcpDaemon(driver, obj) < 0)\n                goto cleanup;\n\n        }\n\n        if (section == VIR_NETWORK_SECTION_IP) {\n            /* only a change in IP addresses will affect radvd, and all of radvd's\n             * config is stored in the conf file which will be re-read with a SIGHUP.\n             */\n            if (networkRefreshRadvd(driver, obj) < 0)\n                goto cleanup;\n        }\n\n        /* save current network state to disk */\n        if ((ret = virNetworkObjSaveStatus(driver->stateDir,\n                                           obj, network_driver->xmlopt)) < 0)\n            goto cleanup;\n    }\n\n    /* call the 'updated' network hook script */\n    if (networkRunHook(obj, NULL, VIR_HOOK_NETWORK_OP_UPDATED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkUndefine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3751-3806",
    "snippet": "static int\nnetworkUndefine(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    int ret = -1;\n    bool active = false;\n    virObjectEventPtr event = NULL;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        goto cleanup;\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkUndefineEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    if (virNetworkObjIsActive(obj))\n        active = true;\n\n    if (!virNetworkObjIsPersistent(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"can't undefine transient network\"));\n        goto cleanup;\n    }\n\n    /* remove autostart link */\n    if (virNetworkObjDeleteConfig(driver->networkConfigDir,\n                                  driver->networkAutostartDir,\n                                  obj) < 0)\n        goto cleanup;\n\n    event = virNetworkEventLifecycleNew(def->name,\n                                        def->uuid,\n                                        VIR_NETWORK_EVENT_UNDEFINED,\n                                        0);\n\n    VIR_INFO(\"Undefining network '%s'\", def->name);\n    if (!active) {\n        if (networkRemoveInactive(driver, obj) < 0)\n            goto cleanup;\n    } else {\n\n        /* if the network still exists, it was active, and we need to make\n         * it transient (by deleting the persistent def)\n         */\n        virNetworkObjUpdateAssignDef(obj, NULL, false);\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectEventStateQueue(driver->networkEventState, event);\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 3804
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->networkEventState",
            "event"
          ],
          "line": 3803
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjUpdateAssignDef",
          "args": [
            "obj",
            "NULL",
            "false"
          ],
          "line": 3797
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjUpdateAssignDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "511-554",
          "snippet": "void\nvirNetworkObjUpdateAssignDef(virNetworkObjPtr obj,\n                             virNetworkDefPtr def,\n                             bool live)\n{\n    if (live) {\n        /* before setting new live def, save (into newDef) any\n         * existing persistent (!live) def to be restored when the\n         * network is destroyed, unless there is one already saved.\n         */\n        if (obj->persistent && !obj->newDef)\n            obj->newDef = obj->def;\n        else\n            virNetworkDefFree(obj->def);\n        obj->def = def;\n    } else { /* !live */\n        virNetworkDefFree(obj->newDef);\n        if (virNetworkObjIsActive(obj)) {\n            /* save new configuration to be restored on network\n             * shutdown, leaving current live def alone\n             */\n            obj->newDef = def;\n        } else { /* !live and !active */\n            if (obj->def && !obj->persistent) {\n                /* network isn't (yet) marked active or persistent,\n                 * but already has a \"live\" def set. This means we are\n                 * currently setting the persistent def as a part of\n                 * the process of starting the network, so we need to\n                 * preserve the \"not yet live\" def in network->def.\n                 */\n                obj->newDef = def;\n            } else {\n                /* either there is no live def set, or this network\n                 * was already set as persistent, so the proper thing\n                 * is to overwrite network->def.\n                 */\n                obj->newDef = NULL;\n                virNetworkDefFree(obj->def);\n                obj->def = def;\n            }\n        }\n        obj->persistent = !!def;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjUpdateAssignDef(virNetworkObjPtr obj,\n                             virNetworkDefPtr def,\n                             bool live)\n{\n    if (live) {\n        /* before setting new live def, save (into newDef) any\n         * existing persistent (!live) def to be restored when the\n         * network is destroyed, unless there is one already saved.\n         */\n        if (obj->persistent && !obj->newDef)\n            obj->newDef = obj->def;\n        else\n            virNetworkDefFree(obj->def);\n        obj->def = def;\n    } else { /* !live */\n        virNetworkDefFree(obj->newDef);\n        if (virNetworkObjIsActive(obj)) {\n            /* save new configuration to be restored on network\n             * shutdown, leaving current live def alone\n             */\n            obj->newDef = def;\n        } else { /* !live and !active */\n            if (obj->def && !obj->persistent) {\n                /* network isn't (yet) marked active or persistent,\n                 * but already has a \"live\" def set. This means we are\n                 * currently setting the persistent def as a part of\n                 * the process of starting the network, so we need to\n                 * preserve the \"not yet live\" def in network->def.\n                 */\n                obj->newDef = def;\n            } else {\n                /* either there is no live def set, or this network\n                 * was already set as persistent, so the proper thing\n                 * is to overwrite network->def.\n                 */\n                obj->newDef = NULL;\n                virNetworkDefFree(obj->def);\n                obj->def = def;\n            }\n        }\n        obj->persistent = !!def;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRemoveInactive",
          "args": [
            "driver",
            "obj"
          ],
          "line": 3790
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveInactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "423-497",
          "snippet": "static int\nnetworkRemoveInactive(virNetworkDriverStatePtr driver,\n                      virNetworkObjPtr obj)\n{\n    char *leasefile = NULL;\n    char *customleasefile = NULL;\n    char *radvdconfigfile = NULL;\n    char *configfile = NULL;\n    char *radvdpidbase = NULL;\n    char *statusfile = NULL;\n    char *macMapFile = NULL;\n    dnsmasqContext *dctx = NULL;\n    virNetworkDefPtr def = virNetworkObjGetPersistentDef(obj);\n\n    int ret = -1;\n\n    /* remove the (possibly) existing dnsmasq and radvd files */\n    if (!(dctx = dnsmasqContextNew(def->name,\n                                   driver->dnsmasqStateDir))) {\n        goto cleanup;\n    }\n\n    if (!(leasefile = networkDnsmasqLeaseFileNameDefault(driver, def->name)))\n        goto cleanup;\n\n    if (!(customleasefile = networkDnsmasqLeaseFileNameCustom(driver, def->bridge)))\n        goto cleanup;\n\n    if (!(radvdconfigfile = networkRadvdConfigFileName(driver, def->name)))\n        goto cleanup;\n\n    if (!(radvdpidbase = networkRadvdPidfileBasename(def->name)))\n        goto cleanup;\n\n    if (!(configfile = networkDnsmasqConfigFileName(driver, def->name)))\n        goto cleanup;\n\n    if (!(statusfile = virNetworkConfigFile(driver->stateDir, def->name)))\n        goto cleanup;\n\n    if (!(macMapFile = virMacMapFileName(driver->dnsmasqStateDir, def->bridge)))\n        goto cleanup;\n\n    /* dnsmasq */\n    dnsmasqDelete(dctx);\n    unlink(leasefile);\n    unlink(customleasefile);\n    unlink(configfile);\n\n    /* MAC map manager */\n    unlink(macMapFile);\n\n    /* radvd */\n    unlink(radvdconfigfile);\n    virPidFileDelete(driver->pidDir, radvdpidbase);\n\n    /* remove status file */\n    unlink(statusfile);\n\n    /* remove the network definition */\n    virNetworkObjRemoveInactive(driver->networks, obj);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(leasefile);\n    VIR_FREE(configfile);\n    VIR_FREE(customleasefile);\n    VIR_FREE(radvdconfigfile);\n    VIR_FREE(radvdpidbase);\n    VIR_FREE(statusfile);\n    VIR_FREE(macMapFile);\n    dnsmasqContextFree(dctx);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRemoveInactive(virNetworkDriverStatePtr driver,\n                      virNetworkObjPtr obj)\n{\n    char *leasefile = NULL;\n    char *customleasefile = NULL;\n    char *radvdconfigfile = NULL;\n    char *configfile = NULL;\n    char *radvdpidbase = NULL;\n    char *statusfile = NULL;\n    char *macMapFile = NULL;\n    dnsmasqContext *dctx = NULL;\n    virNetworkDefPtr def = virNetworkObjGetPersistentDef(obj);\n\n    int ret = -1;\n\n    /* remove the (possibly) existing dnsmasq and radvd files */\n    if (!(dctx = dnsmasqContextNew(def->name,\n                                   driver->dnsmasqStateDir))) {\n        goto cleanup;\n    }\n\n    if (!(leasefile = networkDnsmasqLeaseFileNameDefault(driver, def->name)))\n        goto cleanup;\n\n    if (!(customleasefile = networkDnsmasqLeaseFileNameCustom(driver, def->bridge)))\n        goto cleanup;\n\n    if (!(radvdconfigfile = networkRadvdConfigFileName(driver, def->name)))\n        goto cleanup;\n\n    if (!(radvdpidbase = networkRadvdPidfileBasename(def->name)))\n        goto cleanup;\n\n    if (!(configfile = networkDnsmasqConfigFileName(driver, def->name)))\n        goto cleanup;\n\n    if (!(statusfile = virNetworkConfigFile(driver->stateDir, def->name)))\n        goto cleanup;\n\n    if (!(macMapFile = virMacMapFileName(driver->dnsmasqStateDir, def->bridge)))\n        goto cleanup;\n\n    /* dnsmasq */\n    dnsmasqDelete(dctx);\n    unlink(leasefile);\n    unlink(customleasefile);\n    unlink(configfile);\n\n    /* MAC map manager */\n    unlink(macMapFile);\n\n    /* radvd */\n    unlink(radvdconfigfile);\n    virPidFileDelete(driver->pidDir, radvdpidbase);\n\n    /* remove status file */\n    unlink(statusfile);\n\n    /* remove the network definition */\n    virNetworkObjRemoveInactive(driver->networks, obj);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(leasefile);\n    VIR_FREE(configfile);\n    VIR_FREE(customleasefile);\n    VIR_FREE(radvdconfigfile);\n    VIR_FREE(radvdpidbase);\n    VIR_FREE(statusfile);\n    VIR_FREE(macMapFile);\n    dnsmasqContextFree(dctx);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Undefining network '%s'\"",
            "def->name"
          ],
          "line": 3788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkEventLifecycleNew",
          "args": [
            "def->name",
            "def->uuid",
            "VIR_NETWORK_EVENT_UNDEFINED",
            "0"
          ],
          "line": 3783
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkEventLifecycleNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_event.c",
          "lines": "214-237",
          "snippet": "virObjectEventPtr\nvirNetworkEventLifecycleNew(const char *name,\n                            const unsigned char *uuid,\n                            int type,\n                            int detail)\n{\n    virNetworkEventLifecyclePtr event;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (virNetworkEventsInitialize() < 0)\n        return NULL;\n\n    virUUIDFormat(uuid, uuidstr);\n    if (!(event = virObjectEventNew(virNetworkEventLifecycleClass,\n                                    virNetworkEventDispatchDefaultFunc,\n                                    VIR_NETWORK_EVENT_ID_LIFECYCLE,\n                                    0, name, uuid, uuidstr)))\n        return NULL;\n\n    event->type = type;\n    event->detail = detail;\n\n    return (virObjectEventPtr)event;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetworkEventLifecycleClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include <config.h>\n\nstatic virClassPtr virNetworkEventLifecycleClass;\n\nvirObjectEventPtr\nvirNetworkEventLifecycleNew(const char *name,\n                            const unsigned char *uuid,\n                            int type,\n                            int detail)\n{\n    virNetworkEventLifecyclePtr event;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (virNetworkEventsInitialize() < 0)\n        return NULL;\n\n    virUUIDFormat(uuid, uuidstr);\n    if (!(event = virObjectEventNew(virNetworkEventLifecycleClass,\n                                    virNetworkEventDispatchDefaultFunc,\n                                    VIR_NETWORK_EVENT_ID_LIFECYCLE,\n                                    0, name, uuid, uuidstr)))\n        return NULL;\n\n    event->type = type;\n    event->detail = detail;\n\n    return (virObjectEventPtr)event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjDeleteConfig",
          "args": [
            "driver->networkConfigDir",
            "driver->networkAutostartDir",
            "obj"
          ],
          "line": 3778
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjDeleteConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1146-1177",
          "snippet": "int\nvirNetworkObjDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virNetworkObjPtr obj)\n{\n    char *configFile = NULL;\n    char *autostartLink = NULL;\n    int ret = -1;\n\n    if (!(configFile = virNetworkConfigFile(configDir, obj->def->name)))\n        goto error;\n    if (!(autostartLink = virNetworkConfigFile(autostartDir, obj->def->name)))\n        goto error;\n\n    /* Not fatal if this doesn't work */\n    unlink(autostartLink);\n    obj->autostart = false;\n\n    if (unlink(configFile) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot remove config file '%s'\"),\n                             configFile);\n        goto error;\n    }\n\n    ret = 0;\n\n error:\n    VIR_FREE(configFile);\n    VIR_FREE(autostartLink);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nint\nvirNetworkObjDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virNetworkObjPtr obj)\n{\n    char *configFile = NULL;\n    char *autostartLink = NULL;\n    int ret = -1;\n\n    if (!(configFile = virNetworkConfigFile(configDir, obj->def->name)))\n        goto error;\n    if (!(autostartLink = virNetworkConfigFile(autostartDir, obj->def->name)))\n        goto error;\n\n    /* Not fatal if this doesn't work */\n    unlink(autostartLink);\n    obj->autostart = false;\n\n    if (unlink(configFile) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot remove config file '%s'\"),\n                             configFile);\n        goto error;\n    }\n\n    ret = 0;\n\n error:\n    VIR_FREE(configFile);\n    VIR_FREE(autostartLink);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"can't undefine transient network\")"
          ],
          "line": 3772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"can't undefine transient network\""
          ],
          "line": 3773
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsPersistent",
          "args": [
            "obj"
          ],
          "line": 3771
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsPersistent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "185-189",
          "snippet": "bool\nvirNetworkObjIsPersistent(virNetworkObjPtr obj)\n{\n    return obj->persistent;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsPersistent(virNetworkObjPtr obj)\n{\n    return obj->persistent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 3768
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkUndefineEnsureACL",
          "args": [
            "net->conn",
            "def"
          ],
          "line": 3765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 3763
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "net"
          ],
          "line": 3761
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 3754
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkUndefine(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    int ret = -1;\n    bool active = false;\n    virObjectEventPtr event = NULL;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        goto cleanup;\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkUndefineEnsureACL(net->conn, def) < 0)\n        goto cleanup;\n\n    if (virNetworkObjIsActive(obj))\n        active = true;\n\n    if (!virNetworkObjIsPersistent(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"can't undefine transient network\"));\n        goto cleanup;\n    }\n\n    /* remove autostart link */\n    if (virNetworkObjDeleteConfig(driver->networkConfigDir,\n                                  driver->networkAutostartDir,\n                                  obj) < 0)\n        goto cleanup;\n\n    event = virNetworkEventLifecycleNew(def->name,\n                                        def->uuid,\n                                        VIR_NETWORK_EVENT_UNDEFINED,\n                                        0);\n\n    VIR_INFO(\"Undefining network '%s'\", def->name);\n    if (!active) {\n        if (networkRemoveInactive(driver, obj) < 0)\n            goto cleanup;\n    } else {\n\n        /* if the network still exists, it was active, and we need to make\n         * it transient (by deleting the persistent def)\n         */\n        virNetworkObjUpdateAssignDef(obj, NULL, false);\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectEventStateQueue(driver->networkEventState, event);\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkDefineXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3695-3748",
    "snippet": "static virNetworkPtr\nnetworkDefineXML(virConnectPtr conn,\n                 const char *xml)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr def = NULL;\n    bool freeDef = true;\n    virNetworkObjPtr obj = NULL;\n    virNetworkPtr net = NULL;\n    virObjectEventPtr event = NULL;\n\n    if (!(def = virNetworkDefParseString(xml, network_driver->xmlopt)))\n        goto cleanup;\n\n    if (virNetworkDefineXMLEnsureACL(conn, def) < 0)\n        goto cleanup;\n\n    if (networkValidate(driver, def) < 0)\n        goto cleanup;\n\n    if (!(obj = virNetworkObjAssignDef(driver->networks, def, 0)))\n        goto cleanup;\n\n    /* def was assigned to network object */\n    freeDef = false;\n\n    if (virNetworkSaveConfig(driver->networkConfigDir,\n                             def, network_driver->xmlopt) < 0) {\n        if (!virNetworkObjIsActive(obj)) {\n            virNetworkObjRemoveInactive(driver->networks, obj);\n            goto cleanup;\n        }\n        /* if network was active already, just undo new persistent\n         * definition by making it transient.\n         * XXX - this isn't necessarily the correct thing to do.\n         */\n        virNetworkObjUpdateAssignDef(obj, NULL, false);\n        goto cleanup;\n    }\n\n    event = virNetworkEventLifecycleNew(def->name, def->uuid,\n                                        VIR_NETWORK_EVENT_DEFINED,\n                                        0);\n\n    VIR_INFO(\"Defining network '%s'\", def->name);\n    net = virGetNetwork(conn, def->name, def->uuid);\n\n cleanup:\n    virObjectEventStateQueue(driver->networkEventState, event);\n    if (freeDef)\n        virNetworkDefFree(def);\n    virNetworkObjEndAPI(&obj);\n    return net;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverStatePtr network_driver;",
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 3746
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefFree",
          "args": [
            "def"
          ],
          "line": 3745
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "235-274",
          "snippet": "void\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->networkEventState",
            "event"
          ],
          "line": 3743
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetNetwork",
          "args": [
            "conn",
            "def->name",
            "def->uuid"
          ],
          "line": 3740
        },
        "resolved": true,
        "details": {
          "function_name": "virGetNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "341-366",
          "snippet": "virNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virNetworkClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virNetworkClass;\n\nvirNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Defining network '%s'\"",
            "def->name"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkEventLifecycleNew",
          "args": [
            "def->name",
            "def->uuid",
            "VIR_NETWORK_EVENT_DEFINED",
            "0"
          ],
          "line": 3735
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkEventLifecycleNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_event.c",
          "lines": "214-237",
          "snippet": "virObjectEventPtr\nvirNetworkEventLifecycleNew(const char *name,\n                            const unsigned char *uuid,\n                            int type,\n                            int detail)\n{\n    virNetworkEventLifecyclePtr event;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (virNetworkEventsInitialize() < 0)\n        return NULL;\n\n    virUUIDFormat(uuid, uuidstr);\n    if (!(event = virObjectEventNew(virNetworkEventLifecycleClass,\n                                    virNetworkEventDispatchDefaultFunc,\n                                    VIR_NETWORK_EVENT_ID_LIFECYCLE,\n                                    0, name, uuid, uuidstr)))\n        return NULL;\n\n    event->type = type;\n    event->detail = detail;\n\n    return (virObjectEventPtr)event;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetworkEventLifecycleClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include <config.h>\n\nstatic virClassPtr virNetworkEventLifecycleClass;\n\nvirObjectEventPtr\nvirNetworkEventLifecycleNew(const char *name,\n                            const unsigned char *uuid,\n                            int type,\n                            int detail)\n{\n    virNetworkEventLifecyclePtr event;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (virNetworkEventsInitialize() < 0)\n        return NULL;\n\n    virUUIDFormat(uuid, uuidstr);\n    if (!(event = virObjectEventNew(virNetworkEventLifecycleClass,\n                                    virNetworkEventDispatchDefaultFunc,\n                                    VIR_NETWORK_EVENT_ID_LIFECYCLE,\n                                    0, name, uuid, uuidstr)))\n        return NULL;\n\n    event->type = type;\n    event->detail = detail;\n\n    return (virObjectEventPtr)event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjUpdateAssignDef",
          "args": [
            "obj",
            "NULL",
            "false"
          ],
          "line": 3731
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjUpdateAssignDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "511-554",
          "snippet": "void\nvirNetworkObjUpdateAssignDef(virNetworkObjPtr obj,\n                             virNetworkDefPtr def,\n                             bool live)\n{\n    if (live) {\n        /* before setting new live def, save (into newDef) any\n         * existing persistent (!live) def to be restored when the\n         * network is destroyed, unless there is one already saved.\n         */\n        if (obj->persistent && !obj->newDef)\n            obj->newDef = obj->def;\n        else\n            virNetworkDefFree(obj->def);\n        obj->def = def;\n    } else { /* !live */\n        virNetworkDefFree(obj->newDef);\n        if (virNetworkObjIsActive(obj)) {\n            /* save new configuration to be restored on network\n             * shutdown, leaving current live def alone\n             */\n            obj->newDef = def;\n        } else { /* !live and !active */\n            if (obj->def && !obj->persistent) {\n                /* network isn't (yet) marked active or persistent,\n                 * but already has a \"live\" def set. This means we are\n                 * currently setting the persistent def as a part of\n                 * the process of starting the network, so we need to\n                 * preserve the \"not yet live\" def in network->def.\n                 */\n                obj->newDef = def;\n            } else {\n                /* either there is no live def set, or this network\n                 * was already set as persistent, so the proper thing\n                 * is to overwrite network->def.\n                 */\n                obj->newDef = NULL;\n                virNetworkDefFree(obj->def);\n                obj->def = def;\n            }\n        }\n        obj->persistent = !!def;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjUpdateAssignDef(virNetworkObjPtr obj,\n                             virNetworkDefPtr def,\n                             bool live)\n{\n    if (live) {\n        /* before setting new live def, save (into newDef) any\n         * existing persistent (!live) def to be restored when the\n         * network is destroyed, unless there is one already saved.\n         */\n        if (obj->persistent && !obj->newDef)\n            obj->newDef = obj->def;\n        else\n            virNetworkDefFree(obj->def);\n        obj->def = def;\n    } else { /* !live */\n        virNetworkDefFree(obj->newDef);\n        if (virNetworkObjIsActive(obj)) {\n            /* save new configuration to be restored on network\n             * shutdown, leaving current live def alone\n             */\n            obj->newDef = def;\n        } else { /* !live and !active */\n            if (obj->def && !obj->persistent) {\n                /* network isn't (yet) marked active or persistent,\n                 * but already has a \"live\" def set. This means we are\n                 * currently setting the persistent def as a part of\n                 * the process of starting the network, so we need to\n                 * preserve the \"not yet live\" def in network->def.\n                 */\n                obj->newDef = def;\n            } else {\n                /* either there is no live def set, or this network\n                 * was already set as persistent, so the proper thing\n                 * is to overwrite network->def.\n                 */\n                obj->newDef = NULL;\n                virNetworkDefFree(obj->def);\n                obj->def = def;\n            }\n        }\n        obj->persistent = !!def;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjRemoveInactive",
          "args": [
            "driver->networks",
            "obj"
          ],
          "line": 3724
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjRemoveInactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "796-810",
          "snippet": "void\nvirNetworkObjRemoveInactive(virNetworkObjListPtr nets,\n                            virNetworkObjPtr obj)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(obj->def->uuid, uuidstr);\n    virObjectRef(obj);\n    virObjectUnlock(obj);\n    virObjectRWLockWrite(nets);\n    virObjectLock(obj);\n    virHashRemoveEntry(nets->objs, uuidstr);\n    virObjectRWUnlock(nets);\n    virObjectUnref(obj);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjRemoveInactive(virNetworkObjListPtr nets,\n                            virNetworkObjPtr obj)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(obj->def->uuid, uuidstr);\n    virObjectRef(obj);\n    virObjectUnlock(obj);\n    virObjectRWLockWrite(nets);\n    virObjectLock(obj);\n    virHashRemoveEntry(nets->objs, uuidstr);\n    virObjectRWUnlock(nets);\n    virObjectUnref(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 3723
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkSaveConfig",
          "args": [
            "driver->networkConfigDir",
            "def",
            "network_driver->xmlopt"
          ],
          "line": 3721
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkSaveConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2749-2767",
          "snippet": "int\nvirNetworkSaveConfig(const char *configDir,\n                     virNetworkDefPtr def,\n                     virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    char *xml;\n\n    if (!(xml = virNetworkDefFormat(def, xmlopt, VIR_NETWORK_XML_INACTIVE)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(configDir, def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkSaveConfig(const char *configDir,\n                     virNetworkDefPtr def,\n                     virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    char *xml;\n\n    if (!(xml = virNetworkDefFormat(def, xmlopt, VIR_NETWORK_XML_INACTIVE)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(configDir, def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjAssignDef",
          "args": [
            "driver->networks",
            "def",
            "0"
          ],
          "line": 3715
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjAssignDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "646-657",
          "snippet": "virNetworkObjPtr\nvirNetworkObjAssignDef(virNetworkObjListPtr nets,\n                       virNetworkDefPtr def,\n                       unsigned int flags)\n{\n    virNetworkObjPtr obj;\n\n    virObjectRWLockWrite(nets);\n    obj = virNetworkObjAssignDefLocked(nets, def, flags);\n    virObjectRWUnlock(nets);\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkObjPtr\nvirNetworkObjAssignDef(virNetworkObjListPtr nets,\n                       virNetworkDefPtr def,\n                       unsigned int flags)\n{\n    virNetworkObjPtr obj;\n\n    virObjectRWLockWrite(nets);\n    obj = virNetworkObjAssignDefLocked(nets, def, flags);\n    virObjectRWUnlock(nets);\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkValidate",
          "args": [
            "driver",
            "def"
          ],
          "line": 3712
        },
        "resolved": true,
        "details": {
          "function_name": "networkValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "3345-3640",
          "snippet": "static int\nnetworkValidate(virNetworkDriverStatePtr driver,\n                virNetworkDefPtr def)\n{\n    size_t i, j;\n    bool vlanUsed, vlanAllowed, badVlanUse = false;\n    virPortGroupDefPtr defaultPortGroup = NULL;\n    virNetworkIPDefPtr ipdef;\n    bool ipv4def = false, ipv6def = false;\n    bool bandwidthAllowed = false;\n    bool usesInterface = false, usesAddress = false;\n\n    if (virXMLCheckIllegalChars(\"name\", def->name, \"\\n\") < 0)\n        return -1;\n\n    /* Only the three L3 network types that are configured by libvirt\n     * need to have a bridge device name / mac address provided\n     */\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* if no bridge name was given in the config, find a name\n         * unused by any other libvirt networks and assign it.\n         */\n        if (networkBridgeNameValidate(driver->networks, def) < 0)\n            return -1;\n\n        virNetworkSetBridgeMacAddr(def);\n        bandwidthAllowed = true;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge != NULL)\n            bandwidthAllowed = true;\n\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        /* They are also the only types that currently support setting\n         * a MAC or IP address for the host-side device (bridge), DNS\n         * configuration, or network-wide bandwidth limits.\n         */\n        if (def->mac_specified) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <mac> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (virNetworkDefGetIPByIndex(def, AF_UNSPEC, 0)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <ip> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (def->dns.ntxts || def->dns.nhosts || def->dns.nsrvs) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <dns> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (def->domain) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <domain> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    if (def->bandwidth &&\n        !bandwidthAllowed) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported network-wide <bandwidth> element \"\n                         \"in network %s with forward mode='%s'\"),\n                       def->name,\n                       virNetworkForwardTypeToString(def->forward.type));\n        return -1;\n    }\n\n    /* we support configs with a single PF defined:\n     *   <pf dev='eth0'/>\n     * or with a list of netdev names:\n     *   <interface dev='eth9'/>\n     * OR a list of PCI addresses\n     *   <address type='pci' domain='0' bus='4' slot='0' function='1'/>\n     * but not any combination of those.\n     *\n     * Since <interface> and <address> are for some strange reason\n     * stored in the same array, we need to cycle through it and check\n     * the type of each.\n     */\n    for (i = 0; i < def->forward.nifs; i++) {\n        virNetworkForwardIfDefPtr iface = &def->forward.ifs[i];\n        char *sysfs_path = NULL;\n\n        switch ((virNetworkForwardHostdevDeviceType)iface->type) {\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV:\n            usesInterface = true;\n\n            if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"hostdev network '%s' lists '%s' \"\n                                 \"in the device pool, but hostdev \"\n                                 \"networks require all devices to \"\n                                 \"be listed by PCI address, not \"\n                                 \"network device name\"),\n                               def->name, iface->device.dev);\n                return -1;\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI: {\n            usesAddress = true;\n\n            if (def->forward.type != VIR_NETWORK_FORWARD_HOSTDEV) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"network '%s' has forward mode '%s' \"\n                                 \" but lists a device by PCI address \"\n                                 \"in the device pool. This is only \"\n                                 \"supported for networks with forward \"\n                                 \"mode 'hostdev'\"),\n                               def->name,\n                               virNetworkForwardTypeToString(def->forward.type));\n                return -1;\n            }\n\n            if (virPCIDeviceAddressGetSysfsFile(&iface->device.pci, &sysfs_path) < 0)\n                return -1;\n\n            if (!virPCIIsVirtualFunction(sysfs_path)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"device '%s' in network '%s' is not \"\n                                 \"an SR-IOV Virtual Function\"),\n                               sysfs_path, def->name);\n                VIR_FREE(sysfs_path);\n                return -1;\n            }\n            VIR_FREE(sysfs_path);\n            break;\n        }\n\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NONE:\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_LAST:\n            break;\n        }\n    }\n    if ((def->forward.npfs > 0) + usesInterface + usesAddress > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"<address>, <interface>, and <pf> elements of \"\n                         \"<forward> in network %s are mutually exclusive\"),\n                       def->name);\n        return -1;\n    }\n\n    /* We only support dhcp on one IPv4 address and\n     * on one IPv6 address per defined network\n     */\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (ipv4def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple IPv4 dhcp sections found -- \"\n                                 \"dhcp is supported only for a \"\n                                 \"single IPv4 address on each network\"));\n                    return -1;\n                } else {\n                    ipv4def = true;\n                }\n            }\n        }\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (ipv6def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple IPv6 dhcp sections found -- \"\n                                 \"dhcp is supported only for a \"\n                                 \"single IPv6 address on each network\"));\n                    return -1;\n                } else {\n                    ipv6def = true;\n                }\n            }\n        }\n    }\n\n    /* The only type of networks that currently support transparent\n     * vlan configuration are those using hostdev sr-iov devices from\n     * a pool, and those using an Open vSwitch bridge.\n     */\n\n    vlanAllowed = (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV ||\n                   def->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH ||\n                   (def->forward.type == VIR_NETWORK_FORWARD_BRIDGE &&\n                    def->virtPortProfile &&\n                    def->virtPortProfile->virtPortType\n                    == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH));\n\n    vlanUsed = def->vlan.nTags > 0;\n    for (i = 0; i < def->nPortGroups; i++) {\n        if (vlanUsed || def->portGroups[i].vlan.nTags > 0) {\n            /* anyone using this portgroup will get a vlan tag. Verify\n             * that they will also be using an openvswitch connection,\n             * as that is the only type of network that currently\n             * supports a vlan tag.\n             */\n            if (def->portGroups[i].virtPortProfile) {\n                if (def->forward.type != VIR_NETWORK_FORWARD_BRIDGE ||\n                    def->portGroups[i].virtPortProfile->virtPortType\n                    != VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                    badVlanUse = true;\n                }\n            } else if (!vlanAllowed) {\n                /* virtualport taken from base network definition */\n                badVlanUse = true;\n            }\n        }\n        if (def->portGroups[i].isDefault) {\n            if (defaultPortGroup) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"network '%s' has multiple default \"\n                                 \"<portgroup> elements (%s and %s), \"\n                                 \"but only one default is allowed\"),\n                               def->name, defaultPortGroup->name,\n                               def->portGroups[i].name);\n                return -1;\n            }\n            defaultPortGroup = &def->portGroups[i];\n        }\n        for (j = i + 1; j < def->nPortGroups; j++) {\n            if (STREQ(def->portGroups[i].name, def->portGroups[j].name)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"multiple <portgroup> elements with the \"\n                                 \"same name (%s) in network '%s'\"),\n                               def->portGroups[i].name, def->name);\n                return -1;\n            }\n        }\n        if (def->portGroups[i].bandwidth && !bandwidthAllowed) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <bandwidth> element in network '%s' \"\n                             \"in portgroup '%s' with forward mode='%s'\"),\n                           def->name, def->portGroups[i].name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n    }\n    if (badVlanUse ||\n        (vlanUsed && !vlanAllowed && !defaultPortGroup)) {\n        /* NB: if defaultPortGroup is set, we don't directly look at\n         * vlanUsed && !vlanAllowed, because the network will never be\n         * used without having a portgroup added in, so all necessary\n         * checks were done in the loop above.\n         */\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"<vlan> element specified for network %s, \"\n                         \"whose type doesn't support vlan configuration\"),\n                       def->name);\n        return -1;\n    }\n\n    if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n        for (i = 0; i < def->nPortGroups; i++) {\n            if (def->portGroups[i].bandwidth) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unsupported <bandwidth> element \"\n                                 \"in <portgroup name='%s'> of \"\n                                 \"network '%s' with forward mode='%s'\"),\n                               def->portGroups[i].name, def->name,\n                               virNetworkForwardTypeToString(def->forward.type));\n                return -1;\n            }\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkValidate(virNetworkDriverStatePtr driver,\n                virNetworkDefPtr def)\n{\n    size_t i, j;\n    bool vlanUsed, vlanAllowed, badVlanUse = false;\n    virPortGroupDefPtr defaultPortGroup = NULL;\n    virNetworkIPDefPtr ipdef;\n    bool ipv4def = false, ipv6def = false;\n    bool bandwidthAllowed = false;\n    bool usesInterface = false, usesAddress = false;\n\n    if (virXMLCheckIllegalChars(\"name\", def->name, \"\\n\") < 0)\n        return -1;\n\n    /* Only the three L3 network types that are configured by libvirt\n     * need to have a bridge device name / mac address provided\n     */\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* if no bridge name was given in the config, find a name\n         * unused by any other libvirt networks and assign it.\n         */\n        if (networkBridgeNameValidate(driver->networks, def) < 0)\n            return -1;\n\n        virNetworkSetBridgeMacAddr(def);\n        bandwidthAllowed = true;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge != NULL)\n            bandwidthAllowed = true;\n\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        /* They are also the only types that currently support setting\n         * a MAC or IP address for the host-side device (bridge), DNS\n         * configuration, or network-wide bandwidth limits.\n         */\n        if (def->mac_specified) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <mac> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (virNetworkDefGetIPByIndex(def, AF_UNSPEC, 0)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <ip> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (def->dns.ntxts || def->dns.nhosts || def->dns.nsrvs) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <dns> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (def->domain) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <domain> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    if (def->bandwidth &&\n        !bandwidthAllowed) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported network-wide <bandwidth> element \"\n                         \"in network %s with forward mode='%s'\"),\n                       def->name,\n                       virNetworkForwardTypeToString(def->forward.type));\n        return -1;\n    }\n\n    /* we support configs with a single PF defined:\n     *   <pf dev='eth0'/>\n     * or with a list of netdev names:\n     *   <interface dev='eth9'/>\n     * OR a list of PCI addresses\n     *   <address type='pci' domain='0' bus='4' slot='0' function='1'/>\n     * but not any combination of those.\n     *\n     * Since <interface> and <address> are for some strange reason\n     * stored in the same array, we need to cycle through it and check\n     * the type of each.\n     */\n    for (i = 0; i < def->forward.nifs; i++) {\n        virNetworkForwardIfDefPtr iface = &def->forward.ifs[i];\n        char *sysfs_path = NULL;\n\n        switch ((virNetworkForwardHostdevDeviceType)iface->type) {\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV:\n            usesInterface = true;\n\n            if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"hostdev network '%s' lists '%s' \"\n                                 \"in the device pool, but hostdev \"\n                                 \"networks require all devices to \"\n                                 \"be listed by PCI address, not \"\n                                 \"network device name\"),\n                               def->name, iface->device.dev);\n                return -1;\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI: {\n            usesAddress = true;\n\n            if (def->forward.type != VIR_NETWORK_FORWARD_HOSTDEV) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"network '%s' has forward mode '%s' \"\n                                 \" but lists a device by PCI address \"\n                                 \"in the device pool. This is only \"\n                                 \"supported for networks with forward \"\n                                 \"mode 'hostdev'\"),\n                               def->name,\n                               virNetworkForwardTypeToString(def->forward.type));\n                return -1;\n            }\n\n            if (virPCIDeviceAddressGetSysfsFile(&iface->device.pci, &sysfs_path) < 0)\n                return -1;\n\n            if (!virPCIIsVirtualFunction(sysfs_path)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"device '%s' in network '%s' is not \"\n                                 \"an SR-IOV Virtual Function\"),\n                               sysfs_path, def->name);\n                VIR_FREE(sysfs_path);\n                return -1;\n            }\n            VIR_FREE(sysfs_path);\n            break;\n        }\n\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NONE:\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_LAST:\n            break;\n        }\n    }\n    if ((def->forward.npfs > 0) + usesInterface + usesAddress > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"<address>, <interface>, and <pf> elements of \"\n                         \"<forward> in network %s are mutually exclusive\"),\n                       def->name);\n        return -1;\n    }\n\n    /* We only support dhcp on one IPv4 address and\n     * on one IPv6 address per defined network\n     */\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (ipv4def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple IPv4 dhcp sections found -- \"\n                                 \"dhcp is supported only for a \"\n                                 \"single IPv4 address on each network\"));\n                    return -1;\n                } else {\n                    ipv4def = true;\n                }\n            }\n        }\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (ipv6def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple IPv6 dhcp sections found -- \"\n                                 \"dhcp is supported only for a \"\n                                 \"single IPv6 address on each network\"));\n                    return -1;\n                } else {\n                    ipv6def = true;\n                }\n            }\n        }\n    }\n\n    /* The only type of networks that currently support transparent\n     * vlan configuration are those using hostdev sr-iov devices from\n     * a pool, and those using an Open vSwitch bridge.\n     */\n\n    vlanAllowed = (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV ||\n                   def->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH ||\n                   (def->forward.type == VIR_NETWORK_FORWARD_BRIDGE &&\n                    def->virtPortProfile &&\n                    def->virtPortProfile->virtPortType\n                    == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH));\n\n    vlanUsed = def->vlan.nTags > 0;\n    for (i = 0; i < def->nPortGroups; i++) {\n        if (vlanUsed || def->portGroups[i].vlan.nTags > 0) {\n            /* anyone using this portgroup will get a vlan tag. Verify\n             * that they will also be using an openvswitch connection,\n             * as that is the only type of network that currently\n             * supports a vlan tag.\n             */\n            if (def->portGroups[i].virtPortProfile) {\n                if (def->forward.type != VIR_NETWORK_FORWARD_BRIDGE ||\n                    def->portGroups[i].virtPortProfile->virtPortType\n                    != VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                    badVlanUse = true;\n                }\n            } else if (!vlanAllowed) {\n                /* virtualport taken from base network definition */\n                badVlanUse = true;\n            }\n        }\n        if (def->portGroups[i].isDefault) {\n            if (defaultPortGroup) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"network '%s' has multiple default \"\n                                 \"<portgroup> elements (%s and %s), \"\n                                 \"but only one default is allowed\"),\n                               def->name, defaultPortGroup->name,\n                               def->portGroups[i].name);\n                return -1;\n            }\n            defaultPortGroup = &def->portGroups[i];\n        }\n        for (j = i + 1; j < def->nPortGroups; j++) {\n            if (STREQ(def->portGroups[i].name, def->portGroups[j].name)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"multiple <portgroup> elements with the \"\n                                 \"same name (%s) in network '%s'\"),\n                               def->portGroups[i].name, def->name);\n                return -1;\n            }\n        }\n        if (def->portGroups[i].bandwidth && !bandwidthAllowed) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <bandwidth> element in network '%s' \"\n                             \"in portgroup '%s' with forward mode='%s'\"),\n                           def->name, def->portGroups[i].name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n    }\n    if (badVlanUse ||\n        (vlanUsed && !vlanAllowed && !defaultPortGroup)) {\n        /* NB: if defaultPortGroup is set, we don't directly look at\n         * vlanUsed && !vlanAllowed, because the network will never be\n         * used without having a portgroup added in, so all necessary\n         * checks were done in the loop above.\n         */\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"<vlan> element specified for network %s, \"\n                         \"whose type doesn't support vlan configuration\"),\n                       def->name);\n        return -1;\n    }\n\n    if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n        for (i = 0; i < def->nPortGroups; i++) {\n            if (def->portGroups[i].bandwidth) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unsupported <bandwidth> element \"\n                                 \"in <portgroup name='%s'> of \"\n                                 \"network '%s' with forward mode='%s'\"),\n                               def->portGroups[i].name, def->name,\n                               virNetworkForwardTypeToString(def->forward.type));\n                return -1;\n            }\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefineXMLEnsureACL",
          "args": [
            "conn",
            "def"
          ],
          "line": 3709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefParseString",
          "args": [
            "xml",
            "network_driver->xmlopt"
          ],
          "line": 3706
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2114-2119",
          "snippet": "virNetworkDefPtr\nvirNetworkDefParseString(const char *xmlStr,\n                         virNetworkXMLOptionPtr xmlopt)\n{\n    return virNetworkDefParse(xmlStr, NULL, xmlopt);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkDefPtr\nvirNetworkDefParseString(const char *xmlStr,\n                         virNetworkXMLOptionPtr xmlopt)\n{\n    return virNetworkDefParse(xmlStr, NULL, xmlopt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 3699
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkPtr\nnetworkDefineXML(virConnectPtr conn,\n                 const char *xml)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr def = NULL;\n    bool freeDef = true;\n    virNetworkObjPtr obj = NULL;\n    virNetworkPtr net = NULL;\n    virObjectEventPtr event = NULL;\n\n    if (!(def = virNetworkDefParseString(xml, network_driver->xmlopt)))\n        goto cleanup;\n\n    if (virNetworkDefineXMLEnsureACL(conn, def) < 0)\n        goto cleanup;\n\n    if (networkValidate(driver, def) < 0)\n        goto cleanup;\n\n    if (!(obj = virNetworkObjAssignDef(driver->networks, def, 0)))\n        goto cleanup;\n\n    /* def was assigned to network object */\n    freeDef = false;\n\n    if (virNetworkSaveConfig(driver->networkConfigDir,\n                             def, network_driver->xmlopt) < 0) {\n        if (!virNetworkObjIsActive(obj)) {\n            virNetworkObjRemoveInactive(driver->networks, obj);\n            goto cleanup;\n        }\n        /* if network was active already, just undo new persistent\n         * definition by making it transient.\n         * XXX - this isn't necessarily the correct thing to do.\n         */\n        virNetworkObjUpdateAssignDef(obj, NULL, false);\n        goto cleanup;\n    }\n\n    event = virNetworkEventLifecycleNew(def->name, def->uuid,\n                                        VIR_NETWORK_EVENT_DEFINED,\n                                        0);\n\n    VIR_INFO(\"Defining network '%s'\", def->name);\n    net = virGetNetwork(conn, def->name, def->uuid);\n\n cleanup:\n    virObjectEventStateQueue(driver->networkEventState, event);\n    if (freeDef)\n        virNetworkDefFree(def);\n    virNetworkObjEndAPI(&obj);\n    return net;\n}"
  },
  {
    "function_name": "networkCreateXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3643-3692",
    "snippet": "static virNetworkPtr\nnetworkCreateXML(virConnectPtr conn,\n                 const char *xml)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr newDef;\n    virNetworkObjPtr obj = NULL;\n    virNetworkDefPtr def;\n    virNetworkPtr net = NULL;\n    virObjectEventPtr event = NULL;\n\n    if (!(newDef = virNetworkDefParseString(xml, network_driver->xmlopt)))\n        goto cleanup;\n\n    if (virNetworkCreateXMLEnsureACL(conn, newDef) < 0)\n        goto cleanup;\n\n    if (networkValidate(driver, newDef) < 0)\n        goto cleanup;\n\n    /* NB: even though this transient network hasn't yet been started,\n     * we assign the def with live = true in anticipation that it will\n     * be started momentarily.\n     */\n    if (!(obj = virNetworkObjAssignDef(driver->networks, newDef,\n                                       VIR_NETWORK_OBJ_LIST_ADD_LIVE |\n                                       VIR_NETWORK_OBJ_LIST_ADD_CHECK_LIVE)))\n        goto cleanup;\n    newDef = NULL;\n    def = virNetworkObjGetDef(obj);\n\n    if (networkStartNetwork(driver, obj) < 0) {\n        virNetworkObjRemoveInactive(driver->networks, obj);\n        goto cleanup;\n    }\n\n    event = virNetworkEventLifecycleNew(def->name,\n                                        def->uuid,\n                                        VIR_NETWORK_EVENT_STARTED,\n                                        0);\n\n    VIR_INFO(\"Creating network '%s'\", def->name);\n    net = virGetNetwork(conn, def->name, def->uuid);\n\n cleanup:\n    virNetworkDefFree(newDef);\n    virObjectEventStateQueue(driver->networkEventState, event);\n    virNetworkObjEndAPI(&obj);\n    return net;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverStatePtr network_driver;",
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 3690
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->networkEventState",
            "event"
          ],
          "line": 3689
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefFree",
          "args": [
            "newDef"
          ],
          "line": 3688
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "235-274",
          "snippet": "void\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetNetwork",
          "args": [
            "conn",
            "def->name",
            "def->uuid"
          ],
          "line": 3685
        },
        "resolved": true,
        "details": {
          "function_name": "virGetNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "341-366",
          "snippet": "virNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virNetworkClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virNetworkClass;\n\nvirNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Creating network '%s'\"",
            "def->name"
          ],
          "line": 3684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkEventLifecycleNew",
          "args": [
            "def->name",
            "def->uuid",
            "VIR_NETWORK_EVENT_STARTED",
            "0"
          ],
          "line": 3679
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkEventLifecycleNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_event.c",
          "lines": "214-237",
          "snippet": "virObjectEventPtr\nvirNetworkEventLifecycleNew(const char *name,\n                            const unsigned char *uuid,\n                            int type,\n                            int detail)\n{\n    virNetworkEventLifecyclePtr event;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (virNetworkEventsInitialize() < 0)\n        return NULL;\n\n    virUUIDFormat(uuid, uuidstr);\n    if (!(event = virObjectEventNew(virNetworkEventLifecycleClass,\n                                    virNetworkEventDispatchDefaultFunc,\n                                    VIR_NETWORK_EVENT_ID_LIFECYCLE,\n                                    0, name, uuid, uuidstr)))\n        return NULL;\n\n    event->type = type;\n    event->detail = detail;\n\n    return (virObjectEventPtr)event;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetworkEventLifecycleClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include <config.h>\n\nstatic virClassPtr virNetworkEventLifecycleClass;\n\nvirObjectEventPtr\nvirNetworkEventLifecycleNew(const char *name,\n                            const unsigned char *uuid,\n                            int type,\n                            int detail)\n{\n    virNetworkEventLifecyclePtr event;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (virNetworkEventsInitialize() < 0)\n        return NULL;\n\n    virUUIDFormat(uuid, uuidstr);\n    if (!(event = virObjectEventNew(virNetworkEventLifecycleClass,\n                                    virNetworkEventDispatchDefaultFunc,\n                                    VIR_NETWORK_EVENT_ID_LIFECYCLE,\n                                    0, name, uuid, uuidstr)))\n        return NULL;\n\n    event->type = type;\n    event->detail = detail;\n\n    return (virObjectEventPtr)event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjRemoveInactive",
          "args": [
            "driver->networks",
            "obj"
          ],
          "line": 3675
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjRemoveInactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "796-810",
          "snippet": "void\nvirNetworkObjRemoveInactive(virNetworkObjListPtr nets,\n                            virNetworkObjPtr obj)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(obj->def->uuid, uuidstr);\n    virObjectRef(obj);\n    virObjectUnlock(obj);\n    virObjectRWLockWrite(nets);\n    virObjectLock(obj);\n    virHashRemoveEntry(nets->objs, uuidstr);\n    virObjectRWUnlock(nets);\n    virObjectUnref(obj);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjRemoveInactive(virNetworkObjListPtr nets,\n                            virNetworkObjPtr obj)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(obj->def->uuid, uuidstr);\n    virObjectRef(obj);\n    virObjectUnlock(obj);\n    virObjectRWLockWrite(nets);\n    virObjectLock(obj);\n    virHashRemoveEntry(nets->objs, uuidstr);\n    virObjectRWUnlock(nets);\n    virObjectUnref(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkStartNetwork",
          "args": [
            "driver",
            "obj"
          ],
          "line": 3674
        },
        "resolved": true,
        "details": {
          "function_name": "networkStartNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2890-2986",
          "snippet": "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n\n    VIR_DEBUG(\"driver=%p, network=%p\", driver, obj);\n\n    if (virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"network is already active\"));\n        return ret;\n    }\n\n    VIR_DEBUG(\"Beginning network startup process\");\n\n    virNetworkObjDeleteAllPorts(obj, driver->stateDir);\n\n    VIR_DEBUG(\"Setting current network def as transient\");\n    if (virNetworkObjSetDefTransient(obj, true, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices.\n     * If the script raised an error abort the launch. */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_START,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    switch ((virNetworkForwardType) def->forward.type) {\n\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        if (networkStartNetworkVirtual(driver, obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            if (networkStartNetworkBridge(obj) < 0)\n                goto cleanup;\n            break;\n        }\n        /* intentionally fall through to the macvtap/direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         * (since that is macvtap bridge mode).\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        if (networkStartNetworkExternal(obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto cleanup;\n    }\n\n    virNetworkObjSetFloorSum(obj, 0);\n\n    /* finally we can call the 'started' hook script if any */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_STARTED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    /* Persist the live configuration now that anything autogenerated\n     * is setup.\n     */\n    VIR_DEBUG(\"Writing network status to disk\");\n    if (virNetworkObjSaveStatus(driver->stateDir,\n                                obj, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    virNetworkObjSetActive(obj, true);\n    VIR_INFO(\"Network '%s' started up\", def->name);\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virErrorPtr save_err;\n\n        virErrorPreserveLast(&save_err);\n        virNetworkObjUnsetDefTransient(obj);\n        networkShutdownNetwork(driver, obj);\n        virErrorRestore(&save_err);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n\n    VIR_DEBUG(\"driver=%p, network=%p\", driver, obj);\n\n    if (virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"network is already active\"));\n        return ret;\n    }\n\n    VIR_DEBUG(\"Beginning network startup process\");\n\n    virNetworkObjDeleteAllPorts(obj, driver->stateDir);\n\n    VIR_DEBUG(\"Setting current network def as transient\");\n    if (virNetworkObjSetDefTransient(obj, true, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices.\n     * If the script raised an error abort the launch. */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_START,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    switch ((virNetworkForwardType) def->forward.type) {\n\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        if (networkStartNetworkVirtual(driver, obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            if (networkStartNetworkBridge(obj) < 0)\n                goto cleanup;\n            break;\n        }\n        /* intentionally fall through to the macvtap/direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         * (since that is macvtap bridge mode).\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        if (networkStartNetworkExternal(obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto cleanup;\n    }\n\n    virNetworkObjSetFloorSum(obj, 0);\n\n    /* finally we can call the 'started' hook script if any */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_STARTED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    /* Persist the live configuration now that anything autogenerated\n     * is setup.\n     */\n    VIR_DEBUG(\"Writing network status to disk\");\n    if (virNetworkObjSaveStatus(driver->stateDir,\n                                obj, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    virNetworkObjSetActive(obj, true);\n    VIR_INFO(\"Network '%s' started up\", def->name);\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virErrorPtr save_err;\n\n        virErrorPreserveLast(&save_err);\n        virNetworkObjUnsetDefTransient(obj);\n        networkShutdownNetwork(driver, obj);\n        virErrorRestore(&save_err);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 3672
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjAssignDef",
          "args": [
            "driver->networks",
            "newDef",
            "VIR_NETWORK_OBJ_LIST_ADD_LIVE |\n                                       VIR_NETWORK_OBJ_LIST_ADD_CHECK_LIVE"
          ],
          "line": 3667
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjAssignDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "646-657",
          "snippet": "virNetworkObjPtr\nvirNetworkObjAssignDef(virNetworkObjListPtr nets,\n                       virNetworkDefPtr def,\n                       unsigned int flags)\n{\n    virNetworkObjPtr obj;\n\n    virObjectRWLockWrite(nets);\n    obj = virNetworkObjAssignDefLocked(nets, def, flags);\n    virObjectRWUnlock(nets);\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkObjPtr\nvirNetworkObjAssignDef(virNetworkObjListPtr nets,\n                       virNetworkDefPtr def,\n                       unsigned int flags)\n{\n    virNetworkObjPtr obj;\n\n    virObjectRWLockWrite(nets);\n    obj = virNetworkObjAssignDefLocked(nets, def, flags);\n    virObjectRWUnlock(nets);\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkValidate",
          "args": [
            "driver",
            "newDef"
          ],
          "line": 3660
        },
        "resolved": true,
        "details": {
          "function_name": "networkValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "3345-3640",
          "snippet": "static int\nnetworkValidate(virNetworkDriverStatePtr driver,\n                virNetworkDefPtr def)\n{\n    size_t i, j;\n    bool vlanUsed, vlanAllowed, badVlanUse = false;\n    virPortGroupDefPtr defaultPortGroup = NULL;\n    virNetworkIPDefPtr ipdef;\n    bool ipv4def = false, ipv6def = false;\n    bool bandwidthAllowed = false;\n    bool usesInterface = false, usesAddress = false;\n\n    if (virXMLCheckIllegalChars(\"name\", def->name, \"\\n\") < 0)\n        return -1;\n\n    /* Only the three L3 network types that are configured by libvirt\n     * need to have a bridge device name / mac address provided\n     */\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* if no bridge name was given in the config, find a name\n         * unused by any other libvirt networks and assign it.\n         */\n        if (networkBridgeNameValidate(driver->networks, def) < 0)\n            return -1;\n\n        virNetworkSetBridgeMacAddr(def);\n        bandwidthAllowed = true;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge != NULL)\n            bandwidthAllowed = true;\n\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        /* They are also the only types that currently support setting\n         * a MAC or IP address for the host-side device (bridge), DNS\n         * configuration, or network-wide bandwidth limits.\n         */\n        if (def->mac_specified) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <mac> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (virNetworkDefGetIPByIndex(def, AF_UNSPEC, 0)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <ip> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (def->dns.ntxts || def->dns.nhosts || def->dns.nsrvs) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <dns> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (def->domain) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <domain> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    if (def->bandwidth &&\n        !bandwidthAllowed) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported network-wide <bandwidth> element \"\n                         \"in network %s with forward mode='%s'\"),\n                       def->name,\n                       virNetworkForwardTypeToString(def->forward.type));\n        return -1;\n    }\n\n    /* we support configs with a single PF defined:\n     *   <pf dev='eth0'/>\n     * or with a list of netdev names:\n     *   <interface dev='eth9'/>\n     * OR a list of PCI addresses\n     *   <address type='pci' domain='0' bus='4' slot='0' function='1'/>\n     * but not any combination of those.\n     *\n     * Since <interface> and <address> are for some strange reason\n     * stored in the same array, we need to cycle through it and check\n     * the type of each.\n     */\n    for (i = 0; i < def->forward.nifs; i++) {\n        virNetworkForwardIfDefPtr iface = &def->forward.ifs[i];\n        char *sysfs_path = NULL;\n\n        switch ((virNetworkForwardHostdevDeviceType)iface->type) {\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV:\n            usesInterface = true;\n\n            if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"hostdev network '%s' lists '%s' \"\n                                 \"in the device pool, but hostdev \"\n                                 \"networks require all devices to \"\n                                 \"be listed by PCI address, not \"\n                                 \"network device name\"),\n                               def->name, iface->device.dev);\n                return -1;\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI: {\n            usesAddress = true;\n\n            if (def->forward.type != VIR_NETWORK_FORWARD_HOSTDEV) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"network '%s' has forward mode '%s' \"\n                                 \" but lists a device by PCI address \"\n                                 \"in the device pool. This is only \"\n                                 \"supported for networks with forward \"\n                                 \"mode 'hostdev'\"),\n                               def->name,\n                               virNetworkForwardTypeToString(def->forward.type));\n                return -1;\n            }\n\n            if (virPCIDeviceAddressGetSysfsFile(&iface->device.pci, &sysfs_path) < 0)\n                return -1;\n\n            if (!virPCIIsVirtualFunction(sysfs_path)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"device '%s' in network '%s' is not \"\n                                 \"an SR-IOV Virtual Function\"),\n                               sysfs_path, def->name);\n                VIR_FREE(sysfs_path);\n                return -1;\n            }\n            VIR_FREE(sysfs_path);\n            break;\n        }\n\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NONE:\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_LAST:\n            break;\n        }\n    }\n    if ((def->forward.npfs > 0) + usesInterface + usesAddress > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"<address>, <interface>, and <pf> elements of \"\n                         \"<forward> in network %s are mutually exclusive\"),\n                       def->name);\n        return -1;\n    }\n\n    /* We only support dhcp on one IPv4 address and\n     * on one IPv6 address per defined network\n     */\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (ipv4def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple IPv4 dhcp sections found -- \"\n                                 \"dhcp is supported only for a \"\n                                 \"single IPv4 address on each network\"));\n                    return -1;\n                } else {\n                    ipv4def = true;\n                }\n            }\n        }\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (ipv6def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple IPv6 dhcp sections found -- \"\n                                 \"dhcp is supported only for a \"\n                                 \"single IPv6 address on each network\"));\n                    return -1;\n                } else {\n                    ipv6def = true;\n                }\n            }\n        }\n    }\n\n    /* The only type of networks that currently support transparent\n     * vlan configuration are those using hostdev sr-iov devices from\n     * a pool, and those using an Open vSwitch bridge.\n     */\n\n    vlanAllowed = (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV ||\n                   def->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH ||\n                   (def->forward.type == VIR_NETWORK_FORWARD_BRIDGE &&\n                    def->virtPortProfile &&\n                    def->virtPortProfile->virtPortType\n                    == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH));\n\n    vlanUsed = def->vlan.nTags > 0;\n    for (i = 0; i < def->nPortGroups; i++) {\n        if (vlanUsed || def->portGroups[i].vlan.nTags > 0) {\n            /* anyone using this portgroup will get a vlan tag. Verify\n             * that they will also be using an openvswitch connection,\n             * as that is the only type of network that currently\n             * supports a vlan tag.\n             */\n            if (def->portGroups[i].virtPortProfile) {\n                if (def->forward.type != VIR_NETWORK_FORWARD_BRIDGE ||\n                    def->portGroups[i].virtPortProfile->virtPortType\n                    != VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                    badVlanUse = true;\n                }\n            } else if (!vlanAllowed) {\n                /* virtualport taken from base network definition */\n                badVlanUse = true;\n            }\n        }\n        if (def->portGroups[i].isDefault) {\n            if (defaultPortGroup) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"network '%s' has multiple default \"\n                                 \"<portgroup> elements (%s and %s), \"\n                                 \"but only one default is allowed\"),\n                               def->name, defaultPortGroup->name,\n                               def->portGroups[i].name);\n                return -1;\n            }\n            defaultPortGroup = &def->portGroups[i];\n        }\n        for (j = i + 1; j < def->nPortGroups; j++) {\n            if (STREQ(def->portGroups[i].name, def->portGroups[j].name)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"multiple <portgroup> elements with the \"\n                                 \"same name (%s) in network '%s'\"),\n                               def->portGroups[i].name, def->name);\n                return -1;\n            }\n        }\n        if (def->portGroups[i].bandwidth && !bandwidthAllowed) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <bandwidth> element in network '%s' \"\n                             \"in portgroup '%s' with forward mode='%s'\"),\n                           def->name, def->portGroups[i].name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n    }\n    if (badVlanUse ||\n        (vlanUsed && !vlanAllowed && !defaultPortGroup)) {\n        /* NB: if defaultPortGroup is set, we don't directly look at\n         * vlanUsed && !vlanAllowed, because the network will never be\n         * used without having a portgroup added in, so all necessary\n         * checks were done in the loop above.\n         */\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"<vlan> element specified for network %s, \"\n                         \"whose type doesn't support vlan configuration\"),\n                       def->name);\n        return -1;\n    }\n\n    if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n        for (i = 0; i < def->nPortGroups; i++) {\n            if (def->portGroups[i].bandwidth) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unsupported <bandwidth> element \"\n                                 \"in <portgroup name='%s'> of \"\n                                 \"network '%s' with forward mode='%s'\"),\n                               def->portGroups[i].name, def->name,\n                               virNetworkForwardTypeToString(def->forward.type));\n                return -1;\n            }\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkValidate(virNetworkDriverStatePtr driver,\n                virNetworkDefPtr def)\n{\n    size_t i, j;\n    bool vlanUsed, vlanAllowed, badVlanUse = false;\n    virPortGroupDefPtr defaultPortGroup = NULL;\n    virNetworkIPDefPtr ipdef;\n    bool ipv4def = false, ipv6def = false;\n    bool bandwidthAllowed = false;\n    bool usesInterface = false, usesAddress = false;\n\n    if (virXMLCheckIllegalChars(\"name\", def->name, \"\\n\") < 0)\n        return -1;\n\n    /* Only the three L3 network types that are configured by libvirt\n     * need to have a bridge device name / mac address provided\n     */\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* if no bridge name was given in the config, find a name\n         * unused by any other libvirt networks and assign it.\n         */\n        if (networkBridgeNameValidate(driver->networks, def) < 0)\n            return -1;\n\n        virNetworkSetBridgeMacAddr(def);\n        bandwidthAllowed = true;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge != NULL)\n            bandwidthAllowed = true;\n\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        /* They are also the only types that currently support setting\n         * a MAC or IP address for the host-side device (bridge), DNS\n         * configuration, or network-wide bandwidth limits.\n         */\n        if (def->mac_specified) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <mac> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (virNetworkDefGetIPByIndex(def, AF_UNSPEC, 0)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <ip> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (def->dns.ntxts || def->dns.nhosts || def->dns.nsrvs) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <dns> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (def->domain) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <domain> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    if (def->bandwidth &&\n        !bandwidthAllowed) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported network-wide <bandwidth> element \"\n                         \"in network %s with forward mode='%s'\"),\n                       def->name,\n                       virNetworkForwardTypeToString(def->forward.type));\n        return -1;\n    }\n\n    /* we support configs with a single PF defined:\n     *   <pf dev='eth0'/>\n     * or with a list of netdev names:\n     *   <interface dev='eth9'/>\n     * OR a list of PCI addresses\n     *   <address type='pci' domain='0' bus='4' slot='0' function='1'/>\n     * but not any combination of those.\n     *\n     * Since <interface> and <address> are for some strange reason\n     * stored in the same array, we need to cycle through it and check\n     * the type of each.\n     */\n    for (i = 0; i < def->forward.nifs; i++) {\n        virNetworkForwardIfDefPtr iface = &def->forward.ifs[i];\n        char *sysfs_path = NULL;\n\n        switch ((virNetworkForwardHostdevDeviceType)iface->type) {\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV:\n            usesInterface = true;\n\n            if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"hostdev network '%s' lists '%s' \"\n                                 \"in the device pool, but hostdev \"\n                                 \"networks require all devices to \"\n                                 \"be listed by PCI address, not \"\n                                 \"network device name\"),\n                               def->name, iface->device.dev);\n                return -1;\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI: {\n            usesAddress = true;\n\n            if (def->forward.type != VIR_NETWORK_FORWARD_HOSTDEV) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"network '%s' has forward mode '%s' \"\n                                 \" but lists a device by PCI address \"\n                                 \"in the device pool. This is only \"\n                                 \"supported for networks with forward \"\n                                 \"mode 'hostdev'\"),\n                               def->name,\n                               virNetworkForwardTypeToString(def->forward.type));\n                return -1;\n            }\n\n            if (virPCIDeviceAddressGetSysfsFile(&iface->device.pci, &sysfs_path) < 0)\n                return -1;\n\n            if (!virPCIIsVirtualFunction(sysfs_path)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"device '%s' in network '%s' is not \"\n                                 \"an SR-IOV Virtual Function\"),\n                               sysfs_path, def->name);\n                VIR_FREE(sysfs_path);\n                return -1;\n            }\n            VIR_FREE(sysfs_path);\n            break;\n        }\n\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NONE:\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_LAST:\n            break;\n        }\n    }\n    if ((def->forward.npfs > 0) + usesInterface + usesAddress > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"<address>, <interface>, and <pf> elements of \"\n                         \"<forward> in network %s are mutually exclusive\"),\n                       def->name);\n        return -1;\n    }\n\n    /* We only support dhcp on one IPv4 address and\n     * on one IPv6 address per defined network\n     */\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (ipv4def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple IPv4 dhcp sections found -- \"\n                                 \"dhcp is supported only for a \"\n                                 \"single IPv4 address on each network\"));\n                    return -1;\n                } else {\n                    ipv4def = true;\n                }\n            }\n        }\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (ipv6def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple IPv6 dhcp sections found -- \"\n                                 \"dhcp is supported only for a \"\n                                 \"single IPv6 address on each network\"));\n                    return -1;\n                } else {\n                    ipv6def = true;\n                }\n            }\n        }\n    }\n\n    /* The only type of networks that currently support transparent\n     * vlan configuration are those using hostdev sr-iov devices from\n     * a pool, and those using an Open vSwitch bridge.\n     */\n\n    vlanAllowed = (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV ||\n                   def->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH ||\n                   (def->forward.type == VIR_NETWORK_FORWARD_BRIDGE &&\n                    def->virtPortProfile &&\n                    def->virtPortProfile->virtPortType\n                    == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH));\n\n    vlanUsed = def->vlan.nTags > 0;\n    for (i = 0; i < def->nPortGroups; i++) {\n        if (vlanUsed || def->portGroups[i].vlan.nTags > 0) {\n            /* anyone using this portgroup will get a vlan tag. Verify\n             * that they will also be using an openvswitch connection,\n             * as that is the only type of network that currently\n             * supports a vlan tag.\n             */\n            if (def->portGroups[i].virtPortProfile) {\n                if (def->forward.type != VIR_NETWORK_FORWARD_BRIDGE ||\n                    def->portGroups[i].virtPortProfile->virtPortType\n                    != VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                    badVlanUse = true;\n                }\n            } else if (!vlanAllowed) {\n                /* virtualport taken from base network definition */\n                badVlanUse = true;\n            }\n        }\n        if (def->portGroups[i].isDefault) {\n            if (defaultPortGroup) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"network '%s' has multiple default \"\n                                 \"<portgroup> elements (%s and %s), \"\n                                 \"but only one default is allowed\"),\n                               def->name, defaultPortGroup->name,\n                               def->portGroups[i].name);\n                return -1;\n            }\n            defaultPortGroup = &def->portGroups[i];\n        }\n        for (j = i + 1; j < def->nPortGroups; j++) {\n            if (STREQ(def->portGroups[i].name, def->portGroups[j].name)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"multiple <portgroup> elements with the \"\n                                 \"same name (%s) in network '%s'\"),\n                               def->portGroups[i].name, def->name);\n                return -1;\n            }\n        }\n        if (def->portGroups[i].bandwidth && !bandwidthAllowed) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <bandwidth> element in network '%s' \"\n                             \"in portgroup '%s' with forward mode='%s'\"),\n                           def->name, def->portGroups[i].name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n    }\n    if (badVlanUse ||\n        (vlanUsed && !vlanAllowed && !defaultPortGroup)) {\n        /* NB: if defaultPortGroup is set, we don't directly look at\n         * vlanUsed && !vlanAllowed, because the network will never be\n         * used without having a portgroup added in, so all necessary\n         * checks were done in the loop above.\n         */\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"<vlan> element specified for network %s, \"\n                         \"whose type doesn't support vlan configuration\"),\n                       def->name);\n        return -1;\n    }\n\n    if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n        for (i = 0; i < def->nPortGroups; i++) {\n            if (def->portGroups[i].bandwidth) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unsupported <bandwidth> element \"\n                                 \"in <portgroup name='%s'> of \"\n                                 \"network '%s' with forward mode='%s'\"),\n                               def->portGroups[i].name, def->name,\n                               virNetworkForwardTypeToString(def->forward.type));\n                return -1;\n            }\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkCreateXMLEnsureACL",
          "args": [
            "conn",
            "newDef"
          ],
          "line": 3657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefParseString",
          "args": [
            "xml",
            "network_driver->xmlopt"
          ],
          "line": 3654
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2114-2119",
          "snippet": "virNetworkDefPtr\nvirNetworkDefParseString(const char *xmlStr,\n                         virNetworkXMLOptionPtr xmlopt)\n{\n    return virNetworkDefParse(xmlStr, NULL, xmlopt);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkDefPtr\nvirNetworkDefParseString(const char *xmlStr,\n                         virNetworkXMLOptionPtr xmlopt)\n{\n    return virNetworkDefParse(xmlStr, NULL, xmlopt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 3647
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkPtr\nnetworkCreateXML(virConnectPtr conn,\n                 const char *xml)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkDefPtr newDef;\n    virNetworkObjPtr obj = NULL;\n    virNetworkDefPtr def;\n    virNetworkPtr net = NULL;\n    virObjectEventPtr event = NULL;\n\n    if (!(newDef = virNetworkDefParseString(xml, network_driver->xmlopt)))\n        goto cleanup;\n\n    if (virNetworkCreateXMLEnsureACL(conn, newDef) < 0)\n        goto cleanup;\n\n    if (networkValidate(driver, newDef) < 0)\n        goto cleanup;\n\n    /* NB: even though this transient network hasn't yet been started,\n     * we assign the def with live = true in anticipation that it will\n     * be started momentarily.\n     */\n    if (!(obj = virNetworkObjAssignDef(driver->networks, newDef,\n                                       VIR_NETWORK_OBJ_LIST_ADD_LIVE |\n                                       VIR_NETWORK_OBJ_LIST_ADD_CHECK_LIVE)))\n        goto cleanup;\n    newDef = NULL;\n    def = virNetworkObjGetDef(obj);\n\n    if (networkStartNetwork(driver, obj) < 0) {\n        virNetworkObjRemoveInactive(driver->networks, obj);\n        goto cleanup;\n    }\n\n    event = virNetworkEventLifecycleNew(def->name,\n                                        def->uuid,\n                                        VIR_NETWORK_EVENT_STARTED,\n                                        0);\n\n    VIR_INFO(\"Creating network '%s'\", def->name);\n    net = virGetNetwork(conn, def->name, def->uuid);\n\n cleanup:\n    virNetworkDefFree(newDef);\n    virObjectEventStateQueue(driver->networkEventState, event);\n    virNetworkObjEndAPI(&obj);\n    return net;\n}"
  },
  {
    "function_name": "networkValidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3345-3640",
    "snippet": "static int\nnetworkValidate(virNetworkDriverStatePtr driver,\n                virNetworkDefPtr def)\n{\n    size_t i, j;\n    bool vlanUsed, vlanAllowed, badVlanUse = false;\n    virPortGroupDefPtr defaultPortGroup = NULL;\n    virNetworkIPDefPtr ipdef;\n    bool ipv4def = false, ipv6def = false;\n    bool bandwidthAllowed = false;\n    bool usesInterface = false, usesAddress = false;\n\n    if (virXMLCheckIllegalChars(\"name\", def->name, \"\\n\") < 0)\n        return -1;\n\n    /* Only the three L3 network types that are configured by libvirt\n     * need to have a bridge device name / mac address provided\n     */\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* if no bridge name was given in the config, find a name\n         * unused by any other libvirt networks and assign it.\n         */\n        if (networkBridgeNameValidate(driver->networks, def) < 0)\n            return -1;\n\n        virNetworkSetBridgeMacAddr(def);\n        bandwidthAllowed = true;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge != NULL)\n            bandwidthAllowed = true;\n\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        /* They are also the only types that currently support setting\n         * a MAC or IP address for the host-side device (bridge), DNS\n         * configuration, or network-wide bandwidth limits.\n         */\n        if (def->mac_specified) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <mac> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (virNetworkDefGetIPByIndex(def, AF_UNSPEC, 0)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <ip> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (def->dns.ntxts || def->dns.nhosts || def->dns.nsrvs) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <dns> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (def->domain) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <domain> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    if (def->bandwidth &&\n        !bandwidthAllowed) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported network-wide <bandwidth> element \"\n                         \"in network %s with forward mode='%s'\"),\n                       def->name,\n                       virNetworkForwardTypeToString(def->forward.type));\n        return -1;\n    }\n\n    /* we support configs with a single PF defined:\n     *   <pf dev='eth0'/>\n     * or with a list of netdev names:\n     *   <interface dev='eth9'/>\n     * OR a list of PCI addresses\n     *   <address type='pci' domain='0' bus='4' slot='0' function='1'/>\n     * but not any combination of those.\n     *\n     * Since <interface> and <address> are for some strange reason\n     * stored in the same array, we need to cycle through it and check\n     * the type of each.\n     */\n    for (i = 0; i < def->forward.nifs; i++) {\n        virNetworkForwardIfDefPtr iface = &def->forward.ifs[i];\n        char *sysfs_path = NULL;\n\n        switch ((virNetworkForwardHostdevDeviceType)iface->type) {\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV:\n            usesInterface = true;\n\n            if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"hostdev network '%s' lists '%s' \"\n                                 \"in the device pool, but hostdev \"\n                                 \"networks require all devices to \"\n                                 \"be listed by PCI address, not \"\n                                 \"network device name\"),\n                               def->name, iface->device.dev);\n                return -1;\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI: {\n            usesAddress = true;\n\n            if (def->forward.type != VIR_NETWORK_FORWARD_HOSTDEV) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"network '%s' has forward mode '%s' \"\n                                 \" but lists a device by PCI address \"\n                                 \"in the device pool. This is only \"\n                                 \"supported for networks with forward \"\n                                 \"mode 'hostdev'\"),\n                               def->name,\n                               virNetworkForwardTypeToString(def->forward.type));\n                return -1;\n            }\n\n            if (virPCIDeviceAddressGetSysfsFile(&iface->device.pci, &sysfs_path) < 0)\n                return -1;\n\n            if (!virPCIIsVirtualFunction(sysfs_path)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"device '%s' in network '%s' is not \"\n                                 \"an SR-IOV Virtual Function\"),\n                               sysfs_path, def->name);\n                VIR_FREE(sysfs_path);\n                return -1;\n            }\n            VIR_FREE(sysfs_path);\n            break;\n        }\n\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NONE:\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_LAST:\n            break;\n        }\n    }\n    if ((def->forward.npfs > 0) + usesInterface + usesAddress > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"<address>, <interface>, and <pf> elements of \"\n                         \"<forward> in network %s are mutually exclusive\"),\n                       def->name);\n        return -1;\n    }\n\n    /* We only support dhcp on one IPv4 address and\n     * on one IPv6 address per defined network\n     */\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (ipv4def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple IPv4 dhcp sections found -- \"\n                                 \"dhcp is supported only for a \"\n                                 \"single IPv4 address on each network\"));\n                    return -1;\n                } else {\n                    ipv4def = true;\n                }\n            }\n        }\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (ipv6def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple IPv6 dhcp sections found -- \"\n                                 \"dhcp is supported only for a \"\n                                 \"single IPv6 address on each network\"));\n                    return -1;\n                } else {\n                    ipv6def = true;\n                }\n            }\n        }\n    }\n\n    /* The only type of networks that currently support transparent\n     * vlan configuration are those using hostdev sr-iov devices from\n     * a pool, and those using an Open vSwitch bridge.\n     */\n\n    vlanAllowed = (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV ||\n                   def->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH ||\n                   (def->forward.type == VIR_NETWORK_FORWARD_BRIDGE &&\n                    def->virtPortProfile &&\n                    def->virtPortProfile->virtPortType\n                    == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH));\n\n    vlanUsed = def->vlan.nTags > 0;\n    for (i = 0; i < def->nPortGroups; i++) {\n        if (vlanUsed || def->portGroups[i].vlan.nTags > 0) {\n            /* anyone using this portgroup will get a vlan tag. Verify\n             * that they will also be using an openvswitch connection,\n             * as that is the only type of network that currently\n             * supports a vlan tag.\n             */\n            if (def->portGroups[i].virtPortProfile) {\n                if (def->forward.type != VIR_NETWORK_FORWARD_BRIDGE ||\n                    def->portGroups[i].virtPortProfile->virtPortType\n                    != VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                    badVlanUse = true;\n                }\n            } else if (!vlanAllowed) {\n                /* virtualport taken from base network definition */\n                badVlanUse = true;\n            }\n        }\n        if (def->portGroups[i].isDefault) {\n            if (defaultPortGroup) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"network '%s' has multiple default \"\n                                 \"<portgroup> elements (%s and %s), \"\n                                 \"but only one default is allowed\"),\n                               def->name, defaultPortGroup->name,\n                               def->portGroups[i].name);\n                return -1;\n            }\n            defaultPortGroup = &def->portGroups[i];\n        }\n        for (j = i + 1; j < def->nPortGroups; j++) {\n            if (STREQ(def->portGroups[i].name, def->portGroups[j].name)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"multiple <portgroup> elements with the \"\n                                 \"same name (%s) in network '%s'\"),\n                               def->portGroups[i].name, def->name);\n                return -1;\n            }\n        }\n        if (def->portGroups[i].bandwidth && !bandwidthAllowed) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <bandwidth> element in network '%s' \"\n                             \"in portgroup '%s' with forward mode='%s'\"),\n                           def->name, def->portGroups[i].name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n    }\n    if (badVlanUse ||\n        (vlanUsed && !vlanAllowed && !defaultPortGroup)) {\n        /* NB: if defaultPortGroup is set, we don't directly look at\n         * vlanUsed && !vlanAllowed, because the network will never be\n         * used without having a portgroup added in, so all necessary\n         * checks were done in the loop above.\n         */\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"<vlan> element specified for network %s, \"\n                         \"whose type doesn't support vlan configuration\"),\n                       def->name);\n        return -1;\n    }\n\n    if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n        for (i = 0; i < def->nPortGroups; i++) {\n            if (def->portGroups[i].bandwidth) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unsupported <bandwidth> element \"\n                                 \"in <portgroup name='%s'> of \"\n                                 \"network '%s' with forward mode='%s'\"),\n                               def->portGroups[i].name, def->name,\n                               virNetworkForwardTypeToString(def->forward.type));\n                return -1;\n            }\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported <bandwidth> element \"\n                                 \"in <portgroup name='%s'> of \"\n                                 \"network '%s' with forward mode='%s'\")",
            "def->portGroups[i].name",
            "def->name",
            "virNetworkForwardTypeToString(def->forward.type)"
          ],
          "line": 3629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 3634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported <bandwidth> element \"\n                                 \"in <portgroup name='%s'> of \"\n                                 \"network '%s' with forward mode='%s'\""
          ],
          "line": 3630
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"<vlan> element specified for network %s, \"\n                         \"whose type doesn't support vlan configuration\")",
            "def->name"
          ],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported <bandwidth> element in network '%s' \"\n                             \"in portgroup '%s' with forward mode='%s'\")",
            "def->name",
            "def->portGroups[i].name",
            "virNetworkForwardTypeToString(def->forward.type)"
          ],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 3608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"multiple <portgroup> elements with the \"\n                                 \"same name (%s) in network '%s'\")",
            "def->portGroups[i].name",
            "def->name"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->portGroups[i].name",
            "def->portGroups[j].name"
          ],
          "line": 3595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"network '%s' has multiple default \"\n                                 \"<portgroup> elements (%s and %s), \"\n                                 \"but only one default is allowed\")",
            "def->name",
            "defaultPortGroup->name",
            "def->portGroups[i].name"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Multiple IPv6 dhcp sections found -- \"\n                                 \"dhcp is supported only for a \"\n                                 \"single IPv6 address on each network\")"
          ],
          "line": 3539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef->address",
            "AF_INET6"
          ],
          "line": 3536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Multiple IPv4 dhcp sections found -- \"\n                                 \"dhcp is supported only for a \"\n                                 \"single IPv4 address on each network\")"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef->address",
            "AF_INET"
          ],
          "line": 3523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_UNSPEC",
            "i"
          ],
          "line": 3521
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"<address>, <interface>, and <pf> elements of \"\n                         \"<forward> in network %s are mutually exclusive\")",
            "def->name"
          ],
          "line": 3510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sysfs_path"
          ],
          "line": 3500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sysfs_path"
          ],
          "line": 3497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"device '%s' in network '%s' is not \"\n                                 \"an SR-IOV Virtual Function\")",
            "sysfs_path",
            "def->name"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIIsVirtualFunction",
          "args": [
            "sysfs_path"
          ],
          "line": 3492
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIIsVirtualFunction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2664-2669",
          "snippet": "int\nvirPCIIsVirtualFunction(const char *vf_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIIsVirtualFunction(const char *vf_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressGetSysfsFile",
          "args": [
            "&iface->device.pci",
            "&sysfs_path"
          ],
          "line": 3489
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressGetSysfsFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2689-2695",
          "snippet": "int\nvirPCIDeviceAddressGetSysfsFile(virPCIDeviceAddressPtr dev G_GNUC_UNUSED,\n                                char **pci_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressGetSysfsFile(virPCIDeviceAddressPtr dev G_GNUC_UNUSED,\n                                char **pci_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"network '%s' has forward mode '%s' \"\n                                 \" but lists a device by PCI address \"\n                                 \"in the device pool. This is only \"\n                                 \"supported for networks with forward \"\n                                 \"mode 'hostdev'\")",
            "def->name",
            "virNetworkForwardTypeToString(def->forward.type)"
          ],
          "line": 3478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 3485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"hostdev network '%s' lists '%s' \"\n                                 \"in the device pool, but hostdev \"\n                                 \"networks require all devices to \"\n                                 \"be listed by PCI address, not \"\n                                 \"network device name\")",
            "def->name",
            "iface->device.dev"
          ],
          "line": 3463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported network-wide <bandwidth> element \"\n                         \"in network %s with forward mode='%s'\")",
            "def->name",
            "virNetworkForwardTypeToString(def->forward.type)"
          ],
          "line": 3434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkForwardType",
            "def->forward.type"
          ],
          "line": 3428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported <domain> element in network %s \"\n                             \"with forward mode='%s'\")",
            "def->name",
            "virNetworkForwardTypeToString(def->forward.type)"
          ],
          "line": 3417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 3421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported <dns> element in network %s \"\n                             \"with forward mode='%s'\")",
            "def->name",
            "virNetworkForwardTypeToString(def->forward.type)"
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 3413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported <ip> element in network %s \"\n                             \"with forward mode='%s'\")",
            "def->name",
            "virNetworkForwardTypeToString(def->forward.type)"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported <mac> element in network %s \"\n                             \"with forward mode='%s'\")",
            "def->name",
            "virNetworkForwardTypeToString(def->forward.type)"
          ],
          "line": 3393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkForwardTypeToString",
          "args": [
            "def->forward.type"
          ],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkSetBridgeMacAddr",
          "args": [
            "def"
          ],
          "line": 3374
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkSetBridgeMacAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2781-2792",
          "snippet": "void\nvirNetworkSetBridgeMacAddr(virNetworkDefPtr def)\n{\n    if (!def->mac_specified) {\n        /* if the bridge doesn't have a mac address explicitly defined,\n         * autogenerate a random one.\n         */\n        virMacAddrGenerate((unsigned char[]){ 0x52, 0x54, 0 },\n                           &def->mac);\n        def->mac_specified = true;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetworkSetBridgeMacAddr(virNetworkDefPtr def)\n{\n    if (!def->mac_specified) {\n        /* if the bridge doesn't have a mac address explicitly defined,\n         * autogenerate a random one.\n         */\n        virMacAddrGenerate((unsigned char[]){ 0x52, 0x54, 0 },\n                           &def->mac);\n        def->mac_specified = true;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkBridgeNameValidate",
          "args": [
            "driver->networks",
            "def"
          ],
          "line": 3371
        },
        "resolved": true,
        "details": {
          "function_name": "networkBridgeNameValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "3324-3342",
          "snippet": "static int\nnetworkBridgeNameValidate(virNetworkObjListPtr nets,\n                          virNetworkDefPtr def)\n{\n    if (def->bridge && !strstr(def->bridge, \"%d\")) {\n        if (virNetworkObjBridgeInUse(nets, def->bridge, def->name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bridge name '%s' already in use.\"),\n                           def->bridge);\n            return -1;\n        }\n    } else {\n        /* Allocate a bridge name */\n        if (networkFindUnusedBridgeName(nets, def) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkBridgeNameValidate(virNetworkObjListPtr nets,\n                          virNetworkDefPtr def)\n{\n    if (def->bridge && !strstr(def->bridge, \"%d\")) {\n        if (virNetworkObjBridgeInUse(nets, def->bridge, def->name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bridge name '%s' already in use.\"),\n                           def->bridge);\n            return -1;\n        }\n    } else {\n        /* Allocate a bridge name */\n        if (networkFindUnusedBridgeName(nets, def) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLCheckIllegalChars",
          "args": [
            "\"name\"",
            "def->name",
            "\"\\n\""
          ],
          "line": 3357
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLCheckIllegalChars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "490-502",
          "snippet": "int\nvirXMLCheckIllegalChars(const char *nodeName,\n                        const char *str,\n                        const char *illegal)\n{\n    char *c;\n    if ((c = strpbrk(str, illegal))) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"invalid char in %s: %c\"), nodeName, *c);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXMLCheckIllegalChars(const char *nodeName,\n                        const char *str,\n                        const char *illegal)\n{\n    char *c;\n    if ((c = strpbrk(str, illegal))) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"invalid char in %s: %c\"), nodeName, *c);\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkValidate(virNetworkDriverStatePtr driver,\n                virNetworkDefPtr def)\n{\n    size_t i, j;\n    bool vlanUsed, vlanAllowed, badVlanUse = false;\n    virPortGroupDefPtr defaultPortGroup = NULL;\n    virNetworkIPDefPtr ipdef;\n    bool ipv4def = false, ipv6def = false;\n    bool bandwidthAllowed = false;\n    bool usesInterface = false, usesAddress = false;\n\n    if (virXMLCheckIllegalChars(\"name\", def->name, \"\\n\") < 0)\n        return -1;\n\n    /* Only the three L3 network types that are configured by libvirt\n     * need to have a bridge device name / mac address provided\n     */\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* if no bridge name was given in the config, find a name\n         * unused by any other libvirt networks and assign it.\n         */\n        if (networkBridgeNameValidate(driver->networks, def) < 0)\n            return -1;\n\n        virNetworkSetBridgeMacAddr(def);\n        bandwidthAllowed = true;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge != NULL)\n            bandwidthAllowed = true;\n\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        /* They are also the only types that currently support setting\n         * a MAC or IP address for the host-side device (bridge), DNS\n         * configuration, or network-wide bandwidth limits.\n         */\n        if (def->mac_specified) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <mac> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (virNetworkDefGetIPByIndex(def, AF_UNSPEC, 0)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <ip> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (def->dns.ntxts || def->dns.nhosts || def->dns.nsrvs) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <dns> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        if (def->domain) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <domain> element in network %s \"\n                             \"with forward mode='%s'\"),\n                           def->name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    if (def->bandwidth &&\n        !bandwidthAllowed) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported network-wide <bandwidth> element \"\n                         \"in network %s with forward mode='%s'\"),\n                       def->name,\n                       virNetworkForwardTypeToString(def->forward.type));\n        return -1;\n    }\n\n    /* we support configs with a single PF defined:\n     *   <pf dev='eth0'/>\n     * or with a list of netdev names:\n     *   <interface dev='eth9'/>\n     * OR a list of PCI addresses\n     *   <address type='pci' domain='0' bus='4' slot='0' function='1'/>\n     * but not any combination of those.\n     *\n     * Since <interface> and <address> are for some strange reason\n     * stored in the same array, we need to cycle through it and check\n     * the type of each.\n     */\n    for (i = 0; i < def->forward.nifs; i++) {\n        virNetworkForwardIfDefPtr iface = &def->forward.ifs[i];\n        char *sysfs_path = NULL;\n\n        switch ((virNetworkForwardHostdevDeviceType)iface->type) {\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV:\n            usesInterface = true;\n\n            if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"hostdev network '%s' lists '%s' \"\n                                 \"in the device pool, but hostdev \"\n                                 \"networks require all devices to \"\n                                 \"be listed by PCI address, not \"\n                                 \"network device name\"),\n                               def->name, iface->device.dev);\n                return -1;\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI: {\n            usesAddress = true;\n\n            if (def->forward.type != VIR_NETWORK_FORWARD_HOSTDEV) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"network '%s' has forward mode '%s' \"\n                                 \" but lists a device by PCI address \"\n                                 \"in the device pool. This is only \"\n                                 \"supported for networks with forward \"\n                                 \"mode 'hostdev'\"),\n                               def->name,\n                               virNetworkForwardTypeToString(def->forward.type));\n                return -1;\n            }\n\n            if (virPCIDeviceAddressGetSysfsFile(&iface->device.pci, &sysfs_path) < 0)\n                return -1;\n\n            if (!virPCIIsVirtualFunction(sysfs_path)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"device '%s' in network '%s' is not \"\n                                 \"an SR-IOV Virtual Function\"),\n                               sysfs_path, def->name);\n                VIR_FREE(sysfs_path);\n                return -1;\n            }\n            VIR_FREE(sysfs_path);\n            break;\n        }\n\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NONE:\n        case VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_LAST:\n            break;\n        }\n    }\n    if ((def->forward.npfs > 0) + usesInterface + usesAddress > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"<address>, <interface>, and <pf> elements of \"\n                         \"<forward> in network %s are mutually exclusive\"),\n                       def->name);\n        return -1;\n    }\n\n    /* We only support dhcp on one IPv4 address and\n     * on one IPv6 address per defined network\n     */\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (ipv4def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple IPv4 dhcp sections found -- \"\n                                 \"dhcp is supported only for a \"\n                                 \"single IPv4 address on each network\"));\n                    return -1;\n                } else {\n                    ipv4def = true;\n                }\n            }\n        }\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (ipv6def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple IPv6 dhcp sections found -- \"\n                                 \"dhcp is supported only for a \"\n                                 \"single IPv6 address on each network\"));\n                    return -1;\n                } else {\n                    ipv6def = true;\n                }\n            }\n        }\n    }\n\n    /* The only type of networks that currently support transparent\n     * vlan configuration are those using hostdev sr-iov devices from\n     * a pool, and those using an Open vSwitch bridge.\n     */\n\n    vlanAllowed = (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV ||\n                   def->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH ||\n                   (def->forward.type == VIR_NETWORK_FORWARD_BRIDGE &&\n                    def->virtPortProfile &&\n                    def->virtPortProfile->virtPortType\n                    == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH));\n\n    vlanUsed = def->vlan.nTags > 0;\n    for (i = 0; i < def->nPortGroups; i++) {\n        if (vlanUsed || def->portGroups[i].vlan.nTags > 0) {\n            /* anyone using this portgroup will get a vlan tag. Verify\n             * that they will also be using an openvswitch connection,\n             * as that is the only type of network that currently\n             * supports a vlan tag.\n             */\n            if (def->portGroups[i].virtPortProfile) {\n                if (def->forward.type != VIR_NETWORK_FORWARD_BRIDGE ||\n                    def->portGroups[i].virtPortProfile->virtPortType\n                    != VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                    badVlanUse = true;\n                }\n            } else if (!vlanAllowed) {\n                /* virtualport taken from base network definition */\n                badVlanUse = true;\n            }\n        }\n        if (def->portGroups[i].isDefault) {\n            if (defaultPortGroup) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"network '%s' has multiple default \"\n                                 \"<portgroup> elements (%s and %s), \"\n                                 \"but only one default is allowed\"),\n                               def->name, defaultPortGroup->name,\n                               def->portGroups[i].name);\n                return -1;\n            }\n            defaultPortGroup = &def->portGroups[i];\n        }\n        for (j = i + 1; j < def->nPortGroups; j++) {\n            if (STREQ(def->portGroups[i].name, def->portGroups[j].name)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"multiple <portgroup> elements with the \"\n                                 \"same name (%s) in network '%s'\"),\n                               def->portGroups[i].name, def->name);\n                return -1;\n            }\n        }\n        if (def->portGroups[i].bandwidth && !bandwidthAllowed) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported <bandwidth> element in network '%s' \"\n                             \"in portgroup '%s' with forward mode='%s'\"),\n                           def->name, def->portGroups[i].name,\n                           virNetworkForwardTypeToString(def->forward.type));\n            return -1;\n        }\n    }\n    if (badVlanUse ||\n        (vlanUsed && !vlanAllowed && !defaultPortGroup)) {\n        /* NB: if defaultPortGroup is set, we don't directly look at\n         * vlanUsed && !vlanAllowed, because the network will never be\n         * used without having a portgroup added in, so all necessary\n         * checks were done in the loop above.\n         */\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"<vlan> element specified for network %s, \"\n                         \"whose type doesn't support vlan configuration\"),\n                       def->name);\n        return -1;\n    }\n\n    if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n        for (i = 0; i < def->nPortGroups; i++) {\n            if (def->portGroups[i].bandwidth) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unsupported <bandwidth> element \"\n                                 \"in <portgroup name='%s'> of \"\n                                 \"network '%s' with forward mode='%s'\"),\n                               def->portGroups[i].name, def->name,\n                               virNetworkForwardTypeToString(def->forward.type));\n                return -1;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "networkBridgeNameValidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3324-3342",
    "snippet": "static int\nnetworkBridgeNameValidate(virNetworkObjListPtr nets,\n                          virNetworkDefPtr def)\n{\n    if (def->bridge && !strstr(def->bridge, \"%d\")) {\n        if (virNetworkObjBridgeInUse(nets, def->bridge, def->name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bridge name '%s' already in use.\"),\n                           def->bridge);\n            return -1;\n        }\n    } else {\n        /* Allocate a bridge name */\n        if (networkFindUnusedBridgeName(nets, def) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkFindUnusedBridgeName",
          "args": [
            "nets",
            "def"
          ],
          "line": 3337
        },
        "resolved": true,
        "details": {
          "function_name": "networkFindUnusedBridgeName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "3275-3314",
          "snippet": "static int\nnetworkFindUnusedBridgeName(virNetworkObjListPtr nets,\n                            virNetworkDefPtr def)\n{\n    int ret = -1, id = 0;\n    char *newname = NULL;\n    const char *templ = \"virbr%d\";\n    const char *p;\n\n    if (def->bridge &&\n        (p = strchr(def->bridge, '%')) == strrchr(def->bridge, '%') &&\n        p && p[1] == 'd')\n        templ = def->bridge;\n\n    do {\n        newname = g_strdup_printf(templ, id);\n        /* check if this name is used in another libvirt network or\n         * there is an existing device with that name. ignore errors\n         * from virNetDevExists(), just in case it isn't implemented\n         * on this platform (probably impossible).\n         */\n        if (!(virNetworkObjBridgeInUse(nets, newname, def->name) ||\n              virNetDevExists(newname) == 1)) {\n            VIR_FREE(def->bridge); /*could contain template */\n            def->bridge = newname;\n            ret = 0;\n            goto cleanup;\n        }\n        VIR_FREE(newname);\n    } while (++id <= MAX_BRIDGE_ID);\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Bridge generation exceeded max id %d\"),\n                   MAX_BRIDGE_ID);\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        VIR_FREE(newname);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_BRIDGE_ID 256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_BRIDGE_ID 256\n\nstatic int\nnetworkFindUnusedBridgeName(virNetworkObjListPtr nets,\n                            virNetworkDefPtr def)\n{\n    int ret = -1, id = 0;\n    char *newname = NULL;\n    const char *templ = \"virbr%d\";\n    const char *p;\n\n    if (def->bridge &&\n        (p = strchr(def->bridge, '%')) == strrchr(def->bridge, '%') &&\n        p && p[1] == 'd')\n        templ = def->bridge;\n\n    do {\n        newname = g_strdup_printf(templ, id);\n        /* check if this name is used in another libvirt network or\n         * there is an existing device with that name. ignore errors\n         * from virNetDevExists(), just in case it isn't implemented\n         * on this platform (probably impossible).\n         */\n        if (!(virNetworkObjBridgeInUse(nets, newname, def->name) ||\n              virNetDevExists(newname) == 1)) {\n            VIR_FREE(def->bridge); /*could contain template */\n            def->bridge = newname;\n            ret = 0;\n            goto cleanup;\n        }\n        VIR_FREE(newname);\n    } while (++id <= MAX_BRIDGE_ID);\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Bridge generation exceeded max id %d\"),\n                   MAX_BRIDGE_ID);\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        VIR_FREE(newname);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"bridge name '%s' already in use.\")",
            "def->bridge"
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"bridge name '%s' already in use.\""
          ],
          "line": 3331
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjBridgeInUse",
          "args": [
            "nets",
            "def->bridge",
            "def->name"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjBridgeInUse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1211-1224",
          "snippet": "bool\nvirNetworkObjBridgeInUse(virNetworkObjListPtr nets,\n                         const char *bridge,\n                         const char *skipname)\n{\n    virNetworkObjPtr obj;\n    struct virNetworkObjBridgeInUseHelperData data = {bridge, skipname};\n\n    virObjectRWLockRead(nets);\n    obj = virHashSearch(nets->objs, virNetworkObjBridgeInUseHelper, &data, NULL);\n    virObjectRWUnlock(nets);\n\n    return obj != NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjBridgeInUse(virNetworkObjListPtr nets,\n                         const char *bridge,\n                         const char *skipname)\n{\n    virNetworkObjPtr obj;\n    struct virNetworkObjBridgeInUseHelperData data = {bridge, skipname};\n\n    virObjectRWLockRead(nets);\n    obj = virHashSearch(nets->objs, virNetworkObjBridgeInUseHelper, &data, NULL);\n    virObjectRWUnlock(nets);\n\n    return obj != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "def->bridge",
            "\"%d\""
          ],
          "line": 3328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkBridgeNameValidate(virNetworkObjListPtr nets,\n                          virNetworkDefPtr def)\n{\n    if (def->bridge && !strstr(def->bridge, \"%d\")) {\n        if (virNetworkObjBridgeInUse(nets, def->bridge, def->name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bridge name '%s' already in use.\"),\n                           def->bridge);\n            return -1;\n        }\n    } else {\n        /* Allocate a bridge name */\n        if (networkFindUnusedBridgeName(nets, def) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "networkFindUnusedBridgeName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3275-3314",
    "snippet": "static int\nnetworkFindUnusedBridgeName(virNetworkObjListPtr nets,\n                            virNetworkDefPtr def)\n{\n    int ret = -1, id = 0;\n    char *newname = NULL;\n    const char *templ = \"virbr%d\";\n    const char *p;\n\n    if (def->bridge &&\n        (p = strchr(def->bridge, '%')) == strrchr(def->bridge, '%') &&\n        p && p[1] == 'd')\n        templ = def->bridge;\n\n    do {\n        newname = g_strdup_printf(templ, id);\n        /* check if this name is used in another libvirt network or\n         * there is an existing device with that name. ignore errors\n         * from virNetDevExists(), just in case it isn't implemented\n         * on this platform (probably impossible).\n         */\n        if (!(virNetworkObjBridgeInUse(nets, newname, def->name) ||\n              virNetDevExists(newname) == 1)) {\n            VIR_FREE(def->bridge); /*could contain template */\n            def->bridge = newname;\n            ret = 0;\n            goto cleanup;\n        }\n        VIR_FREE(newname);\n    } while (++id <= MAX_BRIDGE_ID);\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Bridge generation exceeded max id %d\"),\n                   MAX_BRIDGE_ID);\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        VIR_FREE(newname);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define MAX_BRIDGE_ID 256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "newname"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Bridge generation exceeded max id %d\")",
            "MAX_BRIDGE_ID"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Bridge generation exceeded max id %d\""
          ],
          "line": 3307
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "newname"
          ],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->bridge"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevExists",
          "args": [
            "newname"
          ],
          "line": 3297
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "218-223",
          "snippet": "int virNetDevExists(const char *ifname)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to check interface %s\"), ifname);\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint virNetDevExists(const char *ifname)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to check interface %s\"), ifname);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjBridgeInUse",
          "args": [
            "nets",
            "newname",
            "def->name"
          ],
          "line": 3296
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjBridgeInUse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1211-1224",
          "snippet": "bool\nvirNetworkObjBridgeInUse(virNetworkObjListPtr nets,\n                         const char *bridge,\n                         const char *skipname)\n{\n    virNetworkObjPtr obj;\n    struct virNetworkObjBridgeInUseHelperData data = {bridge, skipname};\n\n    virObjectRWLockRead(nets);\n    obj = virHashSearch(nets->objs, virNetworkObjBridgeInUseHelper, &data, NULL);\n    virObjectRWUnlock(nets);\n\n    return obj != NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjBridgeInUse(virNetworkObjListPtr nets,\n                         const char *bridge,\n                         const char *skipname)\n{\n    virNetworkObjPtr obj;\n    struct virNetworkObjBridgeInUseHelperData data = {bridge, skipname};\n\n    virObjectRWLockRead(nets);\n    obj = virHashSearch(nets->objs, virNetworkObjBridgeInUseHelper, &data, NULL);\n    virObjectRWUnlock(nets);\n\n    return obj != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "def->bridge",
            "'%'"
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "def->bridge",
            "'%'"
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_BRIDGE_ID 256\n\nstatic int\nnetworkFindUnusedBridgeName(virNetworkObjListPtr nets,\n                            virNetworkDefPtr def)\n{\n    int ret = -1, id = 0;\n    char *newname = NULL;\n    const char *templ = \"virbr%d\";\n    const char *p;\n\n    if (def->bridge &&\n        (p = strchr(def->bridge, '%')) == strrchr(def->bridge, '%') &&\n        p && p[1] == 'd')\n        templ = def->bridge;\n\n    do {\n        newname = g_strdup_printf(templ, id);\n        /* check if this name is used in another libvirt network or\n         * there is an existing device with that name. ignore errors\n         * from virNetDevExists(), just in case it isn't implemented\n         * on this platform (probably impossible).\n         */\n        if (!(virNetworkObjBridgeInUse(nets, newname, def->name) ||\n              virNetDevExists(newname) == 1)) {\n            VIR_FREE(def->bridge); /*could contain template */\n            def->bridge = newname;\n            ret = 0;\n            goto cleanup;\n        }\n        VIR_FREE(newname);\n    } while (++id <= MAX_BRIDGE_ID);\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Bridge generation exceeded max id %d\"),\n                   MAX_BRIDGE_ID);\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        VIR_FREE(newname);\n    return ret;\n}"
  },
  {
    "function_name": "networkIsPersistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3249-3266",
    "snippet": "static int\nnetworkIsPersistent(virNetworkPtr net)\n{\n    virNetworkObjPtr obj;\n    int ret = -1;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return ret;\n\n    if (virNetworkIsPersistentEnsureACL(net->conn, virNetworkObjGetDef(obj)) < 0)\n        goto cleanup;\n\n    ret = virNetworkObjIsPersistent(obj);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsPersistent",
          "args": [
            "obj"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsPersistent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "185-189",
          "snippet": "bool\nvirNetworkObjIsPersistent(virNetworkObjPtr obj)\n{\n    return obj->persistent;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsPersistent(virNetworkObjPtr obj)\n{\n    return obj->persistent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkIsPersistentEnsureACL",
          "args": [
            "net->conn",
            "virNetworkObjGetDef(obj)"
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 3258
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "net"
          ],
          "line": 3255
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkIsPersistent(virNetworkPtr net)\n{\n    virNetworkObjPtr obj;\n    int ret = -1;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return ret;\n\n    if (virNetworkIsPersistentEnsureACL(net->conn, virNetworkObjGetDef(obj)) < 0)\n        goto cleanup;\n\n    ret = virNetworkObjIsPersistent(obj);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkIsActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3229-3246",
    "snippet": "static int\nnetworkIsActive(virNetworkPtr net)\n{\n    virNetworkObjPtr obj;\n    int ret = -1;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return ret;\n\n    if (virNetworkIsActiveEnsureACL(net->conn, virNetworkObjGetDef(obj)) < 0)\n        goto cleanup;\n\n    ret = virNetworkObjIsActive(obj);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 3241
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkIsActiveEnsureACL",
          "args": [
            "net->conn",
            "virNetworkObjGetDef(obj)"
          ],
          "line": 3238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkObjFromNetwork",
          "args": [
            "net"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "networkObjFromNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "297-313",
          "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkIsActive(virNetworkPtr net)\n{\n    virNetworkObjPtr obj;\n    int ret = -1;\n\n    if (!(obj = networkObjFromNetwork(net)))\n        return ret;\n\n    if (virNetworkIsActiveEnsureACL(net->conn, virNetworkObjGetDef(obj)) < 0)\n        goto cleanup;\n\n    ret = virNetworkObjIsActive(obj);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkConnectNetworkEventDeregisterAny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3211-3226",
    "snippet": "static int\nnetworkConnectNetworkEventDeregisterAny(virConnectPtr conn,\n                                        int callbackID)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n\n    if (virConnectNetworkEventDeregisterAnyEnsureACL(conn) < 0)\n        return -1;\n\n    if (virObjectEventStateDeregisterID(conn,\n                                        driver->networkEventState,\n                                        callbackID, true) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectEventStateDeregisterID",
          "args": [
            "conn",
            "driver->networkEventState",
            "callbackID",
            "true"
          ],
          "line": 3220
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateDeregisterID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "936-957",
          "snippet": "int\nvirObjectEventStateDeregisterID(virConnectPtr conn,\n                                virObjectEventStatePtr state,\n                                int callbackID,\n                                bool doFreeCb)\n{\n    int ret;\n\n    virObjectLock(state);\n    if (state->isDispatching)\n        ret = virObjectEventCallbackListMarkDeleteID(conn,\n                                                     state->callbacks,\n                                                     callbackID);\n    else\n        ret = virObjectEventCallbackListRemoveID(conn, state->callbacks,\n                                                 callbackID, doFreeCb);\n\n    virObjectEventStateCleanupTimer(state, true);\n\n    virObjectUnlock(state);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nint\nvirObjectEventStateDeregisterID(virConnectPtr conn,\n                                virObjectEventStatePtr state,\n                                int callbackID,\n                                bool doFreeCb)\n{\n    int ret;\n\n    virObjectLock(state);\n    if (state->isDispatching)\n        ret = virObjectEventCallbackListMarkDeleteID(conn,\n                                                     state->callbacks,\n                                                     callbackID);\n    else\n        ret = virObjectEventCallbackListRemoveID(conn, state->callbacks,\n                                                 callbackID, doFreeCb);\n\n    virObjectEventStateCleanupTimer(state, true);\n\n    virObjectUnlock(state);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectNetworkEventDeregisterAnyEnsureACL",
          "args": [
            "conn"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 3215
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkConnectNetworkEventDeregisterAny(virConnectPtr conn,\n                                        int callbackID)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n\n    if (virConnectNetworkEventDeregisterAnyEnsureACL(conn) < 0)\n        return -1;\n\n    if (virObjectEventStateDeregisterID(conn,\n                                        driver->networkEventState,\n                                        callbackID, true) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "networkConnectNetworkEventRegisterAny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3188-3208",
    "snippet": "static int\nnetworkConnectNetworkEventRegisterAny(virConnectPtr conn,\n                                      virNetworkPtr net,\n                                      int eventID,\n                                      virConnectNetworkEventGenericCallback callback,\n                                      void *opaque,\n                                      virFreeCallback freecb)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    int ret = -1;\n\n    if (virConnectNetworkEventRegisterAnyEnsureACL(conn) < 0)\n        return -1;\n\n    if (virNetworkEventStateRegisterID(conn, driver->networkEventState,\n                                       net, eventID, callback,\n                                       opaque, freecb, &ret) < 0)\n        ret = -1;\n\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkEventStateRegisterID",
          "args": [
            "conn",
            "driver->networkEventState",
            "net",
            "eventID",
            "callback",
            "opaque",
            "freecb",
            "&ret"
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkEventStateRegisterID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_event.c",
          "lines": "135-158",
          "snippet": "int\nvirNetworkEventStateRegisterID(virConnectPtr conn,\n                               virObjectEventStatePtr state,\n                               virNetworkPtr net,\n                               int eventID,\n                               virConnectNetworkEventGenericCallback cb,\n                               void *opaque,\n                               virFreeCallback freecb,\n                               int *callbackID)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (virNetworkEventsInitialize() < 0)\n        return -1;\n\n    if (net)\n        virUUIDFormat(net->uuid, uuidstr);\n    return virObjectEventStateRegisterID(conn, state, net ? uuidstr : NULL,\n                                         NULL, NULL,\n                                         virNetworkEventClass, eventID,\n                                         VIR_OBJECT_EVENT_CALLBACK(cb),\n                                         opaque, freecb,\n                                         false, callbackID, false);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetworkEventClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include <config.h>\n\nstatic virClassPtr virNetworkEventClass;\n\nint\nvirNetworkEventStateRegisterID(virConnectPtr conn,\n                               virObjectEventStatePtr state,\n                               virNetworkPtr net,\n                               int eventID,\n                               virConnectNetworkEventGenericCallback cb,\n                               void *opaque,\n                               virFreeCallback freecb,\n                               int *callbackID)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (virNetworkEventsInitialize() < 0)\n        return -1;\n\n    if (net)\n        virUUIDFormat(net->uuid, uuidstr);\n    return virObjectEventStateRegisterID(conn, state, net ? uuidstr : NULL,\n                                         NULL, NULL,\n                                         virNetworkEventClass, eventID,\n                                         VIR_OBJECT_EVENT_CALLBACK(cb),\n                                         opaque, freecb,\n                                         false, callbackID, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectNetworkEventRegisterAnyEnsureACL",
          "args": [
            "conn"
          ],
          "line": 3199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 3196
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkConnectNetworkEventRegisterAny(virConnectPtr conn,\n                                      virNetworkPtr net,\n                                      int eventID,\n                                      virConnectNetworkEventGenericCallback callback,\n                                      void *opaque,\n                                      virFreeCallback freecb)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    int ret = -1;\n\n    if (virConnectNetworkEventRegisterAnyEnsureACL(conn) < 0)\n        return -1;\n\n    if (virNetworkEventStateRegisterID(conn, driver->networkEventState,\n                                       net, eventID, callback,\n                                       opaque, freecb, &ret) < 0)\n        ret = -1;\n\n    return ret;\n}"
  },
  {
    "function_name": "networkConnectListAllNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3170-3185",
    "snippet": "static int\nnetworkConnectListAllNetworks(virConnectPtr conn,\n                              virNetworkPtr **nets,\n                              unsigned int flags)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n\n    virCheckFlags(VIR_CONNECT_LIST_NETWORKS_FILTERS_ALL, -1);\n\n    if (virConnectListAllNetworksEnsureACL(conn) < 0)\n        return -1;\n\n    return virNetworkObjListExport(conn, driver->networks, nets,\n                                   virConnectListAllNetworksCheckACL,\n                                   flags);\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjListExport",
          "args": [
            "conn",
            "driver->networks",
            "nets",
            "virConnectListAllNetworksCheckACL",
            "flags"
          ],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjListExport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1401-1437",
          "snippet": "int\nvirNetworkObjListExport(virConnectPtr conn,\n                        virNetworkObjListPtr netobjs,\n                        virNetworkPtr **nets,\n                        virNetworkObjListFilter filter,\n                        unsigned int flags)\n{\n    int ret = -1;\n    virNetworkObjListExportData data = {\n        .conn = conn, .nets = NULL, .filter = filter, .flags = flags,\n        .nnets = 0, .error = false };\n\n    virObjectRWLockRead(netobjs);\n    if (nets && VIR_ALLOC_N(data.nets, virHashSize(netobjs->objs) + 1) < 0)\n        goto cleanup;\n\n    virHashForEach(netobjs->objs, virNetworkObjListExportCallback, &data);\n\n    if (data.error)\n        goto cleanup;\n\n    if (data.nets) {\n        /* trim the array to the final size */\n        ignore_value(VIR_REALLOC_N(data.nets, data.nnets + 1));\n        *nets = data.nets;\n        data.nets = NULL;\n    }\n\n    ret = data.nnets;\n cleanup:\n    virObjectRWUnlock(netobjs);\n    while (data.nets && data.nnets)\n        virObjectUnref(data.nets[--data.nnets]);\n\n    VIR_FREE(data.nets);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirNetworkObjListExport(virConnectPtr conn,\n                        virNetworkObjListPtr netobjs,\n                        virNetworkPtr **nets,\n                        virNetworkObjListFilter filter,\n                        unsigned int flags)\n{\n    int ret = -1;\n    virNetworkObjListExportData data = {\n        .conn = conn, .nets = NULL, .filter = filter, .flags = flags,\n        .nnets = 0, .error = false };\n\n    virObjectRWLockRead(netobjs);\n    if (nets && VIR_ALLOC_N(data.nets, virHashSize(netobjs->objs) + 1) < 0)\n        goto cleanup;\n\n    virHashForEach(netobjs->objs, virNetworkObjListExportCallback, &data);\n\n    if (data.error)\n        goto cleanup;\n\n    if (data.nets) {\n        /* trim the array to the final size */\n        ignore_value(VIR_REALLOC_N(data.nets, data.nnets + 1));\n        *nets = data.nets;\n        data.nets = NULL;\n    }\n\n    ret = data.nnets;\n cleanup:\n    virObjectRWUnlock(netobjs);\n    while (data.nets && data.nnets)\n        virObjectUnref(data.nets[--data.nnets]);\n\n    VIR_FREE(data.nets);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectListAllNetworksEnsureACL",
          "args": [
            "conn"
          ],
          "line": 3179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_LIST_NETWORKS_FILTERS_ALL",
            "-1"
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 3175
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkConnectListAllNetworks(virConnectPtr conn,\n                              virNetworkPtr **nets,\n                              unsigned int flags)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n\n    virCheckFlags(VIR_CONNECT_LIST_NETWORKS_FILTERS_ALL, -1);\n\n    if (virConnectListAllNetworksEnsureACL(conn) < 0)\n        return -1;\n\n    return virNetworkObjListExport(conn, driver->networks, nets,\n                                   virConnectListAllNetworksCheckACL,\n                                   flags);\n}"
  },
  {
    "function_name": "networkConnectListDefinedNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3154-3167",
    "snippet": "static int\nnetworkConnectListDefinedNetworks(virConnectPtr conn,\n                                  char **const names,\n                                  int maxnames)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n\n    if (virConnectListDefinedNetworksEnsureACL(conn) < 0)\n        return -1;\n\n    return virNetworkObjListGetNames(driver->networks, false, names, maxnames,\n                                     virConnectListDefinedNetworksCheckACL,\n                                     conn);\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjListGetNames",
          "args": [
            "driver->networks",
            "false",
            "names",
            "maxnames",
            "virConnectListDefinedNetworksCheckACL",
            "conn"
          ],
          "line": 3164
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjListGetNames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1530-1558",
          "snippet": "int\nvirNetworkObjListGetNames(virNetworkObjListPtr nets,\n                          bool active,\n                          char **names,\n                          int maxnames,\n                          virNetworkObjListFilter filter,\n                          virConnectPtr conn)\n{\n    int ret = -1;\n\n    struct virNetworkObjListGetHelperData data = {\n        .conn = conn, .filter = filter, .names = names, .nnames = 0,\n        .maxnames = maxnames, .active = active, .error = false};\n\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListGetHelper, &data);\n    virObjectRWUnlock(nets);\n\n    if (data.error)\n        goto cleanup;\n\n    ret = data.nnames;\n cleanup:\n    if (ret < 0) {\n        while (data.nnames)\n            VIR_FREE(data.names[--data.nnames]);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirNetworkObjListGetNames(virNetworkObjListPtr nets,\n                          bool active,\n                          char **names,\n                          int maxnames,\n                          virNetworkObjListFilter filter,\n                          virConnectPtr conn)\n{\n    int ret = -1;\n\n    struct virNetworkObjListGetHelperData data = {\n        .conn = conn, .filter = filter, .names = names, .nnames = 0,\n        .maxnames = maxnames, .active = active, .error = false};\n\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListGetHelper, &data);\n    virObjectRWUnlock(nets);\n\n    if (data.error)\n        goto cleanup;\n\n    ret = data.nnames;\n cleanup:\n    if (ret < 0) {\n        while (data.nnames)\n            VIR_FREE(data.names[--data.nnames]);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectListDefinedNetworksEnsureACL",
          "args": [
            "conn"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkConnectListDefinedNetworks(virConnectPtr conn,\n                                  char **const names,\n                                  int maxnames)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n\n    if (virConnectListDefinedNetworksEnsureACL(conn) < 0)\n        return -1;\n\n    return virNetworkObjListGetNames(driver->networks, false, names, maxnames,\n                                     virConnectListDefinedNetworksCheckACL,\n                                     conn);\n}"
  },
  {
    "function_name": "networkConnectNumOfDefinedNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3140-3151",
    "snippet": "static int\nnetworkConnectNumOfDefinedNetworks(virConnectPtr conn)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n\n    if (virConnectNumOfDefinedNetworksEnsureACL(conn) < 0)\n        return -1;\n\n    return virNetworkObjListNumOfNetworks(driver->networks, false,\n                                          virConnectNumOfDefinedNetworksCheckACL,\n                                          conn);\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjListNumOfNetworks",
          "args": [
            "driver->networks",
            "false",
            "virConnectNumOfDefinedNetworksCheckACL",
            "conn"
          ],
          "line": 3148
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjListNumOfNetworks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1561-1576",
          "snippet": "int\nvirNetworkObjListNumOfNetworks(virNetworkObjListPtr nets,\n                               bool active,\n                               virNetworkObjListFilter filter,\n                               virConnectPtr conn)\n{\n    struct virNetworkObjListGetHelperData data = {\n        .conn = conn, .filter = filter, .names = NULL, .nnames = 0,\n        .maxnames = -1, .active = active, .error = false};\n\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListGetHelper, &data);\n    virObjectRWUnlock(nets);\n\n    return data.nnames;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirNetworkObjListNumOfNetworks(virNetworkObjListPtr nets,\n                               bool active,\n                               virNetworkObjListFilter filter,\n                               virConnectPtr conn)\n{\n    struct virNetworkObjListGetHelperData data = {\n        .conn = conn, .filter = filter, .names = NULL, .nnames = 0,\n        .maxnames = -1, .active = active, .error = false};\n\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListGetHelper, &data);\n    virObjectRWUnlock(nets);\n\n    return data.nnames;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectNumOfDefinedNetworksEnsureACL",
          "args": [
            "conn"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkConnectNumOfDefinedNetworks(virConnectPtr conn)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n\n    if (virConnectNumOfDefinedNetworksEnsureACL(conn) < 0)\n        return -1;\n\n    return virNetworkObjListNumOfNetworks(driver->networks, false,\n                                          virConnectNumOfDefinedNetworksCheckACL,\n                                          conn);\n}"
  },
  {
    "function_name": "networkConnectListNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3125-3137",
    "snippet": "static int\nnetworkConnectListNetworks(virConnectPtr conn,\n                           char **const names,\n                           int maxnames)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n\n    if (virConnectListNetworksEnsureACL(conn) < 0)\n        return -1;\n\n    return virNetworkObjListGetNames(driver->networks, true, names, maxnames,\n                                     virConnectListNetworksCheckACL, conn);\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjListGetNames",
          "args": [
            "driver->networks",
            "true",
            "names",
            "maxnames",
            "virConnectListNetworksCheckACL",
            "conn"
          ],
          "line": 3135
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjListGetNames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1530-1558",
          "snippet": "int\nvirNetworkObjListGetNames(virNetworkObjListPtr nets,\n                          bool active,\n                          char **names,\n                          int maxnames,\n                          virNetworkObjListFilter filter,\n                          virConnectPtr conn)\n{\n    int ret = -1;\n\n    struct virNetworkObjListGetHelperData data = {\n        .conn = conn, .filter = filter, .names = names, .nnames = 0,\n        .maxnames = maxnames, .active = active, .error = false};\n\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListGetHelper, &data);\n    virObjectRWUnlock(nets);\n\n    if (data.error)\n        goto cleanup;\n\n    ret = data.nnames;\n cleanup:\n    if (ret < 0) {\n        while (data.nnames)\n            VIR_FREE(data.names[--data.nnames]);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirNetworkObjListGetNames(virNetworkObjListPtr nets,\n                          bool active,\n                          char **names,\n                          int maxnames,\n                          virNetworkObjListFilter filter,\n                          virConnectPtr conn)\n{\n    int ret = -1;\n\n    struct virNetworkObjListGetHelperData data = {\n        .conn = conn, .filter = filter, .names = names, .nnames = 0,\n        .maxnames = maxnames, .active = active, .error = false};\n\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListGetHelper, &data);\n    virObjectRWUnlock(nets);\n\n    if (data.error)\n        goto cleanup;\n\n    ret = data.nnames;\n cleanup:\n    if (ret < 0) {\n        while (data.nnames)\n            VIR_FREE(data.names[--data.nnames]);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectListNetworksEnsureACL",
          "args": [
            "conn"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 3130
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkConnectListNetworks(virConnectPtr conn,\n                           char **const names,\n                           int maxnames)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n\n    if (virConnectListNetworksEnsureACL(conn) < 0)\n        return -1;\n\n    return virNetworkObjListGetNames(driver->networks, true, names, maxnames,\n                                     virConnectListNetworksCheckACL, conn);\n}"
  },
  {
    "function_name": "networkConnectNumOfNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3111-3122",
    "snippet": "static int\nnetworkConnectNumOfNetworks(virConnectPtr conn)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n\n    if (virConnectNumOfNetworksEnsureACL(conn) < 0)\n        return -1;\n\n    return virNetworkObjListNumOfNetworks(driver->networks, true,\n                                          virConnectNumOfNetworksCheckACL,\n                                          conn);\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjListNumOfNetworks",
          "args": [
            "driver->networks",
            "true",
            "virConnectNumOfNetworksCheckACL",
            "conn"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjListNumOfNetworks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1561-1576",
          "snippet": "int\nvirNetworkObjListNumOfNetworks(virNetworkObjListPtr nets,\n                               bool active,\n                               virNetworkObjListFilter filter,\n                               virConnectPtr conn)\n{\n    struct virNetworkObjListGetHelperData data = {\n        .conn = conn, .filter = filter, .names = NULL, .nnames = 0,\n        .maxnames = -1, .active = active, .error = false};\n\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListGetHelper, &data);\n    virObjectRWUnlock(nets);\n\n    return data.nnames;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirNetworkObjListNumOfNetworks(virNetworkObjListPtr nets,\n                               bool active,\n                               virNetworkObjListFilter filter,\n                               virConnectPtr conn)\n{\n    struct virNetworkObjListGetHelperData data = {\n        .conn = conn, .filter = filter, .names = NULL, .nnames = 0,\n        .maxnames = -1, .active = active, .error = false};\n\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListGetHelper, &data);\n    virObjectRWUnlock(nets);\n\n    return data.nnames;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectNumOfNetworksEnsureACL",
          "args": [
            "conn"
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 3114
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkConnectNumOfNetworks(virConnectPtr conn)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n\n    if (virConnectNumOfNetworksEnsureACL(conn) < 0)\n        return -1;\n\n    return virNetworkObjListNumOfNetworks(driver->networks, true,\n                                          virConnectNumOfNetworksCheckACL,\n                                          conn);\n}"
  },
  {
    "function_name": "networkLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3083-3108",
    "snippet": "static virNetworkPtr\nnetworkLookupByName(virConnectPtr conn,\n                    const char *name)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virNetworkPtr net = NULL;\n\n    obj = virNetworkObjFindByName(driver->networks, name);\n    if (!obj) {\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching name '%s'\"), name);\n        goto cleanup;\n    }\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkLookupByNameEnsureACL(conn, def) < 0)\n        goto cleanup;\n\n    net = virGetNetwork(conn, def->name, def->uuid);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return net;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 3106
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetNetwork",
          "args": [
            "conn",
            "def->name",
            "def->uuid"
          ],
          "line": 3103
        },
        "resolved": true,
        "details": {
          "function_name": "virGetNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "341-366",
          "snippet": "virNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virNetworkClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virNetworkClass;\n\nvirNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkLookupByNameEnsureACL",
          "args": [
            "conn",
            "def"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 3098
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_NETWORK",
            "_(\"no network with matching name '%s'\")",
            "name"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no network with matching name '%s'\""
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjFindByName",
          "args": [
            "driver->networks",
            "name"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjFindByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "444-456",
          "snippet": "virNetworkObjPtr\nvirNetworkObjFindByName(virNetworkObjListPtr nets,\n                        const char *name)\n{\n    virNetworkObjPtr obj;\n\n    virObjectRWLockRead(nets);\n    obj = virNetworkObjFindByNameLocked(nets, name);\n    virObjectRWUnlock(nets);\n    if (obj)\n        virObjectLock(obj);\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkObjPtr\nvirNetworkObjFindByName(virNetworkObjListPtr nets,\n                        const char *name)\n{\n    virNetworkObjPtr obj;\n\n    virObjectRWLockRead(nets);\n    obj = virNetworkObjFindByNameLocked(nets, name);\n    virObjectRWUnlock(nets);\n    if (obj)\n        virObjectLock(obj);\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkPtr\nnetworkLookupByName(virConnectPtr conn,\n                    const char *name)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virNetworkPtr net = NULL;\n\n    obj = virNetworkObjFindByName(driver->networks, name);\n    if (!obj) {\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching name '%s'\"), name);\n        goto cleanup;\n    }\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkLookupByNameEnsureACL(conn, def) < 0)\n        goto cleanup;\n\n    net = virGetNetwork(conn, def->name, def->uuid);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return net;\n}"
  },
  {
    "function_name": "networkLookupByUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "3052-3080",
    "snippet": "static virNetworkPtr\nnetworkLookupByUUID(virConnectPtr conn,\n                    const unsigned char *uuid)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virNetworkPtr net = NULL;\n\n    obj = virNetworkObjFindByUUID(driver->networks, uuid);\n    if (!obj) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n        virUUIDFormat(uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s'\"),\n                       uuidstr);\n        goto cleanup;\n    }\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkLookupByUUIDEnsureACL(conn, def) < 0)\n        goto cleanup;\n\n    net = virGetNetwork(conn, def->name, def->uuid);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return net;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 3078
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "136-145",
          "snippet": "void\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjEndAPI(virNetworkObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetNetwork",
          "args": [
            "conn",
            "def->name",
            "def->uuid"
          ],
          "line": 3075
        },
        "resolved": true,
        "details": {
          "function_name": "virGetNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "341-366",
          "snippet": "virNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virNetworkClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virNetworkClass;\n\nvirNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkLookupByUUIDEnsureACL",
          "args": [
            "conn",
            "def"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 3070
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_NETWORK",
            "_(\"no network with matching uuid '%s'\")",
            "uuidstr"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no network with matching uuid '%s'\""
          ],
          "line": 3066
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "uuidstr"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjFindByUUID",
          "args": [
            "driver->networks",
            "uuid"
          ],
          "line": 3061
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjFindByUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "390-402",
          "snippet": "virNetworkObjPtr\nvirNetworkObjFindByUUID(virNetworkObjListPtr nets,\n                        const unsigned char *uuid)\n{\n    virNetworkObjPtr obj;\n\n    virObjectRWLockRead(nets);\n    obj = virNetworkObjFindByUUIDLocked(nets, uuid);\n    virObjectRWUnlock(nets);\n    if (obj)\n        virObjectLock(obj);\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkObjPtr\nvirNetworkObjFindByUUID(virNetworkObjListPtr nets,\n                        const unsigned char *uuid)\n{\n    virNetworkObjPtr obj;\n\n    virObjectRWLockRead(nets);\n    obj = virNetworkObjFindByUUIDLocked(nets, uuid);\n    virObjectRWUnlock(nets);\n    if (obj)\n        virObjectLock(obj);\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 3056
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkPtr\nnetworkLookupByUUID(virConnectPtr conn,\n                    const unsigned char *uuid)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    virNetworkDefPtr def;\n    virNetworkPtr net = NULL;\n\n    obj = virNetworkObjFindByUUID(driver->networks, uuid);\n    if (!obj) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n        virUUIDFormat(uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s'\"),\n                       uuidstr);\n        goto cleanup;\n    }\n    def = virNetworkObjGetDef(obj);\n\n    if (virNetworkLookupByUUIDEnsureACL(conn, def) < 0)\n        goto cleanup;\n\n    net = virGetNetwork(conn, def->name, def->uuid);\n\n cleanup:\n    virNetworkObjEndAPI(&obj);\n    return net;\n}"
  },
  {
    "function_name": "networkShutdownNetwork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2989-3049",
    "snippet": "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = 0;\n    char *stateFile;\n\n    VIR_INFO(\"Shutting down network '%s'\", def->name);\n\n    if (!virNetworkObjIsActive(obj))\n        return 0;\n\n    stateFile = virNetworkConfigFile(driver->stateDir, def->name);\n    if (!stateFile)\n        return -1;\n\n    unlink(stateFile);\n    VIR_FREE(stateFile);\n\n    switch ((virNetworkForwardType) def->forward.type) {\n\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        ret = networkShutdownNetworkVirtual(driver, obj);\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            ret = networkShutdownNetworkBridge(obj);\n            break;\n        }\n        /* intentionally fall through to the macvtap/direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         * (since that is macvtap bridge mode).\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        ret = networkShutdownNetworkExternal(obj);\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    /* now that we know it's stopped call the hook if present */\n    networkRunHook(obj, NULL, VIR_HOOK_NETWORK_OP_STOPPED,\n                   VIR_HOOK_SUBOP_END);\n\n    virNetworkObjSetActive(obj, false);\n    virNetworkObjUnsetDefTransient(obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjUnsetDefTransient",
          "args": [
            "obj"
          ],
          "line": 3047
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjUnsetDefTransient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "696-704",
          "snippet": "void\nvirNetworkObjUnsetDefTransient(virNetworkObjPtr obj)\n{\n    if (obj->newDef) {\n        virNetworkDefFree(obj->def);\n        obj->def = obj->newDef;\n        obj->newDef = NULL;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjUnsetDefTransient(virNetworkObjPtr obj)\n{\n    if (obj->newDef) {\n        virNetworkDefFree(obj->def);\n        obj->def = obj->newDef;\n        obj->newDef = NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetActive",
          "args": [
            "obj",
            "false"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "177-182",
          "snippet": "void\nvirNetworkObjSetActive(virNetworkObjPtr obj,\n                       bool active)\n{\n    obj->active = active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetActive(virNetworkObjPtr obj,\n                       bool active)\n{\n    obj->active = active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRunHook",
          "args": [
            "obj",
            "NULL",
            "VIR_HOOK_NETWORK_OP_STOPPED",
            "VIR_HOOK_SUBOP_END"
          ],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "networkRunHook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "316-364",
          "snippet": "static int\nnetworkRunHook(virNetworkObjPtr obj,\n               virNetworkPortDefPtr port,\n               int op,\n               int sub_op)\n{\n    virNetworkDefPtr def;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xml = NULL;\n    int hookret;\n    int ret = -1;\n\n    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {\n        if (!obj) {\n            VIR_DEBUG(\"Not running hook as @obj is NULL\");\n            ret = 0;\n            goto cleanup;\n        }\n        def = virNetworkObjGetDef(obj);\n\n        virBufferAddLit(&buf, \"<hookData>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        if (virNetworkDefFormatBuf(&buf, def, network_driver->xmlopt, 0) < 0)\n            goto cleanup;\n        if (port && virNetworkPortDefFormatBuf(&buf, port) < 0)\n            goto cleanup;\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</hookData>\");\n\n        xml = virBufferContentAndReset(&buf);\n        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, def->name,\n                              op, sub_op, NULL, xml, NULL);\n\n        /*\n         * If the script raised an error, pass it to the callee.\n         */\n        if (hookret < 0)\n            goto cleanup;\n\n        networkNetworkObjTaint(obj, VIR_NETWORK_TAINT_HOOK);\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n    VIR_FREE(xml);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkRunHook(virNetworkObjPtr obj,\n               virNetworkPortDefPtr port,\n               int op,\n               int sub_op)\n{\n    virNetworkDefPtr def;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xml = NULL;\n    int hookret;\n    int ret = -1;\n\n    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {\n        if (!obj) {\n            VIR_DEBUG(\"Not running hook as @obj is NULL\");\n            ret = 0;\n            goto cleanup;\n        }\n        def = virNetworkObjGetDef(obj);\n\n        virBufferAddLit(&buf, \"<hookData>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        if (virNetworkDefFormatBuf(&buf, def, network_driver->xmlopt, 0) < 0)\n            goto cleanup;\n        if (port && virNetworkPortDefFormatBuf(&buf, port) < 0)\n            goto cleanup;\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</hookData>\");\n\n        xml = virBufferContentAndReset(&buf);\n        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, def->name,\n                              op, sub_op, NULL, xml, NULL);\n\n        /*\n         * If the script raised an error, pass it to the callee.\n         */\n        if (hookret < 0)\n            goto cleanup;\n\n        networkNetworkObjTaint(obj, VIR_NETWORK_TAINT_HOOK);\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n    VIR_FREE(xml);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkForwardType",
            "def->forward.type"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkShutdownNetworkExternal",
          "args": [
            "obj"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "networkShutdownNetworkExternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2878-2887",
          "snippet": "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj G_GNUC_UNUSED)\n{\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE, PRIVATE, VEPA, HOSTDEV or PASSTHROUGH is shutdown. On\n     * failure, undo anything you've done, and return -1. On success\n     * return 0.\n     */\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj G_GNUC_UNUSED)\n{\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE, PRIVATE, VEPA, HOSTDEV or PASSTHROUGH is shutdown. On\n     * failure, undo anything you've done, and return -1. On success\n     * return 0.\n     */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkShutdownNetworkBridge",
          "args": [
            "obj"
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "networkShutdownNetworkBridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2739-2752",
          "snippet": "static int\nnetworkShutdownNetworkBridge(virNetworkObjPtr obj G_GNUC_UNUSED)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE is shutdown. On failure, undo anything you've done,\n     * and return -1. On success return 0.\n     */\n    if (def->bandwidth)\n       virNetDevBandwidthClear(def->bridge);\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkShutdownNetworkBridge(virNetworkObjPtr obj G_GNUC_UNUSED)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE is shutdown. On failure, undo anything you've done,\n     * and return -1. On success return 0.\n     */\n    if (def->bandwidth)\n       virNetDevBandwidthClear(def->bridge);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkShutdownNetworkVirtual",
          "args": [
            "driver",
            "obj"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "networkShutdownNetworkVirtual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2654-2712",
          "snippet": "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    pid_t radvdPid;\n    pid_t dnsmasqPid;\n\n    if (def->bandwidth)\n        virNetDevBandwidthClear(def->bridge);\n\n    virNetworkObjUnrefMacMap(obj);\n\n    radvdPid = virNetworkObjGetRadvdPid(obj);\n    if (radvdPid > 0) {\n        char *radvdpidbase;\n\n        kill(radvdPid, SIGTERM);\n        /* attempt to delete the pidfile we created */\n        if ((radvdpidbase = networkRadvdPidfileBasename(def->name))) {\n            virPidFileDelete(driver->pidDir, radvdpidbase);\n            VIR_FREE(radvdpidbase);\n        }\n    }\n\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    if (dnsmasqPid > 0)\n        kill(dnsmasqPid, SIGTERM);\n\n    if (def->mac_specified) {\n        char *macTapIfName = networkBridgeDummyNicName(def->bridge);\n        if (macTapIfName) {\n            ignore_value(virNetDevTapDelete(macTapIfName, NULL));\n            VIR_FREE(macTapIfName);\n        }\n    }\n\n    ignore_value(virNetDevSetOnline(def->bridge, 0));\n\n    if (def->forward.type != VIR_NETWORK_FORWARD_OPEN)\n        networkRemoveFirewallRules(def);\n\n    ignore_value(virNetDevBridgeDelete(def->bridge));\n\n    /* See if its still alive and really really kill it */\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    if (dnsmasqPid > 0 &&\n        (kill(dnsmasqPid, 0) == 0))\n        kill(dnsmasqPid, SIGKILL);\n    virNetworkObjSetDnsmasqPid(obj, -1);\n\n    radvdPid = virNetworkObjGetRadvdPid(obj);\n    if (radvdPid > 0 &&\n        (kill(radvdPid, 0) == 0))\n        kill(radvdPid, SIGKILL);\n    virNetworkObjSetRadvdPid(obj, -1);\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    pid_t radvdPid;\n    pid_t dnsmasqPid;\n\n    if (def->bandwidth)\n        virNetDevBandwidthClear(def->bridge);\n\n    virNetworkObjUnrefMacMap(obj);\n\n    radvdPid = virNetworkObjGetRadvdPid(obj);\n    if (radvdPid > 0) {\n        char *radvdpidbase;\n\n        kill(radvdPid, SIGTERM);\n        /* attempt to delete the pidfile we created */\n        if ((radvdpidbase = networkRadvdPidfileBasename(def->name))) {\n            virPidFileDelete(driver->pidDir, radvdpidbase);\n            VIR_FREE(radvdpidbase);\n        }\n    }\n\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    if (dnsmasqPid > 0)\n        kill(dnsmasqPid, SIGTERM);\n\n    if (def->mac_specified) {\n        char *macTapIfName = networkBridgeDummyNicName(def->bridge);\n        if (macTapIfName) {\n            ignore_value(virNetDevTapDelete(macTapIfName, NULL));\n            VIR_FREE(macTapIfName);\n        }\n    }\n\n    ignore_value(virNetDevSetOnline(def->bridge, 0));\n\n    if (def->forward.type != VIR_NETWORK_FORWARD_OPEN)\n        networkRemoveFirewallRules(def);\n\n    ignore_value(virNetDevBridgeDelete(def->bridge));\n\n    /* See if its still alive and really really kill it */\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    if (dnsmasqPid > 0 &&\n        (kill(dnsmasqPid, 0) == 0))\n        kill(dnsmasqPid, SIGKILL);\n    virNetworkObjSetDnsmasqPid(obj, -1);\n\n    radvdPid = virNetworkObjGetRadvdPid(obj);\n    if (radvdPid > 0 &&\n        (kill(radvdPid, 0) == 0))\n        kill(radvdPid, SIGKILL);\n    virNetworkObjSetRadvdPid(obj, -1);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "stateFile"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "stateFile"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkConfigFile",
          "args": [
            "driver->stateDir",
            "def->name"
          ],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkConfigFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2770-2778",
          "snippet": "char *\nvirNetworkConfigFile(const char *dir,\n                     const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNetworkConfigFile(const char *dir,\n                     const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 2999
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Shutting down network '%s'\"",
            "def->name"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2993
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = 0;\n    char *stateFile;\n\n    VIR_INFO(\"Shutting down network '%s'\", def->name);\n\n    if (!virNetworkObjIsActive(obj))\n        return 0;\n\n    stateFile = virNetworkConfigFile(driver->stateDir, def->name);\n    if (!stateFile)\n        return -1;\n\n    unlink(stateFile);\n    VIR_FREE(stateFile);\n\n    switch ((virNetworkForwardType) def->forward.type) {\n\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        ret = networkShutdownNetworkVirtual(driver, obj);\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            ret = networkShutdownNetworkBridge(obj);\n            break;\n        }\n        /* intentionally fall through to the macvtap/direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         * (since that is macvtap bridge mode).\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        ret = networkShutdownNetworkExternal(obj);\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    /* now that we know it's stopped call the hook if present */\n    networkRunHook(obj, NULL, VIR_HOOK_NETWORK_OP_STOPPED,\n                   VIR_HOOK_SUBOP_END);\n\n    virNetworkObjSetActive(obj, false);\n    virNetworkObjUnsetDefTransient(obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkStartNetwork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2890-2986",
    "snippet": "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n\n    VIR_DEBUG(\"driver=%p, network=%p\", driver, obj);\n\n    if (virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"network is already active\"));\n        return ret;\n    }\n\n    VIR_DEBUG(\"Beginning network startup process\");\n\n    virNetworkObjDeleteAllPorts(obj, driver->stateDir);\n\n    VIR_DEBUG(\"Setting current network def as transient\");\n    if (virNetworkObjSetDefTransient(obj, true, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices.\n     * If the script raised an error abort the launch. */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_START,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    switch ((virNetworkForwardType) def->forward.type) {\n\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        if (networkStartNetworkVirtual(driver, obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            if (networkStartNetworkBridge(obj) < 0)\n                goto cleanup;\n            break;\n        }\n        /* intentionally fall through to the macvtap/direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         * (since that is macvtap bridge mode).\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        if (networkStartNetworkExternal(obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto cleanup;\n    }\n\n    virNetworkObjSetFloorSum(obj, 0);\n\n    /* finally we can call the 'started' hook script if any */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_STARTED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    /* Persist the live configuration now that anything autogenerated\n     * is setup.\n     */\n    VIR_DEBUG(\"Writing network status to disk\");\n    if (virNetworkObjSaveStatus(driver->stateDir,\n                                obj, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    virNetworkObjSetActive(obj, true);\n    VIR_INFO(\"Network '%s' started up\", def->name);\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virErrorPtr save_err;\n\n        virErrorPreserveLast(&save_err);\n        virNetworkObjUnsetDefTransient(obj);\n        networkShutdownNetwork(driver, obj);\n        virErrorRestore(&save_err);\n    }\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverStatePtr network_driver;",
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&save_err"
          ],
          "line": 2983
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkShutdownNetwork",
          "args": [
            "driver",
            "obj"
          ],
          "line": 2982
        },
        "resolved": true,
        "details": {
          "function_name": "networkShutdownNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2989-3049",
          "snippet": "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = 0;\n    char *stateFile;\n\n    VIR_INFO(\"Shutting down network '%s'\", def->name);\n\n    if (!virNetworkObjIsActive(obj))\n        return 0;\n\n    stateFile = virNetworkConfigFile(driver->stateDir, def->name);\n    if (!stateFile)\n        return -1;\n\n    unlink(stateFile);\n    VIR_FREE(stateFile);\n\n    switch ((virNetworkForwardType) def->forward.type) {\n\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        ret = networkShutdownNetworkVirtual(driver, obj);\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            ret = networkShutdownNetworkBridge(obj);\n            break;\n        }\n        /* intentionally fall through to the macvtap/direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         * (since that is macvtap bridge mode).\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        ret = networkShutdownNetworkExternal(obj);\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    /* now that we know it's stopped call the hook if present */\n    networkRunHook(obj, NULL, VIR_HOOK_NETWORK_OP_STOPPED,\n                   VIR_HOOK_SUBOP_END);\n\n    virNetworkObjSetActive(obj, false);\n    virNetworkObjUnsetDefTransient(obj);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = 0;\n    char *stateFile;\n\n    VIR_INFO(\"Shutting down network '%s'\", def->name);\n\n    if (!virNetworkObjIsActive(obj))\n        return 0;\n\n    stateFile = virNetworkConfigFile(driver->stateDir, def->name);\n    if (!stateFile)\n        return -1;\n\n    unlink(stateFile);\n    VIR_FREE(stateFile);\n\n    switch ((virNetworkForwardType) def->forward.type) {\n\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        ret = networkShutdownNetworkVirtual(driver, obj);\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            ret = networkShutdownNetworkBridge(obj);\n            break;\n        }\n        /* intentionally fall through to the macvtap/direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         * (since that is macvtap bridge mode).\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        ret = networkShutdownNetworkExternal(obj);\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    /* now that we know it's stopped call the hook if present */\n    networkRunHook(obj, NULL, VIR_HOOK_NETWORK_OP_STOPPED,\n                   VIR_HOOK_SUBOP_END);\n\n    virNetworkObjSetActive(obj, false);\n    virNetworkObjUnsetDefTransient(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjUnsetDefTransient",
          "args": [
            "obj"
          ],
          "line": 2981
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjUnsetDefTransient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "696-704",
          "snippet": "void\nvirNetworkObjUnsetDefTransient(virNetworkObjPtr obj)\n{\n    if (obj->newDef) {\n        virNetworkDefFree(obj->def);\n        obj->def = obj->newDef;\n        obj->newDef = NULL;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjUnsetDefTransient(virNetworkObjPtr obj)\n{\n    if (obj->newDef) {\n        virNetworkDefFree(obj->def);\n        obj->def = obj->newDef;\n        obj->newDef = NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&save_err"
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Network '%s' started up\"",
            "def->name"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetActive",
          "args": [
            "obj",
            "true"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "177-182",
          "snippet": "void\nvirNetworkObjSetActive(virNetworkObjPtr obj,\n                       bool active)\n{\n    obj->active = active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetActive(virNetworkObjPtr obj,\n                       bool active)\n{\n    obj->active = active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSaveStatus",
          "args": [
            "driver->stateDir",
            "obj",
            "network_driver->xmlopt"
          ],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSaveStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "851-870",
          "snippet": "int\nvirNetworkObjSaveStatus(const char *statusDir,\n                        virNetworkObjPtr obj,\n                        virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    int flags = 0;\n    char *xml;\n\n    if (!(xml = virNetworkObjFormat(obj, xmlopt, flags)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(statusDir, obj->def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nint\nvirNetworkObjSaveStatus(const char *statusDir,\n                        virNetworkObjPtr obj,\n                        virNetworkXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    int flags = 0;\n    char *xml;\n\n    if (!(xml = virNetworkObjFormat(obj, xmlopt, flags)))\n        goto cleanup;\n\n    if (virNetworkSaveXML(statusDir, obj->def, xml))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Writing network status to disk\""
          ],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkRunHook",
          "args": [
            "obj",
            "NULL",
            "VIR_HOOK_NETWORK_OP_STARTED",
            "VIR_HOOK_SUBOP_BEGIN"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "networkRunHook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "316-364",
          "snippet": "static int\nnetworkRunHook(virNetworkObjPtr obj,\n               virNetworkPortDefPtr port,\n               int op,\n               int sub_op)\n{\n    virNetworkDefPtr def;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xml = NULL;\n    int hookret;\n    int ret = -1;\n\n    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {\n        if (!obj) {\n            VIR_DEBUG(\"Not running hook as @obj is NULL\");\n            ret = 0;\n            goto cleanup;\n        }\n        def = virNetworkObjGetDef(obj);\n\n        virBufferAddLit(&buf, \"<hookData>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        if (virNetworkDefFormatBuf(&buf, def, network_driver->xmlopt, 0) < 0)\n            goto cleanup;\n        if (port && virNetworkPortDefFormatBuf(&buf, port) < 0)\n            goto cleanup;\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</hookData>\");\n\n        xml = virBufferContentAndReset(&buf);\n        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, def->name,\n                              op, sub_op, NULL, xml, NULL);\n\n        /*\n         * If the script raised an error, pass it to the callee.\n         */\n        if (hookret < 0)\n            goto cleanup;\n\n        networkNetworkObjTaint(obj, VIR_NETWORK_TAINT_HOOK);\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n    VIR_FREE(xml);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkRunHook(virNetworkObjPtr obj,\n               virNetworkPortDefPtr port,\n               int op,\n               int sub_op)\n{\n    virNetworkDefPtr def;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xml = NULL;\n    int hookret;\n    int ret = -1;\n\n    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {\n        if (!obj) {\n            VIR_DEBUG(\"Not running hook as @obj is NULL\");\n            ret = 0;\n            goto cleanup;\n        }\n        def = virNetworkObjGetDef(obj);\n\n        virBufferAddLit(&buf, \"<hookData>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        if (virNetworkDefFormatBuf(&buf, def, network_driver->xmlopt, 0) < 0)\n            goto cleanup;\n        if (port && virNetworkPortDefFormatBuf(&buf, port) < 0)\n            goto cleanup;\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</hookData>\");\n\n        xml = virBufferContentAndReset(&buf);\n        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, def->name,\n                              op, sub_op, NULL, xml, NULL);\n\n        /*\n         * If the script raised an error, pass it to the callee.\n         */\n        if (hookret < 0)\n            goto cleanup;\n\n        networkNetworkObjTaint(obj, VIR_NETWORK_TAINT_HOOK);\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n    VIR_FREE(xml);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetFloorSum",
          "args": [
            "obj",
            "0"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetFloorSum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "258-263",
          "snippet": "void\nvirNetworkObjSetFloorSum(virNetworkObjPtr obj,\n                         unsigned long long floor_sum)\n{\n    obj->floor_sum = floor_sum;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetFloorSum(virNetworkObjPtr obj,\n                         unsigned long long floor_sum)\n{\n    obj->floor_sum = floor_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkForwardType",
            "def->forward.type"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkStartNetworkExternal",
          "args": [
            "obj"
          ],
          "line": 2946
        },
        "resolved": true,
        "details": {
          "function_name": "networkStartNetworkExternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2866-2875",
          "snippet": "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj)\n{\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE, PRIVATE, VEPA, HOSTDEV or PASSTHROUGH is started. On\n     * failure, undo anything you've done, and return -1. On success\n     * return 0.\n     */\n    return networkCreateInterfacePool(virNetworkObjGetDef(obj));\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj)\n{\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE, PRIVATE, VEPA, HOSTDEV or PASSTHROUGH is started. On\n     * failure, undo anything you've done, and return -1. On success\n     * return 0.\n     */\n    return networkCreateInterfacePool(virNetworkObjGetDef(obj));\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkStartNetworkBridge",
          "args": [
            "obj"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "networkStartNetworkBridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2715-2736",
          "snippet": "static int\nnetworkStartNetworkBridge(virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE, is started. On failure, undo anything you've done,\n     * and return -1. On success return 0.\n     */\n    if (virNetDevBandwidthSet(def->bridge, def->bandwidth, true, true) < 0)\n        goto error;\n\n    if (networkStartHandleMACTableManagerMode(obj, NULL) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    if (def->bandwidth)\n       virNetDevBandwidthClear(def->bridge);\n    return -1;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkStartNetworkBridge(virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE, is started. On failure, undo anything you've done,\n     * and return -1. On success return 0.\n     */\n    if (virNetDevBandwidthSet(def->bridge, def->bandwidth, true, true) < 0)\n        goto error;\n\n    if (networkStartHandleMACTableManagerMode(obj, NULL) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    if (def->bandwidth)\n       virNetDevBandwidthClear(def->bridge);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkStartNetworkVirtual",
          "args": [
            "driver",
            "obj"
          ],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "networkStartNetworkVirtual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2440-2651",
          "snippet": "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    size_t i;\n    bool v4present = false, v6present = false;\n    virErrorPtr save_err = NULL;\n    virNetworkIPDefPtr ipdef;\n    virNetDevIPRoutePtr routedef;\n    char *macTapIfName = NULL;\n    virMacMapPtr macmap;\n    char *macMapFile = NULL;\n    int tapfd = -1;\n    bool dnsmasqStarted = false;\n    bool devOnline = false;\n    bool firewalRulesAdded = false;\n\n    /* Check to see if any network IP collides with an existing route */\n    if (networkCheckRouteCollision(def) < 0)\n        return -1;\n\n    /* Create and configure the bridge device */\n    if (!def->bridge) {\n        /* bridge name can only be empty if the config files were\n         * edited directly. Otherwise networkValidate() (called after\n         * parsing the XML from networkCreateXML() and\n         * networkDefine()) guarantees we will have a valid bridge\n         * name before this point. Since hand editing of the config\n         * files is explicitly prohibited we can, with clear\n         * conscience, log an error and fail at this point.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"network '%s' has no bridge name defined\"),\n                       def->name);\n        return -1;\n    }\n    if (virNetDevBridgeCreate(def->bridge, &def->mac) < 0)\n        return -1;\n\n    if (def->mac_specified) {\n        /* To set a mac for the bridge, we need to define a dummy tap\n         * device, set its mac, then attach it to the bridge. As long\n         * as its mac address is lower than any other interface that\n         * gets attached, the bridge will always maintain this mac\n         * address.\n         */\n        macTapIfName = networkBridgeDummyNicName(def->bridge);\n        if (!macTapIfName)\n            goto error;\n        /* Keep tun fd open and interface up to allow for IPv6 DAD to happen */\n        if (virNetDevTapCreateInBridgePort(def->bridge,\n                                           &macTapIfName, &def->mac,\n                                           NULL, NULL, &tapfd, 1, NULL, NULL,\n                                           VIR_TRISTATE_BOOL_NO,\n                                           NULL, def->mtu, NULL,\n                                           VIR_NETDEV_TAP_CREATE_USE_MAC_FOR_BRIDGE |\n                                           VIR_NETDEV_TAP_CREATE_IFUP |\n                                           VIR_NETDEV_TAP_CREATE_PERSIST) < 0) {\n            VIR_FREE(macTapIfName);\n            goto error;\n        }\n    }\n\n    if (!(macMapFile = virMacMapFileName(driver->dnsmasqStateDir,\n                                         def->bridge)) ||\n        !(macmap = virMacMapNew(macMapFile)))\n        goto error;\n\n    virNetworkObjSetMacMap(obj, macmap);\n    macmap = NULL;\n\n    /* Set bridge options */\n\n    /* delay is configured in seconds, but virNetDevBridgeSetSTPDelay\n     * expects milliseconds\n     */\n    if (virNetDevBridgeSetSTPDelay(def->bridge, def->delay * 1000) < 0)\n        goto error;\n\n    if (virNetDevBridgeSetSTP(def->bridge, def->stp ? true : false) < 0)\n        goto error;\n\n    /* Disable IPv6 on the bridge if there are no IPv6 addresses\n     * defined, and set other IPv6 sysctl tunables appropriately.\n     */\n    if (networkSetIPv6Sysctls(obj) < 0)\n        goto error;\n\n    /* Add \"once per network\" rules */\n    if (def->forward.type != VIR_NETWORK_FORWARD_OPEN &&\n        networkAddFirewallRules(def) < 0)\n        goto error;\n\n    firewalRulesAdded = true;\n\n    for (i = 0; (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i)); i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET))\n            v4present = true;\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n            v6present = true;\n\n        /* Add the IP address/netmask to the bridge */\n        if (networkAddAddrToBridge(obj, ipdef) < 0)\n            goto error;\n    }\n\n    if (networkStartHandleMACTableManagerMode(obj, macTapIfName) < 0)\n        goto error;\n\n    /* Bring up the bridge interface */\n    if (virNetDevSetOnline(def->bridge, 1) < 0)\n        goto error;\n\n    devOnline = true;\n\n    for (i = 0; i < def->nroutes; i++) {\n        virSocketAddrPtr gateway = NULL;\n\n        routedef = def->routes[i];\n        gateway = virNetDevIPRouteGetGateway(routedef);\n\n        /* Add the IP route to the bridge */\n        /* ignore errors, error msg will be generated */\n        /* but libvirt will not know and net-destroy will work. */\n        if (VIR_SOCKET_ADDR_VALID(gateway)) {\n            if (networkAddRouteToBridge(obj, routedef) < 0) {\n                /* an error occurred adding the static route */\n                continue; /* for now, do nothing */\n            }\n        }\n    }\n\n    /* If forward.type != NONE, turn on global IP forwarding */\n    if (def->forward.type != VIR_NETWORK_FORWARD_NONE) {\n        if (v6present && !virNetDevIPCheckIPv6Forwarding())\n            goto error; /* Precise error message already provided */\n\n        if (networkEnableIPForwarding(v4present, v6present) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"failed to enable IP forwarding\"));\n            goto error;\n        }\n    }\n\n\n    /* start dnsmasq if there are any IP addresses (v4 or v6) */\n    if ((v4present || v6present) &&\n        networkStartDhcpDaemon(driver, obj) < 0)\n        goto error;\n\n    dnsmasqStarted = true;\n\n    /* start radvd if there are any ipv6 addresses */\n    if (v6present && networkStartRadvd(driver, obj) < 0)\n        goto error;\n\n    /* dnsmasq does not wait for DAD to complete before daemonizing,\n     * so we need to wait for it ourselves.\n     */\n    if (v6present && networkWaitDadFinish(obj) < 0)\n        goto error;\n\n    /* DAD has finished, dnsmasq is now bound to the\n     * bridge's IPv6 address, so we can set the dummy tun down.\n     */\n    if (tapfd >= 0) {\n        if (virNetDevSetOnline(macTapIfName, false) < 0)\n            goto error;\n        VIR_FORCE_CLOSE(tapfd);\n    }\n\n    if (virNetDevBandwidthSet(def->bridge, def->bandwidth, true, true) < 0)\n        goto error;\n\n    VIR_FREE(macTapIfName);\n    VIR_FREE(macMapFile);\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&save_err);\n    if (def->bandwidth)\n       virNetDevBandwidthClear(def->bridge);\n\n    if (dnsmasqStarted) {\n        pid_t dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n        kill(dnsmasqPid, SIGTERM);\n        virNetworkObjSetDnsmasqPid(obj, -1);\n    }\n\n    if (devOnline)\n        ignore_value(virNetDevSetOnline(def->bridge, 0));\n\n    if (firewalRulesAdded &&\n        def->forward.type != VIR_NETWORK_FORWARD_OPEN)\n        networkRemoveFirewallRules(def);\n\n    if (macTapIfName) {\n        VIR_FORCE_CLOSE(tapfd);\n        ignore_value(virNetDevTapDelete(macTapIfName, NULL));\n        VIR_FREE(macTapIfName);\n    }\n    virNetworkObjUnrefMacMap(obj);\n    VIR_FREE(macMapFile);\n\n    ignore_value(virNetDevBridgeDelete(def->bridge));\n\n    virErrorRestore(&save_err);\n    /* coverity[leaked_handle] - 'tapfd' is not leaked */\n    return -1;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    size_t i;\n    bool v4present = false, v6present = false;\n    virErrorPtr save_err = NULL;\n    virNetworkIPDefPtr ipdef;\n    virNetDevIPRoutePtr routedef;\n    char *macTapIfName = NULL;\n    virMacMapPtr macmap;\n    char *macMapFile = NULL;\n    int tapfd = -1;\n    bool dnsmasqStarted = false;\n    bool devOnline = false;\n    bool firewalRulesAdded = false;\n\n    /* Check to see if any network IP collides with an existing route */\n    if (networkCheckRouteCollision(def) < 0)\n        return -1;\n\n    /* Create and configure the bridge device */\n    if (!def->bridge) {\n        /* bridge name can only be empty if the config files were\n         * edited directly. Otherwise networkValidate() (called after\n         * parsing the XML from networkCreateXML() and\n         * networkDefine()) guarantees we will have a valid bridge\n         * name before this point. Since hand editing of the config\n         * files is explicitly prohibited we can, with clear\n         * conscience, log an error and fail at this point.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"network '%s' has no bridge name defined\"),\n                       def->name);\n        return -1;\n    }\n    if (virNetDevBridgeCreate(def->bridge, &def->mac) < 0)\n        return -1;\n\n    if (def->mac_specified) {\n        /* To set a mac for the bridge, we need to define a dummy tap\n         * device, set its mac, then attach it to the bridge. As long\n         * as its mac address is lower than any other interface that\n         * gets attached, the bridge will always maintain this mac\n         * address.\n         */\n        macTapIfName = networkBridgeDummyNicName(def->bridge);\n        if (!macTapIfName)\n            goto error;\n        /* Keep tun fd open and interface up to allow for IPv6 DAD to happen */\n        if (virNetDevTapCreateInBridgePort(def->bridge,\n                                           &macTapIfName, &def->mac,\n                                           NULL, NULL, &tapfd, 1, NULL, NULL,\n                                           VIR_TRISTATE_BOOL_NO,\n                                           NULL, def->mtu, NULL,\n                                           VIR_NETDEV_TAP_CREATE_USE_MAC_FOR_BRIDGE |\n                                           VIR_NETDEV_TAP_CREATE_IFUP |\n                                           VIR_NETDEV_TAP_CREATE_PERSIST) < 0) {\n            VIR_FREE(macTapIfName);\n            goto error;\n        }\n    }\n\n    if (!(macMapFile = virMacMapFileName(driver->dnsmasqStateDir,\n                                         def->bridge)) ||\n        !(macmap = virMacMapNew(macMapFile)))\n        goto error;\n\n    virNetworkObjSetMacMap(obj, macmap);\n    macmap = NULL;\n\n    /* Set bridge options */\n\n    /* delay is configured in seconds, but virNetDevBridgeSetSTPDelay\n     * expects milliseconds\n     */\n    if (virNetDevBridgeSetSTPDelay(def->bridge, def->delay * 1000) < 0)\n        goto error;\n\n    if (virNetDevBridgeSetSTP(def->bridge, def->stp ? true : false) < 0)\n        goto error;\n\n    /* Disable IPv6 on the bridge if there are no IPv6 addresses\n     * defined, and set other IPv6 sysctl tunables appropriately.\n     */\n    if (networkSetIPv6Sysctls(obj) < 0)\n        goto error;\n\n    /* Add \"once per network\" rules */\n    if (def->forward.type != VIR_NETWORK_FORWARD_OPEN &&\n        networkAddFirewallRules(def) < 0)\n        goto error;\n\n    firewalRulesAdded = true;\n\n    for (i = 0; (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i)); i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET))\n            v4present = true;\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n            v6present = true;\n\n        /* Add the IP address/netmask to the bridge */\n        if (networkAddAddrToBridge(obj, ipdef) < 0)\n            goto error;\n    }\n\n    if (networkStartHandleMACTableManagerMode(obj, macTapIfName) < 0)\n        goto error;\n\n    /* Bring up the bridge interface */\n    if (virNetDevSetOnline(def->bridge, 1) < 0)\n        goto error;\n\n    devOnline = true;\n\n    for (i = 0; i < def->nroutes; i++) {\n        virSocketAddrPtr gateway = NULL;\n\n        routedef = def->routes[i];\n        gateway = virNetDevIPRouteGetGateway(routedef);\n\n        /* Add the IP route to the bridge */\n        /* ignore errors, error msg will be generated */\n        /* but libvirt will not know and net-destroy will work. */\n        if (VIR_SOCKET_ADDR_VALID(gateway)) {\n            if (networkAddRouteToBridge(obj, routedef) < 0) {\n                /* an error occurred adding the static route */\n                continue; /* for now, do nothing */\n            }\n        }\n    }\n\n    /* If forward.type != NONE, turn on global IP forwarding */\n    if (def->forward.type != VIR_NETWORK_FORWARD_NONE) {\n        if (v6present && !virNetDevIPCheckIPv6Forwarding())\n            goto error; /* Precise error message already provided */\n\n        if (networkEnableIPForwarding(v4present, v6present) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"failed to enable IP forwarding\"));\n            goto error;\n        }\n    }\n\n\n    /* start dnsmasq if there are any IP addresses (v4 or v6) */\n    if ((v4present || v6present) &&\n        networkStartDhcpDaemon(driver, obj) < 0)\n        goto error;\n\n    dnsmasqStarted = true;\n\n    /* start radvd if there are any ipv6 addresses */\n    if (v6present && networkStartRadvd(driver, obj) < 0)\n        goto error;\n\n    /* dnsmasq does not wait for DAD to complete before daemonizing,\n     * so we need to wait for it ourselves.\n     */\n    if (v6present && networkWaitDadFinish(obj) < 0)\n        goto error;\n\n    /* DAD has finished, dnsmasq is now bound to the\n     * bridge's IPv6 address, so we can set the dummy tun down.\n     */\n    if (tapfd >= 0) {\n        if (virNetDevSetOnline(macTapIfName, false) < 0)\n            goto error;\n        VIR_FORCE_CLOSE(tapfd);\n    }\n\n    if (virNetDevBandwidthSet(def->bridge, def->bandwidth, true, true) < 0)\n        goto error;\n\n    VIR_FREE(macTapIfName);\n    VIR_FREE(macMapFile);\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&save_err);\n    if (def->bandwidth)\n       virNetDevBandwidthClear(def->bridge);\n\n    if (dnsmasqStarted) {\n        pid_t dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n        kill(dnsmasqPid, SIGTERM);\n        virNetworkObjSetDnsmasqPid(obj, -1);\n    }\n\n    if (devOnline)\n        ignore_value(virNetDevSetOnline(def->bridge, 0));\n\n    if (firewalRulesAdded &&\n        def->forward.type != VIR_NETWORK_FORWARD_OPEN)\n        networkRemoveFirewallRules(def);\n\n    if (macTapIfName) {\n        VIR_FORCE_CLOSE(tapfd);\n        ignore_value(virNetDevTapDelete(macTapIfName, NULL));\n        VIR_FREE(macTapIfName);\n    }\n    virNetworkObjUnrefMacMap(obj);\n    VIR_FREE(macMapFile);\n\n    ignore_value(virNetDevBridgeDelete(def->bridge));\n\n    virErrorRestore(&save_err);\n    /* coverity[leaked_handle] - 'tapfd' is not leaked */\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetDefTransient",
          "args": [
            "obj",
            "true",
            "network_driver->xmlopt"
          ],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetDefTransient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "674-689",
          "snippet": "int\nvirNetworkObjSetDefTransient(virNetworkObjPtr obj,\n                             bool live,\n                             virNetworkXMLOptionPtr xmlopt)\n{\n    if (!virNetworkObjIsActive(obj) && !live)\n        return 0;\n\n    if (!obj->persistent || obj->newDef)\n        return 0;\n\n    obj->newDef = virNetworkDefCopy(obj->def,\n                                    xmlopt,\n                                    VIR_NETWORK_XML_INACTIVE);\n    return obj->newDef ? 0 : -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nint\nvirNetworkObjSetDefTransient(virNetworkObjPtr obj,\n                             bool live,\n                             virNetworkXMLOptionPtr xmlopt)\n{\n    if (!virNetworkObjIsActive(obj) && !live)\n        return 0;\n\n    if (!obj->persistent || obj->newDef)\n        return 0;\n\n    obj->newDef = virNetworkDefCopy(obj->def,\n                                    xmlopt,\n                                    VIR_NETWORK_XML_INACTIVE);\n    return obj->newDef ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting current network def as transient\""
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjDeleteAllPorts",
          "args": [
            "obj",
            "driver->stateDir"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjDeleteAllPorts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1711-1749",
          "snippet": "int\nvirNetworkObjDeleteAllPorts(virNetworkObjPtr net,\n                            const char *stateDir)\n{\n    g_autofree char *dir = NULL;\n    DIR *dh = NULL;\n    struct dirent *de;\n    int rc;\n    int ret = -1;\n\n    if (!(dir = virNetworkObjGetPortStatusDir(net, stateDir)))\n        goto cleanup;\n\n    if ((rc = virDirOpenIfExists(&dh, dir)) <= 0) {\n        ret = rc;\n        goto cleanup;\n    }\n\n    while ((rc = virDirRead(dh, &de, dir)) > 0) {\n        char *file = NULL;\n\n        if (!virStringStripSuffix(de->d_name, \".xml\"))\n            continue;\n\n        file = g_strdup_printf(\"%s/%s.xml\", dir, de->d_name);\n\n        if (unlink(file) < 0 && errno != ENOENT)\n            VIR_WARN(\"Unable to delete %s\", file);\n\n        VIR_FREE(file);\n    }\n\n    virHashRemoveAll(net->ports);\n\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dh);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetworkObjLoadAllPorts(virNetworkObjPtr net,\n                          const char *stateDir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic int\nvirNetworkObjLoadAllPorts(virNetworkObjPtr net,\n                          const char *stateDir);\n\nint\nvirNetworkObjDeleteAllPorts(virNetworkObjPtr net,\n                            const char *stateDir)\n{\n    g_autofree char *dir = NULL;\n    DIR *dh = NULL;\n    struct dirent *de;\n    int rc;\n    int ret = -1;\n\n    if (!(dir = virNetworkObjGetPortStatusDir(net, stateDir)))\n        goto cleanup;\n\n    if ((rc = virDirOpenIfExists(&dh, dir)) <= 0) {\n        ret = rc;\n        goto cleanup;\n    }\n\n    while ((rc = virDirRead(dh, &de, dir)) > 0) {\n        char *file = NULL;\n\n        if (!virStringStripSuffix(de->d_name, \".xml\"))\n            continue;\n\n        file = g_strdup_printf(\"%s/%s.xml\", dir, de->d_name);\n\n        if (unlink(file) < 0 && errno != ENOENT)\n            VIR_WARN(\"Unable to delete %s\", file);\n\n        VIR_FREE(file);\n    }\n\n    virHashRemoveAll(net->ports);\n\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dh);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Beginning network startup process\""
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"network is already active\")"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"network is already active\""
          ],
          "line": 2901
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, network=%p\"",
            "driver",
            "obj"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2894
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n\n    VIR_DEBUG(\"driver=%p, network=%p\", driver, obj);\n\n    if (virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"network is already active\"));\n        return ret;\n    }\n\n    VIR_DEBUG(\"Beginning network startup process\");\n\n    virNetworkObjDeleteAllPorts(obj, driver->stateDir);\n\n    VIR_DEBUG(\"Setting current network def as transient\");\n    if (virNetworkObjSetDefTransient(obj, true, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices.\n     * If the script raised an error abort the launch. */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_START,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    switch ((virNetworkForwardType) def->forward.type) {\n\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        if (networkStartNetworkVirtual(driver, obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            if (networkStartNetworkBridge(obj) < 0)\n                goto cleanup;\n            break;\n        }\n        /* intentionally fall through to the macvtap/direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         * (since that is macvtap bridge mode).\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        if (networkStartNetworkExternal(obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto cleanup;\n    }\n\n    virNetworkObjSetFloorSum(obj, 0);\n\n    /* finally we can call the 'started' hook script if any */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_STARTED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    /* Persist the live configuration now that anything autogenerated\n     * is setup.\n     */\n    VIR_DEBUG(\"Writing network status to disk\");\n    if (virNetworkObjSaveStatus(driver->stateDir,\n                                obj, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    virNetworkObjSetActive(obj, true);\n    VIR_INFO(\"Network '%s' started up\", def->name);\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virErrorPtr save_err;\n\n        virErrorPreserveLast(&save_err);\n        virNetworkObjUnsetDefTransient(obj);\n        networkShutdownNetwork(driver, obj);\n        virErrorRestore(&save_err);\n    }\n    return ret;\n}"
  },
  {
    "function_name": "networkShutdownNetworkExternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2878-2887",
    "snippet": "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj G_GNUC_UNUSED)\n{\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE, PRIVATE, VEPA, HOSTDEV or PASSTHROUGH is shutdown. On\n     * failure, undo anything you've done, and return -1. On success\n     * return 0.\n     */\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj G_GNUC_UNUSED)\n{\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE, PRIVATE, VEPA, HOSTDEV or PASSTHROUGH is shutdown. On\n     * failure, undo anything you've done, and return -1. On success\n     * return 0.\n     */\n    return 0;\n}"
  },
  {
    "function_name": "networkStartNetworkExternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2866-2875",
    "snippet": "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj)\n{\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE, PRIVATE, VEPA, HOSTDEV or PASSTHROUGH is started. On\n     * failure, undo anything you've done, and return -1. On success\n     * return 0.\n     */\n    return networkCreateInterfacePool(virNetworkObjGetDef(obj));\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkCreateInterfacePool",
          "args": [
            "virNetworkObjGetDef(obj)"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "networkCreateInterfacePool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2760-2863",
          "snippet": "static int\nnetworkCreateInterfacePool(virNetworkDefPtr netdef)\n{\n    size_t numVirtFns = 0;\n    unsigned int maxVirtFns = 0;\n    char **vfNames = NULL;\n    virPCIDeviceAddressPtr *virtFns;\n\n    int ret = -1;\n    size_t i;\n\n    if (netdef->forward.npfs == 0 || netdef->forward.nifs > 0)\n       return 0;\n\n    if ((virNetDevGetVirtualFunctions(netdef->forward.pfs->dev, &vfNames,\n                                      &virtFns, &numVirtFns, &maxVirtFns)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get Virtual functions on %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(netdef->forward.ifs, numVirtFns) < 0)\n        goto cleanup;\n\n    for (i = 0; i < numVirtFns; i++) {\n        virPCIDeviceAddressPtr thisVirtFn = virtFns[i];\n        const char *thisName = vfNames[i];\n        virNetworkForwardIfDefPtr thisIf\n            = &netdef->forward.ifs[netdef->forward.nifs];\n\n        switch ((virNetworkForwardType) netdef->forward.type) {\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n            if (thisName) {\n                thisIf->device.dev = g_strdup(thisName);\n                thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n                netdef->forward.nifs++;\n            } else {\n                VIR_WARN(\"VF %zu of SRIOV PF %s couldn't be added to the \"\n                         \"interface pool because it isn't bound \"\n                         \"to a network driver - possibly in use elsewhere\",\n                         i, netdef->forward.pfs->dev);\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            /* VF's are always PCI devices */\n            thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI;\n            thisIf->device.pci.domain = thisVirtFn->domain;\n            thisIf->device.pci.bus = thisVirtFn->bus;\n            thisIf->device.pci.slot = thisVirtFn->slot;\n            thisIf->device.pci.function = thisVirtFn->function;\n            netdef->forward.nifs++;\n            break;\n\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n        case VIR_NETWORK_FORWARD_OPEN:\n            /* by definition these will never be encountered here */\n            break;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, netdef->forward.type);\n            goto cleanup;\n        }\n    }\n\n    if (netdef->forward.nifs == 0) {\n        /* If we don't get at least one interface in the pool, declare\n         * failure\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No usable Vf's present on SRIOV PF %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        /* free all the entries made before error */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n                VIR_FREE(netdef->forward.ifs[i].device.dev);\n        }\n        netdef->forward.nifs = 0;\n    }\n    if (netdef->forward.nifs == 0)\n        VIR_FREE(netdef->forward.ifs);\n\n    for (i = 0; i < numVirtFns; i++) {\n        VIR_FREE(vfNames[i]);\n        VIR_FREE(virtFns[i]);\n    }\n    VIR_FREE(vfNames);\n    VIR_FREE(virtFns);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkCreateInterfacePool(virNetworkDefPtr netdef)\n{\n    size_t numVirtFns = 0;\n    unsigned int maxVirtFns = 0;\n    char **vfNames = NULL;\n    virPCIDeviceAddressPtr *virtFns;\n\n    int ret = -1;\n    size_t i;\n\n    if (netdef->forward.npfs == 0 || netdef->forward.nifs > 0)\n       return 0;\n\n    if ((virNetDevGetVirtualFunctions(netdef->forward.pfs->dev, &vfNames,\n                                      &virtFns, &numVirtFns, &maxVirtFns)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get Virtual functions on %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(netdef->forward.ifs, numVirtFns) < 0)\n        goto cleanup;\n\n    for (i = 0; i < numVirtFns; i++) {\n        virPCIDeviceAddressPtr thisVirtFn = virtFns[i];\n        const char *thisName = vfNames[i];\n        virNetworkForwardIfDefPtr thisIf\n            = &netdef->forward.ifs[netdef->forward.nifs];\n\n        switch ((virNetworkForwardType) netdef->forward.type) {\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n            if (thisName) {\n                thisIf->device.dev = g_strdup(thisName);\n                thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n                netdef->forward.nifs++;\n            } else {\n                VIR_WARN(\"VF %zu of SRIOV PF %s couldn't be added to the \"\n                         \"interface pool because it isn't bound \"\n                         \"to a network driver - possibly in use elsewhere\",\n                         i, netdef->forward.pfs->dev);\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            /* VF's are always PCI devices */\n            thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI;\n            thisIf->device.pci.domain = thisVirtFn->domain;\n            thisIf->device.pci.bus = thisVirtFn->bus;\n            thisIf->device.pci.slot = thisVirtFn->slot;\n            thisIf->device.pci.function = thisVirtFn->function;\n            netdef->forward.nifs++;\n            break;\n\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n        case VIR_NETWORK_FORWARD_OPEN:\n            /* by definition these will never be encountered here */\n            break;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, netdef->forward.type);\n            goto cleanup;\n        }\n    }\n\n    if (netdef->forward.nifs == 0) {\n        /* If we don't get at least one interface in the pool, declare\n         * failure\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No usable Vf's present on SRIOV PF %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        /* free all the entries made before error */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n                VIR_FREE(netdef->forward.ifs[i].device.dev);\n        }\n        netdef->forward.nifs = 0;\n    }\n    if (netdef->forward.nifs == 0)\n        VIR_FREE(netdef->forward.ifs);\n\n    for (i = 0; i < numVirtFns; i++) {\n        VIR_FREE(vfNames[i]);\n        VIR_FREE(virtFns[i]);\n    }\n    VIR_FREE(vfNames);\n    VIR_FREE(virtFns);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj)\n{\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE, PRIVATE, VEPA, HOSTDEV or PASSTHROUGH is started. On\n     * failure, undo anything you've done, and return -1. On success\n     * return 0.\n     */\n    return networkCreateInterfacePool(virNetworkObjGetDef(obj));\n}"
  },
  {
    "function_name": "networkCreateInterfacePool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2760-2863",
    "snippet": "static int\nnetworkCreateInterfacePool(virNetworkDefPtr netdef)\n{\n    size_t numVirtFns = 0;\n    unsigned int maxVirtFns = 0;\n    char **vfNames = NULL;\n    virPCIDeviceAddressPtr *virtFns;\n\n    int ret = -1;\n    size_t i;\n\n    if (netdef->forward.npfs == 0 || netdef->forward.nifs > 0)\n       return 0;\n\n    if ((virNetDevGetVirtualFunctions(netdef->forward.pfs->dev, &vfNames,\n                                      &virtFns, &numVirtFns, &maxVirtFns)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get Virtual functions on %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(netdef->forward.ifs, numVirtFns) < 0)\n        goto cleanup;\n\n    for (i = 0; i < numVirtFns; i++) {\n        virPCIDeviceAddressPtr thisVirtFn = virtFns[i];\n        const char *thisName = vfNames[i];\n        virNetworkForwardIfDefPtr thisIf\n            = &netdef->forward.ifs[netdef->forward.nifs];\n\n        switch ((virNetworkForwardType) netdef->forward.type) {\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n            if (thisName) {\n                thisIf->device.dev = g_strdup(thisName);\n                thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n                netdef->forward.nifs++;\n            } else {\n                VIR_WARN(\"VF %zu of SRIOV PF %s couldn't be added to the \"\n                         \"interface pool because it isn't bound \"\n                         \"to a network driver - possibly in use elsewhere\",\n                         i, netdef->forward.pfs->dev);\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            /* VF's are always PCI devices */\n            thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI;\n            thisIf->device.pci.domain = thisVirtFn->domain;\n            thisIf->device.pci.bus = thisVirtFn->bus;\n            thisIf->device.pci.slot = thisVirtFn->slot;\n            thisIf->device.pci.function = thisVirtFn->function;\n            netdef->forward.nifs++;\n            break;\n\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n        case VIR_NETWORK_FORWARD_OPEN:\n            /* by definition these will never be encountered here */\n            break;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, netdef->forward.type);\n            goto cleanup;\n        }\n    }\n\n    if (netdef->forward.nifs == 0) {\n        /* If we don't get at least one interface in the pool, declare\n         * failure\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No usable Vf's present on SRIOV PF %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        /* free all the entries made before error */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n                VIR_FREE(netdef->forward.ifs[i].device.dev);\n        }\n        netdef->forward.nifs = 0;\n    }\n    if (netdef->forward.nifs == 0)\n        VIR_FREE(netdef->forward.ifs);\n\n    for (i = 0; i < numVirtFns; i++) {\n        VIR_FREE(vfNames[i]);\n        VIR_FREE(virtFns[i]);\n    }\n    VIR_FREE(vfNames);\n    VIR_FREE(virtFns);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "virtFns"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vfNames"
          ],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "virtFns[i]"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vfNames[i]"
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "netdef->forward.ifs"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "netdef->forward.ifs[i].device.dev"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"No usable Vf's present on SRIOV PF %s\")",
            "netdef->forward.pfs->dev"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No usable Vf's present on SRIOV PF %s\""
          ],
          "line": 2837
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkForwardType",
            "netdef->forward.type"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"VF %zu of SRIOV PF %s couldn't be added to the \"\n                         \"interface pool because it isn't bound \"\n                         \"to a network driver - possibly in use elsewhere\"",
            "i",
            "netdef->forward.pfs->dev"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "netdef->forward.ifs",
            "numVirtFns"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get Virtual functions on %s\")",
            "netdef->forward.pfs->dev"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevGetVirtualFunctions",
          "args": [
            "netdef->forward.pfs->dev",
            "&vfNames",
            "&virtFns",
            "&numVirtFns",
            "&maxVirtFns"
          ],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetVirtualFunctions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "1465-1475",
          "snippet": "int\nvirNetDevGetVirtualFunctions(const char *pfname G_GNUC_UNUSED,\n                             char ***vfname G_GNUC_UNUSED,\n                             virPCIDeviceAddressPtr **virt_fns G_GNUC_UNUSED,\n                             size_t *n_vfname G_GNUC_UNUSED,\n                             unsigned int *max_vfs G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get virtual functions on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevGetVirtualFunctions(const char *pfname G_GNUC_UNUSED,\n                             char ***vfname G_GNUC_UNUSED,\n                             virPCIDeviceAddressPtr **virt_fns G_GNUC_UNUSED,\n                             size_t *n_vfname G_GNUC_UNUSED,\n                             unsigned int *max_vfs G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get virtual functions on this platform\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkCreateInterfacePool(virNetworkDefPtr netdef)\n{\n    size_t numVirtFns = 0;\n    unsigned int maxVirtFns = 0;\n    char **vfNames = NULL;\n    virPCIDeviceAddressPtr *virtFns;\n\n    int ret = -1;\n    size_t i;\n\n    if (netdef->forward.npfs == 0 || netdef->forward.nifs > 0)\n       return 0;\n\n    if ((virNetDevGetVirtualFunctions(netdef->forward.pfs->dev, &vfNames,\n                                      &virtFns, &numVirtFns, &maxVirtFns)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get Virtual functions on %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(netdef->forward.ifs, numVirtFns) < 0)\n        goto cleanup;\n\n    for (i = 0; i < numVirtFns; i++) {\n        virPCIDeviceAddressPtr thisVirtFn = virtFns[i];\n        const char *thisName = vfNames[i];\n        virNetworkForwardIfDefPtr thisIf\n            = &netdef->forward.ifs[netdef->forward.nifs];\n\n        switch ((virNetworkForwardType) netdef->forward.type) {\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n            if (thisName) {\n                thisIf->device.dev = g_strdup(thisName);\n                thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV;\n                netdef->forward.nifs++;\n            } else {\n                VIR_WARN(\"VF %zu of SRIOV PF %s couldn't be added to the \"\n                         \"interface pool because it isn't bound \"\n                         \"to a network driver - possibly in use elsewhere\",\n                         i, netdef->forward.pfs->dev);\n            }\n            break;\n\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            /* VF's are always PCI devices */\n            thisIf->type = VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI;\n            thisIf->device.pci.domain = thisVirtFn->domain;\n            thisIf->device.pci.bus = thisVirtFn->bus;\n            thisIf->device.pci.slot = thisVirtFn->slot;\n            thisIf->device.pci.function = thisVirtFn->function;\n            netdef->forward.nifs++;\n            break;\n\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n        case VIR_NETWORK_FORWARD_OPEN:\n            /* by definition these will never be encountered here */\n            break;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, netdef->forward.type);\n            goto cleanup;\n        }\n    }\n\n    if (netdef->forward.nifs == 0) {\n        /* If we don't get at least one interface in the pool, declare\n         * failure\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No usable Vf's present on SRIOV PF %s\"),\n                       netdef->forward.pfs->dev);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        /* free all the entries made before error */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV)\n                VIR_FREE(netdef->forward.ifs[i].device.dev);\n        }\n        netdef->forward.nifs = 0;\n    }\n    if (netdef->forward.nifs == 0)\n        VIR_FREE(netdef->forward.ifs);\n\n    for (i = 0; i < numVirtFns; i++) {\n        VIR_FREE(vfNames[i]);\n        VIR_FREE(virtFns[i]);\n    }\n    VIR_FREE(vfNames);\n    VIR_FREE(virtFns);\n    return ret;\n}"
  },
  {
    "function_name": "networkShutdownNetworkBridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2739-2752",
    "snippet": "static int\nnetworkShutdownNetworkBridge(virNetworkObjPtr obj G_GNUC_UNUSED)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE is shutdown. On failure, undo anything you've done,\n     * and return -1. On success return 0.\n     */\n    if (def->bandwidth)\n       virNetDevBandwidthClear(def->bridge);\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevBandwidthClear",
          "args": [
            "def->bridge"
          ],
          "line": 2749
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "404-431",
          "snippet": "int\nvirNetDevBandwidthClear(const char *ifname)\n{\n    int ret = 0;\n    int dummy; /* for ignoring the exit status */\n    virCommandPtr cmd = NULL;\n\n    if (!ifname)\n       return 0;\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", ifname, \"root\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\",  \"del\", \"dev\", ifname, \"ingress\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthClear(const char *ifname)\n{\n    int ret = 0;\n    int dummy; /* for ignoring the exit status */\n    virCommandPtr cmd = NULL;\n\n    if (!ifname)\n       return 0;\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", ifname, \"root\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\",  \"del\", \"dev\", ifname, \"ingress\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkShutdownNetworkBridge(virNetworkObjPtr obj G_GNUC_UNUSED)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE is shutdown. On failure, undo anything you've done,\n     * and return -1. On success return 0.\n     */\n    if (def->bandwidth)\n       virNetDevBandwidthClear(def->bridge);\n\n    return 0;\n}"
  },
  {
    "function_name": "networkStartNetworkBridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2715-2736",
    "snippet": "static int\nnetworkStartNetworkBridge(virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE, is started. On failure, undo anything you've done,\n     * and return -1. On success return 0.\n     */\n    if (virNetDevBandwidthSet(def->bridge, def->bandwidth, true, true) < 0)\n        goto error;\n\n    if (networkStartHandleMACTableManagerMode(obj, NULL) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    if (def->bandwidth)\n       virNetDevBandwidthClear(def->bridge);\n    return -1;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevBandwidthClear",
          "args": [
            "def->bridge"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "404-431",
          "snippet": "int\nvirNetDevBandwidthClear(const char *ifname)\n{\n    int ret = 0;\n    int dummy; /* for ignoring the exit status */\n    virCommandPtr cmd = NULL;\n\n    if (!ifname)\n       return 0;\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", ifname, \"root\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\",  \"del\", \"dev\", ifname, \"ingress\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthClear(const char *ifname)\n{\n    int ret = 0;\n    int dummy; /* for ignoring the exit status */\n    virCommandPtr cmd = NULL;\n\n    if (!ifname)\n       return 0;\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", ifname, \"root\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\",  \"del\", \"dev\", ifname, \"ingress\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkStartHandleMACTableManagerMode",
          "args": [
            "obj",
            "NULL"
          ],
          "line": 2727
        },
        "resolved": true,
        "details": {
          "function_name": "networkStartHandleMACTableManagerMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2366-2385",
          "snippet": "static int\nnetworkStartHandleMACTableManagerMode(virNetworkObjPtr obj,\n                                      const char *macTapIfName)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    const char *brname = def->bridge;\n\n    if (brname &&\n        def->macTableManager == VIR_NETWORK_BRIDGE_MAC_TABLE_MANAGER_LIBVIRT) {\n        if (virNetDevBridgeSetVlanFiltering(brname, true) < 0)\n            return -1;\n        if (macTapIfName) {\n            if (virNetDevBridgePortSetLearning(brname, macTapIfName, false) < 0)\n                return -1;\n            if (virNetDevBridgePortSetUnicastFlood(brname, macTapIfName, false) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkStartHandleMACTableManagerMode(virNetworkObjPtr obj,\n                                      const char *macTapIfName)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    const char *brname = def->bridge;\n\n    if (brname &&\n        def->macTableManager == VIR_NETWORK_BRIDGE_MAC_TABLE_MANAGER_LIBVIRT) {\n        if (virNetDevBridgeSetVlanFiltering(brname, true) < 0)\n            return -1;\n        if (macTapIfName) {\n            if (virNetDevBridgePortSetLearning(brname, macTapIfName, false) < 0)\n                return -1;\n            if (virNetDevBridgePortSetUnicastFlood(brname, macTapIfName, false) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthSet",
          "args": [
            "def->bridge",
            "def->bandwidth",
            "true",
            "true"
          ],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "189-392",
          "snippet": "int\nvirNetDevBandwidthSet(const char *ifname,\n                      const virNetDevBandwidth *bandwidth,\n                      bool hierarchical_class,\n                      bool swapped)\n{\n    int ret = -1;\n    virNetDevBandwidthRatePtr rx = NULL, tx = NULL; /* From domain POV */\n    virCommandPtr cmd = NULL;\n    char *average = NULL;\n    char *peak = NULL;\n    char *burst = NULL;\n\n    if (!bandwidth) {\n        /* nothing to be enabled */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (geteuid() != 0) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Network bandwidth tuning is not available\"\n                         \" in session mode\"));\n        return -1;\n    }\n\n    if (!ifname) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set bandwidth for interface because \"\n                         \"device name is unknown\"));\n        return -1;\n    }\n\n    if (swapped) {\n        rx = bandwidth->out;\n        tx = bandwidth->in;\n    } else {\n        rx = bandwidth->in;\n        tx = bandwidth->out;\n    }\n\n    virNetDevBandwidthClear(ifname);\n\n    if (tx && tx->average) {\n        average = g_strdup_printf(\"%llukbps\", tx->average);\n        if (tx->peak)\n            peak = g_strdup_printf(\"%llukbps\", tx->peak);\n        if (tx->burst)\n            burst = g_strdup_printf(\"%llukb\", tx->burst);\n\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"root\",\n                             \"handle\", \"1:\", \"htb\", \"default\",\n                             hierarchical_class ? \"2\" : \"1\", NULL);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        /* If we are creating a hierarchical class, all non guaranteed traffic\n         * goes to the 1:2 class which will adjust 'rate' dynamically as NICs\n         * with guaranteed throughput are plugged and unplugged. Class 1:1\n         * exists so we don't exceed the maximum limit for the network. For each\n         * NIC with guaranteed throughput a separate classid will be created.\n         * NB '1:' is just a shorter notation of '1:0'.\n         *\n         * To get a picture how this works:\n         *\n         * +-----+     +---------+     +-----------+      +-----------+     +-----+\n         * |     |     |  qdisc  |     | class 1:1 |      | class 1:2 |     |     |\n         * | NIC |     | def 1:2 |     |   rate    |      |   rate    |     | sfq |\n         * |     | --> |         | --> |   peak    | -+-> |   peak    | --> |     |\n         * +-----+     +---------+     +-----------+  |   +-----------+     +-----+\n         *                                            |\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:3 |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                            |   +-----------+     +-----+\n         *                                           ...\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:n |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                                +-----------+     +-----+\n         *\n         * After the routing decision, when is it clear a packet is to be sent\n         * via a particular NIC, it is sent to the root qdisc (queuing\n         * discipline). In this case HTB (Hierarchical Token Bucket). It has\n         * only one direct child class (with id 1:1) which shapes the overall\n         * rate that is sent through the NIC.  This class has at least one child\n         * (1:2) which is meant for all non-privileged (non guaranteed) traffic\n         * from all domains. Then, for each interface with guaranteed\n         * throughput, a separate class (1:n) is created. Imagine a class is a\n         * box. Whenever a packet ends up in a class it is stored in this box\n         * until the kernel sends it, then it is removed from box. Packets are\n         * placed into boxes based on rules (filters) - e.g. depending on\n         * destination IP/MAC address. If there is no rule to be applied, the\n         * root qdisc has a default where such packets go (1:2 in this case).\n         * Packets come in over and over again and boxes get filled more and\n         * more. Imagine that kernel sends packets just once a second. So it\n         * starts to traverse through this tree. It starts with the root qdisc\n         * and through 1:1 it gets to 1:2. It sends packets up to 1:2's 'rate'.\n         * Then it moves to 1:3 and again sends packets up to 1:3's 'rate'.  The\n         * whole process is repeated until 1:n is processed. So now we have\n         * ensured each class its guaranteed bandwidth. If the sum of sent data\n         * doesn't exceed the 'rate' in 1:1 class, we can go further and send\n         * more packets. The rest of available bandwidth is distributed to the\n         * 1:2,1:3...1:n classes by ratio of their 'rate'. As soon as the root\n         * 'rate' limit is reached or there are no more packets to send, we stop\n         * sending and wait another second. Each class has an SFQ qdisc which\n         * shuffles packets in boxes stochastically, so one sender cannot\n         * starve others.\n         *\n         * Therefore, whenever we want to plug in a new guaranteed interface, we\n         * need to create a new class and adjust the 'rate' of the 1:2 class.\n         * When unplugging we do the exact opposite - remove the associated\n         * class, and adjust the 'rate'.\n         *\n         * This description is rather long, but it is still a good idea to read\n         * it before you dig into the code.\n         */\n        if (hierarchical_class) {\n            virCommandFree(cmd);\n            cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                                 \"1:\", \"classid\", \"1:1\", \"htb\", \"rate\", average,\n                                 \"ceil\", peak ? peak : average, NULL);\n            virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n        }\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:1\" : \"1:\", \"classid\",\n                             hierarchical_class ? \"1:2\" : \"1:1\", \"htb\",\n                             \"rate\", average, NULL);\n\n        if (peak)\n            virCommandAddArgList(cmd, \"ceil\", peak, NULL);\n        if (burst)\n            virCommandAddArgList(cmd, \"burst\", burst, NULL);\n\n        virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:2\" : \"1:1\",\n                             \"handle\", \"2:\", \"sfq\", \"perturb\",\n                             \"10\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"1:0\", \"protocol\", \"all\", \"prio\", \"1\", \"handle\",\n                             \"1\", \"fw\", \"flowid\", \"1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        VIR_FREE(average);\n        VIR_FREE(peak);\n        VIR_FREE(burst);\n    }\n\n    if (rx) {\n        average = g_strdup_printf(\"%llukbps\", rx->average);\n        burst = g_strdup_printf(\"%llukb\", rx->burst ? rx->burst : rx->average);\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname,\n                                 \"ingress\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        /* Set filter to match all ingress traffic */\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"ffff:\", \"protocol\", \"all\", \"u32\", \"match\", \"u32\",\n                             \"0\", \"0\", \"police\", \"rate\", average,\n                             \"burst\", burst, \"mtu\", \"64kb\", \"drop\", \"flowid\",\n                             \":1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(average);\n    VIR_FREE(peak);\n    VIR_FREE(burst);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthSet(const char *ifname,\n                      const virNetDevBandwidth *bandwidth,\n                      bool hierarchical_class,\n                      bool swapped)\n{\n    int ret = -1;\n    virNetDevBandwidthRatePtr rx = NULL, tx = NULL; /* From domain POV */\n    virCommandPtr cmd = NULL;\n    char *average = NULL;\n    char *peak = NULL;\n    char *burst = NULL;\n\n    if (!bandwidth) {\n        /* nothing to be enabled */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (geteuid() != 0) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Network bandwidth tuning is not available\"\n                         \" in session mode\"));\n        return -1;\n    }\n\n    if (!ifname) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set bandwidth for interface because \"\n                         \"device name is unknown\"));\n        return -1;\n    }\n\n    if (swapped) {\n        rx = bandwidth->out;\n        tx = bandwidth->in;\n    } else {\n        rx = bandwidth->in;\n        tx = bandwidth->out;\n    }\n\n    virNetDevBandwidthClear(ifname);\n\n    if (tx && tx->average) {\n        average = g_strdup_printf(\"%llukbps\", tx->average);\n        if (tx->peak)\n            peak = g_strdup_printf(\"%llukbps\", tx->peak);\n        if (tx->burst)\n            burst = g_strdup_printf(\"%llukb\", tx->burst);\n\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"root\",\n                             \"handle\", \"1:\", \"htb\", \"default\",\n                             hierarchical_class ? \"2\" : \"1\", NULL);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        /* If we are creating a hierarchical class, all non guaranteed traffic\n         * goes to the 1:2 class which will adjust 'rate' dynamically as NICs\n         * with guaranteed throughput are plugged and unplugged. Class 1:1\n         * exists so we don't exceed the maximum limit for the network. For each\n         * NIC with guaranteed throughput a separate classid will be created.\n         * NB '1:' is just a shorter notation of '1:0'.\n         *\n         * To get a picture how this works:\n         *\n         * +-----+     +---------+     +-----------+      +-----------+     +-----+\n         * |     |     |  qdisc  |     | class 1:1 |      | class 1:2 |     |     |\n         * | NIC |     | def 1:2 |     |   rate    |      |   rate    |     | sfq |\n         * |     | --> |         | --> |   peak    | -+-> |   peak    | --> |     |\n         * +-----+     +---------+     +-----------+  |   +-----------+     +-----+\n         *                                            |\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:3 |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                            |   +-----------+     +-----+\n         *                                           ...\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:n |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                                +-----------+     +-----+\n         *\n         * After the routing decision, when is it clear a packet is to be sent\n         * via a particular NIC, it is sent to the root qdisc (queuing\n         * discipline). In this case HTB (Hierarchical Token Bucket). It has\n         * only one direct child class (with id 1:1) which shapes the overall\n         * rate that is sent through the NIC.  This class has at least one child\n         * (1:2) which is meant for all non-privileged (non guaranteed) traffic\n         * from all domains. Then, for each interface with guaranteed\n         * throughput, a separate class (1:n) is created. Imagine a class is a\n         * box. Whenever a packet ends up in a class it is stored in this box\n         * until the kernel sends it, then it is removed from box. Packets are\n         * placed into boxes based on rules (filters) - e.g. depending on\n         * destination IP/MAC address. If there is no rule to be applied, the\n         * root qdisc has a default where such packets go (1:2 in this case).\n         * Packets come in over and over again and boxes get filled more and\n         * more. Imagine that kernel sends packets just once a second. So it\n         * starts to traverse through this tree. It starts with the root qdisc\n         * and through 1:1 it gets to 1:2. It sends packets up to 1:2's 'rate'.\n         * Then it moves to 1:3 and again sends packets up to 1:3's 'rate'.  The\n         * whole process is repeated until 1:n is processed. So now we have\n         * ensured each class its guaranteed bandwidth. If the sum of sent data\n         * doesn't exceed the 'rate' in 1:1 class, we can go further and send\n         * more packets. The rest of available bandwidth is distributed to the\n         * 1:2,1:3...1:n classes by ratio of their 'rate'. As soon as the root\n         * 'rate' limit is reached or there are no more packets to send, we stop\n         * sending and wait another second. Each class has an SFQ qdisc which\n         * shuffles packets in boxes stochastically, so one sender cannot\n         * starve others.\n         *\n         * Therefore, whenever we want to plug in a new guaranteed interface, we\n         * need to create a new class and adjust the 'rate' of the 1:2 class.\n         * When unplugging we do the exact opposite - remove the associated\n         * class, and adjust the 'rate'.\n         *\n         * This description is rather long, but it is still a good idea to read\n         * it before you dig into the code.\n         */\n        if (hierarchical_class) {\n            virCommandFree(cmd);\n            cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                                 \"1:\", \"classid\", \"1:1\", \"htb\", \"rate\", average,\n                                 \"ceil\", peak ? peak : average, NULL);\n            virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n        }\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:1\" : \"1:\", \"classid\",\n                             hierarchical_class ? \"1:2\" : \"1:1\", \"htb\",\n                             \"rate\", average, NULL);\n\n        if (peak)\n            virCommandAddArgList(cmd, \"ceil\", peak, NULL);\n        if (burst)\n            virCommandAddArgList(cmd, \"burst\", burst, NULL);\n\n        virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:2\" : \"1:1\",\n                             \"handle\", \"2:\", \"sfq\", \"perturb\",\n                             \"10\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"1:0\", \"protocol\", \"all\", \"prio\", \"1\", \"handle\",\n                             \"1\", \"fw\", \"flowid\", \"1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        VIR_FREE(average);\n        VIR_FREE(peak);\n        VIR_FREE(burst);\n    }\n\n    if (rx) {\n        average = g_strdup_printf(\"%llukbps\", rx->average);\n        burst = g_strdup_printf(\"%llukb\", rx->burst ? rx->burst : rx->average);\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname,\n                                 \"ingress\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        /* Set filter to match all ingress traffic */\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"ffff:\", \"protocol\", \"all\", \"u32\", \"match\", \"u32\",\n                             \"0\", \"0\", \"police\", \"rate\", average,\n                             \"burst\", burst, \"mtu\", \"64kb\", \"drop\", \"flowid\",\n                             \":1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(average);\n    VIR_FREE(peak);\n    VIR_FREE(burst);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkStartNetworkBridge(virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n\n    /* put anything here that needs to be done each time a network of\n     * type BRIDGE, is started. On failure, undo anything you've done,\n     * and return -1. On success return 0.\n     */\n    if (virNetDevBandwidthSet(def->bridge, def->bandwidth, true, true) < 0)\n        goto error;\n\n    if (networkStartHandleMACTableManagerMode(obj, NULL) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    if (def->bandwidth)\n       virNetDevBandwidthClear(def->bridge);\n    return -1;\n}"
  },
  {
    "function_name": "networkShutdownNetworkVirtual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2654-2712",
    "snippet": "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    pid_t radvdPid;\n    pid_t dnsmasqPid;\n\n    if (def->bandwidth)\n        virNetDevBandwidthClear(def->bridge);\n\n    virNetworkObjUnrefMacMap(obj);\n\n    radvdPid = virNetworkObjGetRadvdPid(obj);\n    if (radvdPid > 0) {\n        char *radvdpidbase;\n\n        kill(radvdPid, SIGTERM);\n        /* attempt to delete the pidfile we created */\n        if ((radvdpidbase = networkRadvdPidfileBasename(def->name))) {\n            virPidFileDelete(driver->pidDir, radvdpidbase);\n            VIR_FREE(radvdpidbase);\n        }\n    }\n\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    if (dnsmasqPid > 0)\n        kill(dnsmasqPid, SIGTERM);\n\n    if (def->mac_specified) {\n        char *macTapIfName = networkBridgeDummyNicName(def->bridge);\n        if (macTapIfName) {\n            ignore_value(virNetDevTapDelete(macTapIfName, NULL));\n            VIR_FREE(macTapIfName);\n        }\n    }\n\n    ignore_value(virNetDevSetOnline(def->bridge, 0));\n\n    if (def->forward.type != VIR_NETWORK_FORWARD_OPEN)\n        networkRemoveFirewallRules(def);\n\n    ignore_value(virNetDevBridgeDelete(def->bridge));\n\n    /* See if its still alive and really really kill it */\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    if (dnsmasqPid > 0 &&\n        (kill(dnsmasqPid, 0) == 0))\n        kill(dnsmasqPid, SIGKILL);\n    virNetworkObjSetDnsmasqPid(obj, -1);\n\n    radvdPid = virNetworkObjGetRadvdPid(obj);\n    if (radvdPid > 0 &&\n        (kill(radvdPid, 0) == 0))\n        kill(radvdPid, SIGKILL);\n    virNetworkObjSetRadvdPid(obj, -1);\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjSetRadvdPid",
          "args": [
            "obj",
            "-1"
          ],
          "line": 2709
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetRadvdPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "229-234",
          "snippet": "void\nvirNetworkObjSetRadvdPid(virNetworkObjPtr obj,\n                         pid_t radvdPid)\n{\n    obj->radvdPid = radvdPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetRadvdPid(virNetworkObjPtr obj,\n                         pid_t radvdPid)\n{\n    obj->radvdPid = radvdPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "radvdPid",
            "SIGKILL"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "radvdPid",
            "0"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetRadvdPid",
          "args": [
            "obj"
          ],
          "line": 2705
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetRadvdPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "222-226",
          "snippet": "pid_t\nvirNetworkObjGetRadvdPid(virNetworkObjPtr obj)\n{\n    return obj->radvdPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\npid_t\nvirNetworkObjGetRadvdPid(virNetworkObjPtr obj)\n{\n    return obj->radvdPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetDnsmasqPid",
          "args": [
            "obj",
            "-1"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetDnsmasqPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "214-219",
          "snippet": "void\nvirNetworkObjSetDnsmasqPid(virNetworkObjPtr obj,\n                           pid_t dnsmasqPid)\n{\n    obj->dnsmasqPid = dnsmasqPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetDnsmasqPid(virNetworkObjPtr obj,\n                           pid_t dnsmasqPid)\n{\n    obj->dnsmasqPid = dnsmasqPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "dnsmasqPid",
            "SIGKILL"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "dnsmasqPid",
            "0"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDnsmasqPid",
          "args": [
            "obj"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDnsmasqPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "207-211",
          "snippet": "pid_t\nvirNetworkObjGetDnsmasqPid(virNetworkObjPtr obj)\n{\n    return obj->dnsmasqPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\npid_t\nvirNetworkObjGetDnsmasqPid(virNetworkObjPtr obj)\n{\n    return obj->dnsmasqPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevBridgeDelete(def->bridge)"
          ],
          "line": 2696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBridgeDelete",
          "args": [
            "def->bridge"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBridgeDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbridge.c",
          "lines": "597-602",
          "snippet": "int virNetDevBridgeDelete(const char *brname G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to delete bridge %s\"), brname);\n    return EINVAL;\n}",
          "includes": [
            "# include <net/if_bridgevar.h>",
            "# include <net/ethernet.h>",
            "# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */",
            "# include <linux/in6.h>",
            "# include <linux/param.h>     /* HZ                 */",
            "# include <linux/sockios.h>",
            "#  include \"virnetlink.h\"",
            "# include <net/if.h>",
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <net/if_bridgevar.h>\n# include <net/ethernet.h>\n# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */\n# include <linux/in6.h>\n# include <linux/param.h>     /* HZ                 */\n# include <linux/sockios.h>\n#  include \"virnetlink.h\"\n# include <net/if.h>\n#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevbridge.h\"\n#include <config.h>\n\nint virNetDevBridgeDelete(const char *brname G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to delete bridge %s\"), brname);\n    return EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRemoveFirewallRules",
          "args": [
            "def"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_nop.c",
          "lines": "43-45",
          "snippet": "void networkRemoveFirewallRules(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nvoid networkRemoveFirewallRules(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevSetOnline(def->bridge, 0)"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevSetOnline",
          "args": [
            "def->bridge",
            "0"
          ],
          "line": 2691
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevSetOnline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "660-665",
          "snippet": "int\nvirNetDevSetOnline(const char *ifname,\n                   bool online)\n{\n    return virNetDevSetIFFlag(ifname, VIR_IFF_UP, online);\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevSetOnline(const char *ifname,\n                   bool online)\n{\n    return virNetDevSetIFFlag(ifname, VIR_IFF_UP, online);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "macTapIfName"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevTapDelete(macTapIfName, NULL)"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevTapDelete",
          "args": [
            "macTapIfName",
            "NULL"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevTapDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevtap.c",
          "lines": "476-482",
          "snippet": "int virNetDevTapDelete(const char *ifname G_GNUC_UNUSED,\n                       const char *tunpath G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to delete TAP devices on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <ifaddrs.h>",
            "# include <sys/sysctl.h>",
            "# include <net/if_mib.h>",
            "# include <linux/if_tun.h>    /* IFF_TUN, IFF_NO_PI */",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"datatypes.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <ifaddrs.h>\n# include <sys/sysctl.h>\n# include <net/if_mib.h>\n# include <linux/if_tun.h>    /* IFF_TUN, IFF_NO_PI */\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"datatypes.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevtap.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint virNetDevTapDelete(const char *ifname G_GNUC_UNUSED,\n                       const char *tunpath G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to delete TAP devices on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkBridgeDummyNicName",
          "args": [
            "def->bridge"
          ],
          "line": 2684
        },
        "resolved": true,
        "details": {
          "function_name": "networkBridgeDummyNicName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "500-522",
          "snippet": "static char *\nnetworkBridgeDummyNicName(const char *brname)\n{\n    static const char dummyNicSuffix[] = \"-nic\";\n    char *nicname;\n\n    if (strlen(brname) + sizeof(dummyNicSuffix) > IFNAMSIZ) {\n        /* because the length of an ifname is limited to IFNAMSIZ-1\n         * (usually 15), and we're adding 4 more characters, we must\n         * truncate the original name to 11 to fit. In order to catch\n         * a possible numeric ending (eg virbr0, virbr1, etc), we grab\n         * the first 8 and last 3 characters of the string.\n         */\n        nicname = g_strdup_printf(\"%.*s%s%s\",\n                                  /* space for last 3 chars + \"-nic\" + NULL */\n                                  (int)(IFNAMSIZ - (3 + sizeof(dummyNicSuffix))),\n                                  brname, brname + strlen(brname) - 3,\n                                  dummyNicSuffix);\n    } else {\n        nicname = g_strdup_printf(\"%s%s\", brname, dummyNicSuffix);\n    }\n    return nicname;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nnetworkBridgeDummyNicName(const char *brname)\n{\n    static const char dummyNicSuffix[] = \"-nic\";\n    char *nicname;\n\n    if (strlen(brname) + sizeof(dummyNicSuffix) > IFNAMSIZ) {\n        /* because the length of an ifname is limited to IFNAMSIZ-1\n         * (usually 15), and we're adding 4 more characters, we must\n         * truncate the original name to 11 to fit. In order to catch\n         * a possible numeric ending (eg virbr0, virbr1, etc), we grab\n         * the first 8 and last 3 characters of the string.\n         */\n        nicname = g_strdup_printf(\"%.*s%s%s\",\n                                  /* space for last 3 chars + \"-nic\" + NULL */\n                                  (int)(IFNAMSIZ - (3 + sizeof(dummyNicSuffix))),\n                                  brname, brname + strlen(brname) - 3,\n                                  dummyNicSuffix);\n    } else {\n        nicname = g_strdup_printf(\"%s%s\", brname, dummyNicSuffix);\n    }\n    return nicname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "dnsmasqPid",
            "SIGTERM"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "radvdpidbase"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileDelete",
          "args": [
            "driver->pidDir",
            "radvdpidbase"
          ],
          "line": 2674
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "316-328",
          "snippet": "int virPidFileDelete(const char *dir,\n                     const char *name)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileDeletePath(pidfile);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileDelete(const char *dir,\n                     const char *name)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileDeletePath(pidfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRadvdPidfileBasename",
          "args": [
            "def->name"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "networkRadvdPidfileBasename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "400-408",
          "snippet": "static char *\nnetworkRadvdPidfileBasename(const char *netname)\n{\n    /* this is simple but we want to be sure it's consistently done */\n    char *pidfilebase;\n\n    pidfilebase = g_strdup_printf(\"%s-radvd\", netname);\n    return pidfilebase;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nnetworkRadvdPidfileBasename(const char *netname)\n{\n    /* this is simple but we want to be sure it's consistently done */\n    char *pidfilebase;\n\n    pidfilebase = g_strdup_printf(\"%s-radvd\", netname);\n    return pidfilebase;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "radvdPid",
            "SIGTERM"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjUnrefMacMap",
          "args": [
            "obj"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjUnrefMacMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "274-279",
          "snippet": "void\nvirNetworkObjUnrefMacMap(virNetworkObjPtr obj)\n{\n    virObjectUnref(obj->macmap);\n    obj->macmap = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjUnrefMacMap(virNetworkObjPtr obj)\n{\n    virObjectUnref(obj->macmap);\n    obj->macmap = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthClear",
          "args": [
            "def->bridge"
          ],
          "line": 2663
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "404-431",
          "snippet": "int\nvirNetDevBandwidthClear(const char *ifname)\n{\n    int ret = 0;\n    int dummy; /* for ignoring the exit status */\n    virCommandPtr cmd = NULL;\n\n    if (!ifname)\n       return 0;\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", ifname, \"root\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\",  \"del\", \"dev\", ifname, \"ingress\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthClear(const char *ifname)\n{\n    int ret = 0;\n    int dummy; /* for ignoring the exit status */\n    virCommandPtr cmd = NULL;\n\n    if (!ifname)\n       return 0;\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", ifname, \"root\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\",  \"del\", \"dev\", ifname, \"ingress\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    pid_t radvdPid;\n    pid_t dnsmasqPid;\n\n    if (def->bandwidth)\n        virNetDevBandwidthClear(def->bridge);\n\n    virNetworkObjUnrefMacMap(obj);\n\n    radvdPid = virNetworkObjGetRadvdPid(obj);\n    if (radvdPid > 0) {\n        char *radvdpidbase;\n\n        kill(radvdPid, SIGTERM);\n        /* attempt to delete the pidfile we created */\n        if ((radvdpidbase = networkRadvdPidfileBasename(def->name))) {\n            virPidFileDelete(driver->pidDir, radvdpidbase);\n            VIR_FREE(radvdpidbase);\n        }\n    }\n\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    if (dnsmasqPid > 0)\n        kill(dnsmasqPid, SIGTERM);\n\n    if (def->mac_specified) {\n        char *macTapIfName = networkBridgeDummyNicName(def->bridge);\n        if (macTapIfName) {\n            ignore_value(virNetDevTapDelete(macTapIfName, NULL));\n            VIR_FREE(macTapIfName);\n        }\n    }\n\n    ignore_value(virNetDevSetOnline(def->bridge, 0));\n\n    if (def->forward.type != VIR_NETWORK_FORWARD_OPEN)\n        networkRemoveFirewallRules(def);\n\n    ignore_value(virNetDevBridgeDelete(def->bridge));\n\n    /* See if its still alive and really really kill it */\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    if (dnsmasqPid > 0 &&\n        (kill(dnsmasqPid, 0) == 0))\n        kill(dnsmasqPid, SIGKILL);\n    virNetworkObjSetDnsmasqPid(obj, -1);\n\n    radvdPid = virNetworkObjGetRadvdPid(obj);\n    if (radvdPid > 0 &&\n        (kill(radvdPid, 0) == 0))\n        kill(radvdPid, SIGKILL);\n    virNetworkObjSetRadvdPid(obj, -1);\n\n    return 0;\n}"
  },
  {
    "function_name": "networkStartNetworkVirtual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2440-2651",
    "snippet": "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    size_t i;\n    bool v4present = false, v6present = false;\n    virErrorPtr save_err = NULL;\n    virNetworkIPDefPtr ipdef;\n    virNetDevIPRoutePtr routedef;\n    char *macTapIfName = NULL;\n    virMacMapPtr macmap;\n    char *macMapFile = NULL;\n    int tapfd = -1;\n    bool dnsmasqStarted = false;\n    bool devOnline = false;\n    bool firewalRulesAdded = false;\n\n    /* Check to see if any network IP collides with an existing route */\n    if (networkCheckRouteCollision(def) < 0)\n        return -1;\n\n    /* Create and configure the bridge device */\n    if (!def->bridge) {\n        /* bridge name can only be empty if the config files were\n         * edited directly. Otherwise networkValidate() (called after\n         * parsing the XML from networkCreateXML() and\n         * networkDefine()) guarantees we will have a valid bridge\n         * name before this point. Since hand editing of the config\n         * files is explicitly prohibited we can, with clear\n         * conscience, log an error and fail at this point.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"network '%s' has no bridge name defined\"),\n                       def->name);\n        return -1;\n    }\n    if (virNetDevBridgeCreate(def->bridge, &def->mac) < 0)\n        return -1;\n\n    if (def->mac_specified) {\n        /* To set a mac for the bridge, we need to define a dummy tap\n         * device, set its mac, then attach it to the bridge. As long\n         * as its mac address is lower than any other interface that\n         * gets attached, the bridge will always maintain this mac\n         * address.\n         */\n        macTapIfName = networkBridgeDummyNicName(def->bridge);\n        if (!macTapIfName)\n            goto error;\n        /* Keep tun fd open and interface up to allow for IPv6 DAD to happen */\n        if (virNetDevTapCreateInBridgePort(def->bridge,\n                                           &macTapIfName, &def->mac,\n                                           NULL, NULL, &tapfd, 1, NULL, NULL,\n                                           VIR_TRISTATE_BOOL_NO,\n                                           NULL, def->mtu, NULL,\n                                           VIR_NETDEV_TAP_CREATE_USE_MAC_FOR_BRIDGE |\n                                           VIR_NETDEV_TAP_CREATE_IFUP |\n                                           VIR_NETDEV_TAP_CREATE_PERSIST) < 0) {\n            VIR_FREE(macTapIfName);\n            goto error;\n        }\n    }\n\n    if (!(macMapFile = virMacMapFileName(driver->dnsmasqStateDir,\n                                         def->bridge)) ||\n        !(macmap = virMacMapNew(macMapFile)))\n        goto error;\n\n    virNetworkObjSetMacMap(obj, macmap);\n    macmap = NULL;\n\n    /* Set bridge options */\n\n    /* delay is configured in seconds, but virNetDevBridgeSetSTPDelay\n     * expects milliseconds\n     */\n    if (virNetDevBridgeSetSTPDelay(def->bridge, def->delay * 1000) < 0)\n        goto error;\n\n    if (virNetDevBridgeSetSTP(def->bridge, def->stp ? true : false) < 0)\n        goto error;\n\n    /* Disable IPv6 on the bridge if there are no IPv6 addresses\n     * defined, and set other IPv6 sysctl tunables appropriately.\n     */\n    if (networkSetIPv6Sysctls(obj) < 0)\n        goto error;\n\n    /* Add \"once per network\" rules */\n    if (def->forward.type != VIR_NETWORK_FORWARD_OPEN &&\n        networkAddFirewallRules(def) < 0)\n        goto error;\n\n    firewalRulesAdded = true;\n\n    for (i = 0; (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i)); i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET))\n            v4present = true;\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n            v6present = true;\n\n        /* Add the IP address/netmask to the bridge */\n        if (networkAddAddrToBridge(obj, ipdef) < 0)\n            goto error;\n    }\n\n    if (networkStartHandleMACTableManagerMode(obj, macTapIfName) < 0)\n        goto error;\n\n    /* Bring up the bridge interface */\n    if (virNetDevSetOnline(def->bridge, 1) < 0)\n        goto error;\n\n    devOnline = true;\n\n    for (i = 0; i < def->nroutes; i++) {\n        virSocketAddrPtr gateway = NULL;\n\n        routedef = def->routes[i];\n        gateway = virNetDevIPRouteGetGateway(routedef);\n\n        /* Add the IP route to the bridge */\n        /* ignore errors, error msg will be generated */\n        /* but libvirt will not know and net-destroy will work. */\n        if (VIR_SOCKET_ADDR_VALID(gateway)) {\n            if (networkAddRouteToBridge(obj, routedef) < 0) {\n                /* an error occurred adding the static route */\n                continue; /* for now, do nothing */\n            }\n        }\n    }\n\n    /* If forward.type != NONE, turn on global IP forwarding */\n    if (def->forward.type != VIR_NETWORK_FORWARD_NONE) {\n        if (v6present && !virNetDevIPCheckIPv6Forwarding())\n            goto error; /* Precise error message already provided */\n\n        if (networkEnableIPForwarding(v4present, v6present) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"failed to enable IP forwarding\"));\n            goto error;\n        }\n    }\n\n\n    /* start dnsmasq if there are any IP addresses (v4 or v6) */\n    if ((v4present || v6present) &&\n        networkStartDhcpDaemon(driver, obj) < 0)\n        goto error;\n\n    dnsmasqStarted = true;\n\n    /* start radvd if there are any ipv6 addresses */\n    if (v6present && networkStartRadvd(driver, obj) < 0)\n        goto error;\n\n    /* dnsmasq does not wait for DAD to complete before daemonizing,\n     * so we need to wait for it ourselves.\n     */\n    if (v6present && networkWaitDadFinish(obj) < 0)\n        goto error;\n\n    /* DAD has finished, dnsmasq is now bound to the\n     * bridge's IPv6 address, so we can set the dummy tun down.\n     */\n    if (tapfd >= 0) {\n        if (virNetDevSetOnline(macTapIfName, false) < 0)\n            goto error;\n        VIR_FORCE_CLOSE(tapfd);\n    }\n\n    if (virNetDevBandwidthSet(def->bridge, def->bandwidth, true, true) < 0)\n        goto error;\n\n    VIR_FREE(macTapIfName);\n    VIR_FREE(macMapFile);\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&save_err);\n    if (def->bandwidth)\n       virNetDevBandwidthClear(def->bridge);\n\n    if (dnsmasqStarted) {\n        pid_t dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n        kill(dnsmasqPid, SIGTERM);\n        virNetworkObjSetDnsmasqPid(obj, -1);\n    }\n\n    if (devOnline)\n        ignore_value(virNetDevSetOnline(def->bridge, 0));\n\n    if (firewalRulesAdded &&\n        def->forward.type != VIR_NETWORK_FORWARD_OPEN)\n        networkRemoveFirewallRules(def);\n\n    if (macTapIfName) {\n        VIR_FORCE_CLOSE(tapfd);\n        ignore_value(virNetDevTapDelete(macTapIfName, NULL));\n        VIR_FREE(macTapIfName);\n    }\n    virNetworkObjUnrefMacMap(obj);\n    VIR_FREE(macMapFile);\n\n    ignore_value(virNetDevBridgeDelete(def->bridge));\n\n    virErrorRestore(&save_err);\n    /* coverity[leaked_handle] - 'tapfd' is not leaked */\n    return -1;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&save_err"
          ],
          "line": 2648
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevBridgeDelete(def->bridge)"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBridgeDelete",
          "args": [
            "def->bridge"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBridgeDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbridge.c",
          "lines": "597-602",
          "snippet": "int virNetDevBridgeDelete(const char *brname G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to delete bridge %s\"), brname);\n    return EINVAL;\n}",
          "includes": [
            "# include <net/if_bridgevar.h>",
            "# include <net/ethernet.h>",
            "# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */",
            "# include <linux/in6.h>",
            "# include <linux/param.h>     /* HZ                 */",
            "# include <linux/sockios.h>",
            "#  include \"virnetlink.h\"",
            "# include <net/if.h>",
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <net/if_bridgevar.h>\n# include <net/ethernet.h>\n# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */\n# include <linux/in6.h>\n# include <linux/param.h>     /* HZ                 */\n# include <linux/sockios.h>\n#  include \"virnetlink.h\"\n# include <net/if.h>\n#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevbridge.h\"\n#include <config.h>\n\nint virNetDevBridgeDelete(const char *brname G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to delete bridge %s\"), brname);\n    return EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "macMapFile"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjUnrefMacMap",
          "args": [
            "obj"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjUnrefMacMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "274-279",
          "snippet": "void\nvirNetworkObjUnrefMacMap(virNetworkObjPtr obj)\n{\n    virObjectUnref(obj->macmap);\n    obj->macmap = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjUnrefMacMap(virNetworkObjPtr obj)\n{\n    virObjectUnref(obj->macmap);\n    obj->macmap = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "macTapIfName"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevTapDelete(macTapIfName, NULL)"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevTapDelete",
          "args": [
            "macTapIfName",
            "NULL"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevTapDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevtap.c",
          "lines": "476-482",
          "snippet": "int virNetDevTapDelete(const char *ifname G_GNUC_UNUSED,\n                       const char *tunpath G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to delete TAP devices on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <ifaddrs.h>",
            "# include <sys/sysctl.h>",
            "# include <net/if_mib.h>",
            "# include <linux/if_tun.h>    /* IFF_TUN, IFF_NO_PI */",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"datatypes.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <ifaddrs.h>\n# include <sys/sysctl.h>\n# include <net/if_mib.h>\n# include <linux/if_tun.h>    /* IFF_TUN, IFF_NO_PI */\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"datatypes.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevtap.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint virNetDevTapDelete(const char *ifname G_GNUC_UNUSED,\n                       const char *tunpath G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to delete TAP devices on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "tapfd"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkRemoveFirewallRules",
          "args": [
            "def"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_nop.c",
          "lines": "43-45",
          "snippet": "void networkRemoveFirewallRules(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nvoid networkRemoveFirewallRules(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevSetOnline(def->bridge, 0)"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevSetOnline",
          "args": [
            "def->bridge",
            "0"
          ],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevSetOnline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "660-665",
          "snippet": "int\nvirNetDevSetOnline(const char *ifname,\n                   bool online)\n{\n    return virNetDevSetIFFlag(ifname, VIR_IFF_UP, online);\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevSetOnline(const char *ifname,\n                   bool online)\n{\n    return virNetDevSetIFFlag(ifname, VIR_IFF_UP, online);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetDnsmasqPid",
          "args": [
            "obj",
            "-1"
          ],
          "line": 2628
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetDnsmasqPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "214-219",
          "snippet": "void\nvirNetworkObjSetDnsmasqPid(virNetworkObjPtr obj,\n                           pid_t dnsmasqPid)\n{\n    obj->dnsmasqPid = dnsmasqPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetDnsmasqPid(virNetworkObjPtr obj,\n                           pid_t dnsmasqPid)\n{\n    obj->dnsmasqPid = dnsmasqPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "dnsmasqPid",
            "SIGTERM"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDnsmasqPid",
          "args": [
            "obj"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDnsmasqPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "207-211",
          "snippet": "pid_t\nvirNetworkObjGetDnsmasqPid(virNetworkObjPtr obj)\n{\n    return obj->dnsmasqPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\npid_t\nvirNetworkObjGetDnsmasqPid(virNetworkObjPtr obj)\n{\n    return obj->dnsmasqPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthClear",
          "args": [
            "def->bridge"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "404-431",
          "snippet": "int\nvirNetDevBandwidthClear(const char *ifname)\n{\n    int ret = 0;\n    int dummy; /* for ignoring the exit status */\n    virCommandPtr cmd = NULL;\n\n    if (!ifname)\n       return 0;\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", ifname, \"root\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\",  \"del\", \"dev\", ifname, \"ingress\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthClear(const char *ifname)\n{\n    int ret = 0;\n    int dummy; /* for ignoring the exit status */\n    virCommandPtr cmd = NULL;\n\n    if (!ifname)\n       return 0;\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\", \"del\", \"dev\", ifname, \"root\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    cmd = virCommandNew(TC);\n    virCommandAddArgList(cmd, \"qdisc\",  \"del\", \"dev\", ifname, \"ingress\", NULL);\n\n    if (virCommandRun(cmd, &dummy) < 0)\n        ret = -1;\n\n    virCommandFree(cmd);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&save_err"
          ],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "macMapFile"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "macTapIfName"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevBandwidthSet",
          "args": [
            "def->bridge",
            "def->bandwidth",
            "true",
            "true"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBandwidthSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbandwidth.c",
          "lines": "189-392",
          "snippet": "int\nvirNetDevBandwidthSet(const char *ifname,\n                      const virNetDevBandwidth *bandwidth,\n                      bool hierarchical_class,\n                      bool swapped)\n{\n    int ret = -1;\n    virNetDevBandwidthRatePtr rx = NULL, tx = NULL; /* From domain POV */\n    virCommandPtr cmd = NULL;\n    char *average = NULL;\n    char *peak = NULL;\n    char *burst = NULL;\n\n    if (!bandwidth) {\n        /* nothing to be enabled */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (geteuid() != 0) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Network bandwidth tuning is not available\"\n                         \" in session mode\"));\n        return -1;\n    }\n\n    if (!ifname) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set bandwidth for interface because \"\n                         \"device name is unknown\"));\n        return -1;\n    }\n\n    if (swapped) {\n        rx = bandwidth->out;\n        tx = bandwidth->in;\n    } else {\n        rx = bandwidth->in;\n        tx = bandwidth->out;\n    }\n\n    virNetDevBandwidthClear(ifname);\n\n    if (tx && tx->average) {\n        average = g_strdup_printf(\"%llukbps\", tx->average);\n        if (tx->peak)\n            peak = g_strdup_printf(\"%llukbps\", tx->peak);\n        if (tx->burst)\n            burst = g_strdup_printf(\"%llukb\", tx->burst);\n\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"root\",\n                             \"handle\", \"1:\", \"htb\", \"default\",\n                             hierarchical_class ? \"2\" : \"1\", NULL);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        /* If we are creating a hierarchical class, all non guaranteed traffic\n         * goes to the 1:2 class which will adjust 'rate' dynamically as NICs\n         * with guaranteed throughput are plugged and unplugged. Class 1:1\n         * exists so we don't exceed the maximum limit for the network. For each\n         * NIC with guaranteed throughput a separate classid will be created.\n         * NB '1:' is just a shorter notation of '1:0'.\n         *\n         * To get a picture how this works:\n         *\n         * +-----+     +---------+     +-----------+      +-----------+     +-----+\n         * |     |     |  qdisc  |     | class 1:1 |      | class 1:2 |     |     |\n         * | NIC |     | def 1:2 |     |   rate    |      |   rate    |     | sfq |\n         * |     | --> |         | --> |   peak    | -+-> |   peak    | --> |     |\n         * +-----+     +---------+     +-----------+  |   +-----------+     +-----+\n         *                                            |\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:3 |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                            |   +-----------+     +-----+\n         *                                           ...\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:n |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                                +-----------+     +-----+\n         *\n         * After the routing decision, when is it clear a packet is to be sent\n         * via a particular NIC, it is sent to the root qdisc (queuing\n         * discipline). In this case HTB (Hierarchical Token Bucket). It has\n         * only one direct child class (with id 1:1) which shapes the overall\n         * rate that is sent through the NIC.  This class has at least one child\n         * (1:2) which is meant for all non-privileged (non guaranteed) traffic\n         * from all domains. Then, for each interface with guaranteed\n         * throughput, a separate class (1:n) is created. Imagine a class is a\n         * box. Whenever a packet ends up in a class it is stored in this box\n         * until the kernel sends it, then it is removed from box. Packets are\n         * placed into boxes based on rules (filters) - e.g. depending on\n         * destination IP/MAC address. If there is no rule to be applied, the\n         * root qdisc has a default where such packets go (1:2 in this case).\n         * Packets come in over and over again and boxes get filled more and\n         * more. Imagine that kernel sends packets just once a second. So it\n         * starts to traverse through this tree. It starts with the root qdisc\n         * and through 1:1 it gets to 1:2. It sends packets up to 1:2's 'rate'.\n         * Then it moves to 1:3 and again sends packets up to 1:3's 'rate'.  The\n         * whole process is repeated until 1:n is processed. So now we have\n         * ensured each class its guaranteed bandwidth. If the sum of sent data\n         * doesn't exceed the 'rate' in 1:1 class, we can go further and send\n         * more packets. The rest of available bandwidth is distributed to the\n         * 1:2,1:3...1:n classes by ratio of their 'rate'. As soon as the root\n         * 'rate' limit is reached or there are no more packets to send, we stop\n         * sending and wait another second. Each class has an SFQ qdisc which\n         * shuffles packets in boxes stochastically, so one sender cannot\n         * starve others.\n         *\n         * Therefore, whenever we want to plug in a new guaranteed interface, we\n         * need to create a new class and adjust the 'rate' of the 1:2 class.\n         * When unplugging we do the exact opposite - remove the associated\n         * class, and adjust the 'rate'.\n         *\n         * This description is rather long, but it is still a good idea to read\n         * it before you dig into the code.\n         */\n        if (hierarchical_class) {\n            virCommandFree(cmd);\n            cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                                 \"1:\", \"classid\", \"1:1\", \"htb\", \"rate\", average,\n                                 \"ceil\", peak ? peak : average, NULL);\n            virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n        }\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:1\" : \"1:\", \"classid\",\n                             hierarchical_class ? \"1:2\" : \"1:1\", \"htb\",\n                             \"rate\", average, NULL);\n\n        if (peak)\n            virCommandAddArgList(cmd, \"ceil\", peak, NULL);\n        if (burst)\n            virCommandAddArgList(cmd, \"burst\", burst, NULL);\n\n        virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:2\" : \"1:1\",\n                             \"handle\", \"2:\", \"sfq\", \"perturb\",\n                             \"10\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"1:0\", \"protocol\", \"all\", \"prio\", \"1\", \"handle\",\n                             \"1\", \"fw\", \"flowid\", \"1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        VIR_FREE(average);\n        VIR_FREE(peak);\n        VIR_FREE(burst);\n    }\n\n    if (rx) {\n        average = g_strdup_printf(\"%llukbps\", rx->average);\n        burst = g_strdup_printf(\"%llukb\", rx->burst ? rx->burst : rx->average);\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname,\n                                 \"ingress\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        /* Set filter to match all ingress traffic */\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"ffff:\", \"protocol\", \"all\", \"u32\", \"match\", \"u32\",\n                             \"0\", \"0\", \"police\", \"rate\", average,\n                             \"burst\", burst, \"mtu\", \"64kb\", \"drop\", \"flowid\",\n                             \":1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(average);\n    VIR_FREE(peak);\n    VIR_FREE(burst);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevbandwidth.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetDevBandwidthSet(const char *ifname,\n                      const virNetDevBandwidth *bandwidth,\n                      bool hierarchical_class,\n                      bool swapped)\n{\n    int ret = -1;\n    virNetDevBandwidthRatePtr rx = NULL, tx = NULL; /* From domain POV */\n    virCommandPtr cmd = NULL;\n    char *average = NULL;\n    char *peak = NULL;\n    char *burst = NULL;\n\n    if (!bandwidth) {\n        /* nothing to be enabled */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (geteuid() != 0) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Network bandwidth tuning is not available\"\n                         \" in session mode\"));\n        return -1;\n    }\n\n    if (!ifname) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Unable to set bandwidth for interface because \"\n                         \"device name is unknown\"));\n        return -1;\n    }\n\n    if (swapped) {\n        rx = bandwidth->out;\n        tx = bandwidth->in;\n    } else {\n        rx = bandwidth->in;\n        tx = bandwidth->out;\n    }\n\n    virNetDevBandwidthClear(ifname);\n\n    if (tx && tx->average) {\n        average = g_strdup_printf(\"%llukbps\", tx->average);\n        if (tx->peak)\n            peak = g_strdup_printf(\"%llukbps\", tx->peak);\n        if (tx->burst)\n            burst = g_strdup_printf(\"%llukb\", tx->burst);\n\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"root\",\n                             \"handle\", \"1:\", \"htb\", \"default\",\n                             hierarchical_class ? \"2\" : \"1\", NULL);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        /* If we are creating a hierarchical class, all non guaranteed traffic\n         * goes to the 1:2 class which will adjust 'rate' dynamically as NICs\n         * with guaranteed throughput are plugged and unplugged. Class 1:1\n         * exists so we don't exceed the maximum limit for the network. For each\n         * NIC with guaranteed throughput a separate classid will be created.\n         * NB '1:' is just a shorter notation of '1:0'.\n         *\n         * To get a picture how this works:\n         *\n         * +-----+     +---------+     +-----------+      +-----------+     +-----+\n         * |     |     |  qdisc  |     | class 1:1 |      | class 1:2 |     |     |\n         * | NIC |     | def 1:2 |     |   rate    |      |   rate    |     | sfq |\n         * |     | --> |         | --> |   peak    | -+-> |   peak    | --> |     |\n         * +-----+     +---------+     +-----------+  |   +-----------+     +-----+\n         *                                            |\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:3 |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                            |   +-----------+     +-----+\n         *                                           ...\n         *                                            |   +-----------+     +-----+\n         *                                            |   | class 1:n |     |     |\n         *                                            |   |   rate    |     | sfq |\n         *                                            +-> |   peak    | --> |     |\n         *                                                +-----------+     +-----+\n         *\n         * After the routing decision, when is it clear a packet is to be sent\n         * via a particular NIC, it is sent to the root qdisc (queuing\n         * discipline). In this case HTB (Hierarchical Token Bucket). It has\n         * only one direct child class (with id 1:1) which shapes the overall\n         * rate that is sent through the NIC.  This class has at least one child\n         * (1:2) which is meant for all non-privileged (non guaranteed) traffic\n         * from all domains. Then, for each interface with guaranteed\n         * throughput, a separate class (1:n) is created. Imagine a class is a\n         * box. Whenever a packet ends up in a class it is stored in this box\n         * until the kernel sends it, then it is removed from box. Packets are\n         * placed into boxes based on rules (filters) - e.g. depending on\n         * destination IP/MAC address. If there is no rule to be applied, the\n         * root qdisc has a default where such packets go (1:2 in this case).\n         * Packets come in over and over again and boxes get filled more and\n         * more. Imagine that kernel sends packets just once a second. So it\n         * starts to traverse through this tree. It starts with the root qdisc\n         * and through 1:1 it gets to 1:2. It sends packets up to 1:2's 'rate'.\n         * Then it moves to 1:3 and again sends packets up to 1:3's 'rate'.  The\n         * whole process is repeated until 1:n is processed. So now we have\n         * ensured each class its guaranteed bandwidth. If the sum of sent data\n         * doesn't exceed the 'rate' in 1:1 class, we can go further and send\n         * more packets. The rest of available bandwidth is distributed to the\n         * 1:2,1:3...1:n classes by ratio of their 'rate'. As soon as the root\n         * 'rate' limit is reached or there are no more packets to send, we stop\n         * sending and wait another second. Each class has an SFQ qdisc which\n         * shuffles packets in boxes stochastically, so one sender cannot\n         * starve others.\n         *\n         * Therefore, whenever we want to plug in a new guaranteed interface, we\n         * need to create a new class and adjust the 'rate' of the 1:2 class.\n         * When unplugging we do the exact opposite - remove the associated\n         * class, and adjust the 'rate'.\n         *\n         * This description is rather long, but it is still a good idea to read\n         * it before you dig into the code.\n         */\n        if (hierarchical_class) {\n            virCommandFree(cmd);\n            cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                                 \"1:\", \"classid\", \"1:1\", \"htb\", \"rate\", average,\n                                 \"ceil\", peak ? peak : average, NULL);\n            virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n        }\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"class\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:1\" : \"1:\", \"classid\",\n                             hierarchical_class ? \"1:2\" : \"1:1\", \"htb\",\n                             \"rate\", average, NULL);\n\n        if (peak)\n            virCommandAddArgList(cmd, \"ceil\", peak, NULL);\n        if (burst)\n            virCommandAddArgList(cmd, \"burst\", burst, NULL);\n\n        virNetDevBandwidthCmdAddOptimalQuantum(cmd, tx);\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname, \"parent\",\n                             hierarchical_class ? \"1:2\" : \"1:1\",\n                             \"handle\", \"2:\", \"sfq\", \"perturb\",\n                             \"10\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"1:0\", \"protocol\", \"all\", \"prio\", \"1\", \"handle\",\n                             \"1\", \"fw\", \"flowid\", \"1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        VIR_FREE(average);\n        VIR_FREE(peak);\n        VIR_FREE(burst);\n    }\n\n    if (rx) {\n        average = g_strdup_printf(\"%llukbps\", rx->average);\n        burst = g_strdup_printf(\"%llukb\", rx->burst ? rx->burst : rx->average);\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n            virCommandAddArgList(cmd, \"qdisc\", \"add\", \"dev\", ifname,\n                                 \"ingress\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n\n        virCommandFree(cmd);\n        cmd = virCommandNew(TC);\n        /* Set filter to match all ingress traffic */\n        virCommandAddArgList(cmd, \"filter\", \"add\", \"dev\", ifname, \"parent\",\n                             \"ffff:\", \"protocol\", \"all\", \"u32\", \"match\", \"u32\",\n                             \"0\", \"0\", \"police\", \"rate\", average,\n                             \"burst\", burst, \"mtu\", \"64kb\", \"drop\", \"flowid\",\n                             \":1\", NULL);\n\n        if (virCommandRun(cmd, NULL) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(average);\n    VIR_FREE(peak);\n    VIR_FREE(burst);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "tapfd"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkWaitDadFinish",
          "args": [
            "obj"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "networkWaitDadFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2413-2437",
          "snippet": "static int\nnetworkWaitDadFinish(virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetworkIPDefPtr ipdef;\n    virSocketAddrPtr *addrs = NULL, addr = NULL;\n    size_t naddrs = 0;\n    int ret = -1;\n\n    VIR_DEBUG(\"Begin waiting for IPv6 DAD on network %s\", def->name);\n\n    while ((ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, naddrs))) {\n        addr = &ipdef->address;\n        if (VIR_APPEND_ELEMENT_COPY(addrs, naddrs, addr) < 0)\n            goto cleanup;\n    }\n\n    ret = (naddrs == 0) ? 0 : virNetDevIPWaitDadFinish(addrs, naddrs);\n\n cleanup:\n    VIR_FREE(addrs);\n    VIR_DEBUG(\"Finished waiting for IPv6 DAD on network %s with status %d\",\n              def->name, ret);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkWaitDadFinish(virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetworkIPDefPtr ipdef;\n    virSocketAddrPtr *addrs = NULL, addr = NULL;\n    size_t naddrs = 0;\n    int ret = -1;\n\n    VIR_DEBUG(\"Begin waiting for IPv6 DAD on network %s\", def->name);\n\n    while ((ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, naddrs))) {\n        addr = &ipdef->address;\n        if (VIR_APPEND_ELEMENT_COPY(addrs, naddrs, addr) < 0)\n            goto cleanup;\n    }\n\n    ret = (naddrs == 0) ? 0 : virNetDevIPWaitDadFinish(addrs, naddrs);\n\n cleanup:\n    VIR_FREE(addrs);\n    VIR_DEBUG(\"Finished waiting for IPv6 DAD on network %s with status %d\",\n              def->name, ret);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkStartRadvd",
          "args": [
            "driver",
            "obj"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "networkStartRadvd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1971-2060",
          "snippet": "static int\nnetworkStartRadvd(virNetworkDriverStatePtr driver,\n                  virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    dnsmasqCapsPtr dnsmasq_caps = networkGetDnsmasqCaps(driver);\n    pid_t radvdPid;\n    char *pidfile = NULL;\n    char *radvdpidbase = NULL;\n    char *configfile = NULL;\n    virCommandPtr cmd = NULL;\n    int ret = -1;\n\n    virNetworkObjSetRadvdPid(obj, -1);\n\n    /* Is dnsmasq handling RA? */\n    if (DNSMASQ_RA_SUPPORT(dnsmasq_caps)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* no IPv6 addresses, so we don't need to run radvd */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virFileIsExecutable(RADVD)) {\n        virReportSystemError(errno,\n                             _(\"Cannot find %s - \"\n                               \"Possibly the package isn't installed\"),\n                             RADVD);\n        goto cleanup;\n    }\n\n    if (virFileMakePath(driver->pidDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->pidDir);\n        goto cleanup;\n    }\n    if (virFileMakePath(driver->radvdStateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->radvdStateDir);\n        goto cleanup;\n    }\n\n    /* construct pidfile name */\n    if (!(radvdpidbase = networkRadvdPidfileBasename(def->name)))\n        goto cleanup;\n    if (!(pidfile = virPidFileBuildPath(driver->pidDir, radvdpidbase)))\n        goto cleanup;\n\n    if (networkRadvdConfWrite(driver, obj, &configfile) < 0)\n        goto cleanup;\n\n    /* prevent radvd from daemonizing itself with \"--debug 1\", and use\n     * a dummy pidfile name - virCommand will create the pidfile we\n     * want to use (this is necessary because radvd's internal\n     * daemonization and pidfile creation causes a race, and the\n     * virPidFileRead() below will fail if we use them).\n     * Unfortunately, it isn't possible to tell radvd to not create\n     * its own pidfile, so we just let it do so, with a slightly\n     * different name. Unused, but harmless.\n     */\n    cmd = virCommandNewArgList(RADVD, \"--debug\", \"1\",\n                               \"--config\", configfile,\n                               \"--pidfile\", NULL);\n    virCommandAddArgFormat(cmd, \"%s-bin\", pidfile);\n\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandDaemonize(cmd);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virPidFileRead(driver->pidDir, radvdpidbase, &radvdPid) < 0)\n        goto cleanup;\n    virNetworkObjSetRadvdPid(obj, radvdPid);\n\n    ret = 0;\n cleanup:\n    virObjectUnref(dnsmasq_caps);\n    virCommandFree(cmd);\n    VIR_FREE(configfile);\n    VIR_FREE(radvdpidbase);\n    VIR_FREE(pidfile);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStartRadvd(virNetworkDriverStatePtr driver,\n                  virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    dnsmasqCapsPtr dnsmasq_caps = networkGetDnsmasqCaps(driver);\n    pid_t radvdPid;\n    char *pidfile = NULL;\n    char *radvdpidbase = NULL;\n    char *configfile = NULL;\n    virCommandPtr cmd = NULL;\n    int ret = -1;\n\n    virNetworkObjSetRadvdPid(obj, -1);\n\n    /* Is dnsmasq handling RA? */\n    if (DNSMASQ_RA_SUPPORT(dnsmasq_caps)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* no IPv6 addresses, so we don't need to run radvd */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virFileIsExecutable(RADVD)) {\n        virReportSystemError(errno,\n                             _(\"Cannot find %s - \"\n                               \"Possibly the package isn't installed\"),\n                             RADVD);\n        goto cleanup;\n    }\n\n    if (virFileMakePath(driver->pidDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->pidDir);\n        goto cleanup;\n    }\n    if (virFileMakePath(driver->radvdStateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->radvdStateDir);\n        goto cleanup;\n    }\n\n    /* construct pidfile name */\n    if (!(radvdpidbase = networkRadvdPidfileBasename(def->name)))\n        goto cleanup;\n    if (!(pidfile = virPidFileBuildPath(driver->pidDir, radvdpidbase)))\n        goto cleanup;\n\n    if (networkRadvdConfWrite(driver, obj, &configfile) < 0)\n        goto cleanup;\n\n    /* prevent radvd from daemonizing itself with \"--debug 1\", and use\n     * a dummy pidfile name - virCommand will create the pidfile we\n     * want to use (this is necessary because radvd's internal\n     * daemonization and pidfile creation causes a race, and the\n     * virPidFileRead() below will fail if we use them).\n     * Unfortunately, it isn't possible to tell radvd to not create\n     * its own pidfile, so we just let it do so, with a slightly\n     * different name. Unused, but harmless.\n     */\n    cmd = virCommandNewArgList(RADVD, \"--debug\", \"1\",\n                               \"--config\", configfile,\n                               \"--pidfile\", NULL);\n    virCommandAddArgFormat(cmd, \"%s-bin\", pidfile);\n\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandDaemonize(cmd);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virPidFileRead(driver->pidDir, radvdpidbase, &radvdPid) < 0)\n        goto cleanup;\n    virNetworkObjSetRadvdPid(obj, radvdPid);\n\n    ret = 0;\n cleanup:\n    virObjectUnref(dnsmasq_caps);\n    virCommandFree(cmd);\n    VIR_FREE(configfile);\n    VIR_FREE(radvdpidbase);\n    VIR_FREE(pidfile);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkStartDhcpDaemon",
          "args": [
            "driver",
            "obj"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "networkStartDhcpDaemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1659-1748",
          "snippet": "static int\nnetworkStartDhcpDaemon(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetworkIPDefPtr ipdef;\n    size_t i;\n    bool needDnsmasq = false;\n    virCommandPtr cmd = NULL;\n    char *pidfile = NULL;\n    pid_t dnsmasqPid;\n    int ret = -1;\n    dnsmasqContext *dctx = NULL;\n\n    /* see if there are any IP addresses that need a dhcp server */\n    i = 0;\n    while ((ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i))) {\n        i++;\n        if (ipdef->nranges || ipdef->nhosts)\n            needDnsmasq = true;\n    }\n\n    if (i == 0) {\n        /* no IP addresses at all, so we don't need to run */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!needDnsmasq && def->dns.enable == VIR_TRISTATE_BOOL_NO) {\n        /* no DHCP services needed, and user disabled DNS service */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileMakePath(driver->pidDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->pidDir);\n        goto cleanup;\n    }\n\n    if (!(pidfile = virPidFileBuildPath(driver->pidDir, def->name)))\n        goto cleanup;\n\n    if (virFileMakePath(driver->dnsmasqStateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->dnsmasqStateDir);\n        goto cleanup;\n    }\n\n    dctx = dnsmasqContextNew(def->name, driver->dnsmasqStateDir);\n    if (dctx == NULL)\n        goto cleanup;\n\n    if (networkDnsmasqCapsRefresh(driver) < 0)\n        goto cleanup;\n\n    ret = networkBuildDhcpDaemonCommandLine(driver, obj, &cmd, pidfile, dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = dnsmasqSave(dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0)\n        goto cleanup;\n\n    /*\n     * There really is no race here - when dnsmasq daemonizes, its\n     * leader process stays around until its child has actually\n     * written its pidfile. So by time virCommandRun exits it has\n     * waitpid'd and guaranteed the proess has started and written a\n     * pid\n     */\n\n    ret = virPidFileRead(driver->pidDir, def->name, &dnsmasqPid);\n    if (ret < 0)\n        goto cleanup;\n    virNetworkObjSetDnsmasqPid(obj, dnsmasqPid);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pidfile);\n    virCommandFree(cmd);\n    dnsmasqContextFree(dctx);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStartDhcpDaemon(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetworkIPDefPtr ipdef;\n    size_t i;\n    bool needDnsmasq = false;\n    virCommandPtr cmd = NULL;\n    char *pidfile = NULL;\n    pid_t dnsmasqPid;\n    int ret = -1;\n    dnsmasqContext *dctx = NULL;\n\n    /* see if there are any IP addresses that need a dhcp server */\n    i = 0;\n    while ((ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i))) {\n        i++;\n        if (ipdef->nranges || ipdef->nhosts)\n            needDnsmasq = true;\n    }\n\n    if (i == 0) {\n        /* no IP addresses at all, so we don't need to run */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!needDnsmasq && def->dns.enable == VIR_TRISTATE_BOOL_NO) {\n        /* no DHCP services needed, and user disabled DNS service */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileMakePath(driver->pidDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->pidDir);\n        goto cleanup;\n    }\n\n    if (!(pidfile = virPidFileBuildPath(driver->pidDir, def->name)))\n        goto cleanup;\n\n    if (virFileMakePath(driver->dnsmasqStateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->dnsmasqStateDir);\n        goto cleanup;\n    }\n\n    dctx = dnsmasqContextNew(def->name, driver->dnsmasqStateDir);\n    if (dctx == NULL)\n        goto cleanup;\n\n    if (networkDnsmasqCapsRefresh(driver) < 0)\n        goto cleanup;\n\n    ret = networkBuildDhcpDaemonCommandLine(driver, obj, &cmd, pidfile, dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = dnsmasqSave(dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0)\n        goto cleanup;\n\n    /*\n     * There really is no race here - when dnsmasq daemonizes, its\n     * leader process stays around until its child has actually\n     * written its pidfile. So by time virCommandRun exits it has\n     * waitpid'd and guaranteed the proess has started and written a\n     * pid\n     */\n\n    ret = virPidFileRead(driver->pidDir, def->name, &dnsmasqPid);\n    if (ret < 0)\n        goto cleanup;\n    virNetworkObjSetDnsmasqPid(obj, dnsmasqPid);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pidfile);\n    virCommandFree(cmd);\n    dnsmasqContextFree(dctx);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to enable IP forwarding\")"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to enable IP forwarding\""
          ],
          "line": 2580
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkEnableIPForwarding",
          "args": [
            "v4present",
            "v6present"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "networkEnableIPForwarding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2254-2275",
          "snippet": "static int\nnetworkEnableIPForwarding(bool enableIPv4,\n                          bool enableIPv6)\n{\n    int ret = 0;\n#ifdef HAVE_SYSCTLBYNAME\n    int enabled = 1;\n    if (enableIPv4)\n        ret = sysctlbyname(\"net.inet.ip.forwarding\", NULL, 0,\n                           &enabled, sizeof(enabled));\n    if (enableIPv6 && ret == 0)\n        ret = sysctlbyname(\"net.inet6.ip6.forwarding\", NULL, 0,\n                           &enabled, sizeof(enabled));\n#else\n    if (enableIPv4)\n        ret = virFileWriteStr(SYSCTL_PATH \"/net/ipv4/ip_forward\", \"1\\n\", 0);\n    if (enableIPv6 && ret == 0)\n        ret = virFileWriteStr(SYSCTL_PATH \"/net/ipv6/conf/all/forwarding\", \"1\\n\", 0);\n\n#endif\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSCTL_PATH \"/proc/sys\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SYSCTL_PATH \"/proc/sys\"\n\nstatic int\nnetworkEnableIPForwarding(bool enableIPv4,\n                          bool enableIPv6)\n{\n    int ret = 0;\n#ifdef HAVE_SYSCTLBYNAME\n    int enabled = 1;\n    if (enableIPv4)\n        ret = sysctlbyname(\"net.inet.ip.forwarding\", NULL, 0,\n                           &enabled, sizeof(enabled));\n    if (enableIPv6 && ret == 0)\n        ret = sysctlbyname(\"net.inet6.ip6.forwarding\", NULL, 0,\n                           &enabled, sizeof(enabled));\n#else\n    if (enableIPv4)\n        ret = virFileWriteStr(SYSCTL_PATH \"/net/ipv4/ip_forward\", \"1\\n\", 0);\n    if (enableIPv6 && ret == 0)\n        ret = virFileWriteStr(SYSCTL_PATH \"/net/ipv6/conf/all/forwarding\", \"1\\n\", 0);\n\n#endif\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIPCheckIPv6Forwarding",
          "args": [],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPCheckIPv6Forwarding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "815-820",
          "snippet": "bool\nvirNetDevIPCheckIPv6Forwarding(void)\n{\n    VIR_WARN(\"built without libnl: unable to check if IPv6 forwarding can be safely enabled\");\n    return true;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nbool\nvirNetDevIPCheckIPv6Forwarding(void)\n{\n    VIR_WARN(\"built without libnl: unable to check if IPv6 forwarding can be safely enabled\");\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkAddRouteToBridge",
          "args": [
            "obj",
            "routedef"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "networkAddRouteToBridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2389-2411",
          "snippet": "static int\nnetworkAddRouteToBridge(virNetworkObjPtr obj,\n                        virNetDevIPRoutePtr routedef)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int prefix = virNetDevIPRouteGetPrefix(routedef);\n    unsigned int metric = virNetDevIPRouteGetMetric(routedef);\n    virSocketAddrPtr addr = virNetDevIPRouteGetAddress(routedef);\n    virSocketAddrPtr gateway = virNetDevIPRouteGetGateway(routedef);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"network '%s' has an invalid netmask \"\n                         \"or IP address in route definition\"),\n                       def->name);\n        return -1;\n    }\n\n    if (virNetDevIPRouteAdd(def->bridge, addr, prefix, gateway, metric) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkAddRouteToBridge(virNetworkObjPtr obj,\n                        virNetDevIPRoutePtr routedef)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int prefix = virNetDevIPRouteGetPrefix(routedef);\n    unsigned int metric = virNetDevIPRouteGetMetric(routedef);\n    virSocketAddrPtr addr = virNetDevIPRouteGetAddress(routedef);\n    virSocketAddrPtr gateway = virNetDevIPRouteGetGateway(routedef);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"network '%s' has an invalid netmask \"\n                         \"or IP address in route definition\"),\n                       def->name);\n        return -1;\n    }\n\n    if (virNetDevIPRouteAdd(def->bridge, addr, prefix, gateway, metric) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "gateway"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteGetGateway",
          "args": [
            "routedef"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteGetGateway",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "1035-1041",
          "snippet": "virSocketAddrPtr\nvirNetDevIPRouteGetGateway(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->gateway;\n    return NULL;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvirSocketAddrPtr\nvirNetDevIPRouteGetGateway(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->gateway;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkStartHandleMACTableManagerMode",
          "args": [
            "obj",
            "macTapIfName"
          ],
          "line": 2547
        },
        "resolved": true,
        "details": {
          "function_name": "networkStartHandleMACTableManagerMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2366-2385",
          "snippet": "static int\nnetworkStartHandleMACTableManagerMode(virNetworkObjPtr obj,\n                                      const char *macTapIfName)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    const char *brname = def->bridge;\n\n    if (brname &&\n        def->macTableManager == VIR_NETWORK_BRIDGE_MAC_TABLE_MANAGER_LIBVIRT) {\n        if (virNetDevBridgeSetVlanFiltering(brname, true) < 0)\n            return -1;\n        if (macTapIfName) {\n            if (virNetDevBridgePortSetLearning(brname, macTapIfName, false) < 0)\n                return -1;\n            if (virNetDevBridgePortSetUnicastFlood(brname, macTapIfName, false) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkStartHandleMACTableManagerMode(virNetworkObjPtr obj,\n                                      const char *macTapIfName)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    const char *brname = def->bridge;\n\n    if (brname &&\n        def->macTableManager == VIR_NETWORK_BRIDGE_MAC_TABLE_MANAGER_LIBVIRT) {\n        if (virNetDevBridgeSetVlanFiltering(brname, true) < 0)\n            return -1;\n        if (macTapIfName) {\n            if (virNetDevBridgePortSetLearning(brname, macTapIfName, false) < 0)\n                return -1;\n            if (virNetDevBridgePortSetUnicastFlood(brname, macTapIfName, false) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkAddAddrToBridge",
          "args": [
            "obj",
            "ipdef"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "networkAddAddrToBridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2345-2363",
          "snippet": "static int\nnetworkAddAddrToBridge(virNetworkObjPtr obj,\n                       virNetworkIPDefPtr ipdef)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int prefix = virNetworkIPDefPrefix(ipdef);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"bridge '%s' has an invalid netmask or IP address\"),\n                       def->bridge);\n        return -1;\n    }\n\n    if (virNetDevIPAddrAdd(def->bridge, &ipdef->address, NULL, prefix) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkAddAddrToBridge(virNetworkObjPtr obj,\n                       virNetworkIPDefPtr ipdef)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int prefix = virNetworkIPDefPrefix(ipdef);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"bridge '%s' has an invalid netmask or IP address\"),\n                       def->bridge);\n        return -1;\n    }\n\n    if (virNetDevIPAddrAdd(def->bridge, &ipdef->address, NULL, prefix) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef->address",
            "AF_INET6"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef->address",
            "AF_INET"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_UNSPEC",
            "i"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkAddFirewallRules",
          "args": [
            "def"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "networkAddFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_nop.c",
          "lines": "38-41",
          "snippet": "int networkAddFirewallRules(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nint networkAddFirewallRules(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkSetIPv6Sysctls",
          "args": [
            "obj"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "networkSetIPv6Sysctls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2278-2341",
          "snippet": "static int\nnetworkSetIPv6Sysctls(virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    char *field = NULL;\n    int ret = -1;\n    bool enableIPv6 = !!virNetworkDefGetIPByIndex(def, AF_INET6, 0);\n\n    /* set disable_ipv6 if there are no ipv6 addresses defined for the\n     * network. But also unset it if there *are* ipv6 addresses, as we\n     * can't be sure of its default value.\n     */\n    field = g_strdup_printf(SYSCTL_PATH \"/net/ipv6/conf/%s/disable_ipv6\",\n                            def->bridge);\n\n    if (access(field, W_OK) < 0 && errno == ENOENT) {\n        if (!enableIPv6)\n            VIR_DEBUG(\"ipv6 appears to already be disabled on %s\",\n                      def->bridge);\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileWriteStr(field, enableIPv6 ? \"0\" : \"1\", 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot write to %s to enable/disable IPv6 \"\n                               \"on bridge %s\"), field, def->bridge);\n        goto cleanup;\n    }\n    VIR_FREE(field);\n\n    /* The rest of the ipv6 sysctl tunables should always be set the\n     * same, whether or not we're using ipv6 on this bridge.\n     */\n\n    /* Prevent guests from hijacking the host network by sending out\n     * their own router advertisements.\n     */\n    field = g_strdup_printf(SYSCTL_PATH \"/net/ipv6/conf/%s/accept_ra\",\n                            def->bridge);\n\n    if (virFileWriteStr(field, \"0\", 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot disable %s\"), field);\n        goto cleanup;\n    }\n    VIR_FREE(field);\n\n    /* All interfaces used as a gateway (which is what this is, by\n     * definition), must always have autoconf=0.\n     */\n    field = g_strdup_printf(SYSCTL_PATH \"/net/ipv6/conf/%s/autoconf\", def->bridge);\n\n    if (virFileWriteStr(field, \"0\", 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot disable %s\"), field);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(field);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSCTL_PATH \"/proc/sys\""
          ],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SYSCTL_PATH \"/proc/sys\"\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkSetIPv6Sysctls(virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    char *field = NULL;\n    int ret = -1;\n    bool enableIPv6 = !!virNetworkDefGetIPByIndex(def, AF_INET6, 0);\n\n    /* set disable_ipv6 if there are no ipv6 addresses defined for the\n     * network. But also unset it if there *are* ipv6 addresses, as we\n     * can't be sure of its default value.\n     */\n    field = g_strdup_printf(SYSCTL_PATH \"/net/ipv6/conf/%s/disable_ipv6\",\n                            def->bridge);\n\n    if (access(field, W_OK) < 0 && errno == ENOENT) {\n        if (!enableIPv6)\n            VIR_DEBUG(\"ipv6 appears to already be disabled on %s\",\n                      def->bridge);\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileWriteStr(field, enableIPv6 ? \"0\" : \"1\", 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot write to %s to enable/disable IPv6 \"\n                               \"on bridge %s\"), field, def->bridge);\n        goto cleanup;\n    }\n    VIR_FREE(field);\n\n    /* The rest of the ipv6 sysctl tunables should always be set the\n     * same, whether or not we're using ipv6 on this bridge.\n     */\n\n    /* Prevent guests from hijacking the host network by sending out\n     * their own router advertisements.\n     */\n    field = g_strdup_printf(SYSCTL_PATH \"/net/ipv6/conf/%s/accept_ra\",\n                            def->bridge);\n\n    if (virFileWriteStr(field, \"0\", 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot disable %s\"), field);\n        goto cleanup;\n    }\n    VIR_FREE(field);\n\n    /* All interfaces used as a gateway (which is what this is, by\n     * definition), must always have autoconf=0.\n     */\n    field = g_strdup_printf(SYSCTL_PATH \"/net/ipv6/conf/%s/autoconf\", def->bridge);\n\n    if (virFileWriteStr(field, \"0\", 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot disable %s\"), field);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(field);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBridgeSetSTP",
          "args": [
            "def->bridge",
            "def->stp ? true : false"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBridgeSetSTP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbridge.c",
          "lines": "893-901",
          "snippet": "int virNetDevBridgeSetSTP(const char *brname,\n                          bool enable G_GNUC_UNUSED)\n\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to set STP on %s on this platform\"),\n                         brname);\n    return -1;\n}",
          "includes": [
            "# include <net/if_bridgevar.h>",
            "# include <net/ethernet.h>",
            "# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */",
            "# include <linux/in6.h>",
            "# include <linux/param.h>     /* HZ                 */",
            "# include <linux/sockios.h>",
            "#  include \"virnetlink.h\"",
            "# include <net/if.h>",
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <net/if_bridgevar.h>\n# include <net/ethernet.h>\n# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */\n# include <linux/in6.h>\n# include <linux/param.h>     /* HZ                 */\n# include <linux/sockios.h>\n#  include \"virnetlink.h\"\n# include <net/if.h>\n#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevbridge.h\"\n#include <config.h>\n\nint virNetDevBridgeSetSTP(const char *brname,\n                          bool enable G_GNUC_UNUSED)\n\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to set STP on %s on this platform\"),\n                         brname);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBridgeSetSTPDelay",
          "args": [
            "def->bridge",
            "def->delay * 1000"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBridgeSetSTPDelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbridge.c",
          "lines": "876-883",
          "snippet": "int virNetDevBridgeSetSTPDelay(const char *brname,\n                               int delay G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to set STP delay on %s on this platform\"),\n                         brname);\n    return -1;\n}",
          "includes": [
            "# include <net/if_bridgevar.h>",
            "# include <net/ethernet.h>",
            "# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */",
            "# include <linux/in6.h>",
            "# include <linux/param.h>     /* HZ                 */",
            "# include <linux/sockios.h>",
            "#  include \"virnetlink.h\"",
            "# include <net/if.h>",
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <net/if_bridgevar.h>\n# include <net/ethernet.h>\n# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */\n# include <linux/in6.h>\n# include <linux/param.h>     /* HZ                 */\n# include <linux/sockios.h>\n#  include \"virnetlink.h\"\n# include <net/if.h>\n#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevbridge.h\"\n#include <config.h>\n\nint virNetDevBridgeSetSTPDelay(const char *brname,\n                               int delay G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to set STP delay on %s on this platform\"),\n                         brname);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetMacMap",
          "args": [
            "obj",
            "macmap"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetMacMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "266-271",
          "snippet": "void\nvirNetworkObjSetMacMap(virNetworkObjPtr obj,\n                       virMacMapPtr macmap)\n{\n    obj->macmap = macmap;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetMacMap(virNetworkObjPtr obj,\n                       virMacMapPtr macmap)\n{\n    obj->macmap = macmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacMapNew",
          "args": [
            "macMapFile"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "virMacMapNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacmap.c",
          "lines": "290-316",
          "snippet": "virMacMapPtr\nvirMacMapNew(const char *file)\n{\n    virMacMapPtr mgr;\n\n    if (virMacMapInitialize() < 0)\n        return NULL;\n\n    if (!(mgr = virObjectLockableNew(virMacMapClass)))\n        return NULL;\n\n    virObjectLock(mgr);\n    if (!(mgr->macs = virHashCreate(VIR_MAC_HASH_TABLE_SIZE, NULL)))\n        goto error;\n\n    if (file &&\n        virMacMapLoadFile(mgr, file) < 0)\n        goto error;\n\n    virObjectUnlock(mgr);\n    return mgr;\n\n error:\n    virObjectUnlock(mgr);\n    virObjectUnref(mgr);\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virjson.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"virmacmap.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_MAC_HASH_TABLE_SIZE 10"
          ],
          "globals_used": [
            "static virClassPtr virMacMapClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virjson.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"virmacmap.h\"\n#include <config.h>\n\n#define VIR_MAC_HASH_TABLE_SIZE 10\n\nstatic virClassPtr virMacMapClass;\n\nvirMacMapPtr\nvirMacMapNew(const char *file)\n{\n    virMacMapPtr mgr;\n\n    if (virMacMapInitialize() < 0)\n        return NULL;\n\n    if (!(mgr = virObjectLockableNew(virMacMapClass)))\n        return NULL;\n\n    virObjectLock(mgr);\n    if (!(mgr->macs = virHashCreate(VIR_MAC_HASH_TABLE_SIZE, NULL)))\n        goto error;\n\n    if (file &&\n        virMacMapLoadFile(mgr, file) < 0)\n        goto error;\n\n    virObjectUnlock(mgr);\n    return mgr;\n\n error:\n    virObjectUnlock(mgr);\n    virObjectUnref(mgr);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacMapFileName",
          "args": [
            "driver->dnsmasqStateDir",
            "def->bridge"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "virMacMapFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacmap.c",
          "lines": "276-285",
          "snippet": "char *\nvirMacMapFileName(const char *dnsmasqStateDir,\n                  const char *bridge)\n{\n    char *filename;\n\n    filename = g_strdup_printf(\"%s/%s.macs\", dnsmasqStateDir, bridge);\n\n    return filename;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virjson.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"virmacmap.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virjson.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"virmacmap.h\"\n#include <config.h>\n\nchar *\nvirMacMapFileName(const char *dnsmasqStateDir,\n                  const char *bridge)\n{\n    char *filename;\n\n    filename = g_strdup_printf(\"%s/%s.macs\", dnsmasqStateDir, bridge);\n\n    return filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "macTapIfName"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevTapCreateInBridgePort",
          "args": [
            "def->bridge",
            "&macTapIfName",
            "&def->mac",
            "NULL",
            "NULL",
            "&tapfd",
            "1",
            "NULL",
            "NULL",
            "VIR_TRISTATE_BOOL_NO",
            "NULL",
            "def->mtu",
            "NULL",
            "VIR_NETDEV_TAP_CREATE_USE_MAC_FOR_BRIDGE |\n                                           VIR_NETDEV_TAP_CREATE_IFUP |\n                                           VIR_NETDEV_TAP_CREATE_PERSIST"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevTapCreateInBridgePort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevtap.c",
          "lines": "667-732",
          "snippet": "int virNetDevTapCreateInBridgePort(const char *brname,\n                                   char **ifname,\n                                   const virMacAddr *macaddr,\n                                   const unsigned char *vmuuid,\n                                   const char *tunpath,\n                                   int *tapfd,\n                                   size_t tapfdSize,\n                                   const virNetDevVPortProfile *virtPortProfile,\n                                   const virNetDevVlan *virtVlan,\n                                   virTristateBool isolatedPort,\n                                   virNetDevCoalescePtr coalesce,\n                                   unsigned int mtu,\n                                   unsigned int *actualMTU,\n                                   unsigned int flags)\n{\n    virMacAddr tapmac;\n    size_t i;\n\n    if (virNetDevTapCreate(ifname, tunpath, tapfd, tapfdSize, flags) < 0)\n        return -1;\n\n    /* We need to set the interface MAC before adding it\n     * to the bridge, because the bridge assumes the lowest\n     * MAC of all enslaved interfaces & we don't want it\n     * seeing the kernel allocate random MAC for the TAP\n     * device before we set our static MAC.\n     */\n    virMacAddrSet(&tapmac, macaddr);\n    if (!(flags & VIR_NETDEV_TAP_CREATE_USE_MAC_FOR_BRIDGE)) {\n        /* The tap device's MAC address cannot match the MAC address\n         * used by the guest. This results in \"received packet on\n         * vnetX with own address as source address\" error logs from\n         * the kernel. Making the tap address as high as possible\n         * discourages the bridge from using this tap's MAC as its own\n         * (a Linux host bridge will take on the lowest numbered MAC\n         * of all devices attached to it).\n         */\n        if (tapmac.addr[0] == 0xFE)\n            tapmac.addr[0] = 0xFA;\n        else\n            tapmac.addr[0] = 0xFE;\n    }\n\n    if (virNetDevSetMAC(*ifname, &tapmac) < 0)\n        goto error;\n\n    if (virNetDevTapAttachBridge(*ifname, brname, macaddr, vmuuid,\n                                 virtPortProfile, virtVlan,\n                                 isolatedPort, mtu, actualMTU) < 0) {\n        goto error;\n    }\n\n    if (virNetDevSetOnline(*ifname, !!(flags & VIR_NETDEV_TAP_CREATE_IFUP)) < 0)\n        goto error;\n\n    if (virNetDevSetCoalesce(*ifname, coalesce, false) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    for (i = 0; i < tapfdSize && tapfd[i] >= 0; i++)\n        VIR_FORCE_CLOSE(tapfd[i]);\n\n    return -1;\n}",
          "includes": [
            "# include <ifaddrs.h>",
            "# include <sys/sysctl.h>",
            "# include <net/if_mib.h>",
            "# include <linux/if_tun.h>    /* IFF_TUN, IFF_NO_PI */",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"datatypes.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <ifaddrs.h>\n# include <sys/sysctl.h>\n# include <net/if_mib.h>\n# include <linux/if_tun.h>    /* IFF_TUN, IFF_NO_PI */\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include \"datatypes.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevtap.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint virNetDevTapCreateInBridgePort(const char *brname,\n                                   char **ifname,\n                                   const virMacAddr *macaddr,\n                                   const unsigned char *vmuuid,\n                                   const char *tunpath,\n                                   int *tapfd,\n                                   size_t tapfdSize,\n                                   const virNetDevVPortProfile *virtPortProfile,\n                                   const virNetDevVlan *virtVlan,\n                                   virTristateBool isolatedPort,\n                                   virNetDevCoalescePtr coalesce,\n                                   unsigned int mtu,\n                                   unsigned int *actualMTU,\n                                   unsigned int flags)\n{\n    virMacAddr tapmac;\n    size_t i;\n\n    if (virNetDevTapCreate(ifname, tunpath, tapfd, tapfdSize, flags) < 0)\n        return -1;\n\n    /* We need to set the interface MAC before adding it\n     * to the bridge, because the bridge assumes the lowest\n     * MAC of all enslaved interfaces & we don't want it\n     * seeing the kernel allocate random MAC for the TAP\n     * device before we set our static MAC.\n     */\n    virMacAddrSet(&tapmac, macaddr);\n    if (!(flags & VIR_NETDEV_TAP_CREATE_USE_MAC_FOR_BRIDGE)) {\n        /* The tap device's MAC address cannot match the MAC address\n         * used by the guest. This results in \"received packet on\n         * vnetX with own address as source address\" error logs from\n         * the kernel. Making the tap address as high as possible\n         * discourages the bridge from using this tap's MAC as its own\n         * (a Linux host bridge will take on the lowest numbered MAC\n         * of all devices attached to it).\n         */\n        if (tapmac.addr[0] == 0xFE)\n            tapmac.addr[0] = 0xFA;\n        else\n            tapmac.addr[0] = 0xFE;\n    }\n\n    if (virNetDevSetMAC(*ifname, &tapmac) < 0)\n        goto error;\n\n    if (virNetDevTapAttachBridge(*ifname, brname, macaddr, vmuuid,\n                                 virtPortProfile, virtVlan,\n                                 isolatedPort, mtu, actualMTU) < 0) {\n        goto error;\n    }\n\n    if (virNetDevSetOnline(*ifname, !!(flags & VIR_NETDEV_TAP_CREATE_IFUP)) < 0)\n        goto error;\n\n    if (virNetDevSetCoalesce(*ifname, coalesce, false) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    for (i = 0; i < tapfdSize && tapfd[i] >= 0; i++)\n        VIR_FORCE_CLOSE(tapfd[i]);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkBridgeDummyNicName",
          "args": [
            "def->bridge"
          ],
          "line": 2487
        },
        "resolved": true,
        "details": {
          "function_name": "networkBridgeDummyNicName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "500-522",
          "snippet": "static char *\nnetworkBridgeDummyNicName(const char *brname)\n{\n    static const char dummyNicSuffix[] = \"-nic\";\n    char *nicname;\n\n    if (strlen(brname) + sizeof(dummyNicSuffix) > IFNAMSIZ) {\n        /* because the length of an ifname is limited to IFNAMSIZ-1\n         * (usually 15), and we're adding 4 more characters, we must\n         * truncate the original name to 11 to fit. In order to catch\n         * a possible numeric ending (eg virbr0, virbr1, etc), we grab\n         * the first 8 and last 3 characters of the string.\n         */\n        nicname = g_strdup_printf(\"%.*s%s%s\",\n                                  /* space for last 3 chars + \"-nic\" + NULL */\n                                  (int)(IFNAMSIZ - (3 + sizeof(dummyNicSuffix))),\n                                  brname, brname + strlen(brname) - 3,\n                                  dummyNicSuffix);\n    } else {\n        nicname = g_strdup_printf(\"%s%s\", brname, dummyNicSuffix);\n    }\n    return nicname;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nnetworkBridgeDummyNicName(const char *brname)\n{\n    static const char dummyNicSuffix[] = \"-nic\";\n    char *nicname;\n\n    if (strlen(brname) + sizeof(dummyNicSuffix) > IFNAMSIZ) {\n        /* because the length of an ifname is limited to IFNAMSIZ-1\n         * (usually 15), and we're adding 4 more characters, we must\n         * truncate the original name to 11 to fit. In order to catch\n         * a possible numeric ending (eg virbr0, virbr1, etc), we grab\n         * the first 8 and last 3 characters of the string.\n         */\n        nicname = g_strdup_printf(\"%.*s%s%s\",\n                                  /* space for last 3 chars + \"-nic\" + NULL */\n                                  (int)(IFNAMSIZ - (3 + sizeof(dummyNicSuffix))),\n                                  brname, brname + strlen(brname) - 3,\n                                  dummyNicSuffix);\n    } else {\n        nicname = g_strdup_printf(\"%s%s\", brname, dummyNicSuffix);\n    }\n    return nicname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBridgeCreate",
          "args": [
            "def->bridge",
            "&def->mac"
          ],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBridgeCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbridge.c",
          "lines": "513-520",
          "snippet": "int\nvirNetDevBridgeCreate(const char *brname,\n                      const virMacAddr *mac G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to create bridge %s\"), brname);\n    return -1;\n}",
          "includes": [
            "# include <net/if_bridgevar.h>",
            "# include <net/ethernet.h>",
            "# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */",
            "# include <linux/in6.h>",
            "# include <linux/param.h>     /* HZ                 */",
            "# include <linux/sockios.h>",
            "#  include \"virnetlink.h\"",
            "# include <net/if.h>",
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <net/if_bridgevar.h>\n# include <net/ethernet.h>\n# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */\n# include <linux/in6.h>\n# include <linux/param.h>     /* HZ                 */\n# include <linux/sockios.h>\n#  include \"virnetlink.h\"\n# include <net/if.h>\n#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevbridge.h\"\n#include <config.h>\n\nint\nvirNetDevBridgeCreate(const char *brname,\n                      const virMacAddr *mac G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to create bridge %s\"), brname);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"network '%s' has no bridge name defined\")",
            "def->name"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkCheckRouteCollision",
          "args": [
            "def"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "networkCheckRouteCollision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_nop.c",
          "lines": "33-36",
          "snippet": "int networkCheckRouteCollision(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nint networkCheckRouteCollision(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    size_t i;\n    bool v4present = false, v6present = false;\n    virErrorPtr save_err = NULL;\n    virNetworkIPDefPtr ipdef;\n    virNetDevIPRoutePtr routedef;\n    char *macTapIfName = NULL;\n    virMacMapPtr macmap;\n    char *macMapFile = NULL;\n    int tapfd = -1;\n    bool dnsmasqStarted = false;\n    bool devOnline = false;\n    bool firewalRulesAdded = false;\n\n    /* Check to see if any network IP collides with an existing route */\n    if (networkCheckRouteCollision(def) < 0)\n        return -1;\n\n    /* Create and configure the bridge device */\n    if (!def->bridge) {\n        /* bridge name can only be empty if the config files were\n         * edited directly. Otherwise networkValidate() (called after\n         * parsing the XML from networkCreateXML() and\n         * networkDefine()) guarantees we will have a valid bridge\n         * name before this point. Since hand editing of the config\n         * files is explicitly prohibited we can, with clear\n         * conscience, log an error and fail at this point.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"network '%s' has no bridge name defined\"),\n                       def->name);\n        return -1;\n    }\n    if (virNetDevBridgeCreate(def->bridge, &def->mac) < 0)\n        return -1;\n\n    if (def->mac_specified) {\n        /* To set a mac for the bridge, we need to define a dummy tap\n         * device, set its mac, then attach it to the bridge. As long\n         * as its mac address is lower than any other interface that\n         * gets attached, the bridge will always maintain this mac\n         * address.\n         */\n        macTapIfName = networkBridgeDummyNicName(def->bridge);\n        if (!macTapIfName)\n            goto error;\n        /* Keep tun fd open and interface up to allow for IPv6 DAD to happen */\n        if (virNetDevTapCreateInBridgePort(def->bridge,\n                                           &macTapIfName, &def->mac,\n                                           NULL, NULL, &tapfd, 1, NULL, NULL,\n                                           VIR_TRISTATE_BOOL_NO,\n                                           NULL, def->mtu, NULL,\n                                           VIR_NETDEV_TAP_CREATE_USE_MAC_FOR_BRIDGE |\n                                           VIR_NETDEV_TAP_CREATE_IFUP |\n                                           VIR_NETDEV_TAP_CREATE_PERSIST) < 0) {\n            VIR_FREE(macTapIfName);\n            goto error;\n        }\n    }\n\n    if (!(macMapFile = virMacMapFileName(driver->dnsmasqStateDir,\n                                         def->bridge)) ||\n        !(macmap = virMacMapNew(macMapFile)))\n        goto error;\n\n    virNetworkObjSetMacMap(obj, macmap);\n    macmap = NULL;\n\n    /* Set bridge options */\n\n    /* delay is configured in seconds, but virNetDevBridgeSetSTPDelay\n     * expects milliseconds\n     */\n    if (virNetDevBridgeSetSTPDelay(def->bridge, def->delay * 1000) < 0)\n        goto error;\n\n    if (virNetDevBridgeSetSTP(def->bridge, def->stp ? true : false) < 0)\n        goto error;\n\n    /* Disable IPv6 on the bridge if there are no IPv6 addresses\n     * defined, and set other IPv6 sysctl tunables appropriately.\n     */\n    if (networkSetIPv6Sysctls(obj) < 0)\n        goto error;\n\n    /* Add \"once per network\" rules */\n    if (def->forward.type != VIR_NETWORK_FORWARD_OPEN &&\n        networkAddFirewallRules(def) < 0)\n        goto error;\n\n    firewalRulesAdded = true;\n\n    for (i = 0; (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i)); i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET))\n            v4present = true;\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n            v6present = true;\n\n        /* Add the IP address/netmask to the bridge */\n        if (networkAddAddrToBridge(obj, ipdef) < 0)\n            goto error;\n    }\n\n    if (networkStartHandleMACTableManagerMode(obj, macTapIfName) < 0)\n        goto error;\n\n    /* Bring up the bridge interface */\n    if (virNetDevSetOnline(def->bridge, 1) < 0)\n        goto error;\n\n    devOnline = true;\n\n    for (i = 0; i < def->nroutes; i++) {\n        virSocketAddrPtr gateway = NULL;\n\n        routedef = def->routes[i];\n        gateway = virNetDevIPRouteGetGateway(routedef);\n\n        /* Add the IP route to the bridge */\n        /* ignore errors, error msg will be generated */\n        /* but libvirt will not know and net-destroy will work. */\n        if (VIR_SOCKET_ADDR_VALID(gateway)) {\n            if (networkAddRouteToBridge(obj, routedef) < 0) {\n                /* an error occurred adding the static route */\n                continue; /* for now, do nothing */\n            }\n        }\n    }\n\n    /* If forward.type != NONE, turn on global IP forwarding */\n    if (def->forward.type != VIR_NETWORK_FORWARD_NONE) {\n        if (v6present && !virNetDevIPCheckIPv6Forwarding())\n            goto error; /* Precise error message already provided */\n\n        if (networkEnableIPForwarding(v4present, v6present) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"failed to enable IP forwarding\"));\n            goto error;\n        }\n    }\n\n\n    /* start dnsmasq if there are any IP addresses (v4 or v6) */\n    if ((v4present || v6present) &&\n        networkStartDhcpDaemon(driver, obj) < 0)\n        goto error;\n\n    dnsmasqStarted = true;\n\n    /* start radvd if there are any ipv6 addresses */\n    if (v6present && networkStartRadvd(driver, obj) < 0)\n        goto error;\n\n    /* dnsmasq does not wait for DAD to complete before daemonizing,\n     * so we need to wait for it ourselves.\n     */\n    if (v6present && networkWaitDadFinish(obj) < 0)\n        goto error;\n\n    /* DAD has finished, dnsmasq is now bound to the\n     * bridge's IPv6 address, so we can set the dummy tun down.\n     */\n    if (tapfd >= 0) {\n        if (virNetDevSetOnline(macTapIfName, false) < 0)\n            goto error;\n        VIR_FORCE_CLOSE(tapfd);\n    }\n\n    if (virNetDevBandwidthSet(def->bridge, def->bandwidth, true, true) < 0)\n        goto error;\n\n    VIR_FREE(macTapIfName);\n    VIR_FREE(macMapFile);\n\n    return 0;\n\n error:\n    virErrorPreserveLast(&save_err);\n    if (def->bandwidth)\n       virNetDevBandwidthClear(def->bridge);\n\n    if (dnsmasqStarted) {\n        pid_t dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n        kill(dnsmasqPid, SIGTERM);\n        virNetworkObjSetDnsmasqPid(obj, -1);\n    }\n\n    if (devOnline)\n        ignore_value(virNetDevSetOnline(def->bridge, 0));\n\n    if (firewalRulesAdded &&\n        def->forward.type != VIR_NETWORK_FORWARD_OPEN)\n        networkRemoveFirewallRules(def);\n\n    if (macTapIfName) {\n        VIR_FORCE_CLOSE(tapfd);\n        ignore_value(virNetDevTapDelete(macTapIfName, NULL));\n        VIR_FREE(macTapIfName);\n    }\n    virNetworkObjUnrefMacMap(obj);\n    VIR_FREE(macMapFile);\n\n    ignore_value(virNetDevBridgeDelete(def->bridge));\n\n    virErrorRestore(&save_err);\n    /* coverity[leaked_handle] - 'tapfd' is not leaked */\n    return -1;\n}"
  },
  {
    "function_name": "networkWaitDadFinish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2413-2437",
    "snippet": "static int\nnetworkWaitDadFinish(virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetworkIPDefPtr ipdef;\n    virSocketAddrPtr *addrs = NULL, addr = NULL;\n    size_t naddrs = 0;\n    int ret = -1;\n\n    VIR_DEBUG(\"Begin waiting for IPv6 DAD on network %s\", def->name);\n\n    while ((ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, naddrs))) {\n        addr = &ipdef->address;\n        if (VIR_APPEND_ELEMENT_COPY(addrs, naddrs, addr) < 0)\n            goto cleanup;\n    }\n\n    ret = (naddrs == 0) ? 0 : virNetDevIPWaitDadFinish(addrs, naddrs);\n\n cleanup:\n    VIR_FREE(addrs);\n    VIR_DEBUG(\"Finished waiting for IPv6 DAD on network %s with status %d\",\n              def->name, ret);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Finished waiting for IPv6 DAD on network %s with status %d\"",
            "def->name",
            "ret"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrs"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevIPWaitDadFinish",
          "args": [
            "addrs",
            "naddrs"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPWaitDadFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "806-813",
          "snippet": "int\nvirNetDevIPWaitDadFinish(virSocketAddrPtr *addrs G_GNUC_UNUSED,\n                         size_t count G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to wait for IPv6 DAD on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPWaitDadFinish(virSocketAddrPtr *addrs G_GNUC_UNUSED,\n                         size_t count G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to wait for IPv6 DAD on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT_COPY",
          "args": [
            "addrs",
            "naddrs",
            "addr"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET6",
            "naddrs"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Begin waiting for IPv6 DAD on network %s\"",
            "def->name"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkWaitDadFinish(virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetworkIPDefPtr ipdef;\n    virSocketAddrPtr *addrs = NULL, addr = NULL;\n    size_t naddrs = 0;\n    int ret = -1;\n\n    VIR_DEBUG(\"Begin waiting for IPv6 DAD on network %s\", def->name);\n\n    while ((ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, naddrs))) {\n        addr = &ipdef->address;\n        if (VIR_APPEND_ELEMENT_COPY(addrs, naddrs, addr) < 0)\n            goto cleanup;\n    }\n\n    ret = (naddrs == 0) ? 0 : virNetDevIPWaitDadFinish(addrs, naddrs);\n\n cleanup:\n    VIR_FREE(addrs);\n    VIR_DEBUG(\"Finished waiting for IPv6 DAD on network %s with status %d\",\n              def->name, ret);\n    return ret;\n}"
  },
  {
    "function_name": "networkAddRouteToBridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2389-2411",
    "snippet": "static int\nnetworkAddRouteToBridge(virNetworkObjPtr obj,\n                        virNetDevIPRoutePtr routedef)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int prefix = virNetDevIPRouteGetPrefix(routedef);\n    unsigned int metric = virNetDevIPRouteGetMetric(routedef);\n    virSocketAddrPtr addr = virNetDevIPRouteGetAddress(routedef);\n    virSocketAddrPtr gateway = virNetDevIPRouteGetGateway(routedef);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"network '%s' has an invalid netmask \"\n                         \"or IP address in route definition\"),\n                       def->name);\n        return -1;\n    }\n\n    if (virNetDevIPRouteAdd(def->bridge, addr, prefix, gateway, metric) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevIPRouteAdd",
          "args": [
            "def->bridge",
            "addr",
            "prefix",
            "gateway",
            "metric"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "776-802",
          "snippet": "int\nvirNetDevIPRouteAdd(const char *ifname,\n                    virSocketAddrPtr addr,\n                    unsigned int prefix,\n                    virSocketAddrPtr gateway,\n                    unsigned int metric)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *addrstr = NULL;\n    g_autofree char *gatewaystr = NULL;\n\n    if (!(addrstr = virSocketAddrFormat(addr)))\n        return -1;\n    if (!(gatewaystr = virSocketAddrFormat(gateway)))\n        return -1;\n    cmd = virCommandNew(IP_PATH);\n    virCommandAddArgList(cmd, \"route\", \"add\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    virCommandAddArgList(cmd, \"via\", gatewaystr, \"dev\", ifname,\n                         \"proto\", \"static\", \"metric\", NULL);\n    virCommandAddArgFormat(cmd, \"%u\", metric);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPRouteAdd(const char *ifname,\n                    virSocketAddrPtr addr,\n                    unsigned int prefix,\n                    virSocketAddrPtr gateway,\n                    unsigned int metric)\n{\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *addrstr = NULL;\n    g_autofree char *gatewaystr = NULL;\n\n    if (!(addrstr = virSocketAddrFormat(addr)))\n        return -1;\n    if (!(gatewaystr = virSocketAddrFormat(gateway)))\n        return -1;\n    cmd = virCommandNew(IP_PATH);\n    virCommandAddArgList(cmd, \"route\", \"add\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    virCommandAddArgList(cmd, \"via\", gatewaystr, \"dev\", ifname,\n                         \"proto\", \"static\", \"metric\", NULL);\n    virCommandAddArgFormat(cmd, \"%u\", metric);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"network '%s' has an invalid netmask \"\n                         \"or IP address in route definition\")",
            "def->name"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"network '%s' has an invalid netmask \"\n                         \"or IP address in route definition\""
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteGetGateway",
          "args": [
            "routedef"
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteGetGateway",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "1035-1041",
          "snippet": "virSocketAddrPtr\nvirNetDevIPRouteGetGateway(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->gateway;\n    return NULL;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvirSocketAddrPtr\nvirNetDevIPRouteGetGateway(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->gateway;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteGetAddress",
          "args": [
            "routedef"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteGetAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "984-991",
          "snippet": "virSocketAddrPtr\nvirNetDevIPRouteGetAddress(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->address;\n\n    return NULL;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nvirSocketAddrPtr\nvirNetDevIPRouteGetAddress(virNetDevIPRoutePtr def)\n{\n    if (def)\n        return &def->address;\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteGetMetric",
          "args": [
            "routedef"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteGetMetric",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "1026-1033",
          "snippet": "unsigned int\nvirNetDevIPRouteGetMetric(virNetDevIPRoutePtr def)\n{\n    if (def && def->has_metric && def->metric > 0)\n        return def->metric;\n\n    return 1;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nunsigned int\nvirNetDevIPRouteGetMetric(virNetDevIPRoutePtr def)\n{\n    if (def && def->has_metric && def->metric > 0)\n        return def->metric;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIPRouteGetPrefix",
          "args": [
            "routedef"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPRouteGetPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "993-1024",
          "snippet": "int\nvirNetDevIPRouteGetPrefix(virNetDevIPRoutePtr def)\n{\n    int prefix = 0;\n    virSocketAddr zero;\n\n    if (!def)\n        return -1;\n\n    /* this creates an all-0 address of the appropriate family */\n    ignore_value(virSocketAddrParse(&zero,\n                                    (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET)\n                                     ? VIR_SOCKET_ADDR_IPV4_ALL\n                                     : VIR_SOCKET_ADDR_IPV6_ALL),\n                                    VIR_SOCKET_ADDR_FAMILY(&def->address)));\n\n    if (virSocketAddrEqual(&def->address, &zero)) {\n        if (def->has_prefix && def->prefix == 0)\n            prefix = 0;\n        else if ((VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET) &&\n                  virSocketAddrEqual(&def->netmask, &zero)))\n            prefix = 0;\n        else\n            prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                              def->prefix);\n    } else {\n        prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                          def->prefix);\n    }\n\n    return prefix;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPRouteGetPrefix(virNetDevIPRoutePtr def)\n{\n    int prefix = 0;\n    virSocketAddr zero;\n\n    if (!def)\n        return -1;\n\n    /* this creates an all-0 address of the appropriate family */\n    ignore_value(virSocketAddrParse(&zero,\n                                    (VIR_SOCKET_ADDR_IS_FAMILY(&def->address, AF_INET)\n                                     ? VIR_SOCKET_ADDR_IPV4_ALL\n                                     : VIR_SOCKET_ADDR_IPV6_ALL),\n                                    VIR_SOCKET_ADDR_FAMILY(&def->address)));\n\n    if (virSocketAddrEqual(&def->address, &zero)) {\n        if (def->has_prefix && def->prefix == 0)\n            prefix = 0;\n        else if ((VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET) &&\n                  virSocketAddrEqual(&def->netmask, &zero)))\n            prefix = 0;\n        else\n            prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                              def->prefix);\n    } else {\n        prefix = virSocketAddrGetIPPrefix(&def->address, &def->netmask,\n                                          def->prefix);\n    }\n\n    return prefix;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkAddRouteToBridge(virNetworkObjPtr obj,\n                        virNetDevIPRoutePtr routedef)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int prefix = virNetDevIPRouteGetPrefix(routedef);\n    unsigned int metric = virNetDevIPRouteGetMetric(routedef);\n    virSocketAddrPtr addr = virNetDevIPRouteGetAddress(routedef);\n    virSocketAddrPtr gateway = virNetDevIPRouteGetGateway(routedef);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"network '%s' has an invalid netmask \"\n                         \"or IP address in route definition\"),\n                       def->name);\n        return -1;\n    }\n\n    if (virNetDevIPRouteAdd(def->bridge, addr, prefix, gateway, metric) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "networkStartHandleMACTableManagerMode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2366-2385",
    "snippet": "static int\nnetworkStartHandleMACTableManagerMode(virNetworkObjPtr obj,\n                                      const char *macTapIfName)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    const char *brname = def->bridge;\n\n    if (brname &&\n        def->macTableManager == VIR_NETWORK_BRIDGE_MAC_TABLE_MANAGER_LIBVIRT) {\n        if (virNetDevBridgeSetVlanFiltering(brname, true) < 0)\n            return -1;\n        if (macTapIfName) {\n            if (virNetDevBridgePortSetLearning(brname, macTapIfName, false) < 0)\n                return -1;\n            if (virNetDevBridgePortSetUnicastFlood(brname, macTapIfName, false) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevBridgePortSetUnicastFlood",
          "args": [
            "brname",
            "macTapIfName",
            "false"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBridgePortSetUnicastFlood",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbridge.c",
          "lines": "371-379",
          "snippet": "int\nvirNetDevBridgePortSetUnicastFlood(const char *brname G_GNUC_UNUSED,\n                                   const char *ifname G_GNUC_UNUSED,\n                                   bool enable G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to set bridge port unicast_flood on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <net/if_bridgevar.h>",
            "# include <net/ethernet.h>",
            "# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */",
            "# include <linux/in6.h>",
            "# include <linux/param.h>     /* HZ                 */",
            "# include <linux/sockios.h>",
            "#  include \"virnetlink.h\"",
            "# include <net/if.h>",
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <net/if_bridgevar.h>\n# include <net/ethernet.h>\n# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */\n# include <linux/in6.h>\n# include <linux/param.h>     /* HZ                 */\n# include <linux/sockios.h>\n#  include \"virnetlink.h\"\n# include <net/if.h>\n#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevbridge.h\"\n#include <config.h>\n\nint\nvirNetDevBridgePortSetUnicastFlood(const char *brname G_GNUC_UNUSED,\n                                   const char *ifname G_GNUC_UNUSED,\n                                   bool enable G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to set bridge port unicast_flood on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBridgePortSetLearning",
          "args": [
            "brname",
            "macTapIfName",
            "false"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBridgePortSetLearning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbridge.c",
          "lines": "349-357",
          "snippet": "int\nvirNetDevBridgePortSetLearning(const char *brname G_GNUC_UNUSED,\n                               const char *ifname G_GNUC_UNUSED,\n                               bool enable G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to set bridge port learning on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <net/if_bridgevar.h>",
            "# include <net/ethernet.h>",
            "# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */",
            "# include <linux/in6.h>",
            "# include <linux/param.h>     /* HZ                 */",
            "# include <linux/sockios.h>",
            "#  include \"virnetlink.h\"",
            "# include <net/if.h>",
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <net/if_bridgevar.h>\n# include <net/ethernet.h>\n# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */\n# include <linux/in6.h>\n# include <linux/param.h>     /* HZ                 */\n# include <linux/sockios.h>\n#  include \"virnetlink.h\"\n# include <net/if.h>\n#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevbridge.h\"\n#include <config.h>\n\nint\nvirNetDevBridgePortSetLearning(const char *brname G_GNUC_UNUSED,\n                               const char *ifname G_GNUC_UNUSED,\n                               bool enable G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to set bridge port learning on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevBridgeSetVlanFiltering",
          "args": [
            "brname",
            "true"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevBridgeSetVlanFiltering",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevbridge.c",
          "lines": "966-973",
          "snippet": "int\nvirNetDevBridgeSetVlanFiltering(const char *brname G_GNUC_UNUSED,\n                                bool enable G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to set bridge vlan_filtering on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <net/if_bridgevar.h>",
            "# include <net/ethernet.h>",
            "# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */",
            "# include <linux/in6.h>",
            "# include <linux/param.h>     /* HZ                 */",
            "# include <linux/sockios.h>",
            "#  include \"virnetlink.h\"",
            "# include <net/if.h>",
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <net/if_bridgevar.h>\n# include <net/ethernet.h>\n# include <linux/if_bridge.h> /* SYSFS_BRIDGE_ATTR  */\n# include <linux/in6.h>\n# include <linux/param.h>     /* HZ                 */\n# include <linux/sockios.h>\n#  include \"virnetlink.h\"\n# include <net/if.h>\n#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevbridge.h\"\n#include <config.h>\n\nint\nvirNetDevBridgeSetVlanFiltering(const char *brname G_GNUC_UNUSED,\n                                bool enable G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to set bridge vlan_filtering on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkStartHandleMACTableManagerMode(virNetworkObjPtr obj,\n                                      const char *macTapIfName)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    const char *brname = def->bridge;\n\n    if (brname &&\n        def->macTableManager == VIR_NETWORK_BRIDGE_MAC_TABLE_MANAGER_LIBVIRT) {\n        if (virNetDevBridgeSetVlanFiltering(brname, true) < 0)\n            return -1;\n        if (macTapIfName) {\n            if (virNetDevBridgePortSetLearning(brname, macTapIfName, false) < 0)\n                return -1;\n            if (virNetDevBridgePortSetUnicastFlood(brname, macTapIfName, false) < 0)\n                return -1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "networkAddAddrToBridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2345-2363",
    "snippet": "static int\nnetworkAddAddrToBridge(virNetworkObjPtr obj,\n                       virNetworkIPDefPtr ipdef)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int prefix = virNetworkIPDefPrefix(ipdef);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"bridge '%s' has an invalid netmask or IP address\"),\n                       def->bridge);\n        return -1;\n    }\n\n    if (virNetDevIPAddrAdd(def->bridge, &ipdef->address, NULL, prefix) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevIPAddrAdd",
          "args": [
            "def->bridge",
            "&ipdef->address",
            "NULL",
            "prefix"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIPAddrAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevip.c",
          "lines": "686-740",
          "snippet": "int\nvirNetDevIPAddrAdd(const char *ifname,\n                   virSocketAddr *addr,\n                   virSocketAddr *peer,\n                   unsigned int prefix)\n{\n    virSocketAddr broadcast;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *addrstr = NULL;\n    g_autofree char *bcaststr = NULL;\n    g_autofree char *peerstr = NULL;\n\n    if (!(addrstr = virSocketAddrFormat(addr)))\n        return -1;\n\n    if (peer && VIR_SOCKET_ADDR_VALID(peer) && !(peerstr = virSocketAddrFormat(peer)))\n        return -1;\n\n    /* format up a broadcast address if this is IPv4 */\n    if (!peerstr &&\n        ((VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET)) &&\n         ((virSocketAddrBroadcastByPrefix(addr, prefix, &broadcast) < 0) ||\n          !(bcaststr = virSocketAddrFormat(&broadcast))))) {\n        return -1;\n    }\n\n# ifdef IFCONFIG_PATH\n    cmd = virCommandNew(IFCONFIG_PATH);\n    virCommandAddArg(cmd, ifname);\n    if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET6))\n        virCommandAddArg(cmd, \"inet6\");\n    else\n        virCommandAddArg(cmd, \"inet\");\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    if (peerstr)\n        virCommandAddArgList(cmd, \"pointopoint\", peerstr, NULL);\n    if (bcaststr)\n        virCommandAddArgList(cmd, \"broadcast\", bcaststr, NULL);\n    virCommandAddArg(cmd, \"alias\");\n# else\n    cmd = virCommandNew(IP_PATH);\n    virCommandAddArgList(cmd, \"addr\", \"add\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    if (peerstr)\n        virCommandAddArgList(cmd, \"peer\", peerstr, NULL);\n    if (bcaststr)\n        virCommandAddArgList(cmd, \"broadcast\", bcaststr, NULL);\n    virCommandAddArgList(cmd, \"dev\", ifname, NULL);\n# endif\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <net/if.h>",
            "# include <sys/ioctl.h>",
            "# include <ifaddrs.h>",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetlink.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetdevip.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <net/if.h>\n# include <sys/ioctl.h>\n# include <ifaddrs.h>\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virnetlink.h\"\n#include \"virnetdev.h\"\n#include \"virnetdevip.h\"\n#include <config.h>\n\nint\nvirNetDevIPAddrAdd(const char *ifname,\n                   virSocketAddr *addr,\n                   virSocketAddr *peer,\n                   unsigned int prefix)\n{\n    virSocketAddr broadcast;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *addrstr = NULL;\n    g_autofree char *bcaststr = NULL;\n    g_autofree char *peerstr = NULL;\n\n    if (!(addrstr = virSocketAddrFormat(addr)))\n        return -1;\n\n    if (peer && VIR_SOCKET_ADDR_VALID(peer) && !(peerstr = virSocketAddrFormat(peer)))\n        return -1;\n\n    /* format up a broadcast address if this is IPv4 */\n    if (!peerstr &&\n        ((VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET)) &&\n         ((virSocketAddrBroadcastByPrefix(addr, prefix, &broadcast) < 0) ||\n          !(bcaststr = virSocketAddrFormat(&broadcast))))) {\n        return -1;\n    }\n\n# ifdef IFCONFIG_PATH\n    cmd = virCommandNew(IFCONFIG_PATH);\n    virCommandAddArg(cmd, ifname);\n    if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET6))\n        virCommandAddArg(cmd, \"inet6\");\n    else\n        virCommandAddArg(cmd, \"inet\");\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    if (peerstr)\n        virCommandAddArgList(cmd, \"pointopoint\", peerstr, NULL);\n    if (bcaststr)\n        virCommandAddArgList(cmd, \"broadcast\", bcaststr, NULL);\n    virCommandAddArg(cmd, \"alias\");\n# else\n    cmd = virCommandNew(IP_PATH);\n    virCommandAddArgList(cmd, \"addr\", \"add\", NULL);\n    virCommandAddArgFormat(cmd, \"%s/%u\", addrstr, prefix);\n    if (peerstr)\n        virCommandAddArgList(cmd, \"peer\", peerstr, NULL);\n    if (bcaststr)\n        virCommandAddArgList(cmd, \"broadcast\", bcaststr, NULL);\n    virCommandAddArgList(cmd, \"dev\", ifname, NULL);\n# endif\n\n    if (virCommandRun(cmd, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"bridge '%s' has an invalid netmask or IP address\")",
            "def->bridge"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"bridge '%s' has an invalid netmask or IP address\""
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefPrefix",
          "args": [
            "ipdef"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "367-373",
          "snippet": "int\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkAddAddrToBridge(virNetworkObjPtr obj,\n                       virNetworkIPDefPtr ipdef)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int prefix = virNetworkIPDefPrefix(ipdef);\n\n    if (prefix < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"bridge '%s' has an invalid netmask or IP address\"),\n                       def->bridge);\n        return -1;\n    }\n\n    if (virNetDevIPAddrAdd(def->bridge, &ipdef->address, NULL, prefix) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "networkSetIPv6Sysctls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2278-2341",
    "snippet": "static int\nnetworkSetIPv6Sysctls(virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    char *field = NULL;\n    int ret = -1;\n    bool enableIPv6 = !!virNetworkDefGetIPByIndex(def, AF_INET6, 0);\n\n    /* set disable_ipv6 if there are no ipv6 addresses defined for the\n     * network. But also unset it if there *are* ipv6 addresses, as we\n     * can't be sure of its default value.\n     */\n    field = g_strdup_printf(SYSCTL_PATH \"/net/ipv6/conf/%s/disable_ipv6\",\n                            def->bridge);\n\n    if (access(field, W_OK) < 0 && errno == ENOENT) {\n        if (!enableIPv6)\n            VIR_DEBUG(\"ipv6 appears to already be disabled on %s\",\n                      def->bridge);\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileWriteStr(field, enableIPv6 ? \"0\" : \"1\", 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot write to %s to enable/disable IPv6 \"\n                               \"on bridge %s\"), field, def->bridge);\n        goto cleanup;\n    }\n    VIR_FREE(field);\n\n    /* The rest of the ipv6 sysctl tunables should always be set the\n     * same, whether or not we're using ipv6 on this bridge.\n     */\n\n    /* Prevent guests from hijacking the host network by sending out\n     * their own router advertisements.\n     */\n    field = g_strdup_printf(SYSCTL_PATH \"/net/ipv6/conf/%s/accept_ra\",\n                            def->bridge);\n\n    if (virFileWriteStr(field, \"0\", 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot disable %s\"), field);\n        goto cleanup;\n    }\n    VIR_FREE(field);\n\n    /* All interfaces used as a gateway (which is what this is, by\n     * definition), must always have autoconf=0.\n     */\n    field = g_strdup_printf(SYSCTL_PATH \"/net/ipv6/conf/%s/autoconf\", def->bridge);\n\n    if (virFileWriteStr(field, \"0\", 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot disable %s\"), field);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(field);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSCTL_PATH \"/proc/sys\""
    ],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "field"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot disable %s\")",
            "field"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot disable %s\""
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "field",
            "\"0\"",
            "0"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "field"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot disable %s\")",
            "field"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "field"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot write to %s to enable/disable IPv6 \"\n                               \"on bridge %s\")",
            "field",
            "def->bridge"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"ipv6 appears to already be disabled on %s\"",
            "def->bridge"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "field",
            "W_OK"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET6",
            "0"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SYSCTL_PATH \"/proc/sys\"\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkSetIPv6Sysctls(virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    char *field = NULL;\n    int ret = -1;\n    bool enableIPv6 = !!virNetworkDefGetIPByIndex(def, AF_INET6, 0);\n\n    /* set disable_ipv6 if there are no ipv6 addresses defined for the\n     * network. But also unset it if there *are* ipv6 addresses, as we\n     * can't be sure of its default value.\n     */\n    field = g_strdup_printf(SYSCTL_PATH \"/net/ipv6/conf/%s/disable_ipv6\",\n                            def->bridge);\n\n    if (access(field, W_OK) < 0 && errno == ENOENT) {\n        if (!enableIPv6)\n            VIR_DEBUG(\"ipv6 appears to already be disabled on %s\",\n                      def->bridge);\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileWriteStr(field, enableIPv6 ? \"0\" : \"1\", 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot write to %s to enable/disable IPv6 \"\n                               \"on bridge %s\"), field, def->bridge);\n        goto cleanup;\n    }\n    VIR_FREE(field);\n\n    /* The rest of the ipv6 sysctl tunables should always be set the\n     * same, whether or not we're using ipv6 on this bridge.\n     */\n\n    /* Prevent guests from hijacking the host network by sending out\n     * their own router advertisements.\n     */\n    field = g_strdup_printf(SYSCTL_PATH \"/net/ipv6/conf/%s/accept_ra\",\n                            def->bridge);\n\n    if (virFileWriteStr(field, \"0\", 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot disable %s\"), field);\n        goto cleanup;\n    }\n    VIR_FREE(field);\n\n    /* All interfaces used as a gateway (which is what this is, by\n     * definition), must always have autoconf=0.\n     */\n    field = g_strdup_printf(SYSCTL_PATH \"/net/ipv6/conf/%s/autoconf\", def->bridge);\n\n    if (virFileWriteStr(field, \"0\", 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot disable %s\"), field);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(field);\n    return ret;\n}"
  },
  {
    "function_name": "networkEnableIPForwarding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2254-2275",
    "snippet": "static int\nnetworkEnableIPForwarding(bool enableIPv4,\n                          bool enableIPv6)\n{\n    int ret = 0;\n#ifdef HAVE_SYSCTLBYNAME\n    int enabled = 1;\n    if (enableIPv4)\n        ret = sysctlbyname(\"net.inet.ip.forwarding\", NULL, 0,\n                           &enabled, sizeof(enabled));\n    if (enableIPv6 && ret == 0)\n        ret = sysctlbyname(\"net.inet6.ip6.forwarding\", NULL, 0,\n                           &enabled, sizeof(enabled));\n#else\n    if (enableIPv4)\n        ret = virFileWriteStr(SYSCTL_PATH \"/net/ipv4/ip_forward\", \"1\\n\", 0);\n    if (enableIPv6 && ret == 0)\n        ret = virFileWriteStr(SYSCTL_PATH \"/net/ipv6/conf/all/forwarding\", \"1\\n\", 0);\n\n#endif\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSCTL_PATH \"/proc/sys\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "SYSCTL_PATH \"/net/ipv6/conf/all/forwarding\"",
            "\"1\\n\"",
            "0"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysctlbyname",
          "args": [
            "\"net.inet6.ip6.forwarding\"",
            "NULL",
            "0",
            "&enabled",
            "sizeof(enabled)"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctlbyname",
          "args": [
            "\"net.inet.ip.forwarding\"",
            "NULL",
            "0",
            "&enabled",
            "sizeof(enabled)"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define SYSCTL_PATH \"/proc/sys\"\n\nstatic int\nnetworkEnableIPForwarding(bool enableIPv4,\n                          bool enableIPv6)\n{\n    int ret = 0;\n#ifdef HAVE_SYSCTLBYNAME\n    int enabled = 1;\n    if (enableIPv4)\n        ret = sysctlbyname(\"net.inet.ip.forwarding\", NULL, 0,\n                           &enabled, sizeof(enabled));\n    if (enableIPv6 && ret == 0)\n        ret = sysctlbyname(\"net.inet6.ip6.forwarding\", NULL, 0,\n                           &enabled, sizeof(enabled));\n#else\n    if (enableIPv4)\n        ret = virFileWriteStr(SYSCTL_PATH \"/net/ipv4/ip_forward\", \"1\\n\", 0);\n    if (enableIPv6 && ret == 0)\n        ret = virFileWriteStr(SYSCTL_PATH \"/net/ipv6/conf/all/forwarding\", \"1\\n\", 0);\n\n#endif\n    return ret;\n}"
  },
  {
    "function_name": "networkReloadFirewallRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2237-2250",
    "snippet": "static void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup)\n{\n    VIR_INFO(\"Reloading iptables rules\");\n    /* Ideally we'd not even register the driver when unprivilegd\n     * but until we untangle the virt driver that's not viable */\n    if (!driver->privileged)\n        return;\n    networkPreReloadFirewallRules(driver, startup);\n    virNetworkObjListForEach(driver->networks,\n                             networkReloadFirewallRulesHelper,\n                             NULL);\n    networkPostReloadFirewallRules(startup);\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkPostReloadFirewallRules",
          "args": [
            "startup"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "networkPostReloadFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_nop.c",
          "lines": "28-30",
          "snippet": "void networkPostReloadFirewallRules(bool startup G_GNUC_UNUSED)\n{\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nvoid networkPostReloadFirewallRules(bool startup G_GNUC_UNUSED)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjListForEach",
          "args": [
            "driver->networks",
            "networkReloadFirewallRulesHelper",
            "NULL"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjListForEach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1472-1483",
          "snippet": "int\nvirNetworkObjListForEach(virNetworkObjListPtr nets,\n                         virNetworkObjListIterator callback,\n                         void *opaque)\n{\n    struct virNetworkObjListForEachHelperData data = {\n        .callback = callback, .opaque = opaque, .ret = 0};\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListForEachHelper, &data);\n    virObjectRWUnlock(nets);\n    return data.ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirNetworkObjListForEach(virNetworkObjListPtr nets,\n                         virNetworkObjListIterator callback,\n                         void *opaque)\n{\n    struct virNetworkObjListForEachHelperData data = {\n        .callback = callback, .opaque = opaque, .ret = 0};\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListForEachHelper, &data);\n    virObjectRWUnlock(nets);\n    return data.ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkPreReloadFirewallRules",
          "args": [
            "driver",
            "startup"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "networkPreReloadFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_nop.c",
          "lines": "22-25",
          "snippet": "void networkPreReloadFirewallRules(virNetworkDriverStatePtr driver G_GNUC_UNUSED,\n                                   bool startup G_GNUC_UNUSED)\n{\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nvoid networkPreReloadFirewallRules(virNetworkDriverStatePtr driver G_GNUC_UNUSED,\n                                   bool startup G_GNUC_UNUSED)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Reloading iptables rules\""
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup)\n{\n    VIR_INFO(\"Reloading iptables rules\");\n    /* Ideally we'd not even register the driver when unprivilegd\n     * but until we untangle the virt driver that's not viable */\n    if (!driver->privileged)\n        return;\n    networkPreReloadFirewallRules(driver, startup);\n    virNetworkObjListForEach(driver->networks,\n                             networkReloadFirewallRulesHelper,\n                             NULL);\n    networkPostReloadFirewallRules(startup);\n}"
  },
  {
    "function_name": "networkReloadFirewallRulesHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2194-2234",
    "snippet": "static int\nnetworkReloadFirewallRulesHelper(virNetworkObjPtr obj,\n                                 void *opaque G_GNUC_UNUSED)\n{\n    virNetworkDefPtr def;\n\n    virObjectLock(obj);\n    def = virNetworkObjGetDef(obj);\n    if (virNetworkObjIsActive(obj)) {\n        switch ((virNetworkForwardType) def->forward.type) {\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n            /* Only three of the L3 network types that are configured by\n             * libvirt need to have iptables rules reloaded. The 4th L3\n             * network type, forward='open', doesn't need this because it\n             * has no iptables rules.\n             */\n            networkRemoveFirewallRules(def);\n            ignore_value(networkAddFirewallRules(def));\n            break;\n\n        case VIR_NETWORK_FORWARD_OPEN:\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            break;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n            goto cleanup;\n        }\n    }\n\n cleanup:\n    virObjectUnlock(obj);\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "obj"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkForwardType",
            "def->forward.type"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "networkAddFirewallRules(def)"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkAddFirewallRules",
          "args": [
            "def"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "networkAddFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_nop.c",
          "lines": "38-41",
          "snippet": "int networkAddFirewallRules(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nint networkAddFirewallRules(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRemoveFirewallRules",
          "args": [
            "def"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "networkRemoveFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver_nop.c",
          "lines": "43-45",
          "snippet": "void networkRemoveFirewallRules(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n}",
          "includes": [
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <config.h>\n\nvoid networkRemoveFirewallRules(virNetworkDefPtr def G_GNUC_UNUSED)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "obj"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\n\nstatic int\nnetworkReloadFirewallRulesHelper(virNetworkObjPtr obj,\n                                 void *opaque G_GNUC_UNUSED)\n{\n    virNetworkDefPtr def;\n\n    virObjectLock(obj);\n    def = virNetworkObjGetDef(obj);\n    if (virNetworkObjIsActive(obj)) {\n        switch ((virNetworkForwardType) def->forward.type) {\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n            /* Only three of the L3 network types that are configured by\n             * libvirt need to have iptables rules reloaded. The 4th L3\n             * network type, forward='open', doesn't need this because it\n             * has no iptables rules.\n             */\n            networkRemoveFirewallRules(def);\n            ignore_value(networkAddFirewallRules(def));\n            break;\n\n        case VIR_NETWORK_FORWARD_OPEN:\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            break;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n            goto cleanup;\n        }\n    }\n\n cleanup:\n    virObjectUnlock(obj);\n    return 0;\n}"
  },
  {
    "function_name": "networkRefreshDaemons",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2184-2191",
    "snippet": "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver)\n{\n    VIR_INFO(\"Refreshing network daemons\");\n    virNetworkObjListForEach(driver->networks,\n                             networkRefreshDaemonsHelper,\n                             driver);\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjListForEach",
          "args": [
            "driver->networks",
            "networkRefreshDaemonsHelper",
            "driver"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjListForEach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1472-1483",
          "snippet": "int\nvirNetworkObjListForEach(virNetworkObjListPtr nets,\n                         virNetworkObjListIterator callback,\n                         void *opaque)\n{\n    struct virNetworkObjListForEachHelperData data = {\n        .callback = callback, .opaque = opaque, .ret = 0};\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListForEachHelper, &data);\n    virObjectRWUnlock(nets);\n    return data.ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirNetworkObjListForEach(virNetworkObjListPtr nets,\n                         virNetworkObjListIterator callback,\n                         void *opaque)\n{\n    struct virNetworkObjListForEachHelperData data = {\n        .callback = callback, .opaque = opaque, .ret = 0};\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListForEachHelper, &data);\n    virObjectRWUnlock(nets);\n    return data.ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Refreshing network daemons\""
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver)\n{\n    VIR_INFO(\"Refreshing network daemons\");\n    virNetworkObjListForEach(driver->networks,\n                             networkRefreshDaemonsHelper,\n                             driver);\n}"
  },
  {
    "function_name": "networkRefreshDaemonsHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2136-2178",
    "snippet": "static int\nnetworkRefreshDaemonsHelper(virNetworkObjPtr obj,\n                            void *opaque)\n{\n    virNetworkDefPtr def;\n    virNetworkDriverStatePtr driver = opaque;\n\n    virObjectLock(obj);\n    def = virNetworkObjGetDef(obj);\n    if (virNetworkObjIsActive(obj)) {\n        switch ((virNetworkForwardType) def->forward.type) {\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n        case VIR_NETWORK_FORWARD_OPEN:\n            /* Only the three L3 network types that are configured by\n             * libvirt will have a dnsmasq or radvd daemon associated\n             * with them.  Here we send a SIGHUP to an existing\n             * dnsmasq and/or radvd, or restart them if they've\n             * disappeared.\n             */\n            networkRefreshDhcpDaemon(driver, obj);\n            networkRefreshRadvd(driver, obj);\n            break;\n\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            break;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n            goto cleanup;\n        }\n    }\n\n cleanup:\n    virObjectUnlock(obj);\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "obj"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkForwardType",
            "def->forward.type"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkRefreshRadvd",
          "args": [
            "driver",
            "obj"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "networkRefreshRadvd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2063-2104",
          "snippet": "static int\nnetworkRefreshRadvd(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    dnsmasqCapsPtr dnsmasq_caps = networkGetDnsmasqCaps(driver);\n    char *radvdpidbase;\n    pid_t radvdPid;\n\n    /* Is dnsmasq handling RA? */\n    if (DNSMASQ_RA_SUPPORT(dnsmasq_caps)) {\n        virObjectUnref(dnsmasq_caps);\n        radvdPid = virNetworkObjGetRadvdPid(obj);\n        if (radvdPid <= 0)\n            return 0;\n        /* radvd should not be running but in case it is */\n        if ((networkKillDaemon(radvdPid, \"radvd\", def->name) >= 0) &&\n            ((radvdpidbase = networkRadvdPidfileBasename(def->name))\n             != NULL)) {\n            virPidFileDelete(driver->pidDir, radvdpidbase);\n            VIR_FREE(radvdpidbase);\n        }\n        virNetworkObjSetRadvdPid(obj, -1);\n        return 0;\n    }\n    virObjectUnref(dnsmasq_caps);\n\n    /* if there's no running radvd, just start it */\n    radvdPid = virNetworkObjGetRadvdPid(obj);\n    if (radvdPid <= 0 || (kill(radvdPid, 0) < 0))\n        return networkStartRadvd(driver, obj);\n\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* no IPv6 addresses, so we don't need to run radvd */\n        return 0;\n    }\n\n    if (networkRadvdConfWrite(driver, obj, NULL) < 0)\n        return -1;\n\n    return kill(radvdPid, SIGHUP);\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRefreshRadvd(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    dnsmasqCapsPtr dnsmasq_caps = networkGetDnsmasqCaps(driver);\n    char *radvdpidbase;\n    pid_t radvdPid;\n\n    /* Is dnsmasq handling RA? */\n    if (DNSMASQ_RA_SUPPORT(dnsmasq_caps)) {\n        virObjectUnref(dnsmasq_caps);\n        radvdPid = virNetworkObjGetRadvdPid(obj);\n        if (radvdPid <= 0)\n            return 0;\n        /* radvd should not be running but in case it is */\n        if ((networkKillDaemon(radvdPid, \"radvd\", def->name) >= 0) &&\n            ((radvdpidbase = networkRadvdPidfileBasename(def->name))\n             != NULL)) {\n            virPidFileDelete(driver->pidDir, radvdpidbase);\n            VIR_FREE(radvdpidbase);\n        }\n        virNetworkObjSetRadvdPid(obj, -1);\n        return 0;\n    }\n    virObjectUnref(dnsmasq_caps);\n\n    /* if there's no running radvd, just start it */\n    radvdPid = virNetworkObjGetRadvdPid(obj);\n    if (radvdPid <= 0 || (kill(radvdPid, 0) < 0))\n        return networkStartRadvd(driver, obj);\n\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* no IPv6 addresses, so we don't need to run radvd */\n        return 0;\n    }\n\n    if (networkRadvdConfWrite(driver, obj, NULL) < 0)\n        return -1;\n\n    return kill(radvdPid, SIGHUP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRefreshDhcpDaemon",
          "args": [
            "driver",
            "obj"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "networkRefreshDhcpDaemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1758-1821",
          "snippet": "static int\nnetworkRefreshDhcpDaemon(virNetworkDriverStatePtr driver,\n                         virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n    size_t i;\n    pid_t dnsmasqPid;\n    virNetworkIPDefPtr ipdef, ipv4def, ipv6def;\n    dnsmasqContext *dctx = NULL;\n\n    /* if no IP addresses specified, nothing to do */\n    if (!virNetworkDefGetIPByIndex(def, AF_UNSPEC, 0))\n        return 0;\n\n    /* if there's no running dnsmasq, just start it */\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    if (dnsmasqPid <= 0 || (kill(dnsmasqPid, 0) < 0))\n        return networkStartDhcpDaemon(driver, obj);\n\n    VIR_INFO(\"Refreshing dnsmasq for network %s\", def->bridge);\n    if (!(dctx = dnsmasqContextNew(def->name,\n                                   driver->dnsmasqStateDir))) {\n        goto cleanup;\n    }\n\n    /* Look for first IPv4 address that has dhcp defined.\n     * We only support dhcp-host config on one IPv4 subnetwork\n     * and on one IPv6 subnetwork.\n     */\n    ipv4def = NULL;\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (!ipv4def && (ipdef->nranges || ipdef->nhosts))\n            ipv4def = ipdef;\n    }\n\n    ipv6def = NULL;\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i));\n         i++) {\n        if (!ipv6def && (ipdef->nranges || ipdef->nhosts))\n            ipv6def = ipdef;\n    }\n\n    if (ipv4def && (networkBuildDnsmasqDhcpHostsList(dctx, ipv4def) < 0))\n        goto cleanup;\n\n    if (ipv6def && (networkBuildDnsmasqDhcpHostsList(dctx, ipv6def) < 0))\n        goto cleanup;\n\n    if (networkBuildDnsmasqHostsList(dctx, &def->dns) < 0)\n        goto cleanup;\n\n    if ((ret = dnsmasqSave(dctx)) < 0)\n        goto cleanup;\n\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    ret = kill(dnsmasqPid, SIGHUP);\n cleanup:\n    dnsmasqContextFree(dctx);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRefreshDhcpDaemon(virNetworkDriverStatePtr driver,\n                         virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n    size_t i;\n    pid_t dnsmasqPid;\n    virNetworkIPDefPtr ipdef, ipv4def, ipv6def;\n    dnsmasqContext *dctx = NULL;\n\n    /* if no IP addresses specified, nothing to do */\n    if (!virNetworkDefGetIPByIndex(def, AF_UNSPEC, 0))\n        return 0;\n\n    /* if there's no running dnsmasq, just start it */\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    if (dnsmasqPid <= 0 || (kill(dnsmasqPid, 0) < 0))\n        return networkStartDhcpDaemon(driver, obj);\n\n    VIR_INFO(\"Refreshing dnsmasq for network %s\", def->bridge);\n    if (!(dctx = dnsmasqContextNew(def->name,\n                                   driver->dnsmasqStateDir))) {\n        goto cleanup;\n    }\n\n    /* Look for first IPv4 address that has dhcp defined.\n     * We only support dhcp-host config on one IPv4 subnetwork\n     * and on one IPv6 subnetwork.\n     */\n    ipv4def = NULL;\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (!ipv4def && (ipdef->nranges || ipdef->nhosts))\n            ipv4def = ipdef;\n    }\n\n    ipv6def = NULL;\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i));\n         i++) {\n        if (!ipv6def && (ipdef->nranges || ipdef->nhosts))\n            ipv6def = ipdef;\n    }\n\n    if (ipv4def && (networkBuildDnsmasqDhcpHostsList(dctx, ipv4def) < 0))\n        goto cleanup;\n\n    if (ipv6def && (networkBuildDnsmasqDhcpHostsList(dctx, ipv6def) < 0))\n        goto cleanup;\n\n    if (networkBuildDnsmasqHostsList(dctx, &def->dns) < 0)\n        goto cleanup;\n\n    if ((ret = dnsmasqSave(dctx)) < 0)\n        goto cleanup;\n\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    ret = kill(dnsmasqPid, SIGHUP);\n cleanup:\n    dnsmasqContextFree(dctx);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "obj"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRefreshDaemonsHelper(virNetworkObjPtr obj,\n                            void *opaque)\n{\n    virNetworkDefPtr def;\n    virNetworkDriverStatePtr driver = opaque;\n\n    virObjectLock(obj);\n    def = virNetworkObjGetDef(obj);\n    if (virNetworkObjIsActive(obj)) {\n        switch ((virNetworkForwardType) def->forward.type) {\n        case VIR_NETWORK_FORWARD_NONE:\n        case VIR_NETWORK_FORWARD_NAT:\n        case VIR_NETWORK_FORWARD_ROUTE:\n        case VIR_NETWORK_FORWARD_OPEN:\n            /* Only the three L3 network types that are configured by\n             * libvirt will have a dnsmasq or radvd daemon associated\n             * with them.  Here we send a SIGHUP to an existing\n             * dnsmasq and/or radvd, or restart them if they've\n             * disappeared.\n             */\n            networkRefreshDhcpDaemon(driver, obj);\n            networkRefreshRadvd(driver, obj);\n            break;\n\n        case VIR_NETWORK_FORWARD_BRIDGE:\n        case VIR_NETWORK_FORWARD_PRIVATE:\n        case VIR_NETWORK_FORWARD_VEPA:\n        case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        case VIR_NETWORK_FORWARD_HOSTDEV:\n            break;\n\n        case VIR_NETWORK_FORWARD_LAST:\n        default:\n            virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n            goto cleanup;\n        }\n    }\n\n cleanup:\n    virObjectUnlock(obj);\n    return 0;\n}"
  },
  {
    "function_name": "networkRestartRadvd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2109-2132",
    "snippet": "static int\nnetworkRestartRadvd(virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    char *radvdpidbase;\n    pid_t radvdPid = virNeworkObjGetRadvdPid(obj);\n\n    /* if there is a running radvd, kill it */\n    if (radvdPid > 0) {\n        /* essentially ignore errors from the following two functions,\n         * since there's really no better recovery to be done than to\n         * just push ahead (and that may be exactly what's needed).\n         */\n        if ((networkKillDaemon(radvdPid, \"radvd\", def->name) >= 0) &&\n            ((radvdpidbase = networkRadvdPidfileBasename(def->name))\n             != NULL)) {\n            virPidFileDelete(driver->pidDir, radvdpidbase);\n            VIR_FREE(radvdpidbase);\n        }\n        virNetworkObjSetRadvdPid(obj, -1);\n    }\n    /* now start radvd if it should be started */\n    return networkStartRadvd(obj);\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkStartRadvd",
          "args": [
            "obj"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetRadvdPid",
          "args": [
            "obj",
            "-1"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetRadvdPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "229-234",
          "snippet": "void\nvirNetworkObjSetRadvdPid(virNetworkObjPtr obj,\n                         pid_t radvdPid)\n{\n    obj->radvdPid = radvdPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetRadvdPid(virNetworkObjPtr obj,\n                         pid_t radvdPid)\n{\n    obj->radvdPid = radvdPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "radvdpidbase"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileDelete",
          "args": [
            "driver->pidDir",
            "radvdpidbase"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "316-328",
          "snippet": "int virPidFileDelete(const char *dir,\n                     const char *name)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileDeletePath(pidfile);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileDelete(const char *dir,\n                     const char *name)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileDeletePath(pidfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRadvdPidfileBasename",
          "args": [
            "def->name"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "networkRadvdPidfileBasename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "400-408",
          "snippet": "static char *\nnetworkRadvdPidfileBasename(const char *netname)\n{\n    /* this is simple but we want to be sure it's consistently done */\n    char *pidfilebase;\n\n    pidfilebase = g_strdup_printf(\"%s-radvd\", netname);\n    return pidfilebase;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nnetworkRadvdPidfileBasename(const char *netname)\n{\n    /* this is simple but we want to be sure it's consistently done */\n    char *pidfilebase;\n\n    pidfilebase = g_strdup_printf(\"%s-radvd\", netname);\n    return pidfilebase;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkKillDaemon",
          "args": [
            "radvdPid",
            "\"radvd\"",
            "def->name"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "networkKillDaemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "973-1027",
          "snippet": "static int\nnetworkKillDaemon(pid_t pid,\n                  const char *daemonName,\n                  const char *networkName)\n{\n    size_t i;\n    int ret = -1;\n    const char *signame = \"TERM\";\n\n    /* send SIGTERM, then wait up to 3 seconds for the process to\n     * disappear, send SIGKILL, then wait for up to another 2\n     * seconds. If that fails, log a warning and continue, hoping\n     * for the best.\n     */\n    for (i = 0; i < 25; i++) {\n        int signum = 0;\n        if (i == 0) {\n            signum = SIGTERM;\n        } else if (i == 15) {\n            signum = SIGKILL;\n            signame = \"KILL\";\n        }\n        if (kill(pid, signum) < 0) {\n            if (errno == ESRCH) {\n                ret = 0;\n            } else {\n                VIR_WARN(\"Failed to terminate %s process %d \"\n                         \"for network '%s' with SIG%s: %s\",\n                         daemonName, pid, networkName, signame,\n                         g_strerror(errno));\n            }\n            return ret;\n        }\n        /* NB: since networks have no reference count like\n         * domains, there is no safe way to unlock the network\n         * object temporarily, and so we can't follow the\n         * procedure used by the qemu driver of 1) unlock driver\n         * 2) sleep, 3) add ref to object 4) unlock object, 5)\n         * re-lock driver, 6) re-lock object. We may need to add\n         * that functionality eventually, but for now this\n         * function is rarely used and, at worst, leaving the\n         * network driver locked during this loop of sleeps will\n         * have the effect of holding up any other thread trying\n         * to make modifications to a network for up to 5 seconds;\n         * since modifications to networks are much less common\n         * than modifications to domains, this seems a reasonable\n         * tradeoff in exchange for less code disruption.\n         */\n        g_usleep(20 * 1000);\n    }\n    VIR_WARN(\"Timed out waiting after SIG%s to %s process %d \"\n             \"(network '%s')\",\n             signame, daemonName, pid, networkName);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkKillDaemon(pid_t pid,\n                  const char *daemonName,\n                  const char *networkName)\n{\n    size_t i;\n    int ret = -1;\n    const char *signame = \"TERM\";\n\n    /* send SIGTERM, then wait up to 3 seconds for the process to\n     * disappear, send SIGKILL, then wait for up to another 2\n     * seconds. If that fails, log a warning and continue, hoping\n     * for the best.\n     */\n    for (i = 0; i < 25; i++) {\n        int signum = 0;\n        if (i == 0) {\n            signum = SIGTERM;\n        } else if (i == 15) {\n            signum = SIGKILL;\n            signame = \"KILL\";\n        }\n        if (kill(pid, signum) < 0) {\n            if (errno == ESRCH) {\n                ret = 0;\n            } else {\n                VIR_WARN(\"Failed to terminate %s process %d \"\n                         \"for network '%s' with SIG%s: %s\",\n                         daemonName, pid, networkName, signame,\n                         g_strerror(errno));\n            }\n            return ret;\n        }\n        /* NB: since networks have no reference count like\n         * domains, there is no safe way to unlock the network\n         * object temporarily, and so we can't follow the\n         * procedure used by the qemu driver of 1) unlock driver\n         * 2) sleep, 3) add ref to object 4) unlock object, 5)\n         * re-lock driver, 6) re-lock object. We may need to add\n         * that functionality eventually, but for now this\n         * function is rarely used and, at worst, leaving the\n         * network driver locked during this loop of sleeps will\n         * have the effect of holding up any other thread trying\n         * to make modifications to a network for up to 5 seconds;\n         * since modifications to networks are much less common\n         * than modifications to domains, this seems a reasonable\n         * tradeoff in exchange for less code disruption.\n         */\n        g_usleep(20 * 1000);\n    }\n    VIR_WARN(\"Timed out waiting after SIG%s to %s process %d \"\n             \"(network '%s')\",\n             signame, daemonName, pid, networkName);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNeworkObjGetRadvdPid",
          "args": [
            "obj"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRestartRadvd(virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    char *radvdpidbase;\n    pid_t radvdPid = virNeworkObjGetRadvdPid(obj);\n\n    /* if there is a running radvd, kill it */\n    if (radvdPid > 0) {\n        /* essentially ignore errors from the following two functions,\n         * since there's really no better recovery to be done than to\n         * just push ahead (and that may be exactly what's needed).\n         */\n        if ((networkKillDaemon(radvdPid, \"radvd\", def->name) >= 0) &&\n            ((radvdpidbase = networkRadvdPidfileBasename(def->name))\n             != NULL)) {\n            virPidFileDelete(driver->pidDir, radvdpidbase);\n            VIR_FREE(radvdpidbase);\n        }\n        virNetworkObjSetRadvdPid(obj, -1);\n    }\n    /* now start radvd if it should be started */\n    return networkStartRadvd(obj);\n}"
  },
  {
    "function_name": "networkRefreshRadvd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "2063-2104",
    "snippet": "static int\nnetworkRefreshRadvd(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    dnsmasqCapsPtr dnsmasq_caps = networkGetDnsmasqCaps(driver);\n    char *radvdpidbase;\n    pid_t radvdPid;\n\n    /* Is dnsmasq handling RA? */\n    if (DNSMASQ_RA_SUPPORT(dnsmasq_caps)) {\n        virObjectUnref(dnsmasq_caps);\n        radvdPid = virNetworkObjGetRadvdPid(obj);\n        if (radvdPid <= 0)\n            return 0;\n        /* radvd should not be running but in case it is */\n        if ((networkKillDaemon(radvdPid, \"radvd\", def->name) >= 0) &&\n            ((radvdpidbase = networkRadvdPidfileBasename(def->name))\n             != NULL)) {\n            virPidFileDelete(driver->pidDir, radvdpidbase);\n            VIR_FREE(radvdpidbase);\n        }\n        virNetworkObjSetRadvdPid(obj, -1);\n        return 0;\n    }\n    virObjectUnref(dnsmasq_caps);\n\n    /* if there's no running radvd, just start it */\n    radvdPid = virNetworkObjGetRadvdPid(obj);\n    if (radvdPid <= 0 || (kill(radvdPid, 0) < 0))\n        return networkStartRadvd(driver, obj);\n\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* no IPv6 addresses, so we don't need to run radvd */\n        return 0;\n    }\n\n    if (networkRadvdConfWrite(driver, obj, NULL) < 0)\n        return -1;\n\n    return kill(radvdPid, SIGHUP);\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "radvdPid",
            "SIGHUP"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkRadvdConfWrite",
          "args": [
            "driver",
            "obj",
            "NULL"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "networkRadvdConfWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1929-1968",
          "snippet": "static int\nnetworkRadvdConfWrite(virNetworkDriverStatePtr driver,\n                      virNetworkObjPtr obj,\n                      char **configFile)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n    char *configStr = NULL;\n    char *myConfigFile = NULL;\n\n    if (!configFile)\n        configFile = &myConfigFile;\n\n    *configFile = NULL;\n\n    if (networkRadvdConfContents(obj, &configStr) < 0)\n        goto cleanup;\n\n    if (!configStr) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* construct the filename */\n    if (!(*configFile = networkRadvdConfigFileName(driver, def->name)))\n        goto cleanup;\n    /* write the file */\n    if (virFileWriteStr(*configFile, configStr, 0600) < 0) {\n        virReportSystemError(errno,\n                             _(\"couldn't write radvd config file '%s'\"),\n                             *configFile);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(configStr);\n    VIR_FREE(myConfigFile);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRadvdConfWrite(virNetworkDriverStatePtr driver,\n                      virNetworkObjPtr obj,\n                      char **configFile)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n    char *configStr = NULL;\n    char *myConfigFile = NULL;\n\n    if (!configFile)\n        configFile = &myConfigFile;\n\n    *configFile = NULL;\n\n    if (networkRadvdConfContents(obj, &configStr) < 0)\n        goto cleanup;\n\n    if (!configStr) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* construct the filename */\n    if (!(*configFile = networkRadvdConfigFileName(driver, def->name)))\n        goto cleanup;\n    /* write the file */\n    if (virFileWriteStr(*configFile, configStr, 0600) < 0) {\n        virReportSystemError(errno,\n                             _(\"couldn't write radvd config file '%s'\"),\n                             *configFile);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(configStr);\n    VIR_FREE(myConfigFile);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET6",
            "0"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkStartRadvd",
          "args": [
            "driver",
            "obj"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "networkStartRadvd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1971-2060",
          "snippet": "static int\nnetworkStartRadvd(virNetworkDriverStatePtr driver,\n                  virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    dnsmasqCapsPtr dnsmasq_caps = networkGetDnsmasqCaps(driver);\n    pid_t radvdPid;\n    char *pidfile = NULL;\n    char *radvdpidbase = NULL;\n    char *configfile = NULL;\n    virCommandPtr cmd = NULL;\n    int ret = -1;\n\n    virNetworkObjSetRadvdPid(obj, -1);\n\n    /* Is dnsmasq handling RA? */\n    if (DNSMASQ_RA_SUPPORT(dnsmasq_caps)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* no IPv6 addresses, so we don't need to run radvd */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virFileIsExecutable(RADVD)) {\n        virReportSystemError(errno,\n                             _(\"Cannot find %s - \"\n                               \"Possibly the package isn't installed\"),\n                             RADVD);\n        goto cleanup;\n    }\n\n    if (virFileMakePath(driver->pidDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->pidDir);\n        goto cleanup;\n    }\n    if (virFileMakePath(driver->radvdStateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->radvdStateDir);\n        goto cleanup;\n    }\n\n    /* construct pidfile name */\n    if (!(radvdpidbase = networkRadvdPidfileBasename(def->name)))\n        goto cleanup;\n    if (!(pidfile = virPidFileBuildPath(driver->pidDir, radvdpidbase)))\n        goto cleanup;\n\n    if (networkRadvdConfWrite(driver, obj, &configfile) < 0)\n        goto cleanup;\n\n    /* prevent radvd from daemonizing itself with \"--debug 1\", and use\n     * a dummy pidfile name - virCommand will create the pidfile we\n     * want to use (this is necessary because radvd's internal\n     * daemonization and pidfile creation causes a race, and the\n     * virPidFileRead() below will fail if we use them).\n     * Unfortunately, it isn't possible to tell radvd to not create\n     * its own pidfile, so we just let it do so, with a slightly\n     * different name. Unused, but harmless.\n     */\n    cmd = virCommandNewArgList(RADVD, \"--debug\", \"1\",\n                               \"--config\", configfile,\n                               \"--pidfile\", NULL);\n    virCommandAddArgFormat(cmd, \"%s-bin\", pidfile);\n\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandDaemonize(cmd);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virPidFileRead(driver->pidDir, radvdpidbase, &radvdPid) < 0)\n        goto cleanup;\n    virNetworkObjSetRadvdPid(obj, radvdPid);\n\n    ret = 0;\n cleanup:\n    virObjectUnref(dnsmasq_caps);\n    virCommandFree(cmd);\n    VIR_FREE(configfile);\n    VIR_FREE(radvdpidbase);\n    VIR_FREE(pidfile);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStartRadvd(virNetworkDriverStatePtr driver,\n                  virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    dnsmasqCapsPtr dnsmasq_caps = networkGetDnsmasqCaps(driver);\n    pid_t radvdPid;\n    char *pidfile = NULL;\n    char *radvdpidbase = NULL;\n    char *configfile = NULL;\n    virCommandPtr cmd = NULL;\n    int ret = -1;\n\n    virNetworkObjSetRadvdPid(obj, -1);\n\n    /* Is dnsmasq handling RA? */\n    if (DNSMASQ_RA_SUPPORT(dnsmasq_caps)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* no IPv6 addresses, so we don't need to run radvd */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virFileIsExecutable(RADVD)) {\n        virReportSystemError(errno,\n                             _(\"Cannot find %s - \"\n                               \"Possibly the package isn't installed\"),\n                             RADVD);\n        goto cleanup;\n    }\n\n    if (virFileMakePath(driver->pidDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->pidDir);\n        goto cleanup;\n    }\n    if (virFileMakePath(driver->radvdStateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->radvdStateDir);\n        goto cleanup;\n    }\n\n    /* construct pidfile name */\n    if (!(radvdpidbase = networkRadvdPidfileBasename(def->name)))\n        goto cleanup;\n    if (!(pidfile = virPidFileBuildPath(driver->pidDir, radvdpidbase)))\n        goto cleanup;\n\n    if (networkRadvdConfWrite(driver, obj, &configfile) < 0)\n        goto cleanup;\n\n    /* prevent radvd from daemonizing itself with \"--debug 1\", and use\n     * a dummy pidfile name - virCommand will create the pidfile we\n     * want to use (this is necessary because radvd's internal\n     * daemonization and pidfile creation causes a race, and the\n     * virPidFileRead() below will fail if we use them).\n     * Unfortunately, it isn't possible to tell radvd to not create\n     * its own pidfile, so we just let it do so, with a slightly\n     * different name. Unused, but harmless.\n     */\n    cmd = virCommandNewArgList(RADVD, \"--debug\", \"1\",\n                               \"--config\", configfile,\n                               \"--pidfile\", NULL);\n    virCommandAddArgFormat(cmd, \"%s-bin\", pidfile);\n\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandDaemonize(cmd);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virPidFileRead(driver->pidDir, radvdpidbase, &radvdPid) < 0)\n        goto cleanup;\n    virNetworkObjSetRadvdPid(obj, radvdPid);\n\n    ret = 0;\n cleanup:\n    virObjectUnref(dnsmasq_caps);\n    virCommandFree(cmd);\n    VIR_FREE(configfile);\n    VIR_FREE(radvdpidbase);\n    VIR_FREE(pidfile);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "radvdPid",
            "0"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetRadvdPid",
          "args": [
            "obj"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetRadvdPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "222-226",
          "snippet": "pid_t\nvirNetworkObjGetRadvdPid(virNetworkObjPtr obj)\n{\n    return obj->radvdPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\npid_t\nvirNetworkObjGetRadvdPid(virNetworkObjPtr obj)\n{\n    return obj->radvdPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "dnsmasq_caps"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetRadvdPid",
          "args": [
            "obj",
            "-1"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetRadvdPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "229-234",
          "snippet": "void\nvirNetworkObjSetRadvdPid(virNetworkObjPtr obj,\n                         pid_t radvdPid)\n{\n    obj->radvdPid = radvdPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetRadvdPid(virNetworkObjPtr obj,\n                         pid_t radvdPid)\n{\n    obj->radvdPid = radvdPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "radvdpidbase"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileDelete",
          "args": [
            "driver->pidDir",
            "radvdpidbase"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "316-328",
          "snippet": "int virPidFileDelete(const char *dir,\n                     const char *name)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileDeletePath(pidfile);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileDelete(const char *dir,\n                     const char *name)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileDeletePath(pidfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRadvdPidfileBasename",
          "args": [
            "def->name"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "networkRadvdPidfileBasename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "400-408",
          "snippet": "static char *\nnetworkRadvdPidfileBasename(const char *netname)\n{\n    /* this is simple but we want to be sure it's consistently done */\n    char *pidfilebase;\n\n    pidfilebase = g_strdup_printf(\"%s-radvd\", netname);\n    return pidfilebase;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nnetworkRadvdPidfileBasename(const char *netname)\n{\n    /* this is simple but we want to be sure it's consistently done */\n    char *pidfilebase;\n\n    pidfilebase = g_strdup_printf(\"%s-radvd\", netname);\n    return pidfilebase;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkKillDaemon",
          "args": [
            "radvdPid",
            "\"radvd\"",
            "def->name"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "networkKillDaemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "973-1027",
          "snippet": "static int\nnetworkKillDaemon(pid_t pid,\n                  const char *daemonName,\n                  const char *networkName)\n{\n    size_t i;\n    int ret = -1;\n    const char *signame = \"TERM\";\n\n    /* send SIGTERM, then wait up to 3 seconds for the process to\n     * disappear, send SIGKILL, then wait for up to another 2\n     * seconds. If that fails, log a warning and continue, hoping\n     * for the best.\n     */\n    for (i = 0; i < 25; i++) {\n        int signum = 0;\n        if (i == 0) {\n            signum = SIGTERM;\n        } else if (i == 15) {\n            signum = SIGKILL;\n            signame = \"KILL\";\n        }\n        if (kill(pid, signum) < 0) {\n            if (errno == ESRCH) {\n                ret = 0;\n            } else {\n                VIR_WARN(\"Failed to terminate %s process %d \"\n                         \"for network '%s' with SIG%s: %s\",\n                         daemonName, pid, networkName, signame,\n                         g_strerror(errno));\n            }\n            return ret;\n        }\n        /* NB: since networks have no reference count like\n         * domains, there is no safe way to unlock the network\n         * object temporarily, and so we can't follow the\n         * procedure used by the qemu driver of 1) unlock driver\n         * 2) sleep, 3) add ref to object 4) unlock object, 5)\n         * re-lock driver, 6) re-lock object. We may need to add\n         * that functionality eventually, but for now this\n         * function is rarely used and, at worst, leaving the\n         * network driver locked during this loop of sleeps will\n         * have the effect of holding up any other thread trying\n         * to make modifications to a network for up to 5 seconds;\n         * since modifications to networks are much less common\n         * than modifications to domains, this seems a reasonable\n         * tradeoff in exchange for less code disruption.\n         */\n        g_usleep(20 * 1000);\n    }\n    VIR_WARN(\"Timed out waiting after SIG%s to %s process %d \"\n             \"(network '%s')\",\n             signame, daemonName, pid, networkName);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkKillDaemon(pid_t pid,\n                  const char *daemonName,\n                  const char *networkName)\n{\n    size_t i;\n    int ret = -1;\n    const char *signame = \"TERM\";\n\n    /* send SIGTERM, then wait up to 3 seconds for the process to\n     * disappear, send SIGKILL, then wait for up to another 2\n     * seconds. If that fails, log a warning and continue, hoping\n     * for the best.\n     */\n    for (i = 0; i < 25; i++) {\n        int signum = 0;\n        if (i == 0) {\n            signum = SIGTERM;\n        } else if (i == 15) {\n            signum = SIGKILL;\n            signame = \"KILL\";\n        }\n        if (kill(pid, signum) < 0) {\n            if (errno == ESRCH) {\n                ret = 0;\n            } else {\n                VIR_WARN(\"Failed to terminate %s process %d \"\n                         \"for network '%s' with SIG%s: %s\",\n                         daemonName, pid, networkName, signame,\n                         g_strerror(errno));\n            }\n            return ret;\n        }\n        /* NB: since networks have no reference count like\n         * domains, there is no safe way to unlock the network\n         * object temporarily, and so we can't follow the\n         * procedure used by the qemu driver of 1) unlock driver\n         * 2) sleep, 3) add ref to object 4) unlock object, 5)\n         * re-lock driver, 6) re-lock object. We may need to add\n         * that functionality eventually, but for now this\n         * function is rarely used and, at worst, leaving the\n         * network driver locked during this loop of sleeps will\n         * have the effect of holding up any other thread trying\n         * to make modifications to a network for up to 5 seconds;\n         * since modifications to networks are much less common\n         * than modifications to domains, this seems a reasonable\n         * tradeoff in exchange for less code disruption.\n         */\n        g_usleep(20 * 1000);\n    }\n    VIR_WARN(\"Timed out waiting after SIG%s to %s process %d \"\n             \"(network '%s')\",\n             signame, daemonName, pid, networkName);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DNSMASQ_RA_SUPPORT",
          "args": [
            "dnsmasq_caps"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDnsmasqCaps",
          "args": [
            "driver"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDnsmasqCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "115-123",
          "snippet": "static dnsmasqCapsPtr\nnetworkGetDnsmasqCaps(virNetworkDriverStatePtr driver)\n{\n    dnsmasqCapsPtr ret;\n    networkDriverLock(driver);\n    ret = virObjectRef(driver->dnsmasqCaps);\n    networkDriverUnlock(driver);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic dnsmasqCapsPtr\nnetworkGetDnsmasqCaps(virNetworkDriverStatePtr driver)\n{\n    dnsmasqCapsPtr ret;\n    networkDriverLock(driver);\n    ret = virObjectRef(driver->dnsmasqCaps);\n    networkDriverUnlock(driver);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRefreshRadvd(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    dnsmasqCapsPtr dnsmasq_caps = networkGetDnsmasqCaps(driver);\n    char *radvdpidbase;\n    pid_t radvdPid;\n\n    /* Is dnsmasq handling RA? */\n    if (DNSMASQ_RA_SUPPORT(dnsmasq_caps)) {\n        virObjectUnref(dnsmasq_caps);\n        radvdPid = virNetworkObjGetRadvdPid(obj);\n        if (radvdPid <= 0)\n            return 0;\n        /* radvd should not be running but in case it is */\n        if ((networkKillDaemon(radvdPid, \"radvd\", def->name) >= 0) &&\n            ((radvdpidbase = networkRadvdPidfileBasename(def->name))\n             != NULL)) {\n            virPidFileDelete(driver->pidDir, radvdpidbase);\n            VIR_FREE(radvdpidbase);\n        }\n        virNetworkObjSetRadvdPid(obj, -1);\n        return 0;\n    }\n    virObjectUnref(dnsmasq_caps);\n\n    /* if there's no running radvd, just start it */\n    radvdPid = virNetworkObjGetRadvdPid(obj);\n    if (radvdPid <= 0 || (kill(radvdPid, 0) < 0))\n        return networkStartRadvd(driver, obj);\n\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* no IPv6 addresses, so we don't need to run radvd */\n        return 0;\n    }\n\n    if (networkRadvdConfWrite(driver, obj, NULL) < 0)\n        return -1;\n\n    return kill(radvdPid, SIGHUP);\n}"
  },
  {
    "function_name": "networkStartRadvd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "1971-2060",
    "snippet": "static int\nnetworkStartRadvd(virNetworkDriverStatePtr driver,\n                  virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    dnsmasqCapsPtr dnsmasq_caps = networkGetDnsmasqCaps(driver);\n    pid_t radvdPid;\n    char *pidfile = NULL;\n    char *radvdpidbase = NULL;\n    char *configfile = NULL;\n    virCommandPtr cmd = NULL;\n    int ret = -1;\n\n    virNetworkObjSetRadvdPid(obj, -1);\n\n    /* Is dnsmasq handling RA? */\n    if (DNSMASQ_RA_SUPPORT(dnsmasq_caps)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* no IPv6 addresses, so we don't need to run radvd */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virFileIsExecutable(RADVD)) {\n        virReportSystemError(errno,\n                             _(\"Cannot find %s - \"\n                               \"Possibly the package isn't installed\"),\n                             RADVD);\n        goto cleanup;\n    }\n\n    if (virFileMakePath(driver->pidDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->pidDir);\n        goto cleanup;\n    }\n    if (virFileMakePath(driver->radvdStateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->radvdStateDir);\n        goto cleanup;\n    }\n\n    /* construct pidfile name */\n    if (!(radvdpidbase = networkRadvdPidfileBasename(def->name)))\n        goto cleanup;\n    if (!(pidfile = virPidFileBuildPath(driver->pidDir, radvdpidbase)))\n        goto cleanup;\n\n    if (networkRadvdConfWrite(driver, obj, &configfile) < 0)\n        goto cleanup;\n\n    /* prevent radvd from daemonizing itself with \"--debug 1\", and use\n     * a dummy pidfile name - virCommand will create the pidfile we\n     * want to use (this is necessary because radvd's internal\n     * daemonization and pidfile creation causes a race, and the\n     * virPidFileRead() below will fail if we use them).\n     * Unfortunately, it isn't possible to tell radvd to not create\n     * its own pidfile, so we just let it do so, with a slightly\n     * different name. Unused, but harmless.\n     */\n    cmd = virCommandNewArgList(RADVD, \"--debug\", \"1\",\n                               \"--config\", configfile,\n                               \"--pidfile\", NULL);\n    virCommandAddArgFormat(cmd, \"%s-bin\", pidfile);\n\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandDaemonize(cmd);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virPidFileRead(driver->pidDir, radvdpidbase, &radvdPid) < 0)\n        goto cleanup;\n    virNetworkObjSetRadvdPid(obj, radvdPid);\n\n    ret = 0;\n cleanup:\n    virObjectUnref(dnsmasq_caps);\n    virCommandFree(cmd);\n    VIR_FREE(configfile);\n    VIR_FREE(radvdpidbase);\n    VIR_FREE(pidfile);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pidfile"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "radvdpidbase"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "configfile"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "dnsmasq_caps"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetRadvdPid",
          "args": [
            "obj",
            "radvdPid"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetRadvdPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "229-234",
          "snippet": "void\nvirNetworkObjSetRadvdPid(virNetworkObjPtr obj,\n                         pid_t radvdPid)\n{\n    obj->radvdPid = radvdPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetRadvdPid(virNetworkObjPtr obj,\n                         pid_t radvdPid)\n{\n    obj->radvdPid = radvdPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileRead",
          "args": [
            "driver->pidDir",
            "radvdpidbase",
            "&radvdPid"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPathIfAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "187-264",
          "snippet": "int virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandDaemonize",
          "args": [
            "cmd"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandDaemonize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1263-1270",
          "snippet": "void\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetPidFile",
          "args": [
            "cmd",
            "pidfile"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetPidFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1086-1094",
          "snippet": "void\nvirCommandSetPidFile(virCommandPtr cmd, const char *pidfile)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    VIR_FREE(cmd->pidfile);\n    cmd->pidfile = g_strdup(pidfile);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetPidFile(virCommandPtr cmd, const char *pidfile)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    VIR_FREE(cmd->pidfile);\n    cmd->pidfile = g_strdup(pidfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%s-bin\"",
            "pidfile"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "RADVD",
            "\"--debug\"",
            "\"1\"",
            "\"--config\"",
            "configfile",
            "\"--pidfile\"",
            "NULL"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRadvdConfWrite",
          "args": [
            "driver",
            "obj",
            "&configfile"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "networkRadvdConfWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1929-1968",
          "snippet": "static int\nnetworkRadvdConfWrite(virNetworkDriverStatePtr driver,\n                      virNetworkObjPtr obj,\n                      char **configFile)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n    char *configStr = NULL;\n    char *myConfigFile = NULL;\n\n    if (!configFile)\n        configFile = &myConfigFile;\n\n    *configFile = NULL;\n\n    if (networkRadvdConfContents(obj, &configStr) < 0)\n        goto cleanup;\n\n    if (!configStr) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* construct the filename */\n    if (!(*configFile = networkRadvdConfigFileName(driver, def->name)))\n        goto cleanup;\n    /* write the file */\n    if (virFileWriteStr(*configFile, configStr, 0600) < 0) {\n        virReportSystemError(errno,\n                             _(\"couldn't write radvd config file '%s'\"),\n                             *configFile);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(configStr);\n    VIR_FREE(myConfigFile);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRadvdConfWrite(virNetworkDriverStatePtr driver,\n                      virNetworkObjPtr obj,\n                      char **configFile)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n    char *configStr = NULL;\n    char *myConfigFile = NULL;\n\n    if (!configFile)\n        configFile = &myConfigFile;\n\n    *configFile = NULL;\n\n    if (networkRadvdConfContents(obj, &configStr) < 0)\n        goto cleanup;\n\n    if (!configStr) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* construct the filename */\n    if (!(*configFile = networkRadvdConfigFileName(driver, def->name)))\n        goto cleanup;\n    /* write the file */\n    if (virFileWriteStr(*configFile, configStr, 0600) < 0) {\n        virReportSystemError(errno,\n                             _(\"couldn't write radvd config file '%s'\"),\n                             *configFile);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(configStr);\n    VIR_FREE(myConfigFile);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileBuildPath",
          "args": [
            "driver->pidDir",
            "radvdpidbase"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "43-51",
          "snippet": "char *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRadvdPidfileBasename",
          "args": [
            "def->name"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "networkRadvdPidfileBasename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "400-408",
          "snippet": "static char *\nnetworkRadvdPidfileBasename(const char *netname)\n{\n    /* this is simple but we want to be sure it's consistently done */\n    char *pidfilebase;\n\n    pidfilebase = g_strdup_printf(\"%s-radvd\", netname);\n    return pidfilebase;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nnetworkRadvdPidfileBasename(const char *netname)\n{\n    /* this is simple but we want to be sure it's consistently done */\n    char *pidfilebase;\n\n    pidfilebase = g_strdup_printf(\"%s-radvd\", netname);\n    return pidfilebase;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot create directory %s\")",
            "driver->radvdStateDir"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot create directory %s\""
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "driver->radvdStateDir"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot create directory %s\")",
            "driver->pidDir"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot find %s - \"\n                               \"Possibly the package isn't installed\")",
            "RADVD"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileIsExecutable",
          "args": [
            "RADVD"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsExecutable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1886-1899",
          "snippet": "bool\nvirFileIsExecutable(const char *file)\n{\n    struct stat sb;\n\n    /* We would also want to check faccessat if we cared about ACLs,\n     * but we don't.  */\n    if (stat(file, &sb) < 0)\n        return false;\n    if (S_ISREG(sb.st_mode) && (sb.st_mode & 0111) != 0)\n        return true;\n    errno = S_ISDIR(sb.st_mode) ? EISDIR : EACCES;\n    return false;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileIsExecutable(const char *file)\n{\n    struct stat sb;\n\n    /* We would also want to check faccessat if we cared about ACLs,\n     * but we don't.  */\n    if (stat(file, &sb) < 0)\n        return false;\n    if (S_ISREG(sb.st_mode) && (sb.st_mode & 0111) != 0)\n        return true;\n    errno = S_ISDIR(sb.st_mode) ? EISDIR : EACCES;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET6",
            "0"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DNSMASQ_RA_SUPPORT",
          "args": [
            "dnsmasq_caps"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkGetDnsmasqCaps",
          "args": [
            "driver"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDnsmasqCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "115-123",
          "snippet": "static dnsmasqCapsPtr\nnetworkGetDnsmasqCaps(virNetworkDriverStatePtr driver)\n{\n    dnsmasqCapsPtr ret;\n    networkDriverLock(driver);\n    ret = virObjectRef(driver->dnsmasqCaps);\n    networkDriverUnlock(driver);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic dnsmasqCapsPtr\nnetworkGetDnsmasqCaps(virNetworkDriverStatePtr driver)\n{\n    dnsmasqCapsPtr ret;\n    networkDriverLock(driver);\n    ret = virObjectRef(driver->dnsmasqCaps);\n    networkDriverUnlock(driver);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStartRadvd(virNetworkDriverStatePtr driver,\n                  virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    dnsmasqCapsPtr dnsmasq_caps = networkGetDnsmasqCaps(driver);\n    pid_t radvdPid;\n    char *pidfile = NULL;\n    char *radvdpidbase = NULL;\n    char *configfile = NULL;\n    virCommandPtr cmd = NULL;\n    int ret = -1;\n\n    virNetworkObjSetRadvdPid(obj, -1);\n\n    /* Is dnsmasq handling RA? */\n    if (DNSMASQ_RA_SUPPORT(dnsmasq_caps)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virNetworkDefGetIPByIndex(def, AF_INET6, 0)) {\n        /* no IPv6 addresses, so we don't need to run radvd */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!virFileIsExecutable(RADVD)) {\n        virReportSystemError(errno,\n                             _(\"Cannot find %s - \"\n                               \"Possibly the package isn't installed\"),\n                             RADVD);\n        goto cleanup;\n    }\n\n    if (virFileMakePath(driver->pidDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->pidDir);\n        goto cleanup;\n    }\n    if (virFileMakePath(driver->radvdStateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->radvdStateDir);\n        goto cleanup;\n    }\n\n    /* construct pidfile name */\n    if (!(radvdpidbase = networkRadvdPidfileBasename(def->name)))\n        goto cleanup;\n    if (!(pidfile = virPidFileBuildPath(driver->pidDir, radvdpidbase)))\n        goto cleanup;\n\n    if (networkRadvdConfWrite(driver, obj, &configfile) < 0)\n        goto cleanup;\n\n    /* prevent radvd from daemonizing itself with \"--debug 1\", and use\n     * a dummy pidfile name - virCommand will create the pidfile we\n     * want to use (this is necessary because radvd's internal\n     * daemonization and pidfile creation causes a race, and the\n     * virPidFileRead() below will fail if we use them).\n     * Unfortunately, it isn't possible to tell radvd to not create\n     * its own pidfile, so we just let it do so, with a slightly\n     * different name. Unused, but harmless.\n     */\n    cmd = virCommandNewArgList(RADVD, \"--debug\", \"1\",\n                               \"--config\", configfile,\n                               \"--pidfile\", NULL);\n    virCommandAddArgFormat(cmd, \"%s-bin\", pidfile);\n\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandDaemonize(cmd);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virPidFileRead(driver->pidDir, radvdpidbase, &radvdPid) < 0)\n        goto cleanup;\n    virNetworkObjSetRadvdPid(obj, radvdPid);\n\n    ret = 0;\n cleanup:\n    virObjectUnref(dnsmasq_caps);\n    virCommandFree(cmd);\n    VIR_FREE(configfile);\n    VIR_FREE(radvdpidbase);\n    VIR_FREE(pidfile);\n    return ret;\n}"
  },
  {
    "function_name": "networkRadvdConfWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "1929-1968",
    "snippet": "static int\nnetworkRadvdConfWrite(virNetworkDriverStatePtr driver,\n                      virNetworkObjPtr obj,\n                      char **configFile)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n    char *configStr = NULL;\n    char *myConfigFile = NULL;\n\n    if (!configFile)\n        configFile = &myConfigFile;\n\n    *configFile = NULL;\n\n    if (networkRadvdConfContents(obj, &configStr) < 0)\n        goto cleanup;\n\n    if (!configStr) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* construct the filename */\n    if (!(*configFile = networkRadvdConfigFileName(driver, def->name)))\n        goto cleanup;\n    /* write the file */\n    if (virFileWriteStr(*configFile, configStr, 0600) < 0) {\n        virReportSystemError(errno,\n                             _(\"couldn't write radvd config file '%s'\"),\n                             *configFile);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(configStr);\n    VIR_FREE(myConfigFile);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "myConfigFile"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "configStr"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"couldn't write radvd config file '%s'\")",
            "*configFile"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"couldn't write radvd config file '%s'\""
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "*configFile",
            "configStr",
            "0600"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRadvdConfigFileName",
          "args": [
            "driver",
            "def->name"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "networkRadvdConfigFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "411-419",
          "snippet": "static char *\nnetworkRadvdConfigFileName(virNetworkDriverStatePtr driver,\n                           const char *netname)\n{\n    char *configfile;\n\n    configfile = g_strdup_printf(\"%s/%s-radvd.conf\", driver->radvdStateDir, netname);\n    return configfile;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic char *\nnetworkRadvdConfigFileName(virNetworkDriverStatePtr driver,\n                           const char *netname)\n{\n    char *configfile;\n\n    configfile = g_strdup_printf(\"%s/%s-radvd.conf\", driver->radvdStateDir, netname);\n    return configfile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRadvdConfContents",
          "args": [
            "obj",
            "&configStr"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "networkRadvdConfContents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1854-1925",
          "snippet": "static int\nnetworkRadvdConfContents(virNetworkObjPtr obj,\n                         char **configstr)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBuffer configbuf = VIR_BUFFER_INITIALIZER;\n    int ret = -1;\n    size_t i;\n    virNetworkIPDefPtr ipdef;\n    bool v6present = false, dhcp6 = false;\n\n    *configstr = NULL;\n\n    /* Check if DHCPv6 is needed */\n    for (i = 0; (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i)); i++) {\n        v6present = true;\n        if (ipdef->nranges || ipdef->nhosts) {\n            dhcp6 = true;\n            break;\n        }\n    }\n\n    /* If there are no IPv6 addresses, then we are done */\n    if (!v6present) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* create radvd config file appropriate for this network;\n     * IgnoreIfMissing allows radvd to start even when the bridge is down\n     */\n    virBufferAsprintf(&configbuf, \"interface %s\\n\"\n                      \"{\\n\"\n                      \"  AdvSendAdvert on;\\n\"\n                      \"  IgnoreIfMissing on;\\n\"\n                      \"  AdvManagedFlag %s;\\n\"\n                      \"%s\",\n                      def->bridge,\n                      dhcp6 ? \"on\" : \"off\",\n                      dhcp6 ? \"\\n\" : radvd1);\n\n    /* add a section for each IPv6 address in the config */\n    for (i = 0; (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i)); i++) {\n        int prefix;\n        char *netaddr;\n\n        prefix = virNetworkIPDefPrefix(ipdef);\n        if (prefix < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bridge '%s' has an invalid prefix\"),\n                           def->bridge);\n            goto cleanup;\n        }\n        if (!(netaddr = virSocketAddrFormat(&ipdef->address)))\n            goto cleanup;\n        virBufferAsprintf(&configbuf,\n                          \"  prefix %s/%d\\n\"\n                          \"  {\\n%s  };\\n\",\n                          netaddr, prefix,\n                          dhcp6 ? radvd2 : radvd3);\n        VIR_FREE(netaddr);\n    }\n\n    virBufferAddLit(&configbuf, \"};\\n\");\n\n    *configstr = virBufferContentAndReset(&configbuf);\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&configbuf);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static char radvd1[] = \"  AdvOtherConfigFlag off;\\n\\n\";",
            "static char radvd2[] = \"    AdvAutonomous off;\\n\";",
            "static char radvd3[] = \"    AdvOnLink on;\\n\"\n                       \"    AdvAutonomous on;\\n\"\n                       \"    AdvRouterAddr off;\\n\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic char radvd1[] = \"  AdvOtherConfigFlag off;\\n\\n\";\nstatic char radvd2[] = \"    AdvAutonomous off;\\n\";\nstatic char radvd3[] = \"    AdvOnLink on;\\n\"\n                       \"    AdvAutonomous on;\\n\"\n                       \"    AdvRouterAddr off;\\n\";\n\nstatic int\nnetworkRadvdConfContents(virNetworkObjPtr obj,\n                         char **configstr)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBuffer configbuf = VIR_BUFFER_INITIALIZER;\n    int ret = -1;\n    size_t i;\n    virNetworkIPDefPtr ipdef;\n    bool v6present = false, dhcp6 = false;\n\n    *configstr = NULL;\n\n    /* Check if DHCPv6 is needed */\n    for (i = 0; (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i)); i++) {\n        v6present = true;\n        if (ipdef->nranges || ipdef->nhosts) {\n            dhcp6 = true;\n            break;\n        }\n    }\n\n    /* If there are no IPv6 addresses, then we are done */\n    if (!v6present) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* create radvd config file appropriate for this network;\n     * IgnoreIfMissing allows radvd to start even when the bridge is down\n     */\n    virBufferAsprintf(&configbuf, \"interface %s\\n\"\n                      \"{\\n\"\n                      \"  AdvSendAdvert on;\\n\"\n                      \"  IgnoreIfMissing on;\\n\"\n                      \"  AdvManagedFlag %s;\\n\"\n                      \"%s\",\n                      def->bridge,\n                      dhcp6 ? \"on\" : \"off\",\n                      dhcp6 ? \"\\n\" : radvd1);\n\n    /* add a section for each IPv6 address in the config */\n    for (i = 0; (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i)); i++) {\n        int prefix;\n        char *netaddr;\n\n        prefix = virNetworkIPDefPrefix(ipdef);\n        if (prefix < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bridge '%s' has an invalid prefix\"),\n                           def->bridge);\n            goto cleanup;\n        }\n        if (!(netaddr = virSocketAddrFormat(&ipdef->address)))\n            goto cleanup;\n        virBufferAsprintf(&configbuf,\n                          \"  prefix %s/%d\\n\"\n                          \"  {\\n%s  };\\n\",\n                          netaddr, prefix,\n                          dhcp6 ? radvd2 : radvd3);\n        VIR_FREE(netaddr);\n    }\n\n    virBufferAddLit(&configbuf, \"};\\n\");\n\n    *configstr = virBufferContentAndReset(&configbuf);\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&configbuf);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRadvdConfWrite(virNetworkDriverStatePtr driver,\n                      virNetworkObjPtr obj,\n                      char **configFile)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n    char *configStr = NULL;\n    char *myConfigFile = NULL;\n\n    if (!configFile)\n        configFile = &myConfigFile;\n\n    *configFile = NULL;\n\n    if (networkRadvdConfContents(obj, &configStr) < 0)\n        goto cleanup;\n\n    if (!configStr) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* construct the filename */\n    if (!(*configFile = networkRadvdConfigFileName(driver, def->name)))\n        goto cleanup;\n    /* write the file */\n    if (virFileWriteStr(*configFile, configStr, 0600) < 0) {\n        virReportSystemError(errno,\n                             _(\"couldn't write radvd config file '%s'\"),\n                             *configFile);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(configStr);\n    VIR_FREE(myConfigFile);\n    return ret;\n}"
  },
  {
    "function_name": "networkRadvdConfContents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "1854-1925",
    "snippet": "static int\nnetworkRadvdConfContents(virNetworkObjPtr obj,\n                         char **configstr)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBuffer configbuf = VIR_BUFFER_INITIALIZER;\n    int ret = -1;\n    size_t i;\n    virNetworkIPDefPtr ipdef;\n    bool v6present = false, dhcp6 = false;\n\n    *configstr = NULL;\n\n    /* Check if DHCPv6 is needed */\n    for (i = 0; (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i)); i++) {\n        v6present = true;\n        if (ipdef->nranges || ipdef->nhosts) {\n            dhcp6 = true;\n            break;\n        }\n    }\n\n    /* If there are no IPv6 addresses, then we are done */\n    if (!v6present) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* create radvd config file appropriate for this network;\n     * IgnoreIfMissing allows radvd to start even when the bridge is down\n     */\n    virBufferAsprintf(&configbuf, \"interface %s\\n\"\n                      \"{\\n\"\n                      \"  AdvSendAdvert on;\\n\"\n                      \"  IgnoreIfMissing on;\\n\"\n                      \"  AdvManagedFlag %s;\\n\"\n                      \"%s\",\n                      def->bridge,\n                      dhcp6 ? \"on\" : \"off\",\n                      dhcp6 ? \"\\n\" : radvd1);\n\n    /* add a section for each IPv6 address in the config */\n    for (i = 0; (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i)); i++) {\n        int prefix;\n        char *netaddr;\n\n        prefix = virNetworkIPDefPrefix(ipdef);\n        if (prefix < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bridge '%s' has an invalid prefix\"),\n                           def->bridge);\n            goto cleanup;\n        }\n        if (!(netaddr = virSocketAddrFormat(&ipdef->address)))\n            goto cleanup;\n        virBufferAsprintf(&configbuf,\n                          \"  prefix %s/%d\\n\"\n                          \"  {\\n%s  };\\n\",\n                          netaddr, prefix,\n                          dhcp6 ? radvd2 : radvd3);\n        VIR_FREE(netaddr);\n    }\n\n    virBufferAddLit(&configbuf, \"};\\n\");\n\n    *configstr = virBufferContentAndReset(&configbuf);\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&configbuf);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static char radvd1[] = \"  AdvOtherConfigFlag off;\\n\\n\";",
      "static char radvd2[] = \"    AdvAutonomous off;\\n\";",
      "static char radvd3[] = \"    AdvOnLink on;\\n\"\n                       \"    AdvAutonomous on;\\n\"\n                       \"    AdvRouterAddr off;\\n\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&configbuf"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&configbuf"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"};\\n\""
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "netaddr"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&configbuf",
            "\"  prefix %s/%d\\n\"\n                          \"  {\\n%s  };\\n\"",
            "netaddr",
            "prefix",
            "dhcp6 ? radvd2 : radvd3"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&ipdef->address"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"bridge '%s' has an invalid prefix\")",
            "def->bridge"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"bridge '%s' has an invalid prefix\""
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefPrefix",
          "args": [
            "ipdef"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "367-373",
          "snippet": "int\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET6",
            "i"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic char radvd1[] = \"  AdvOtherConfigFlag off;\\n\\n\";\nstatic char radvd2[] = \"    AdvAutonomous off;\\n\";\nstatic char radvd3[] = \"    AdvOnLink on;\\n\"\n                       \"    AdvAutonomous on;\\n\"\n                       \"    AdvRouterAddr off;\\n\";\n\nstatic int\nnetworkRadvdConfContents(virNetworkObjPtr obj,\n                         char **configstr)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBuffer configbuf = VIR_BUFFER_INITIALIZER;\n    int ret = -1;\n    size_t i;\n    virNetworkIPDefPtr ipdef;\n    bool v6present = false, dhcp6 = false;\n\n    *configstr = NULL;\n\n    /* Check if DHCPv6 is needed */\n    for (i = 0; (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i)); i++) {\n        v6present = true;\n        if (ipdef->nranges || ipdef->nhosts) {\n            dhcp6 = true;\n            break;\n        }\n    }\n\n    /* If there are no IPv6 addresses, then we are done */\n    if (!v6present) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* create radvd config file appropriate for this network;\n     * IgnoreIfMissing allows radvd to start even when the bridge is down\n     */\n    virBufferAsprintf(&configbuf, \"interface %s\\n\"\n                      \"{\\n\"\n                      \"  AdvSendAdvert on;\\n\"\n                      \"  IgnoreIfMissing on;\\n\"\n                      \"  AdvManagedFlag %s;\\n\"\n                      \"%s\",\n                      def->bridge,\n                      dhcp6 ? \"on\" : \"off\",\n                      dhcp6 ? \"\\n\" : radvd1);\n\n    /* add a section for each IPv6 address in the config */\n    for (i = 0; (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i)); i++) {\n        int prefix;\n        char *netaddr;\n\n        prefix = virNetworkIPDefPrefix(ipdef);\n        if (prefix < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bridge '%s' has an invalid prefix\"),\n                           def->bridge);\n            goto cleanup;\n        }\n        if (!(netaddr = virSocketAddrFormat(&ipdef->address)))\n            goto cleanup;\n        virBufferAsprintf(&configbuf,\n                          \"  prefix %s/%d\\n\"\n                          \"  {\\n%s  };\\n\",\n                          netaddr, prefix,\n                          dhcp6 ? radvd2 : radvd3);\n        VIR_FREE(netaddr);\n    }\n\n    virBufferAddLit(&configbuf, \"};\\n\");\n\n    *configstr = virBufferContentAndReset(&configbuf);\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&configbuf);\n    return ret;\n}"
  },
  {
    "function_name": "networkRestartDhcpDaemon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "1831-1845",
    "snippet": "static int\nnetworkRestartDhcpDaemon(virNetworkDriverStatePtr driver,\n                         virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    pid_t dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n\n    /* if there is a running dnsmasq, kill it */\n    if (dnsmasqPid > 0) {\n        networkKillDaemon(dnsmasqPid, \"dnsmasq\", def->name);\n        virNetworkObjSetDnsmasqPid(obj, -1);\n    }\n    /* now start dnsmasq if it should be started */\n    return networkStartDhcpDaemon(driver, obj);\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkStartDhcpDaemon",
          "args": [
            "driver",
            "obj"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "networkStartDhcpDaemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1659-1748",
          "snippet": "static int\nnetworkStartDhcpDaemon(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetworkIPDefPtr ipdef;\n    size_t i;\n    bool needDnsmasq = false;\n    virCommandPtr cmd = NULL;\n    char *pidfile = NULL;\n    pid_t dnsmasqPid;\n    int ret = -1;\n    dnsmasqContext *dctx = NULL;\n\n    /* see if there are any IP addresses that need a dhcp server */\n    i = 0;\n    while ((ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i))) {\n        i++;\n        if (ipdef->nranges || ipdef->nhosts)\n            needDnsmasq = true;\n    }\n\n    if (i == 0) {\n        /* no IP addresses at all, so we don't need to run */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!needDnsmasq && def->dns.enable == VIR_TRISTATE_BOOL_NO) {\n        /* no DHCP services needed, and user disabled DNS service */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileMakePath(driver->pidDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->pidDir);\n        goto cleanup;\n    }\n\n    if (!(pidfile = virPidFileBuildPath(driver->pidDir, def->name)))\n        goto cleanup;\n\n    if (virFileMakePath(driver->dnsmasqStateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->dnsmasqStateDir);\n        goto cleanup;\n    }\n\n    dctx = dnsmasqContextNew(def->name, driver->dnsmasqStateDir);\n    if (dctx == NULL)\n        goto cleanup;\n\n    if (networkDnsmasqCapsRefresh(driver) < 0)\n        goto cleanup;\n\n    ret = networkBuildDhcpDaemonCommandLine(driver, obj, &cmd, pidfile, dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = dnsmasqSave(dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0)\n        goto cleanup;\n\n    /*\n     * There really is no race here - when dnsmasq daemonizes, its\n     * leader process stays around until its child has actually\n     * written its pidfile. So by time virCommandRun exits it has\n     * waitpid'd and guaranteed the proess has started and written a\n     * pid\n     */\n\n    ret = virPidFileRead(driver->pidDir, def->name, &dnsmasqPid);\n    if (ret < 0)\n        goto cleanup;\n    virNetworkObjSetDnsmasqPid(obj, dnsmasqPid);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pidfile);\n    virCommandFree(cmd);\n    dnsmasqContextFree(dctx);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStartDhcpDaemon(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetworkIPDefPtr ipdef;\n    size_t i;\n    bool needDnsmasq = false;\n    virCommandPtr cmd = NULL;\n    char *pidfile = NULL;\n    pid_t dnsmasqPid;\n    int ret = -1;\n    dnsmasqContext *dctx = NULL;\n\n    /* see if there are any IP addresses that need a dhcp server */\n    i = 0;\n    while ((ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i))) {\n        i++;\n        if (ipdef->nranges || ipdef->nhosts)\n            needDnsmasq = true;\n    }\n\n    if (i == 0) {\n        /* no IP addresses at all, so we don't need to run */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!needDnsmasq && def->dns.enable == VIR_TRISTATE_BOOL_NO) {\n        /* no DHCP services needed, and user disabled DNS service */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileMakePath(driver->pidDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->pidDir);\n        goto cleanup;\n    }\n\n    if (!(pidfile = virPidFileBuildPath(driver->pidDir, def->name)))\n        goto cleanup;\n\n    if (virFileMakePath(driver->dnsmasqStateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->dnsmasqStateDir);\n        goto cleanup;\n    }\n\n    dctx = dnsmasqContextNew(def->name, driver->dnsmasqStateDir);\n    if (dctx == NULL)\n        goto cleanup;\n\n    if (networkDnsmasqCapsRefresh(driver) < 0)\n        goto cleanup;\n\n    ret = networkBuildDhcpDaemonCommandLine(driver, obj, &cmd, pidfile, dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = dnsmasqSave(dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0)\n        goto cleanup;\n\n    /*\n     * There really is no race here - when dnsmasq daemonizes, its\n     * leader process stays around until its child has actually\n     * written its pidfile. So by time virCommandRun exits it has\n     * waitpid'd and guaranteed the proess has started and written a\n     * pid\n     */\n\n    ret = virPidFileRead(driver->pidDir, def->name, &dnsmasqPid);\n    if (ret < 0)\n        goto cleanup;\n    virNetworkObjSetDnsmasqPid(obj, dnsmasqPid);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pidfile);\n    virCommandFree(cmd);\n    dnsmasqContextFree(dctx);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetDnsmasqPid",
          "args": [
            "obj",
            "-1"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetDnsmasqPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "214-219",
          "snippet": "void\nvirNetworkObjSetDnsmasqPid(virNetworkObjPtr obj,\n                           pid_t dnsmasqPid)\n{\n    obj->dnsmasqPid = dnsmasqPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetDnsmasqPid(virNetworkObjPtr obj,\n                           pid_t dnsmasqPid)\n{\n    obj->dnsmasqPid = dnsmasqPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkKillDaemon",
          "args": [
            "dnsmasqPid",
            "\"dnsmasq\"",
            "def->name"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "networkKillDaemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "973-1027",
          "snippet": "static int\nnetworkKillDaemon(pid_t pid,\n                  const char *daemonName,\n                  const char *networkName)\n{\n    size_t i;\n    int ret = -1;\n    const char *signame = \"TERM\";\n\n    /* send SIGTERM, then wait up to 3 seconds for the process to\n     * disappear, send SIGKILL, then wait for up to another 2\n     * seconds. If that fails, log a warning and continue, hoping\n     * for the best.\n     */\n    for (i = 0; i < 25; i++) {\n        int signum = 0;\n        if (i == 0) {\n            signum = SIGTERM;\n        } else if (i == 15) {\n            signum = SIGKILL;\n            signame = \"KILL\";\n        }\n        if (kill(pid, signum) < 0) {\n            if (errno == ESRCH) {\n                ret = 0;\n            } else {\n                VIR_WARN(\"Failed to terminate %s process %d \"\n                         \"for network '%s' with SIG%s: %s\",\n                         daemonName, pid, networkName, signame,\n                         g_strerror(errno));\n            }\n            return ret;\n        }\n        /* NB: since networks have no reference count like\n         * domains, there is no safe way to unlock the network\n         * object temporarily, and so we can't follow the\n         * procedure used by the qemu driver of 1) unlock driver\n         * 2) sleep, 3) add ref to object 4) unlock object, 5)\n         * re-lock driver, 6) re-lock object. We may need to add\n         * that functionality eventually, but for now this\n         * function is rarely used and, at worst, leaving the\n         * network driver locked during this loop of sleeps will\n         * have the effect of holding up any other thread trying\n         * to make modifications to a network for up to 5 seconds;\n         * since modifications to networks are much less common\n         * than modifications to domains, this seems a reasonable\n         * tradeoff in exchange for less code disruption.\n         */\n        g_usleep(20 * 1000);\n    }\n    VIR_WARN(\"Timed out waiting after SIG%s to %s process %d \"\n             \"(network '%s')\",\n             signame, daemonName, pid, networkName);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkKillDaemon(pid_t pid,\n                  const char *daemonName,\n                  const char *networkName)\n{\n    size_t i;\n    int ret = -1;\n    const char *signame = \"TERM\";\n\n    /* send SIGTERM, then wait up to 3 seconds for the process to\n     * disappear, send SIGKILL, then wait for up to another 2\n     * seconds. If that fails, log a warning and continue, hoping\n     * for the best.\n     */\n    for (i = 0; i < 25; i++) {\n        int signum = 0;\n        if (i == 0) {\n            signum = SIGTERM;\n        } else if (i == 15) {\n            signum = SIGKILL;\n            signame = \"KILL\";\n        }\n        if (kill(pid, signum) < 0) {\n            if (errno == ESRCH) {\n                ret = 0;\n            } else {\n                VIR_WARN(\"Failed to terminate %s process %d \"\n                         \"for network '%s' with SIG%s: %s\",\n                         daemonName, pid, networkName, signame,\n                         g_strerror(errno));\n            }\n            return ret;\n        }\n        /* NB: since networks have no reference count like\n         * domains, there is no safe way to unlock the network\n         * object temporarily, and so we can't follow the\n         * procedure used by the qemu driver of 1) unlock driver\n         * 2) sleep, 3) add ref to object 4) unlock object, 5)\n         * re-lock driver, 6) re-lock object. We may need to add\n         * that functionality eventually, but for now this\n         * function is rarely used and, at worst, leaving the\n         * network driver locked during this loop of sleeps will\n         * have the effect of holding up any other thread trying\n         * to make modifications to a network for up to 5 seconds;\n         * since modifications to networks are much less common\n         * than modifications to domains, this seems a reasonable\n         * tradeoff in exchange for less code disruption.\n         */\n        g_usleep(20 * 1000);\n    }\n    VIR_WARN(\"Timed out waiting after SIG%s to %s process %d \"\n             \"(network '%s')\",\n             signame, daemonName, pid, networkName);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDnsmasqPid",
          "args": [
            "obj"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDnsmasqPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "207-211",
          "snippet": "pid_t\nvirNetworkObjGetDnsmasqPid(virNetworkObjPtr obj)\n{\n    return obj->dnsmasqPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\npid_t\nvirNetworkObjGetDnsmasqPid(virNetworkObjPtr obj)\n{\n    return obj->dnsmasqPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRestartDhcpDaemon(virNetworkDriverStatePtr driver,\n                         virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    pid_t dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n\n    /* if there is a running dnsmasq, kill it */\n    if (dnsmasqPid > 0) {\n        networkKillDaemon(dnsmasqPid, \"dnsmasq\", def->name);\n        virNetworkObjSetDnsmasqPid(obj, -1);\n    }\n    /* now start dnsmasq if it should be started */\n    return networkStartDhcpDaemon(driver, obj);\n}"
  },
  {
    "function_name": "networkRefreshDhcpDaemon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "1758-1821",
    "snippet": "static int\nnetworkRefreshDhcpDaemon(virNetworkDriverStatePtr driver,\n                         virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n    size_t i;\n    pid_t dnsmasqPid;\n    virNetworkIPDefPtr ipdef, ipv4def, ipv6def;\n    dnsmasqContext *dctx = NULL;\n\n    /* if no IP addresses specified, nothing to do */\n    if (!virNetworkDefGetIPByIndex(def, AF_UNSPEC, 0))\n        return 0;\n\n    /* if there's no running dnsmasq, just start it */\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    if (dnsmasqPid <= 0 || (kill(dnsmasqPid, 0) < 0))\n        return networkStartDhcpDaemon(driver, obj);\n\n    VIR_INFO(\"Refreshing dnsmasq for network %s\", def->bridge);\n    if (!(dctx = dnsmasqContextNew(def->name,\n                                   driver->dnsmasqStateDir))) {\n        goto cleanup;\n    }\n\n    /* Look for first IPv4 address that has dhcp defined.\n     * We only support dhcp-host config on one IPv4 subnetwork\n     * and on one IPv6 subnetwork.\n     */\n    ipv4def = NULL;\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (!ipv4def && (ipdef->nranges || ipdef->nhosts))\n            ipv4def = ipdef;\n    }\n\n    ipv6def = NULL;\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i));\n         i++) {\n        if (!ipv6def && (ipdef->nranges || ipdef->nhosts))\n            ipv6def = ipdef;\n    }\n\n    if (ipv4def && (networkBuildDnsmasqDhcpHostsList(dctx, ipv4def) < 0))\n        goto cleanup;\n\n    if (ipv6def && (networkBuildDnsmasqDhcpHostsList(dctx, ipv6def) < 0))\n        goto cleanup;\n\n    if (networkBuildDnsmasqHostsList(dctx, &def->dns) < 0)\n        goto cleanup;\n\n    if ((ret = dnsmasqSave(dctx)) < 0)\n        goto cleanup;\n\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    ret = kill(dnsmasqPid, SIGHUP);\n cleanup:\n    dnsmasqContextFree(dctx);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnsmasqContextFree",
          "args": [
            "dctx"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqContextFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "473-487",
          "snippet": "void\ndnsmasqContextFree(dnsmasqContext *ctx)\n{\n    if (!ctx)\n        return;\n\n    VIR_FREE(ctx->config_dir);\n\n    if (ctx->hostsfile)\n        hostsfileFree(ctx->hostsfile);\n    if (ctx->addnhostsfile)\n        addnhostsFree(ctx->addnhostsfile);\n\n    VIR_FREE(ctx);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\ndnsmasqContextFree(dnsmasqContext *ctx)\n{\n    if (!ctx)\n        return;\n\n    VIR_FREE(ctx->config_dir);\n\n    if (ctx->hostsfile)\n        hostsfileFree(ctx->hostsfile);\n    if (ctx->addnhostsfile)\n        addnhostsFree(ctx->addnhostsfile);\n\n    VIR_FREE(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "dnsmasqPid",
            "SIGHUP"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDnsmasqPid",
          "args": [
            "obj"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDnsmasqPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "207-211",
          "snippet": "pid_t\nvirNetworkObjGetDnsmasqPid(virNetworkObjPtr obj)\n{\n    return obj->dnsmasqPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\npid_t\nvirNetworkObjGetDnsmasqPid(virNetworkObjPtr obj)\n{\n    return obj->dnsmasqPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnsmasqSave",
          "args": [
            "dctx"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "532-551",
          "snippet": "int\ndnsmasqSave(const dnsmasqContext *ctx)\n{\n    int ret = 0;\n\n    if (virFileMakePath(ctx->config_dir) < 0) {\n        virReportSystemError(errno, _(\"cannot create config directory '%s'\"),\n                             ctx->config_dir);\n        return -1;\n    }\n\n    if (ctx->hostsfile)\n        ret = hostsfileSave(ctx->hostsfile);\n    if (ret == 0) {\n        if (ctx->addnhostsfile)\n            ret = addnhostsSave(ctx->addnhostsfile);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\ndnsmasqSave(const dnsmasqContext *ctx)\n{\n    int ret = 0;\n\n    if (virFileMakePath(ctx->config_dir) < 0) {\n        virReportSystemError(errno, _(\"cannot create config directory '%s'\"),\n                             ctx->config_dir);\n        return -1;\n    }\n\n    if (ctx->hostsfile)\n        ret = hostsfileSave(ctx->hostsfile);\n    if (ret == 0) {\n        if (ctx->addnhostsfile)\n            ret = addnhostsSave(ctx->addnhostsfile);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkBuildDnsmasqHostsList",
          "args": [
            "dctx",
            "&def->dns"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "networkBuildDnsmasqHostsList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1054-1072",
          "snippet": "static int\nnetworkBuildDnsmasqHostsList(dnsmasqContext *dctx,\n                             virNetworkDNSDefPtr dnsdef)\n{\n    size_t i, j;\n\n    if (dnsdef) {\n        for (i = 0; i < dnsdef->nhosts; i++) {\n            virNetworkDNSHostDefPtr host = &(dnsdef->hosts[i]);\n            if (VIR_SOCKET_ADDR_VALID(&host->ip)) {\n                for (j = 0; j < host->nnames; j++)\n                    if (dnsmasqAddHost(dctx, &host->ip, host->names[j]) < 0)\n                        return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkBuildDnsmasqHostsList(dnsmasqContext *dctx,\n                             virNetworkDNSDefPtr dnsdef)\n{\n    size_t i, j;\n\n    if (dnsdef) {\n        for (i = 0; i < dnsdef->nhosts; i++) {\n            virNetworkDNSHostDefPtr host = &(dnsdef->hosts[i]);\n            if (VIR_SOCKET_ADDR_VALID(&host->ip)) {\n                for (j = 0; j < host->nnames; j++)\n                    if (dnsmasqAddHost(dctx, &host->ip, host->names[j]) < 0)\n                        return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkBuildDnsmasqDhcpHostsList",
          "args": [
            "dctx",
            "ipv6def"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "networkBuildDnsmasqDhcpHostsList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1033-1051",
          "snippet": "static int\nnetworkBuildDnsmasqDhcpHostsList(dnsmasqContext *dctx,\n                                 virNetworkIPDefPtr ipdef)\n{\n    size_t i;\n    bool ipv6 = false;\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n        ipv6 = true;\n    for (i = 0; i < ipdef->nhosts; i++) {\n        virNetworkDHCPHostDefPtr host = &(ipdef->hosts[i]);\n        if (VIR_SOCKET_ADDR_VALID(&host->ip))\n            if (dnsmasqAddDhcpHost(dctx, host->mac, &host->ip,\n                                   host->name, host->id, ipv6) < 0)\n                return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkBuildDnsmasqDhcpHostsList(dnsmasqContext *dctx,\n                                 virNetworkIPDefPtr ipdef)\n{\n    size_t i;\n    bool ipv6 = false;\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n        ipv6 = true;\n    for (i = 0; i < ipdef->nhosts; i++) {\n        virNetworkDHCPHostDefPtr host = &(ipdef->hosts[i]);\n        if (VIR_SOCKET_ADDR_VALID(&host->ip))\n            if (dnsmasqAddDhcpHost(dctx, host->mac, &host->ip,\n                                   host->name, host->id, ipv6) < 0)\n                return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET6",
            "i"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnsmasqContextNew",
          "args": [
            "def->name",
            "driver->dnsmasqStateDir"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "444-465",
          "snippet": "dnsmasqContext *\ndnsmasqContextNew(const char *network_name,\n                  const char *config_dir)\n{\n    dnsmasqContext *ctx;\n\n    if (VIR_ALLOC(ctx) < 0)\n        return NULL;\n\n    ctx->config_dir = g_strdup(config_dir);\n\n    if (!(ctx->hostsfile = hostsfileNew(network_name, config_dir)))\n        goto error;\n    if (!(ctx->addnhostsfile = addnhostsNew(network_name, config_dir)))\n        goto error;\n\n    return ctx;\n\n error:\n    dnsmasqContextFree(ctx);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\ndnsmasqContext *\ndnsmasqContextNew(const char *network_name,\n                  const char *config_dir)\n{\n    dnsmasqContext *ctx;\n\n    if (VIR_ALLOC(ctx) < 0)\n        return NULL;\n\n    ctx->config_dir = g_strdup(config_dir);\n\n    if (!(ctx->hostsfile = hostsfileNew(network_name, config_dir)))\n        goto error;\n    if (!(ctx->addnhostsfile = addnhostsNew(network_name, config_dir)))\n        goto error;\n\n    return ctx;\n\n error:\n    dnsmasqContextFree(ctx);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Refreshing dnsmasq for network %s\"",
            "def->bridge"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkStartDhcpDaemon",
          "args": [
            "driver",
            "obj"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "networkStartDhcpDaemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1659-1748",
          "snippet": "static int\nnetworkStartDhcpDaemon(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetworkIPDefPtr ipdef;\n    size_t i;\n    bool needDnsmasq = false;\n    virCommandPtr cmd = NULL;\n    char *pidfile = NULL;\n    pid_t dnsmasqPid;\n    int ret = -1;\n    dnsmasqContext *dctx = NULL;\n\n    /* see if there are any IP addresses that need a dhcp server */\n    i = 0;\n    while ((ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i))) {\n        i++;\n        if (ipdef->nranges || ipdef->nhosts)\n            needDnsmasq = true;\n    }\n\n    if (i == 0) {\n        /* no IP addresses at all, so we don't need to run */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!needDnsmasq && def->dns.enable == VIR_TRISTATE_BOOL_NO) {\n        /* no DHCP services needed, and user disabled DNS service */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileMakePath(driver->pidDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->pidDir);\n        goto cleanup;\n    }\n\n    if (!(pidfile = virPidFileBuildPath(driver->pidDir, def->name)))\n        goto cleanup;\n\n    if (virFileMakePath(driver->dnsmasqStateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->dnsmasqStateDir);\n        goto cleanup;\n    }\n\n    dctx = dnsmasqContextNew(def->name, driver->dnsmasqStateDir);\n    if (dctx == NULL)\n        goto cleanup;\n\n    if (networkDnsmasqCapsRefresh(driver) < 0)\n        goto cleanup;\n\n    ret = networkBuildDhcpDaemonCommandLine(driver, obj, &cmd, pidfile, dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = dnsmasqSave(dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0)\n        goto cleanup;\n\n    /*\n     * There really is no race here - when dnsmasq daemonizes, its\n     * leader process stays around until its child has actually\n     * written its pidfile. So by time virCommandRun exits it has\n     * waitpid'd and guaranteed the proess has started and written a\n     * pid\n     */\n\n    ret = virPidFileRead(driver->pidDir, def->name, &dnsmasqPid);\n    if (ret < 0)\n        goto cleanup;\n    virNetworkObjSetDnsmasqPid(obj, dnsmasqPid);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pidfile);\n    virCommandFree(cmd);\n    dnsmasqContextFree(dctx);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStartDhcpDaemon(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetworkIPDefPtr ipdef;\n    size_t i;\n    bool needDnsmasq = false;\n    virCommandPtr cmd = NULL;\n    char *pidfile = NULL;\n    pid_t dnsmasqPid;\n    int ret = -1;\n    dnsmasqContext *dctx = NULL;\n\n    /* see if there are any IP addresses that need a dhcp server */\n    i = 0;\n    while ((ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i))) {\n        i++;\n        if (ipdef->nranges || ipdef->nhosts)\n            needDnsmasq = true;\n    }\n\n    if (i == 0) {\n        /* no IP addresses at all, so we don't need to run */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!needDnsmasq && def->dns.enable == VIR_TRISTATE_BOOL_NO) {\n        /* no DHCP services needed, and user disabled DNS service */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileMakePath(driver->pidDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->pidDir);\n        goto cleanup;\n    }\n\n    if (!(pidfile = virPidFileBuildPath(driver->pidDir, def->name)))\n        goto cleanup;\n\n    if (virFileMakePath(driver->dnsmasqStateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->dnsmasqStateDir);\n        goto cleanup;\n    }\n\n    dctx = dnsmasqContextNew(def->name, driver->dnsmasqStateDir);\n    if (dctx == NULL)\n        goto cleanup;\n\n    if (networkDnsmasqCapsRefresh(driver) < 0)\n        goto cleanup;\n\n    ret = networkBuildDhcpDaemonCommandLine(driver, obj, &cmd, pidfile, dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = dnsmasqSave(dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0)\n        goto cleanup;\n\n    /*\n     * There really is no race here - when dnsmasq daemonizes, its\n     * leader process stays around until its child has actually\n     * written its pidfile. So by time virCommandRun exits it has\n     * waitpid'd and guaranteed the proess has started and written a\n     * pid\n     */\n\n    ret = virPidFileRead(driver->pidDir, def->name, &dnsmasqPid);\n    if (ret < 0)\n        goto cleanup;\n    virNetworkObjSetDnsmasqPid(obj, dnsmasqPid);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pidfile);\n    virCommandFree(cmd);\n    dnsmasqContextFree(dctx);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "dnsmasqPid",
            "0"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRefreshDhcpDaemon(virNetworkDriverStatePtr driver,\n                         virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n    size_t i;\n    pid_t dnsmasqPid;\n    virNetworkIPDefPtr ipdef, ipv4def, ipv6def;\n    dnsmasqContext *dctx = NULL;\n\n    /* if no IP addresses specified, nothing to do */\n    if (!virNetworkDefGetIPByIndex(def, AF_UNSPEC, 0))\n        return 0;\n\n    /* if there's no running dnsmasq, just start it */\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    if (dnsmasqPid <= 0 || (kill(dnsmasqPid, 0) < 0))\n        return networkStartDhcpDaemon(driver, obj);\n\n    VIR_INFO(\"Refreshing dnsmasq for network %s\", def->bridge);\n    if (!(dctx = dnsmasqContextNew(def->name,\n                                   driver->dnsmasqStateDir))) {\n        goto cleanup;\n    }\n\n    /* Look for first IPv4 address that has dhcp defined.\n     * We only support dhcp-host config on one IPv4 subnetwork\n     * and on one IPv6 subnetwork.\n     */\n    ipv4def = NULL;\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_INET, i));\n         i++) {\n        if (!ipv4def && (ipdef->nranges || ipdef->nhosts))\n            ipv4def = ipdef;\n    }\n\n    ipv6def = NULL;\n    for (i = 0;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i));\n         i++) {\n        if (!ipv6def && (ipdef->nranges || ipdef->nhosts))\n            ipv6def = ipdef;\n    }\n\n    if (ipv4def && (networkBuildDnsmasqDhcpHostsList(dctx, ipv4def) < 0))\n        goto cleanup;\n\n    if (ipv6def && (networkBuildDnsmasqDhcpHostsList(dctx, ipv6def) < 0))\n        goto cleanup;\n\n    if (networkBuildDnsmasqHostsList(dctx, &def->dns) < 0)\n        goto cleanup;\n\n    if ((ret = dnsmasqSave(dctx)) < 0)\n        goto cleanup;\n\n    dnsmasqPid = virNetworkObjGetDnsmasqPid(obj);\n    ret = kill(dnsmasqPid, SIGHUP);\n cleanup:\n    dnsmasqContextFree(dctx);\n    return ret;\n}"
  },
  {
    "function_name": "networkStartDhcpDaemon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "1659-1748",
    "snippet": "static int\nnetworkStartDhcpDaemon(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetworkIPDefPtr ipdef;\n    size_t i;\n    bool needDnsmasq = false;\n    virCommandPtr cmd = NULL;\n    char *pidfile = NULL;\n    pid_t dnsmasqPid;\n    int ret = -1;\n    dnsmasqContext *dctx = NULL;\n\n    /* see if there are any IP addresses that need a dhcp server */\n    i = 0;\n    while ((ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i))) {\n        i++;\n        if (ipdef->nranges || ipdef->nhosts)\n            needDnsmasq = true;\n    }\n\n    if (i == 0) {\n        /* no IP addresses at all, so we don't need to run */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!needDnsmasq && def->dns.enable == VIR_TRISTATE_BOOL_NO) {\n        /* no DHCP services needed, and user disabled DNS service */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileMakePath(driver->pidDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->pidDir);\n        goto cleanup;\n    }\n\n    if (!(pidfile = virPidFileBuildPath(driver->pidDir, def->name)))\n        goto cleanup;\n\n    if (virFileMakePath(driver->dnsmasqStateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->dnsmasqStateDir);\n        goto cleanup;\n    }\n\n    dctx = dnsmasqContextNew(def->name, driver->dnsmasqStateDir);\n    if (dctx == NULL)\n        goto cleanup;\n\n    if (networkDnsmasqCapsRefresh(driver) < 0)\n        goto cleanup;\n\n    ret = networkBuildDhcpDaemonCommandLine(driver, obj, &cmd, pidfile, dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = dnsmasqSave(dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0)\n        goto cleanup;\n\n    /*\n     * There really is no race here - when dnsmasq daemonizes, its\n     * leader process stays around until its child has actually\n     * written its pidfile. So by time virCommandRun exits it has\n     * waitpid'd and guaranteed the proess has started and written a\n     * pid\n     */\n\n    ret = virPidFileRead(driver->pidDir, def->name, &dnsmasqPid);\n    if (ret < 0)\n        goto cleanup;\n    virNetworkObjSetDnsmasqPid(obj, dnsmasqPid);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pidfile);\n    virCommandFree(cmd);\n    dnsmasqContextFree(dctx);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnsmasqContextFree",
          "args": [
            "dctx"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqContextFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "473-487",
          "snippet": "void\ndnsmasqContextFree(dnsmasqContext *ctx)\n{\n    if (!ctx)\n        return;\n\n    VIR_FREE(ctx->config_dir);\n\n    if (ctx->hostsfile)\n        hostsfileFree(ctx->hostsfile);\n    if (ctx->addnhostsfile)\n        addnhostsFree(ctx->addnhostsfile);\n\n    VIR_FREE(ctx);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\ndnsmasqContextFree(dnsmasqContext *ctx)\n{\n    if (!ctx)\n        return;\n\n    VIR_FREE(ctx->config_dir);\n\n    if (ctx->hostsfile)\n        hostsfileFree(ctx->hostsfile);\n    if (ctx->addnhostsfile)\n        addnhostsFree(ctx->addnhostsfile);\n\n    VIR_FREE(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pidfile"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetDnsmasqPid",
          "args": [
            "obj",
            "dnsmasqPid"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetDnsmasqPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "214-219",
          "snippet": "void\nvirNetworkObjSetDnsmasqPid(virNetworkObjPtr obj,\n                           pid_t dnsmasqPid)\n{\n    obj->dnsmasqPid = dnsmasqPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetDnsmasqPid(virNetworkObjPtr obj,\n                           pid_t dnsmasqPid)\n{\n    obj->dnsmasqPid = dnsmasqPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileRead",
          "args": [
            "driver->pidDir",
            "def->name",
            "&dnsmasqPid"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPathIfAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "187-264",
          "snippet": "int virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnsmasqSave",
          "args": [
            "dctx"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "532-551",
          "snippet": "int\ndnsmasqSave(const dnsmasqContext *ctx)\n{\n    int ret = 0;\n\n    if (virFileMakePath(ctx->config_dir) < 0) {\n        virReportSystemError(errno, _(\"cannot create config directory '%s'\"),\n                             ctx->config_dir);\n        return -1;\n    }\n\n    if (ctx->hostsfile)\n        ret = hostsfileSave(ctx->hostsfile);\n    if (ret == 0) {\n        if (ctx->addnhostsfile)\n            ret = addnhostsSave(ctx->addnhostsfile);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\ndnsmasqSave(const dnsmasqContext *ctx)\n{\n    int ret = 0;\n\n    if (virFileMakePath(ctx->config_dir) < 0) {\n        virReportSystemError(errno, _(\"cannot create config directory '%s'\"),\n                             ctx->config_dir);\n        return -1;\n    }\n\n    if (ctx->hostsfile)\n        ret = hostsfileSave(ctx->hostsfile);\n    if (ret == 0) {\n        if (ctx->addnhostsfile)\n            ret = addnhostsSave(ctx->addnhostsfile);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkBuildDhcpDaemonCommandLine",
          "args": [
            "driver",
            "obj",
            "&cmd",
            "pidfile",
            "dctx"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkDnsmasqCapsRefresh",
          "args": [
            "driver"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "networkDnsmasqCapsRefresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "126-139",
          "snippet": "static int\nnetworkDnsmasqCapsRefresh(virNetworkDriverStatePtr driver)\n{\n    dnsmasqCapsPtr caps;\n\n    if (!(caps = dnsmasqCapsNewFromBinary(DNSMASQ)))\n        return -1;\n\n    networkDriverLock(driver);\n    virObjectUnref(driver->dnsmasqCaps);\n    driver->dnsmasqCaps = caps;\n    networkDriverUnlock(driver);\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkDnsmasqCapsRefresh(virNetworkDriverStatePtr driver)\n{\n    dnsmasqCapsPtr caps;\n\n    if (!(caps = dnsmasqCapsNewFromBinary(DNSMASQ)))\n        return -1;\n\n    networkDriverLock(driver);\n    virObjectUnref(driver->dnsmasqCaps);\n    driver->dnsmasqCaps = caps;\n    networkDriverUnlock(driver);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnsmasqContextNew",
          "args": [
            "def->name",
            "driver->dnsmasqStateDir"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "444-465",
          "snippet": "dnsmasqContext *\ndnsmasqContextNew(const char *network_name,\n                  const char *config_dir)\n{\n    dnsmasqContext *ctx;\n\n    if (VIR_ALLOC(ctx) < 0)\n        return NULL;\n\n    ctx->config_dir = g_strdup(config_dir);\n\n    if (!(ctx->hostsfile = hostsfileNew(network_name, config_dir)))\n        goto error;\n    if (!(ctx->addnhostsfile = addnhostsNew(network_name, config_dir)))\n        goto error;\n\n    return ctx;\n\n error:\n    dnsmasqContextFree(ctx);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\ndnsmasqContext *\ndnsmasqContextNew(const char *network_name,\n                  const char *config_dir)\n{\n    dnsmasqContext *ctx;\n\n    if (VIR_ALLOC(ctx) < 0)\n        return NULL;\n\n    ctx->config_dir = g_strdup(config_dir);\n\n    if (!(ctx->hostsfile = hostsfileNew(network_name, config_dir)))\n        goto error;\n    if (!(ctx->addnhostsfile = addnhostsNew(network_name, config_dir)))\n        goto error;\n\n    return ctx;\n\n error:\n    dnsmasqContextFree(ctx);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot create directory %s\")",
            "driver->dnsmasqStateDir"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot create directory %s\""
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "driver->dnsmasqStateDir"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileBuildPath",
          "args": [
            "driver->pidDir",
            "def->name"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "43-51",
          "snippet": "char *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot create directory %s\")",
            "driver->pidDir"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_UNSPEC",
            "i"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStartDhcpDaemon(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virNetworkIPDefPtr ipdef;\n    size_t i;\n    bool needDnsmasq = false;\n    virCommandPtr cmd = NULL;\n    char *pidfile = NULL;\n    pid_t dnsmasqPid;\n    int ret = -1;\n    dnsmasqContext *dctx = NULL;\n\n    /* see if there are any IP addresses that need a dhcp server */\n    i = 0;\n    while ((ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i))) {\n        i++;\n        if (ipdef->nranges || ipdef->nhosts)\n            needDnsmasq = true;\n    }\n\n    if (i == 0) {\n        /* no IP addresses at all, so we don't need to run */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!needDnsmasq && def->dns.enable == VIR_TRISTATE_BOOL_NO) {\n        /* no DHCP services needed, and user disabled DNS service */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileMakePath(driver->pidDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->pidDir);\n        goto cleanup;\n    }\n\n    if (!(pidfile = virPidFileBuildPath(driver->pidDir, def->name)))\n        goto cleanup;\n\n    if (virFileMakePath(driver->dnsmasqStateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             driver->dnsmasqStateDir);\n        goto cleanup;\n    }\n\n    dctx = dnsmasqContextNew(def->name, driver->dnsmasqStateDir);\n    if (dctx == NULL)\n        goto cleanup;\n\n    if (networkDnsmasqCapsRefresh(driver) < 0)\n        goto cleanup;\n\n    ret = networkBuildDhcpDaemonCommandLine(driver, obj, &cmd, pidfile, dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = dnsmasqSave(dctx);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0)\n        goto cleanup;\n\n    /*\n     * There really is no race here - when dnsmasq daemonizes, its\n     * leader process stays around until its child has actually\n     * written its pidfile. So by time virCommandRun exits it has\n     * waitpid'd and guaranteed the proess has started and written a\n     * pid\n     */\n\n    ret = virPidFileRead(driver->pidDir, def->name, &dnsmasqPid);\n    if (ret < 0)\n        goto cleanup;\n    virNetworkObjSetDnsmasqPid(obj, dnsmasqPid);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pidfile);\n    virCommandFree(cmd);\n    dnsmasqContextFree(dctx);\n    return ret;\n}"
  },
  {
    "function_name": "networkDnsmasqConfContents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "1112-1596",
    "snippet": "int\nnetworkDnsmasqConfContents(virNetworkObjPtr obj,\n                           const char *pidfile,\n                           char **configstr,\n                           dnsmasqContext *dctx,\n                           dnsmasqCapsPtr caps G_GNUC_UNUSED)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBuffer configbuf = VIR_BUFFER_INITIALIZER;\n    int r, ret = -1;\n    int nbleases = 0;\n    size_t i;\n    virNetworkDNSDefPtr dns = &def->dns;\n    bool wantDNS = dns->enable != VIR_TRISTATE_BOOL_NO;\n    virNetworkIPDefPtr tmpipdef, ipdef, ipv4def, ipv6def;\n    bool ipv6SLAAC;\n    char *saddr = NULL, *eaddr = NULL;\n\n    *configstr = NULL;\n\n    /*\n     * All dnsmasq parameters are put into a configuration file, except the\n     * command line --conf-file=parameter which specifies the location of\n     * configuration file.\n     *\n     * All dnsmasq conf-file parameters must be specified as \"foo=bar\"\n     * as oppose to \"--foo bar\" which was acceptable on the command line.\n     */\n\n    /*\n     * Needed to ensure dnsmasq uses same algorithm for processing\n     * multiple namedriver entries in /etc/resolv.conf as GLibC.\n     */\n\n    /* create dnsmasq config file appropriate for this network */\n\n    /* Don't forget to update networkxml2conftest :-) */\n    virBufferAsprintf(&configbuf,\n                      \"##WARNING:  THIS IS AN AUTO-GENERATED FILE. \"\n                      \"CHANGES TO IT ARE LIKELY TO BE\\n\"\n                      \"##OVERWRITTEN AND LOST.  Changes to this \"\n                      \"configuration should be made using:\\n\"\n                      \"##    virsh net-edit %s\\n\"\n                      \"## or other application using the libvirt API.\\n\"\n                      \"##\\n## dnsmasq conf file created by libvirt\\n\"\n                      \"strict-order\\n\",\n                      def->name);\n\n    /* if dns is disabled, set its listening port to 0, which\n     * tells dnsmasq to not listen\n     */\n    if (!wantDNS)\n        virBufferAddLit(&configbuf, \"port=0\\n\");\n\n    if (wantDNS && def->dns.forwarders) {\n        /* addNoResolv should be set to true if there are any entries\n         * that specify an IP address for requests, but no domain\n         * qualifier (implying that all requests otherwise \"unclaimed\"\n         * should be sent to that address). if it is still false when\n         * we've looked at all entries, it means we still need the\n         * host's resolv.conf for some cases.\n         */\n        bool addNoResolv = false;\n\n        for (i = 0; i < def->dns.nfwds; i++) {\n            virNetworkDNSForwarderPtr fwd = &def->dns.forwarders[i];\n\n            virBufferAddLit(&configbuf, \"server=\");\n            if (fwd->domain)\n                virBufferAsprintf(&configbuf, \"/%s/\", fwd->domain);\n            if (VIR_SOCKET_ADDR_VALID(&fwd->addr)) {\n                char *addr = virSocketAddrFormat(&fwd->addr);\n\n                if (!addr)\n                    goto cleanup;\n                virBufferAsprintf(&configbuf, \"%s\\n\", addr);\n                VIR_FREE(addr);\n                if (!fwd->domain)\n                    addNoResolv = true;\n            } else {\n                /* \"don't forward requests for this domain\" */\n                virBufferAddLit(&configbuf, \"#\\n\");\n            }\n        }\n        if (addNoResolv)\n            virBufferAddLit(&configbuf, \"no-resolv\\n\");\n    }\n\n    if (def->domain) {\n        if (def->domainLocalOnly == VIR_TRISTATE_BOOL_YES) {\n            virBufferAsprintf(&configbuf,\n                              \"local=/%s/\\n\",\n                              def->domain);\n        }\n        virBufferAsprintf(&configbuf,\n                          \"domain=%s\\n\"\n                          \"expand-hosts\\n\",\n                          def->domain);\n    }\n\n    if (wantDNS &&\n        networkDnsmasqConfLocalPTRs(&configbuf, def) < 0)\n        goto cleanup;\n\n    if (wantDNS && def->dns.forwardPlainNames == VIR_TRISTATE_BOOL_NO) {\n        virBufferAddLit(&configbuf, \"domain-needed\\n\");\n        /* need to specify local=// whether or not a domain is\n         * specified, unless the config says we should forward \"plain\"\n         * names (i.e. not fully qualified, no '.' characters)\n         */\n        virBufferAddLit(&configbuf, \"local=//\\n\");\n    }\n\n    if (pidfile)\n        virBufferAsprintf(&configbuf, \"pid-file=%s\\n\", pidfile);\n\n    /* dnsmasq will *always* listen on localhost unless told otherwise */\n#ifdef __linux__\n    virBufferAddLit(&configbuf, \"except-interface=lo\\n\");\n#else\n    /* BSD family OSes and Solaris call loopback interface as lo0 */\n    virBufferAddLit(&configbuf, \"except-interface=lo0\\n\");\n#endif\n\n    if (dnsmasqCapsGet(caps, DNSMASQ_CAPS_BIND_DYNAMIC)) {\n        /* using --bind-dynamic with only --interface (no\n         * --listen-address) prevents dnsmasq from responding to dns\n         * queries that arrive on some interface other than our bridge\n         * interface (in other words, requests originating somewhere\n         * other than one of the virtual guests connected directly to\n         * this network). This was added in response to CVE 2012-3411.\n         */\n        virBufferAsprintf(&configbuf,\n                          \"bind-dynamic\\n\"\n                          \"interface=%s\\n\",\n                          def->bridge);\n    } else {\n        virBufferAddLit(&configbuf, \"bind-interfaces\\n\");\n        /*\n         * --interface does not actually work with dnsmasq < 2.47,\n         * due to DAD for ipv6 addresses on the interface.\n         *\n         * virCommandAddArgList(cmd, \"--interface\", def->bridge, NULL);\n         *\n         * So listen on all defined IPv[46] addresses\n         */\n        for (i = 0;\n             (tmpipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n             i++) {\n            char *ipaddr = virSocketAddrFormat(&tmpipdef->address);\n\n            if (!ipaddr)\n                goto cleanup;\n\n            /* also part of CVE 2012-3411 - if the host's version of\n             * dnsmasq doesn't have bind-dynamic, only allow listening on\n             * private/local IP addresses (see RFC1918/RFC3484/RFC4193)\n             */\n            if (!dnsmasqCapsGet(caps, DNSMASQ_CAPS_BINDTODEVICE) &&\n                !virSocketAddrIsPrivate(&tmpipdef->address)) {\n                unsigned long version = dnsmasqCapsGetVersion(caps);\n\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Publicly routable address %s is prohibited. \"\n                                 \"The version of dnsmasq on this host (%d.%d) \"\n                                 \"doesn't support the bind-dynamic option or \"\n                                 \"use SO_BINDTODEVICE on listening sockets, \"\n                                 \"one of which is required for safe operation \"\n                                 \"on a publicly routable subnet \"\n                                 \"(see CVE-2012-3411). You must either \"\n                                 \"upgrade dnsmasq, or use a private/local \"\n                                 \"subnet range for this network \"\n                                 \"(as described in RFC1918/RFC3484/RFC4193).\"),\n                               ipaddr, (int)version / 1000000,\n                               (int)(version % 1000000) / 1000);\n                VIR_FREE(ipaddr);\n                goto cleanup;\n            }\n            virBufferAsprintf(&configbuf, \"listen-address=%s\\n\", ipaddr);\n            VIR_FREE(ipaddr);\n        }\n    }\n\n    /* If this is an isolated network, set the default route option\n     * (3) to be empty to avoid setting a default route that's\n     * guaranteed to not work, and set no-resolv so that no dns\n     * requests are forwarded on to the dns server listed in the\n     * host's /etc/resolv.conf (since this could be used as a channel\n     * to build a connection to the outside).\n     * IPv6 RA always contains an implicit default route\n     * via the sender's link-local address. The only thing we can do\n     * is set the lifetime of this route to 0, i.e. disable it.\n     */\n    if (def->forward.type == VIR_NETWORK_FORWARD_NONE) {\n        virBufferAddLit(&configbuf, \"dhcp-option=3\\n\"\n                        \"no-resolv\\n\");\n        if (dnsmasqCapsGet(caps, DNSMASQ_CAPS_RA_PARAM)) {\n            /* interface=* (any), interval=0 (default), lifetime=0 (seconds) */\n            virBufferAddLit(&configbuf, \"ra-param=*,0,0\\n\");\n        }\n    }\n\n    if (wantDNS) {\n        for (i = 0; i < dns->ntxts; i++) {\n            virBufferAsprintf(&configbuf, \"txt-record=%s,%s\\n\",\n                              dns->txts[i].name,\n                              dns->txts[i].value);\n        }\n\n        for (i = 0; i < dns->nsrvs; i++) {\n            /* service/protocol are required, and should have been validated\n             * by the parser.\n             */\n            if (!dns->srvs[i].service) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing required 'service' \"\n                                 \"attribute in SRV record of network '%s'\"),\n                               def->name);\n                goto cleanup;\n            }\n            if (!dns->srvs[i].protocol) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing required 'service' \"\n                                 \"attribute in SRV record of network '%s'\"),\n                               def->name);\n                goto cleanup;\n            }\n            /* RFC2782 requires that service and protocol be preceded by\n             * an underscore.\n             */\n            virBufferAsprintf(&configbuf, \"srv-host=_%s._%s\",\n                              dns->srvs[i].service, dns->srvs[i].protocol);\n\n            /* domain is optional - it defaults to the domain of this network */\n            if (dns->srvs[i].domain)\n                virBufferAsprintf(&configbuf, \".%s\", dns->srvs[i].domain);\n\n            /* If target is empty or \".\", that means \"the service is\n             * decidedly not available at this domain\" (RFC2782). In that\n             * case, any port, priority, or weight is irrelevant.\n             */\n            if (dns->srvs[i].target && STRNEQ(dns->srvs[i].target, \".\")) {\n\n                virBufferAsprintf(&configbuf, \",%s\", dns->srvs[i].target);\n                /* port, priority, and weight are optional, but are\n                 * identified by their position in the line. If an item is\n                 * unspecified, but something later in the line *is*\n                 * specified, we need to give the default value for the\n                 * unspecified item. (According to the dnsmasq manpage,\n                 * the default for port is 1).\n                 */\n                if (dns->srvs[i].port ||\n                    dns->srvs[i].priority || dns->srvs[i].weight)\n                    virBufferAsprintf(&configbuf, \",%d\",\n                                      dns->srvs[i].port ? dns->srvs[i].port : 1);\n                if (dns->srvs[i].priority || dns->srvs[i].weight)\n                    virBufferAsprintf(&configbuf, \",%d\", dns->srvs[i].priority);\n                if (dns->srvs[i].weight)\n                    virBufferAsprintf(&configbuf, \",%d\", dns->srvs[i].weight);\n            }\n            virBufferAddLit(&configbuf, \"\\n\");\n        }\n    }\n\n    /* Find the first dhcp for both IPv4 and IPv6 */\n    for (i = 0, ipv4def = NULL, ipv6def = NULL, ipv6SLAAC = false;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (ipv4def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"For IPv4, multiple DHCP definitions \"\n                                     \"cannot be specified.\"));\n                    goto cleanup;\n                } else {\n                    ipv4def = ipdef;\n                }\n            }\n        }\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (!DNSMASQ_DHCPv6_SUPPORT(caps)) {\n                    unsigned long version = dnsmasqCapsGetVersion(caps);\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"The version of dnsmasq on this host \"\n                                     \"(%d.%d) doesn't adequately support \"\n                                     \"IPv6 dhcp range or dhcp host \"\n                                     \"specification. Version %d.%d or later \"\n                                     \"is required.\"),\n                                   (int)version / 1000000,\n                                   (int)(version % 1000000) / 1000,\n                                   DNSMASQ_DHCPv6_MAJOR_REQD,\n                                   DNSMASQ_DHCPv6_MINOR_REQD);\n                    goto cleanup;\n                }\n                if (ipv6def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"For IPv6, multiple DHCP definitions \"\n                                     \"cannot be specified.\"));\n                    goto cleanup;\n                } else {\n                    ipv6def = ipdef;\n                }\n            } else {\n                ipv6SLAAC = true;\n            }\n        }\n    }\n\n    if (ipv6def && ipv6SLAAC) {\n        VIR_WARN(\"For IPv6, when DHCP is specified for one address, then \"\n                 \"state-full Router Advertising will occur.  The additional \"\n                 \"IPv6 addresses specified require manually configured guest \"\n                 \"network to work properly since both state-full (DHCP) \"\n                 \"and state-less (SLAAC) addressing are not supported \"\n                 \"on the same network interface.\");\n    }\n\n    ipdef = ipv4def ? ipv4def : ipv6def;\n\n    while (ipdef) {\n        int prefix;\n\n        prefix = virNetworkIPDefPrefix(ipdef);\n        if (prefix < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bridge '%s' has an invalid prefix\"),\n                           def->bridge);\n            goto cleanup;\n        }\n        for (r = 0; r < ipdef->nranges; r++) {\n            int thisRange;\n\n            if (!(saddr = virSocketAddrFormat(&ipdef->ranges[r].start)) ||\n                !(eaddr = virSocketAddrFormat(&ipdef->ranges[r].end)))\n                goto cleanup;\n\n            if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6)) {\n               virBufferAsprintf(&configbuf, \"dhcp-range=%s,%s,%d\\n\",\n                                 saddr, eaddr, prefix);\n            } else {\n                /* IPv4 - dnsmasq requires a netmask rather than prefix */\n                virSocketAddr netmask;\n                g_autofree char *netmaskStr = NULL;\n\n                if (virSocketAddrPrefixToNetmask(prefix, &netmask, AF_INET) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Failed to translate bridge '%s' \"\n                                     \"prefix %d to netmask\"),\n                                   def->bridge, prefix);\n                    goto cleanup;\n                }\n\n                if (!(netmaskStr = virSocketAddrFormat(&netmask)))\n                    goto cleanup;\n                virBufferAsprintf(&configbuf, \"dhcp-range=%s,%s,%s\\n\",\n                                  saddr, eaddr, netmaskStr);\n            }\n\n            VIR_FREE(saddr);\n            VIR_FREE(eaddr);\n            thisRange = virSocketAddrGetRange(&ipdef->ranges[r].start,\n                                              &ipdef->ranges[r].end,\n                                              &ipdef->address,\n                                              virNetworkIPDefPrefix(ipdef));\n            if (thisRange < 0)\n                goto cleanup;\n            nbleases += thisRange;\n        }\n\n        /*\n         * For static-only DHCP, i.e. with no range but at least one\n         * host element, we have to add a special --dhcp-range option\n         * to enable the service in dnsmasq. (this is for dhcp-hosts=\n         * support)\n         */\n        if (!ipdef->nranges && ipdef->nhosts) {\n            char *bridgeaddr = virSocketAddrFormat(&ipdef->address);\n            if (!bridgeaddr)\n                goto cleanup;\n            virBufferAsprintf(&configbuf, \"dhcp-range=%s,static\",\n                              bridgeaddr);\n            if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n                virBufferAsprintf(&configbuf, \",%d\", prefix);\n            virBufferAddLit(&configbuf, \"\\n\");\n            VIR_FREE(bridgeaddr);\n        }\n\n        if (networkBuildDnsmasqDhcpHostsList(dctx, ipdef) < 0)\n            goto cleanup;\n\n        /* Note: the following is IPv4 only */\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                virBufferAddLit(&configbuf, \"dhcp-no-override\\n\");\n                virBufferAddLit(&configbuf, \"dhcp-authoritative\\n\");\n            }\n\n            if (ipdef->tftproot) {\n                virBufferAddLit(&configbuf, \"enable-tftp\\n\");\n                virBufferAsprintf(&configbuf, \"tftp-root=%s\\n\", ipdef->tftproot);\n            }\n\n            if (ipdef->bootfile) {\n                if (VIR_SOCKET_ADDR_VALID(&ipdef->bootserver)) {\n                    char *bootserver = virSocketAddrFormat(&ipdef->bootserver);\n\n                    if (!bootserver)\n                        goto cleanup;\n                    virBufferAsprintf(&configbuf, \"dhcp-boot=%s%s%s\\n\",\n                                      ipdef->bootfile, \",,\", bootserver);\n                    VIR_FREE(bootserver);\n                } else {\n                    virBufferAsprintf(&configbuf, \"dhcp-boot=%s\\n\", ipdef->bootfile);\n                }\n            }\n        }\n        ipdef = (ipdef == ipv6def) ? NULL : ipv6def;\n    }\n\n    if (nbleases > 0)\n        virBufferAsprintf(&configbuf, \"dhcp-lease-max=%d\\n\", nbleases);\n\n    /* this is done once per interface */\n    if (networkBuildDnsmasqHostsList(dctx, dns) < 0)\n        goto cleanup;\n\n    /* Even if there are currently no static hosts, if we're\n     * listening for DHCP, we should write a 0-length hosts\n     * file to allow for runtime additions.\n     */\n    if (ipv4def || ipv6def)\n        virBufferAsprintf(&configbuf, \"dhcp-hostsfile=%s\\n\",\n                          dctx->hostsfile->path);\n\n    /* Likewise, always create this file and put it on the\n     * commandline, to allow for runtime additions.\n     */\n    if (wantDNS) {\n        virBufferAsprintf(&configbuf, \"addn-hosts=%s\\n\",\n                          dctx->addnhostsfile->path);\n    }\n\n    /* Configure DHCP to tell clients about the MTU. */\n    if (def->mtu > 0)\n        virBufferAsprintf(&configbuf, \"dhcp-option=option:mtu,%d\\n\", def->mtu);\n\n    /* Are we doing RA instead of radvd? */\n    if (DNSMASQ_RA_SUPPORT(caps)) {\n        if (ipv6def) {\n            virBufferAddLit(&configbuf, \"enable-ra\\n\");\n        } else {\n            for (i = 0;\n                 (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i));\n                 i++) {\n                if (!(ipdef->nranges || ipdef->nhosts)) {\n                    char *bridgeaddr = virSocketAddrFormat(&ipdef->address);\n                    if (!bridgeaddr)\n                        goto cleanup;\n                    virBufferAsprintf(&configbuf,\n                                      \"dhcp-range=%s,ra-only\\n\", bridgeaddr);\n                    VIR_FREE(bridgeaddr);\n                }\n            }\n        }\n    }\n\n    if (def->namespaceData) {\n        networkDnsmasqXmlNsDefPtr dnsmasqxmlns = def->namespaceData;\n        for (i = 0; i < dnsmasqxmlns->noptions; i++)\n            virBufferAsprintf(&configbuf, \"%s\\n\", dnsmasqxmlns->options[i]);\n    }\n\n    if (!(*configstr = virBufferContentAndReset(&configbuf)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(saddr);\n    VIR_FREE(eaddr);\n    virBufferFreeAndReset(&configbuf);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&configbuf"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "eaddr"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "saddr"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&configbuf"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&configbuf",
            "\"%s\\n\"",
            "dnsmasqxmlns->options[i]"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "bridgeaddr"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&ipdef->address"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET6",
            "i"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"enable-ra\\n\""
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DNSMASQ_RA_SUPPORT",
          "args": [
            "caps"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkBuildDnsmasqHostsList",
          "args": [
            "dctx",
            "dns"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "networkBuildDnsmasqHostsList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1054-1072",
          "snippet": "static int\nnetworkBuildDnsmasqHostsList(dnsmasqContext *dctx,\n                             virNetworkDNSDefPtr dnsdef)\n{\n    size_t i, j;\n\n    if (dnsdef) {\n        for (i = 0; i < dnsdef->nhosts; i++) {\n            virNetworkDNSHostDefPtr host = &(dnsdef->hosts[i]);\n            if (VIR_SOCKET_ADDR_VALID(&host->ip)) {\n                for (j = 0; j < host->nnames; j++)\n                    if (dnsmasqAddHost(dctx, &host->ip, host->names[j]) < 0)\n                        return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkBuildDnsmasqHostsList(dnsmasqContext *dctx,\n                             virNetworkDNSDefPtr dnsdef)\n{\n    size_t i, j;\n\n    if (dnsdef) {\n        for (i = 0; i < dnsdef->nhosts; i++) {\n            virNetworkDNSHostDefPtr host = &(dnsdef->hosts[i]);\n            if (VIR_SOCKET_ADDR_VALID(&host->ip)) {\n                for (j = 0; j < host->nnames; j++)\n                    if (dnsmasqAddHost(dctx, &host->ip, host->names[j]) < 0)\n                        return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "bootserver"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&ipdef->bootserver"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"enable-tftp\\n\""
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"dhcp-authoritative\\n\""
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"dhcp-no-override\\n\""
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef->address",
            "AF_INET"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkBuildDnsmasqDhcpHostsList",
          "args": [
            "dctx",
            "ipdef"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "networkBuildDnsmasqDhcpHostsList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1033-1051",
          "snippet": "static int\nnetworkBuildDnsmasqDhcpHostsList(dnsmasqContext *dctx,\n                                 virNetworkIPDefPtr ipdef)\n{\n    size_t i;\n    bool ipv6 = false;\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n        ipv6 = true;\n    for (i = 0; i < ipdef->nhosts; i++) {\n        virNetworkDHCPHostDefPtr host = &(ipdef->hosts[i]);\n        if (VIR_SOCKET_ADDR_VALID(&host->ip))\n            if (dnsmasqAddDhcpHost(dctx, host->mac, &host->ip,\n                                   host->name, host->id, ipv6) < 0)\n                return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkBuildDnsmasqDhcpHostsList(dnsmasqContext *dctx,\n                                 virNetworkIPDefPtr ipdef)\n{\n    size_t i;\n    bool ipv6 = false;\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n        ipv6 = true;\n    for (i = 0; i < ipdef->nhosts; i++) {\n        virNetworkDHCPHostDefPtr host = &(ipdef->hosts[i]);\n        if (VIR_SOCKET_ADDR_VALID(&host->ip))\n            if (dnsmasqAddDhcpHost(dctx, host->mac, &host->ip,\n                                   host->name, host->id, ipv6) < 0)\n                return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "bridgeaddr"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"\\n\""
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef->address",
            "AF_INET6"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetRange",
          "args": [
            "&ipdef->ranges[r].start",
            "&ipdef->ranges[r].end",
            "&ipdef->address",
            "virNetworkIPDefPrefix(ipdef)"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "825-997",
          "snippet": "int\nvirSocketAddrGetRange(virSocketAddrPtr start, virSocketAddrPtr end,\n                      virSocketAddrPtr network, int prefix)\n{\n    int ret = 0;\n    size_t i;\n    virSocketAddr netmask;\n    g_autofree char *startStr = NULL;\n    g_autofree char *endStr = NULL;\n    g_autofree char *netStr = NULL;\n\n    if (start == NULL || end == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NULL argument - %p %p\"), start, end);\n        return -1;\n    }\n\n    startStr = virSocketAddrFormat(start);\n    endStr = virSocketAddrFormat(end);\n    if (!startStr || !endStr)\n        return -1; /*error already reported */\n\n    if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(end)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"mismatch of address family in range %s - %s\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    if (network) {\n        /* some checks can only be done if we have details of the\n         * network the range should be within\n         */\n        if (!(netStr = virSocketAddrFormat(network)))\n            return -1;\n\n        if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(network)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"mismatch of address family in \"\n                             \"range %s - %s for network %s\"),\n                           startStr, endStr, netStr);\n            return -1;\n        }\n\n        if (prefix < 0 ||\n            virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                         VIR_SOCKET_ADDR_FAMILY(network)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bad prefix %d for network %s when \"\n                             \" checking range %s - %s\"),\n                           prefix, netStr, startStr, endStr);\n            return -1;\n        }\n\n        /* both start and end of range need to be within network */\n        if (virSocketAddrCheckNetmask(start, network, &netmask) <= 0 ||\n            virSocketAddrCheckNetmask(end, network, &netmask) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is not entirely within \"\n                             \"network %s/%d\"),\n                           startStr, endStr, netStr, prefix);\n            return -1;\n        }\n\n        if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n            virSocketAddr netaddr, broadcast;\n\n            if (virSocketAddrBroadcast(network, &netmask, &broadcast) < 0 ||\n                virSocketAddrMask(network, &netmask, &netaddr) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"failed to construct broadcast or network \"\n                                 \"address for network %s/%d\"),\n                               netStr, prefix);\n                return -1;\n            }\n\n            /* Don't allow the start of the range to be the network\n             * address (usually \"...0\") or the end of the range to be the\n             * broadcast address (usually \"...255\"). (the opposite also\n             * isn't allowed, but checking for that is implicit in all the\n             * other combined checks) (IPv6 doesn't have broadcast and\n             * network addresses, so this check is only done for IPv4)\n             */\n            if (virSocketAddrEqual(start, &netaddr)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"start of range %s - %s in network %s/%d \"\n                                 \"is the network address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n\n            if (virSocketAddrEqual(end, &broadcast)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"end of range %s - %s in network %s/%d \"\n                                 \"is the broadcast address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n        }\n    }\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n        virSocketAddrIPv4 t1, t2;\n\n        if (virSocketAddrGetIPv4Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv4Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv4 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes\n         * are the same\n         */\n        for (i = 0; i < 2; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = (t2[2] - t1[2]) * 256 + (t2[3] - t1[3]);\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is reversed \"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET6)) {\n        virSocketAddrIPv6 t1, t2;\n\n        if (virSocketAddrGetIPv6Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv6Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv6 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes are\n         * the same\n         */\n        for (i = 0; i < 7; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = t2[7] - t1[7];\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s start larger than end\"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unsupported address family \"\n                         \"for range %s - %s, must be ipv4 or ipv6\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrGetRange(virSocketAddrPtr start, virSocketAddrPtr end,\n                      virSocketAddrPtr network, int prefix)\n{\n    int ret = 0;\n    size_t i;\n    virSocketAddr netmask;\n    g_autofree char *startStr = NULL;\n    g_autofree char *endStr = NULL;\n    g_autofree char *netStr = NULL;\n\n    if (start == NULL || end == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NULL argument - %p %p\"), start, end);\n        return -1;\n    }\n\n    startStr = virSocketAddrFormat(start);\n    endStr = virSocketAddrFormat(end);\n    if (!startStr || !endStr)\n        return -1; /*error already reported */\n\n    if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(end)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"mismatch of address family in range %s - %s\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    if (network) {\n        /* some checks can only be done if we have details of the\n         * network the range should be within\n         */\n        if (!(netStr = virSocketAddrFormat(network)))\n            return -1;\n\n        if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(network)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"mismatch of address family in \"\n                             \"range %s - %s for network %s\"),\n                           startStr, endStr, netStr);\n            return -1;\n        }\n\n        if (prefix < 0 ||\n            virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                         VIR_SOCKET_ADDR_FAMILY(network)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bad prefix %d for network %s when \"\n                             \" checking range %s - %s\"),\n                           prefix, netStr, startStr, endStr);\n            return -1;\n        }\n\n        /* both start and end of range need to be within network */\n        if (virSocketAddrCheckNetmask(start, network, &netmask) <= 0 ||\n            virSocketAddrCheckNetmask(end, network, &netmask) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is not entirely within \"\n                             \"network %s/%d\"),\n                           startStr, endStr, netStr, prefix);\n            return -1;\n        }\n\n        if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n            virSocketAddr netaddr, broadcast;\n\n            if (virSocketAddrBroadcast(network, &netmask, &broadcast) < 0 ||\n                virSocketAddrMask(network, &netmask, &netaddr) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"failed to construct broadcast or network \"\n                                 \"address for network %s/%d\"),\n                               netStr, prefix);\n                return -1;\n            }\n\n            /* Don't allow the start of the range to be the network\n             * address (usually \"...0\") or the end of the range to be the\n             * broadcast address (usually \"...255\"). (the opposite also\n             * isn't allowed, but checking for that is implicit in all the\n             * other combined checks) (IPv6 doesn't have broadcast and\n             * network addresses, so this check is only done for IPv4)\n             */\n            if (virSocketAddrEqual(start, &netaddr)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"start of range %s - %s in network %s/%d \"\n                                 \"is the network address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n\n            if (virSocketAddrEqual(end, &broadcast)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"end of range %s - %s in network %s/%d \"\n                                 \"is the broadcast address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n        }\n    }\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n        virSocketAddrIPv4 t1, t2;\n\n        if (virSocketAddrGetIPv4Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv4Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv4 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes\n         * are the same\n         */\n        for (i = 0; i < 2; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = (t2[2] - t1[2]) * 256 + (t2[3] - t1[3]);\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is reversed \"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET6)) {\n        virSocketAddrIPv6 t1, t2;\n\n        if (virSocketAddrGetIPv6Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv6Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv6 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes are\n         * the same\n         */\n        for (i = 0; i < 7; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = t2[7] - t1[7];\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s start larger than end\"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unsupported address family \"\n                         \"for range %s - %s, must be ipv4 or ipv6\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefPrefix",
          "args": [
            "ipdef"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "367-373",
          "snippet": "int\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "eaddr"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "saddr"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to translate bridge '%s' \"\n                                     \"prefix %d to netmask\")",
            "def->bridge",
            "prefix"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to translate bridge '%s' \"\n                                     \"prefix %d to netmask\""
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrPrefixToNetmask",
          "args": [
            "prefix",
            "&netmask",
            "AF_INET"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrPrefixToNetmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1098-1141",
          "snippet": "int\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef->address",
            "AF_INET6"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"bridge '%s' has an invalid prefix\")",
            "def->bridge"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"For IPv6, when DHCP is specified for one address, then \"\n                 \"state-full Router Advertising will occur.  The additional \"\n                 \"IPv6 addresses specified require manually configured guest \"\n                 \"network to work properly since both state-full (DHCP) \"\n                 \"and state-less (SLAAC) addressing are not supported \"\n                 \"on the same network interface.\""
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"For IPv6, multiple DHCP definitions \"\n                                     \"cannot be specified.\")"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"The version of dnsmasq on this host \"\n                                     \"(%d.%d) doesn't adequately support \"\n                                     \"IPv6 dhcp range or dhcp host \"\n                                     \"specification. Version %d.%d or later \"\n                                     \"is required.\")",
            "(int)version / 1000000",
            "(int)(version % 1000000) / 1000",
            "DNSMASQ_DHCPv6_MAJOR_REQD",
            "DNSMASQ_DHCPv6_MINOR_REQD"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnsmasqCapsGetVersion",
          "args": [
            "caps"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqCapsGetVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "851-858",
          "snippet": "unsigned long\ndnsmasqCapsGetVersion(dnsmasqCapsPtr caps)\n{\n    if (caps)\n        return caps->version;\n    else\n        return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nunsigned long\ndnsmasqCapsGetVersion(dnsmasqCapsPtr caps)\n{\n    if (caps)\n        return caps->version;\n    else\n        return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DNSMASQ_DHCPv6_SUPPORT",
          "args": [
            "caps"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef->address",
            "AF_INET6"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"For IPv4, multiple DHCP definitions \"\n                                     \"cannot be specified.\")"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef->address",
            "AF_INET"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"\\n\""
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "dns->srvs[i].target",
            "\".\""
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing required 'service' \"\n                                 \"attribute in SRV record of network '%s'\")",
            "def->name"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing required 'service' \"\n                                 \"attribute in SRV record of network '%s'\")",
            "def->name"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"ra-param=*,0,0\\n\""
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnsmasqCapsGet",
          "args": [
            "caps",
            "DNSMASQ_CAPS_RA_PARAM"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqCapsGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "860-864",
          "snippet": "bool\ndnsmasqCapsGet(dnsmasqCapsPtr caps, dnsmasqCapsFlags flag)\n{\n    return caps && virBitmapIsBitSet(caps->flags, flag);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nbool\ndnsmasqCapsGet(dnsmasqCapsPtr caps, dnsmasqCapsFlags flag)\n{\n    return caps && virBitmapIsBitSet(caps->flags, flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"dhcp-option=3\\n\"\n                        \"no-resolv\\n\""
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ipaddr"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ipaddr"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Publicly routable address %s is prohibited. \"\n                                 \"The version of dnsmasq on this host (%d.%d) \"\n                                 \"doesn't support the bind-dynamic option or \"\n                                 \"use SO_BINDTODEVICE on listening sockets, \"\n                                 \"one of which is required for safe operation \"\n                                 \"on a publicly routable subnet \"\n                                 \"(see CVE-2012-3411). You must either \"\n                                 \"upgrade dnsmasq, or use a private/local \"\n                                 \"subnet range for this network \"\n                                 \"(as described in RFC1918/RFC3484/RFC4193).\")",
            "ipaddr",
            "(int)version / 1000000",
            "(int)(version % 1000000) / 1000"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrIsPrivate",
          "args": [
            "&tmpipdef->address"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrIsPrivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "392-411",
          "snippet": "bool\nvirSocketAddrIsPrivate(const virSocketAddr *addr)\n{\n    unsigned long val;\n\n    switch (addr->data.stor.ss_family) {\n    case AF_INET:\n       val = ntohl(addr->data.inet4.sin_addr.s_addr);\n\n       return ((val & 0xFFFF0000) == ((192UL << 24) + (168 << 16)) ||\n               (val & 0xFFF00000) == ((172UL << 24) + (16  << 16)) ||\n               (val & 0xFF000000) == ((10UL  << 24)));\n\n    case AF_INET6:\n        return ((addr->data.inet6.sin6_addr.s6_addr[0] & 0xFE) == 0xFC ||\n                ((addr->data.inet6.sin6_addr.s6_addr[0] & 0xFF) == 0xFE &&\n                 (addr->data.inet6.sin6_addr.s6_addr[1] & 0xC0) == 0xC0));\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrIsPrivate(const virSocketAddr *addr)\n{\n    unsigned long val;\n\n    switch (addr->data.stor.ss_family) {\n    case AF_INET:\n       val = ntohl(addr->data.inet4.sin_addr.s_addr);\n\n       return ((val & 0xFFFF0000) == ((192UL << 24) + (168 << 16)) ||\n               (val & 0xFFF00000) == ((172UL << 24) + (16  << 16)) ||\n               (val & 0xFF000000) == ((10UL  << 24)));\n\n    case AF_INET6:\n        return ((addr->data.inet6.sin6_addr.s6_addr[0] & 0xFE) == 0xFC ||\n                ((addr->data.inet6.sin6_addr.s6_addr[0] & 0xFF) == 0xFE &&\n                 (addr->data.inet6.sin6_addr.s6_addr[1] & 0xC0) == 0xC0));\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"bind-interfaces\\n\""
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"except-interface=lo0\\n\""
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"except-interface=lo\\n\""
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"local=//\\n\""
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"domain-needed\\n\""
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkDnsmasqConfLocalPTRs",
          "args": [
            "&configbuf",
            "def"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "networkDnsmasqConfLocalPTRs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "1075-1109",
          "snippet": "static int\nnetworkDnsmasqConfLocalPTRs(virBufferPtr buf,\n                            virNetworkDefPtr def)\n{\n    virNetworkIPDefPtr ip;\n    size_t i;\n    char *ptr = NULL;\n    int rc;\n\n    for (i = 0; i < def->nips; i++) {\n        ip = def->ips + i;\n\n        if (ip->localPTR != VIR_TRISTATE_BOOL_YES)\n            continue;\n\n        if ((rc = virSocketAddrPTRDomain(&ip->address,\n                                         virNetworkIPDefPrefix(ip),\n                                         &ptr)) < 0) {\n            if (rc == -2) {\n                int family = VIR_SOCKET_ADDR_FAMILY(&ip->address);\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"PTR domain for %s network with prefix %u \"\n                                 \"cannot be automatically created\"),\n                               (family == AF_INET) ? \"IPv4\" : \"IPv6\",\n                               virNetworkIPDefPrefix(ip));\n            }\n            return -1;\n        }\n\n        virBufferAsprintf(buf, \"local=/%s/\\n\", ptr);\n        VIR_FREE(ptr);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkDnsmasqConfLocalPTRs(virBufferPtr buf,\n                            virNetworkDefPtr def)\n{\n    virNetworkIPDefPtr ip;\n    size_t i;\n    char *ptr = NULL;\n    int rc;\n\n    for (i = 0; i < def->nips; i++) {\n        ip = def->ips + i;\n\n        if (ip->localPTR != VIR_TRISTATE_BOOL_YES)\n            continue;\n\n        if ((rc = virSocketAddrPTRDomain(&ip->address,\n                                         virNetworkIPDefPrefix(ip),\n                                         &ptr)) < 0) {\n            if (rc == -2) {\n                int family = VIR_SOCKET_ADDR_FAMILY(&ip->address);\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"PTR domain for %s network with prefix %u \"\n                                 \"cannot be automatically created\"),\n                               (family == AF_INET) ? \"IPv4\" : \"IPv6\",\n                               virNetworkIPDefPrefix(ip));\n            }\n            return -1;\n        }\n\n        virBufferAsprintf(buf, \"local=/%s/\\n\", ptr);\n        VIR_FREE(ptr);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"no-resolv\\n\""
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"#\\n\""
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addr"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&fwd->addr"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"server=\""
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&configbuf",
            "\"port=0\\n\""
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nint\nnetworkDnsmasqConfContents(virNetworkObjPtr obj,\n                           const char *pidfile,\n                           char **configstr,\n                           dnsmasqContext *dctx,\n                           dnsmasqCapsPtr caps G_GNUC_UNUSED)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    virBuffer configbuf = VIR_BUFFER_INITIALIZER;\n    int r, ret = -1;\n    int nbleases = 0;\n    size_t i;\n    virNetworkDNSDefPtr dns = &def->dns;\n    bool wantDNS = dns->enable != VIR_TRISTATE_BOOL_NO;\n    virNetworkIPDefPtr tmpipdef, ipdef, ipv4def, ipv6def;\n    bool ipv6SLAAC;\n    char *saddr = NULL, *eaddr = NULL;\n\n    *configstr = NULL;\n\n    /*\n     * All dnsmasq parameters are put into a configuration file, except the\n     * command line --conf-file=parameter which specifies the location of\n     * configuration file.\n     *\n     * All dnsmasq conf-file parameters must be specified as \"foo=bar\"\n     * as oppose to \"--foo bar\" which was acceptable on the command line.\n     */\n\n    /*\n     * Needed to ensure dnsmasq uses same algorithm for processing\n     * multiple namedriver entries in /etc/resolv.conf as GLibC.\n     */\n\n    /* create dnsmasq config file appropriate for this network */\n\n    /* Don't forget to update networkxml2conftest :-) */\n    virBufferAsprintf(&configbuf,\n                      \"##WARNING:  THIS IS AN AUTO-GENERATED FILE. \"\n                      \"CHANGES TO IT ARE LIKELY TO BE\\n\"\n                      \"##OVERWRITTEN AND LOST.  Changes to this \"\n                      \"configuration should be made using:\\n\"\n                      \"##    virsh net-edit %s\\n\"\n                      \"## or other application using the libvirt API.\\n\"\n                      \"##\\n## dnsmasq conf file created by libvirt\\n\"\n                      \"strict-order\\n\",\n                      def->name);\n\n    /* if dns is disabled, set its listening port to 0, which\n     * tells dnsmasq to not listen\n     */\n    if (!wantDNS)\n        virBufferAddLit(&configbuf, \"port=0\\n\");\n\n    if (wantDNS && def->dns.forwarders) {\n        /* addNoResolv should be set to true if there are any entries\n         * that specify an IP address for requests, but no domain\n         * qualifier (implying that all requests otherwise \"unclaimed\"\n         * should be sent to that address). if it is still false when\n         * we've looked at all entries, it means we still need the\n         * host's resolv.conf for some cases.\n         */\n        bool addNoResolv = false;\n\n        for (i = 0; i < def->dns.nfwds; i++) {\n            virNetworkDNSForwarderPtr fwd = &def->dns.forwarders[i];\n\n            virBufferAddLit(&configbuf, \"server=\");\n            if (fwd->domain)\n                virBufferAsprintf(&configbuf, \"/%s/\", fwd->domain);\n            if (VIR_SOCKET_ADDR_VALID(&fwd->addr)) {\n                char *addr = virSocketAddrFormat(&fwd->addr);\n\n                if (!addr)\n                    goto cleanup;\n                virBufferAsprintf(&configbuf, \"%s\\n\", addr);\n                VIR_FREE(addr);\n                if (!fwd->domain)\n                    addNoResolv = true;\n            } else {\n                /* \"don't forward requests for this domain\" */\n                virBufferAddLit(&configbuf, \"#\\n\");\n            }\n        }\n        if (addNoResolv)\n            virBufferAddLit(&configbuf, \"no-resolv\\n\");\n    }\n\n    if (def->domain) {\n        if (def->domainLocalOnly == VIR_TRISTATE_BOOL_YES) {\n            virBufferAsprintf(&configbuf,\n                              \"local=/%s/\\n\",\n                              def->domain);\n        }\n        virBufferAsprintf(&configbuf,\n                          \"domain=%s\\n\"\n                          \"expand-hosts\\n\",\n                          def->domain);\n    }\n\n    if (wantDNS &&\n        networkDnsmasqConfLocalPTRs(&configbuf, def) < 0)\n        goto cleanup;\n\n    if (wantDNS && def->dns.forwardPlainNames == VIR_TRISTATE_BOOL_NO) {\n        virBufferAddLit(&configbuf, \"domain-needed\\n\");\n        /* need to specify local=// whether or not a domain is\n         * specified, unless the config says we should forward \"plain\"\n         * names (i.e. not fully qualified, no '.' characters)\n         */\n        virBufferAddLit(&configbuf, \"local=//\\n\");\n    }\n\n    if (pidfile)\n        virBufferAsprintf(&configbuf, \"pid-file=%s\\n\", pidfile);\n\n    /* dnsmasq will *always* listen on localhost unless told otherwise */\n#ifdef __linux__\n    virBufferAddLit(&configbuf, \"except-interface=lo\\n\");\n#else\n    /* BSD family OSes and Solaris call loopback interface as lo0 */\n    virBufferAddLit(&configbuf, \"except-interface=lo0\\n\");\n#endif\n\n    if (dnsmasqCapsGet(caps, DNSMASQ_CAPS_BIND_DYNAMIC)) {\n        /* using --bind-dynamic with only --interface (no\n         * --listen-address) prevents dnsmasq from responding to dns\n         * queries that arrive on some interface other than our bridge\n         * interface (in other words, requests originating somewhere\n         * other than one of the virtual guests connected directly to\n         * this network). This was added in response to CVE 2012-3411.\n         */\n        virBufferAsprintf(&configbuf,\n                          \"bind-dynamic\\n\"\n                          \"interface=%s\\n\",\n                          def->bridge);\n    } else {\n        virBufferAddLit(&configbuf, \"bind-interfaces\\n\");\n        /*\n         * --interface does not actually work with dnsmasq < 2.47,\n         * due to DAD for ipv6 addresses on the interface.\n         *\n         * virCommandAddArgList(cmd, \"--interface\", def->bridge, NULL);\n         *\n         * So listen on all defined IPv[46] addresses\n         */\n        for (i = 0;\n             (tmpipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n             i++) {\n            char *ipaddr = virSocketAddrFormat(&tmpipdef->address);\n\n            if (!ipaddr)\n                goto cleanup;\n\n            /* also part of CVE 2012-3411 - if the host's version of\n             * dnsmasq doesn't have bind-dynamic, only allow listening on\n             * private/local IP addresses (see RFC1918/RFC3484/RFC4193)\n             */\n            if (!dnsmasqCapsGet(caps, DNSMASQ_CAPS_BINDTODEVICE) &&\n                !virSocketAddrIsPrivate(&tmpipdef->address)) {\n                unsigned long version = dnsmasqCapsGetVersion(caps);\n\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Publicly routable address %s is prohibited. \"\n                                 \"The version of dnsmasq on this host (%d.%d) \"\n                                 \"doesn't support the bind-dynamic option or \"\n                                 \"use SO_BINDTODEVICE on listening sockets, \"\n                                 \"one of which is required for safe operation \"\n                                 \"on a publicly routable subnet \"\n                                 \"(see CVE-2012-3411). You must either \"\n                                 \"upgrade dnsmasq, or use a private/local \"\n                                 \"subnet range for this network \"\n                                 \"(as described in RFC1918/RFC3484/RFC4193).\"),\n                               ipaddr, (int)version / 1000000,\n                               (int)(version % 1000000) / 1000);\n                VIR_FREE(ipaddr);\n                goto cleanup;\n            }\n            virBufferAsprintf(&configbuf, \"listen-address=%s\\n\", ipaddr);\n            VIR_FREE(ipaddr);\n        }\n    }\n\n    /* If this is an isolated network, set the default route option\n     * (3) to be empty to avoid setting a default route that's\n     * guaranteed to not work, and set no-resolv so that no dns\n     * requests are forwarded on to the dns server listed in the\n     * host's /etc/resolv.conf (since this could be used as a channel\n     * to build a connection to the outside).\n     * IPv6 RA always contains an implicit default route\n     * via the sender's link-local address. The only thing we can do\n     * is set the lifetime of this route to 0, i.e. disable it.\n     */\n    if (def->forward.type == VIR_NETWORK_FORWARD_NONE) {\n        virBufferAddLit(&configbuf, \"dhcp-option=3\\n\"\n                        \"no-resolv\\n\");\n        if (dnsmasqCapsGet(caps, DNSMASQ_CAPS_RA_PARAM)) {\n            /* interface=* (any), interval=0 (default), lifetime=0 (seconds) */\n            virBufferAddLit(&configbuf, \"ra-param=*,0,0\\n\");\n        }\n    }\n\n    if (wantDNS) {\n        for (i = 0; i < dns->ntxts; i++) {\n            virBufferAsprintf(&configbuf, \"txt-record=%s,%s\\n\",\n                              dns->txts[i].name,\n                              dns->txts[i].value);\n        }\n\n        for (i = 0; i < dns->nsrvs; i++) {\n            /* service/protocol are required, and should have been validated\n             * by the parser.\n             */\n            if (!dns->srvs[i].service) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing required 'service' \"\n                                 \"attribute in SRV record of network '%s'\"),\n                               def->name);\n                goto cleanup;\n            }\n            if (!dns->srvs[i].protocol) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing required 'service' \"\n                                 \"attribute in SRV record of network '%s'\"),\n                               def->name);\n                goto cleanup;\n            }\n            /* RFC2782 requires that service and protocol be preceded by\n             * an underscore.\n             */\n            virBufferAsprintf(&configbuf, \"srv-host=_%s._%s\",\n                              dns->srvs[i].service, dns->srvs[i].protocol);\n\n            /* domain is optional - it defaults to the domain of this network */\n            if (dns->srvs[i].domain)\n                virBufferAsprintf(&configbuf, \".%s\", dns->srvs[i].domain);\n\n            /* If target is empty or \".\", that means \"the service is\n             * decidedly not available at this domain\" (RFC2782). In that\n             * case, any port, priority, or weight is irrelevant.\n             */\n            if (dns->srvs[i].target && STRNEQ(dns->srvs[i].target, \".\")) {\n\n                virBufferAsprintf(&configbuf, \",%s\", dns->srvs[i].target);\n                /* port, priority, and weight are optional, but are\n                 * identified by their position in the line. If an item is\n                 * unspecified, but something later in the line *is*\n                 * specified, we need to give the default value for the\n                 * unspecified item. (According to the dnsmasq manpage,\n                 * the default for port is 1).\n                 */\n                if (dns->srvs[i].port ||\n                    dns->srvs[i].priority || dns->srvs[i].weight)\n                    virBufferAsprintf(&configbuf, \",%d\",\n                                      dns->srvs[i].port ? dns->srvs[i].port : 1);\n                if (dns->srvs[i].priority || dns->srvs[i].weight)\n                    virBufferAsprintf(&configbuf, \",%d\", dns->srvs[i].priority);\n                if (dns->srvs[i].weight)\n                    virBufferAsprintf(&configbuf, \",%d\", dns->srvs[i].weight);\n            }\n            virBufferAddLit(&configbuf, \"\\n\");\n        }\n    }\n\n    /* Find the first dhcp for both IPv4 and IPv6 */\n    for (i = 0, ipv4def = NULL, ipv6def = NULL, ipv6SLAAC = false;\n         (ipdef = virNetworkDefGetIPByIndex(def, AF_UNSPEC, i));\n         i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (ipv4def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"For IPv4, multiple DHCP definitions \"\n                                     \"cannot be specified.\"));\n                    goto cleanup;\n                } else {\n                    ipv4def = ipdef;\n                }\n            }\n        }\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                if (!DNSMASQ_DHCPv6_SUPPORT(caps)) {\n                    unsigned long version = dnsmasqCapsGetVersion(caps);\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                                   _(\"The version of dnsmasq on this host \"\n                                     \"(%d.%d) doesn't adequately support \"\n                                     \"IPv6 dhcp range or dhcp host \"\n                                     \"specification. Version %d.%d or later \"\n                                     \"is required.\"),\n                                   (int)version / 1000000,\n                                   (int)(version % 1000000) / 1000,\n                                   DNSMASQ_DHCPv6_MAJOR_REQD,\n                                   DNSMASQ_DHCPv6_MINOR_REQD);\n                    goto cleanup;\n                }\n                if (ipv6def) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"For IPv6, multiple DHCP definitions \"\n                                     \"cannot be specified.\"));\n                    goto cleanup;\n                } else {\n                    ipv6def = ipdef;\n                }\n            } else {\n                ipv6SLAAC = true;\n            }\n        }\n    }\n\n    if (ipv6def && ipv6SLAAC) {\n        VIR_WARN(\"For IPv6, when DHCP is specified for one address, then \"\n                 \"state-full Router Advertising will occur.  The additional \"\n                 \"IPv6 addresses specified require manually configured guest \"\n                 \"network to work properly since both state-full (DHCP) \"\n                 \"and state-less (SLAAC) addressing are not supported \"\n                 \"on the same network interface.\");\n    }\n\n    ipdef = ipv4def ? ipv4def : ipv6def;\n\n    while (ipdef) {\n        int prefix;\n\n        prefix = virNetworkIPDefPrefix(ipdef);\n        if (prefix < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bridge '%s' has an invalid prefix\"),\n                           def->bridge);\n            goto cleanup;\n        }\n        for (r = 0; r < ipdef->nranges; r++) {\n            int thisRange;\n\n            if (!(saddr = virSocketAddrFormat(&ipdef->ranges[r].start)) ||\n                !(eaddr = virSocketAddrFormat(&ipdef->ranges[r].end)))\n                goto cleanup;\n\n            if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6)) {\n               virBufferAsprintf(&configbuf, \"dhcp-range=%s,%s,%d\\n\",\n                                 saddr, eaddr, prefix);\n            } else {\n                /* IPv4 - dnsmasq requires a netmask rather than prefix */\n                virSocketAddr netmask;\n                g_autofree char *netmaskStr = NULL;\n\n                if (virSocketAddrPrefixToNetmask(prefix, &netmask, AF_INET) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Failed to translate bridge '%s' \"\n                                     \"prefix %d to netmask\"),\n                                   def->bridge, prefix);\n                    goto cleanup;\n                }\n\n                if (!(netmaskStr = virSocketAddrFormat(&netmask)))\n                    goto cleanup;\n                virBufferAsprintf(&configbuf, \"dhcp-range=%s,%s,%s\\n\",\n                                  saddr, eaddr, netmaskStr);\n            }\n\n            VIR_FREE(saddr);\n            VIR_FREE(eaddr);\n            thisRange = virSocketAddrGetRange(&ipdef->ranges[r].start,\n                                              &ipdef->ranges[r].end,\n                                              &ipdef->address,\n                                              virNetworkIPDefPrefix(ipdef));\n            if (thisRange < 0)\n                goto cleanup;\n            nbleases += thisRange;\n        }\n\n        /*\n         * For static-only DHCP, i.e. with no range but at least one\n         * host element, we have to add a special --dhcp-range option\n         * to enable the service in dnsmasq. (this is for dhcp-hosts=\n         * support)\n         */\n        if (!ipdef->nranges && ipdef->nhosts) {\n            char *bridgeaddr = virSocketAddrFormat(&ipdef->address);\n            if (!bridgeaddr)\n                goto cleanup;\n            virBufferAsprintf(&configbuf, \"dhcp-range=%s,static\",\n                              bridgeaddr);\n            if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n                virBufferAsprintf(&configbuf, \",%d\", prefix);\n            virBufferAddLit(&configbuf, \"\\n\");\n            VIR_FREE(bridgeaddr);\n        }\n\n        if (networkBuildDnsmasqDhcpHostsList(dctx, ipdef) < 0)\n            goto cleanup;\n\n        /* Note: the following is IPv4 only */\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET)) {\n            if (ipdef->nranges || ipdef->nhosts) {\n                virBufferAddLit(&configbuf, \"dhcp-no-override\\n\");\n                virBufferAddLit(&configbuf, \"dhcp-authoritative\\n\");\n            }\n\n            if (ipdef->tftproot) {\n                virBufferAddLit(&configbuf, \"enable-tftp\\n\");\n                virBufferAsprintf(&configbuf, \"tftp-root=%s\\n\", ipdef->tftproot);\n            }\n\n            if (ipdef->bootfile) {\n                if (VIR_SOCKET_ADDR_VALID(&ipdef->bootserver)) {\n                    char *bootserver = virSocketAddrFormat(&ipdef->bootserver);\n\n                    if (!bootserver)\n                        goto cleanup;\n                    virBufferAsprintf(&configbuf, \"dhcp-boot=%s%s%s\\n\",\n                                      ipdef->bootfile, \",,\", bootserver);\n                    VIR_FREE(bootserver);\n                } else {\n                    virBufferAsprintf(&configbuf, \"dhcp-boot=%s\\n\", ipdef->bootfile);\n                }\n            }\n        }\n        ipdef = (ipdef == ipv6def) ? NULL : ipv6def;\n    }\n\n    if (nbleases > 0)\n        virBufferAsprintf(&configbuf, \"dhcp-lease-max=%d\\n\", nbleases);\n\n    /* this is done once per interface */\n    if (networkBuildDnsmasqHostsList(dctx, dns) < 0)\n        goto cleanup;\n\n    /* Even if there are currently no static hosts, if we're\n     * listening for DHCP, we should write a 0-length hosts\n     * file to allow for runtime additions.\n     */\n    if (ipv4def || ipv6def)\n        virBufferAsprintf(&configbuf, \"dhcp-hostsfile=%s\\n\",\n                          dctx->hostsfile->path);\n\n    /* Likewise, always create this file and put it on the\n     * commandline, to allow for runtime additions.\n     */\n    if (wantDNS) {\n        virBufferAsprintf(&configbuf, \"addn-hosts=%s\\n\",\n                          dctx->addnhostsfile->path);\n    }\n\n    /* Configure DHCP to tell clients about the MTU. */\n    if (def->mtu > 0)\n        virBufferAsprintf(&configbuf, \"dhcp-option=option:mtu,%d\\n\", def->mtu);\n\n    /* Are we doing RA instead of radvd? */\n    if (DNSMASQ_RA_SUPPORT(caps)) {\n        if (ipv6def) {\n            virBufferAddLit(&configbuf, \"enable-ra\\n\");\n        } else {\n            for (i = 0;\n                 (ipdef = virNetworkDefGetIPByIndex(def, AF_INET6, i));\n                 i++) {\n                if (!(ipdef->nranges || ipdef->nhosts)) {\n                    char *bridgeaddr = virSocketAddrFormat(&ipdef->address);\n                    if (!bridgeaddr)\n                        goto cleanup;\n                    virBufferAsprintf(&configbuf,\n                                      \"dhcp-range=%s,ra-only\\n\", bridgeaddr);\n                    VIR_FREE(bridgeaddr);\n                }\n            }\n        }\n    }\n\n    if (def->namespaceData) {\n        networkDnsmasqXmlNsDefPtr dnsmasqxmlns = def->namespaceData;\n        for (i = 0; i < dnsmasqxmlns->noptions; i++)\n            virBufferAsprintf(&configbuf, \"%s\\n\", dnsmasqxmlns->options[i]);\n    }\n\n    if (!(*configstr = virBufferContentAndReset(&configbuf)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(saddr);\n    VIR_FREE(eaddr);\n    virBufferFreeAndReset(&configbuf);\n    return ret;\n}"
  },
  {
    "function_name": "networkDnsmasqConfLocalPTRs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "1075-1109",
    "snippet": "static int\nnetworkDnsmasqConfLocalPTRs(virBufferPtr buf,\n                            virNetworkDefPtr def)\n{\n    virNetworkIPDefPtr ip;\n    size_t i;\n    char *ptr = NULL;\n    int rc;\n\n    for (i = 0; i < def->nips; i++) {\n        ip = def->ips + i;\n\n        if (ip->localPTR != VIR_TRISTATE_BOOL_YES)\n            continue;\n\n        if ((rc = virSocketAddrPTRDomain(&ip->address,\n                                         virNetworkIPDefPrefix(ip),\n                                         &ptr)) < 0) {\n            if (rc == -2) {\n                int family = VIR_SOCKET_ADDR_FAMILY(&ip->address);\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"PTR domain for %s network with prefix %u \"\n                                 \"cannot be automatically created\"),\n                               (family == AF_INET) ? \"IPv4\" : \"IPv6\",\n                               virNetworkIPDefPrefix(ip));\n            }\n            return -1;\n        }\n\n        virBufferAsprintf(buf, \"local=/%s/\\n\", ptr);\n        VIR_FREE(ptr);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ptr"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"local=/%s/\\n\"",
            "ptr"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"PTR domain for %s network with prefix %u \"\n                                 \"cannot be automatically created\")",
            "(family == AF_INET) ? \"IPv4\" : \"IPv6\"",
            "virNetworkIPDefPrefix(ip)"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefPrefix",
          "args": [
            "ip"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "367-373",
          "snippet": "int\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkIPDefPrefix(const virNetworkIPDef *def)\n{\n    return virSocketAddrGetIPPrefix(&def->address,\n                                    &def->netmask,\n                                    def->prefix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"PTR domain for %s network with prefix %u \"\n                                 \"cannot be automatically created\""
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "&ip->address"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrPTRDomain",
          "args": [
            "&ip->address",
            "virNetworkIPDefPrefix(ip)",
            "&ptr"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrPTRDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1264-1315",
          "snippet": "int\nvirSocketAddrPTRDomain(const virSocketAddr *addr,\n                       unsigned int prefix,\n                       char **ptr)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    int ret = -1;\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET)) {\n        virSocketAddrIPv4 ip;\n\n        if (prefix == 0 || prefix >= 32 || prefix % 8 != 0)\n            goto unsupported;\n\n        if (virSocketAddrGetIPv4Addr(addr, &ip) < 0)\n            goto cleanup;\n\n        for (i = prefix / 8; i > 0; i--)\n            virBufferAsprintf(&buf, \"%u.\", ip[i - 1]);\n\n        virBufferAddLit(&buf, VIR_SOCKET_ADDR_IPV4_ARPA);\n    } else if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET6)) {\n        virSocketAddrIPv6Nibbles ip;\n\n        if (prefix == 0 || prefix >= 128 || prefix % 4 != 0)\n            goto unsupported;\n\n        if (virSocketAddrGetIPv6Nibbles(addr, &ip) < 0)\n            goto cleanup;\n\n        for (i = prefix / 4; i > 0; i--)\n            virBufferAsprintf(&buf, \"%x.\", ip[i - 1]);\n\n        virBufferAddLit(&buf, VIR_SOCKET_ADDR_IPV6_ARPA);\n    } else {\n        goto unsupported;\n    }\n\n    if (!(*ptr = virBufferContentAndReset(&buf)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return ret;\n\n unsupported:\n    ret = -2;\n    goto cleanup;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrPTRDomain(const virSocketAddr *addr,\n                       unsigned int prefix,\n                       char **ptr)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    int ret = -1;\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET)) {\n        virSocketAddrIPv4 ip;\n\n        if (prefix == 0 || prefix >= 32 || prefix % 8 != 0)\n            goto unsupported;\n\n        if (virSocketAddrGetIPv4Addr(addr, &ip) < 0)\n            goto cleanup;\n\n        for (i = prefix / 8; i > 0; i--)\n            virBufferAsprintf(&buf, \"%u.\", ip[i - 1]);\n\n        virBufferAddLit(&buf, VIR_SOCKET_ADDR_IPV4_ARPA);\n    } else if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET6)) {\n        virSocketAddrIPv6Nibbles ip;\n\n        if (prefix == 0 || prefix >= 128 || prefix % 4 != 0)\n            goto unsupported;\n\n        if (virSocketAddrGetIPv6Nibbles(addr, &ip) < 0)\n            goto cleanup;\n\n        for (i = prefix / 4; i > 0; i--)\n            virBufferAsprintf(&buf, \"%x.\", ip[i - 1]);\n\n        virBufferAddLit(&buf, VIR_SOCKET_ADDR_IPV6_ARPA);\n    } else {\n        goto unsupported;\n    }\n\n    if (!(*ptr = virBufferContentAndReset(&buf)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return ret;\n\n unsupported:\n    ret = -2;\n    goto cleanup;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkDnsmasqConfLocalPTRs(virBufferPtr buf,\n                            virNetworkDefPtr def)\n{\n    virNetworkIPDefPtr ip;\n    size_t i;\n    char *ptr = NULL;\n    int rc;\n\n    for (i = 0; i < def->nips; i++) {\n        ip = def->ips + i;\n\n        if (ip->localPTR != VIR_TRISTATE_BOOL_YES)\n            continue;\n\n        if ((rc = virSocketAddrPTRDomain(&ip->address,\n                                         virNetworkIPDefPrefix(ip),\n                                         &ptr)) < 0) {\n            if (rc == -2) {\n                int family = VIR_SOCKET_ADDR_FAMILY(&ip->address);\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"PTR domain for %s network with prefix %u \"\n                                 \"cannot be automatically created\"),\n                               (family == AF_INET) ? \"IPv4\" : \"IPv6\",\n                               virNetworkIPDefPrefix(ip));\n            }\n            return -1;\n        }\n\n        virBufferAsprintf(buf, \"local=/%s/\\n\", ptr);\n        VIR_FREE(ptr);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "networkBuildDnsmasqHostsList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "1054-1072",
    "snippet": "static int\nnetworkBuildDnsmasqHostsList(dnsmasqContext *dctx,\n                             virNetworkDNSDefPtr dnsdef)\n{\n    size_t i, j;\n\n    if (dnsdef) {\n        for (i = 0; i < dnsdef->nhosts; i++) {\n            virNetworkDNSHostDefPtr host = &(dnsdef->hosts[i]);\n            if (VIR_SOCKET_ADDR_VALID(&host->ip)) {\n                for (j = 0; j < host->nnames; j++)\n                    if (dnsmasqAddHost(dctx, &host->ip, host->names[j]) < 0)\n                        return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnsmasqAddHost",
          "args": [
            "dctx",
            "&host->ip",
            "host->names[j]"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqAddHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "518-524",
          "snippet": "int\ndnsmasqAddHost(dnsmasqContext *ctx,\n               virSocketAddr *ip,\n               const char *name)\n{\n    return addnhostsAdd(ctx->addnhostsfile, ip, name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\ndnsmasqAddHost(dnsmasqContext *ctx,\n               virSocketAddr *ip,\n               const char *name)\n{\n    return addnhostsAdd(ctx->addnhostsfile, ip, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&host->ip"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkBuildDnsmasqHostsList(dnsmasqContext *dctx,\n                             virNetworkDNSDefPtr dnsdef)\n{\n    size_t i, j;\n\n    if (dnsdef) {\n        for (i = 0; i < dnsdef->nhosts; i++) {\n            virNetworkDNSHostDefPtr host = &(dnsdef->hosts[i]);\n            if (VIR_SOCKET_ADDR_VALID(&host->ip)) {\n                for (j = 0; j < host->nnames; j++)\n                    if (dnsmasqAddHost(dctx, &host->ip, host->names[j]) < 0)\n                        return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "networkBuildDnsmasqDhcpHostsList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "1033-1051",
    "snippet": "static int\nnetworkBuildDnsmasqDhcpHostsList(dnsmasqContext *dctx,\n                                 virNetworkIPDefPtr ipdef)\n{\n    size_t i;\n    bool ipv6 = false;\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n        ipv6 = true;\n    for (i = 0; i < ipdef->nhosts; i++) {\n        virNetworkDHCPHostDefPtr host = &(ipdef->hosts[i]);\n        if (VIR_SOCKET_ADDR_VALID(&host->ip))\n            if (dnsmasqAddDhcpHost(dctx, host->mac, &host->ip,\n                                   host->name, host->id, ipv6) < 0)\n                return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnsmasqAddDhcpHost",
          "args": [
            "dctx",
            "host->mac",
            "&host->ip",
            "host->name",
            "host->id",
            "ipv6"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqAddDhcpHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "498-507",
          "snippet": "int\ndnsmasqAddDhcpHost(dnsmasqContext *ctx,\n                   const char *mac,\n                   virSocketAddr *ip,\n                   const char *name,\n                   const char *id,\n                   bool ipv6)\n{\n    return hostsfileAdd(ctx->hostsfile, mac, ip, name, id, ipv6);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\ndnsmasqAddDhcpHost(dnsmasqContext *ctx,\n                   const char *mac,\n                   virSocketAddr *ip,\n                   const char *name,\n                   const char *id,\n                   bool ipv6)\n{\n    return hostsfileAdd(ctx->hostsfile, mac, ip, name, id, ipv6);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&host->ip"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ipdef->address",
            "AF_INET6"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkBuildDnsmasqDhcpHostsList(dnsmasqContext *dctx,\n                                 virNetworkIPDefPtr ipdef)\n{\n    size_t i;\n    bool ipv6 = false;\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(&ipdef->address, AF_INET6))\n        ipv6 = true;\n    for (i = 0; i < ipdef->nhosts; i++) {\n        virNetworkDHCPHostDefPtr host = &(ipdef->hosts[i]);\n        if (VIR_SOCKET_ADDR_VALID(&host->ip))\n            if (dnsmasqAddDhcpHost(dctx, host->mac, &host->ip,\n                                   host->name, host->id, ipv6) < 0)\n                return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "networkKillDaemon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "973-1027",
    "snippet": "static int\nnetworkKillDaemon(pid_t pid,\n                  const char *daemonName,\n                  const char *networkName)\n{\n    size_t i;\n    int ret = -1;\n    const char *signame = \"TERM\";\n\n    /* send SIGTERM, then wait up to 3 seconds for the process to\n     * disappear, send SIGKILL, then wait for up to another 2\n     * seconds. If that fails, log a warning and continue, hoping\n     * for the best.\n     */\n    for (i = 0; i < 25; i++) {\n        int signum = 0;\n        if (i == 0) {\n            signum = SIGTERM;\n        } else if (i == 15) {\n            signum = SIGKILL;\n            signame = \"KILL\";\n        }\n        if (kill(pid, signum) < 0) {\n            if (errno == ESRCH) {\n                ret = 0;\n            } else {\n                VIR_WARN(\"Failed to terminate %s process %d \"\n                         \"for network '%s' with SIG%s: %s\",\n                         daemonName, pid, networkName, signame,\n                         g_strerror(errno));\n            }\n            return ret;\n        }\n        /* NB: since networks have no reference count like\n         * domains, there is no safe way to unlock the network\n         * object temporarily, and so we can't follow the\n         * procedure used by the qemu driver of 1) unlock driver\n         * 2) sleep, 3) add ref to object 4) unlock object, 5)\n         * re-lock driver, 6) re-lock object. We may need to add\n         * that functionality eventually, but for now this\n         * function is rarely used and, at worst, leaving the\n         * network driver locked during this loop of sleeps will\n         * have the effect of holding up any other thread trying\n         * to make modifications to a network for up to 5 seconds;\n         * since modifications to networks are much less common\n         * than modifications to domains, this seems a reasonable\n         * tradeoff in exchange for less code disruption.\n         */\n        g_usleep(20 * 1000);\n    }\n    VIR_WARN(\"Timed out waiting after SIG%s to %s process %d \"\n             \"(network '%s')\",\n             signame, daemonName, pid, networkName);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Timed out waiting after SIG%s to %s process %d \"\n             \"(network '%s')\"",
            "signame",
            "daemonName",
            "pid",
            "networkName"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "20 * 1000"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to terminate %s process %d \"\n                         \"for network '%s' with SIG%s: %s\"",
            "daemonName",
            "pid",
            "networkName",
            "signame",
            "g_strerror(errno)"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "signum"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkKillDaemon(pid_t pid,\n                  const char *daemonName,\n                  const char *networkName)\n{\n    size_t i;\n    int ret = -1;\n    const char *signame = \"TERM\";\n\n    /* send SIGTERM, then wait up to 3 seconds for the process to\n     * disappear, send SIGKILL, then wait for up to another 2\n     * seconds. If that fails, log a warning and continue, hoping\n     * for the best.\n     */\n    for (i = 0; i < 25; i++) {\n        int signum = 0;\n        if (i == 0) {\n            signum = SIGTERM;\n        } else if (i == 15) {\n            signum = SIGKILL;\n            signame = \"KILL\";\n        }\n        if (kill(pid, signum) < 0) {\n            if (errno == ESRCH) {\n                ret = 0;\n            } else {\n                VIR_WARN(\"Failed to terminate %s process %d \"\n                         \"for network '%s' with SIG%s: %s\",\n                         daemonName, pid, networkName, signame,\n                         g_strerror(errno));\n            }\n            return ret;\n        }\n        /* NB: since networks have no reference count like\n         * domains, there is no safe way to unlock the network\n         * object temporarily, and so we can't follow the\n         * procedure used by the qemu driver of 1) unlock driver\n         * 2) sleep, 3) add ref to object 4) unlock object, 5)\n         * re-lock driver, 6) re-lock object. We may need to add\n         * that functionality eventually, but for now this\n         * function is rarely used and, at worst, leaving the\n         * network driver locked during this loop of sleeps will\n         * have the effect of holding up any other thread trying\n         * to make modifications to a network for up to 5 seconds;\n         * since modifications to networks are much less common\n         * than modifications to domains, this seems a reasonable\n         * tradeoff in exchange for less code disruption.\n         */\n        g_usleep(20 * 1000);\n    }\n    VIR_WARN(\"Timed out waiting after SIG%s to %s process %d \"\n             \"(network '%s')\",\n             signame, daemonName, pid, networkName);\n    return ret;\n}"
  },
  {
    "function_name": "networkConnectIsAlive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "963-966",
    "snippet": "static int networkConnectIsAlive(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 1;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int networkConnectIsAlive(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 1;\n}"
  },
  {
    "function_name": "networkConnectIsEncrypted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "956-960",
    "snippet": "static int networkConnectIsEncrypted(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* Not encrypted, but remote driver takes care of that */\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int networkConnectIsEncrypted(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* Not encrypted, but remote driver takes care of that */\n    return 0;\n}"
  },
  {
    "function_name": "networkConnectIsSecure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "949-953",
    "snippet": "static int networkConnectIsSecure(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* Trivially secure, since always inside the daemon */\n    return 1;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int networkConnectIsSecure(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* Trivially secure, since always inside the daemon */\n    return 1;\n}"
  },
  {
    "function_name": "networkConnectClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "943-946",
    "snippet": "static int networkConnectClose(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int networkConnectClose(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "networkConnectOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "918-941",
    "snippet": "static virDrvOpenStatus\nnetworkConnectOpen(virConnectPtr conn,\n                   virConnectAuthPtr auth G_GNUC_UNUSED,\n                   virConfPtr conf G_GNUC_UNUSED,\n                   unsigned int flags)\n{\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    if (network_driver == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"network state driver is not active\"));\n        return VIR_DRV_OPEN_ERROR;\n    }\n\n    if (!virConnectValidateURIPath(conn->uri->path,\n                                   \"network\",\n                                   network_driver->privileged))\n        return VIR_DRV_OPEN_ERROR;\n\n    if (virConnectOpenEnsureACL(conn) < 0)\n        return VIR_DRV_OPEN_ERROR;\n\n    return VIR_DRV_OPEN_SUCCESS;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverStatePtr network_driver;",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConnectOpenEnsureACL",
          "args": [
            "conn"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConnectValidateURIPath",
          "args": [
            "conn->uri->path",
            "\"network\"",
            "network_driver->privileged"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectValidateURIPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "260-296",
          "snippet": "bool\nvirConnectValidateURIPath(const char *uriPath,\n                          const char *entityName,\n                          bool privileged)\n{\n    if (privileged) {\n        /* TODO: qemu and vbox drivers allow '/session'\n         * connections as root. This is not ideal, but changing\n         * these drivers to refuse privileged '/session'\n         * connections, like everyone else is already doing, can\n         * break existing applications. Until we decide what to do,\n         * for now we can handle them as exception in this validate\n         * function.\n         */\n        bool compatSessionRoot = (STREQ(entityName, \"qemu\") ||\n                                  STREQ(entityName, \"vbox\")) &&\n                                  STREQ(uriPath, \"/session\");\n\n        if (STRNEQ(uriPath, \"/system\") && !compatSessionRoot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///system\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    } else {\n        if (STRNEQ(uriPath, \"/session\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///session\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirConnectValidateURIPath(const char *uriPath,\n                          const char *entityName,\n                          bool privileged)\n{\n    if (privileged) {\n        /* TODO: qemu and vbox drivers allow '/session'\n         * connections as root. This is not ideal, but changing\n         * these drivers to refuse privileged '/session'\n         * connections, like everyone else is already doing, can\n         * break existing applications. Until we decide what to do,\n         * for now we can handle them as exception in this validate\n         * function.\n         */\n        bool compatSessionRoot = (STREQ(entityName, \"qemu\") ||\n                                  STREQ(entityName, \"vbox\")) &&\n                                  STREQ(uriPath, \"/session\");\n\n        if (STRNEQ(uriPath, \"/system\") && !compatSessionRoot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///system\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    } else {\n        if (STRNEQ(uriPath, \"/session\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///session\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"network state driver is not active\")"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"network state driver is not active\""
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_RO",
            "VIR_DRV_OPEN_ERROR"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virDrvOpenStatus\nnetworkConnectOpen(virConnectPtr conn,\n                   virConnectAuthPtr auth G_GNUC_UNUSED,\n                   virConfPtr conf G_GNUC_UNUSED,\n                   unsigned int flags)\n{\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    if (network_driver == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"network state driver is not active\"));\n        return VIR_DRV_OPEN_ERROR;\n    }\n\n    if (!virConnectValidateURIPath(conn->uri->path,\n                                   \"network\",\n                                   network_driver->privileged))\n        return VIR_DRV_OPEN_ERROR;\n\n    if (virConnectOpenEnsureACL(conn) < 0)\n        return VIR_DRV_OPEN_ERROR;\n\n    return VIR_DRV_OPEN_SUCCESS;\n}"
  },
  {
    "function_name": "networkStateCleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "885-915",
    "snippet": "static int\nnetworkStateCleanup(void)\n{\n    if (!network_driver)\n        return -1;\n\n    virObjectUnref(network_driver->networkEventState);\n    virObjectUnref(network_driver->xmlopt);\n\n    /* free inactive networks */\n    virObjectUnref(network_driver->networks);\n\n    if (network_driver->lockFD != -1)\n        virPidFileRelease(network_driver->stateDir, \"driver\",\n                          network_driver->lockFD);\n\n    VIR_FREE(network_driver->networkConfigDir);\n    VIR_FREE(network_driver->networkAutostartDir);\n    VIR_FREE(network_driver->stateDir);\n    VIR_FREE(network_driver->pidDir);\n    VIR_FREE(network_driver->dnsmasqStateDir);\n    VIR_FREE(network_driver->radvdStateDir);\n\n    virObjectUnref(network_driver->dnsmasqCaps);\n\n    virMutexDestroy(&network_driver->lock);\n\n    VIR_FREE(network_driver);\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverStatePtr network_driver;",
      "static int\nnetworkStateCleanup(void);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "network_driver"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&network_driver->lock"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "network_driver->dnsmasqCaps"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "network_driver->radvdStateDir"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "network_driver->dnsmasqStateDir"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "network_driver->pidDir"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "network_driver->stateDir"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "network_driver->networkAutostartDir"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "network_driver->networkConfigDir"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileRelease",
          "args": [
            "network_driver->stateDir",
            "\"driver\"",
            "network_driver->lockFD"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "453-466",
          "snippet": "int virPidFileRelease(const char *dir,\n                      const char *name,\n                      int fd)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileReleasePath(pidfile, fd);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileRelease(const char *dir,\n                      const char *name,\n                      int fd)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileReleasePath(pidfile, fd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStateCleanup(void);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStateCleanup(void)\n{\n    if (!network_driver)\n        return -1;\n\n    virObjectUnref(network_driver->networkEventState);\n    virObjectUnref(network_driver->xmlopt);\n\n    /* free inactive networks */\n    virObjectUnref(network_driver->networks);\n\n    if (network_driver->lockFD != -1)\n        virPidFileRelease(network_driver->stateDir, \"driver\",\n                          network_driver->lockFD);\n\n    VIR_FREE(network_driver->networkConfigDir);\n    VIR_FREE(network_driver->networkAutostartDir);\n    VIR_FREE(network_driver->stateDir);\n    VIR_FREE(network_driver->pidDir);\n    VIR_FREE(network_driver->dnsmasqStateDir);\n    VIR_FREE(network_driver->radvdStateDir);\n\n    virObjectUnref(network_driver->dnsmasqCaps);\n\n    virMutexDestroy(&network_driver->lock);\n\n    VIR_FREE(network_driver);\n\n    return 0;\n}"
  },
  {
    "function_name": "networkStateReload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "858-877",
    "snippet": "static int\nnetworkStateReload(void)\n{\n    if (!network_driver)\n        return 0;\n\n    virNetworkObjLoadAllState(network_driver->networks,\n                              network_driver->stateDir,\n                              network_driver->xmlopt);\n    virNetworkObjLoadAllConfigs(network_driver->networks,\n                                network_driver->networkConfigDir,\n                                network_driver->networkAutostartDir,\n                                network_driver->xmlopt);\n    networkReloadFirewallRules(network_driver, false);\n    networkRefreshDaemons(network_driver);\n    virNetworkObjListForEach(network_driver->networks,\n                             networkAutostartConfig,\n                             network_driver);\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverStatePtr network_driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkObjListForEach",
          "args": [
            "network_driver->networks",
            "networkAutostartConfig",
            "network_driver"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjListForEach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1472-1483",
          "snippet": "int\nvirNetworkObjListForEach(virNetworkObjListPtr nets,\n                         virNetworkObjListIterator callback,\n                         void *opaque)\n{\n    struct virNetworkObjListForEachHelperData data = {\n        .callback = callback, .opaque = opaque, .ret = 0};\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListForEachHelper, &data);\n    virObjectRWUnlock(nets);\n    return data.ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirNetworkObjListForEach(virNetworkObjListPtr nets,\n                         virNetworkObjListIterator callback,\n                         void *opaque)\n{\n    struct virNetworkObjListForEachHelperData data = {\n        .callback = callback, .opaque = opaque, .ret = 0};\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListForEachHelper, &data);\n    virObjectRWUnlock(nets);\n    return data.ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRefreshDaemons",
          "args": [
            "network_driver"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "networkRefreshDaemons",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2184-2191",
          "snippet": "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver)\n{\n    VIR_INFO(\"Refreshing network daemons\");\n    virNetworkObjListForEach(driver->networks,\n                             networkRefreshDaemonsHelper,\n                             driver);\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver)\n{\n    VIR_INFO(\"Refreshing network daemons\");\n    virNetworkObjListForEach(driver->networks,\n                             networkRefreshDaemonsHelper,\n                             driver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkReloadFirewallRules",
          "args": [
            "network_driver",
            "false"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "networkReloadFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2237-2250",
          "snippet": "static void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup)\n{\n    VIR_INFO(\"Reloading iptables rules\");\n    /* Ideally we'd not even register the driver when unprivilegd\n     * but until we untangle the virt driver that's not viable */\n    if (!driver->privileged)\n        return;\n    networkPreReloadFirewallRules(driver, startup);\n    virNetworkObjListForEach(driver->networks,\n                             networkReloadFirewallRulesHelper,\n                             NULL);\n    networkPostReloadFirewallRules(startup);\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup)\n{\n    VIR_INFO(\"Reloading iptables rules\");\n    /* Ideally we'd not even register the driver when unprivilegd\n     * but until we untangle the virt driver that's not viable */\n    if (!driver->privileged)\n        return;\n    networkPreReloadFirewallRules(driver, startup);\n    virNetworkObjListForEach(driver->networks,\n                             networkReloadFirewallRulesHelper,\n                             NULL);\n    networkPostReloadFirewallRules(startup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjLoadAllConfigs",
          "args": [
            "network_driver->networks",
            "network_driver->networkConfigDir",
            "network_driver->networkAutostartDir",
            "network_driver->xmlopt"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjLoadAllConfigs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1111-1143",
          "snippet": "int\nvirNetworkObjLoadAllConfigs(virNetworkObjListPtr nets,\n                            const char *configDir,\n                            const char *autostartDir,\n                            virNetworkXMLOptionPtr xmlopt)\n{\n    DIR *dir;\n    struct dirent *entry;\n    int ret = -1;\n    int rc;\n\n    if ((rc = virDirOpenIfExists(&dir, configDir)) <= 0)\n        return rc;\n\n    while ((ret = virDirRead(dir, &entry, configDir)) > 0) {\n        virNetworkObjPtr obj;\n\n        if (!virStringStripSuffix(entry->d_name, \".xml\"))\n            continue;\n\n        /* NB: ignoring errors, so one malformed config doesn't\n           kill the whole process */\n        obj = virNetworkLoadConfig(nets,\n                                   configDir,\n                                   autostartDir,\n                                   entry->d_name,\n                                   xmlopt);\n        virNetworkObjEndAPI(&obj);\n    }\n\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nint\nvirNetworkObjLoadAllConfigs(virNetworkObjListPtr nets,\n                            const char *configDir,\n                            const char *autostartDir,\n                            virNetworkXMLOptionPtr xmlopt)\n{\n    DIR *dir;\n    struct dirent *entry;\n    int ret = -1;\n    int rc;\n\n    if ((rc = virDirOpenIfExists(&dir, configDir)) <= 0)\n        return rc;\n\n    while ((ret = virDirRead(dir, &entry, configDir)) > 0) {\n        virNetworkObjPtr obj;\n\n        if (!virStringStripSuffix(entry->d_name, \".xml\"))\n            continue;\n\n        /* NB: ignoring errors, so one malformed config doesn't\n           kill the whole process */\n        obj = virNetworkLoadConfig(nets,\n                                   configDir,\n                                   autostartDir,\n                                   entry->d_name,\n                                   xmlopt);\n        virNetworkObjEndAPI(&obj);\n    }\n\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjLoadAllState",
          "args": [
            "network_driver->networks",
            "network_driver->stateDir",
            "network_driver->xmlopt"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjLoadAllState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1076-1108",
          "snippet": "int\nvirNetworkObjLoadAllState(virNetworkObjListPtr nets,\n                          const char *stateDir,\n                          virNetworkXMLOptionPtr xmlopt)\n{\n    DIR *dir;\n    struct dirent *entry;\n    int ret = -1;\n    int rc;\n\n    if ((rc = virDirOpenIfExists(&dir, stateDir)) <= 0)\n        return rc;\n\n    while ((ret = virDirRead(dir, &entry, stateDir)) > 0) {\n        virNetworkObjPtr obj;\n\n        if (!virStringStripSuffix(entry->d_name, \".xml\"))\n            continue;\n\n        obj = virNetworkLoadState(nets, stateDir, entry->d_name, xmlopt);\n\n        if (obj &&\n            virNetworkObjLoadAllPorts(obj, stateDir) < 0) {\n            virNetworkObjEndAPI(&obj);\n            goto cleanup;\n        }\n        virNetworkObjEndAPI(&obj);\n    }\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);",
            "static int\nvirNetworkObjLoadAllPorts(virNetworkObjPtr net,\n                          const char *stateDir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\nstatic int\nvirNetworkObjLoadAllPorts(virNetworkObjPtr net,\n                          const char *stateDir);\n\nint\nvirNetworkObjLoadAllState(virNetworkObjListPtr nets,\n                          const char *stateDir,\n                          virNetworkXMLOptionPtr xmlopt)\n{\n    DIR *dir;\n    struct dirent *entry;\n    int ret = -1;\n    int rc;\n\n    if ((rc = virDirOpenIfExists(&dir, stateDir)) <= 0)\n        return rc;\n\n    while ((ret = virDirRead(dir, &entry, stateDir)) > 0) {\n        virNetworkObjPtr obj;\n\n        if (!virStringStripSuffix(entry->d_name, \".xml\"))\n            continue;\n\n        obj = virNetworkLoadState(nets, stateDir, entry->d_name, xmlopt);\n\n        if (obj &&\n            virNetworkObjLoadAllPorts(obj, stateDir) < 0) {\n            virNetworkObjEndAPI(&obj);\n            goto cleanup;\n        }\n        virNetworkObjEndAPI(&obj);\n    }\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic int\nnetworkStateReload(void)\n{\n    if (!network_driver)\n        return 0;\n\n    virNetworkObjLoadAllState(network_driver->networks,\n                              network_driver->stateDir,\n                              network_driver->xmlopt);\n    virNetworkObjLoadAllConfigs(network_driver->networks,\n                                network_driver->networkConfigDir,\n                                network_driver->networkAutostartDir,\n                                network_driver->xmlopt);\n    networkReloadFirewallRules(network_driver, false);\n    networkRefreshDaemons(network_driver);\n    virNetworkObjListForEach(network_driver->networks,\n                             networkAutostartConfig,\n                             network_driver);\n    return 0;\n}"
  },
  {
    "function_name": "networkStateInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "705-849",
    "snippet": "static int\nnetworkStateInitialize(bool privileged,\n                       const char *root,\n                       virStateInhibitCallback callback G_GNUC_UNUSED,\n                       void *opaque G_GNUC_UNUSED)\n{\n    int ret = VIR_DRV_STATE_INIT_ERROR;\n    char *configdir = NULL;\n    char *rundir = NULL;\n    bool autostart = true;\n#ifdef WITH_FIREWALLD\n    DBusConnection *sysbus = NULL;\n#endif\n\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(network_driver) < 0)\n        goto error;\n\n    network_driver->lockFD = -1;\n    if (virMutexInit(&network_driver->lock) < 0) {\n        VIR_FREE(network_driver);\n        goto error;\n    }\n\n    network_driver->privileged = privileged;\n\n    if (!(network_driver->xmlopt = networkDnsmasqCreateXMLConf()))\n        goto error;\n\n    /* configuration/state paths are one of\n     * ~/.config/libvirt/... (session/unprivileged)\n     * /etc/libvirt/... && /var/(run|lib)/libvirt/... (system/privileged).\n     */\n    if (privileged) {\n        network_driver->networkConfigDir = g_strdup(SYSCONFDIR \"/libvirt/qemu/networks\");\n        network_driver->networkAutostartDir = g_strdup(SYSCONFDIR \"/libvirt/qemu/networks/autostart\");\n        network_driver->stateDir = g_strdup(RUNSTATEDIR \"/libvirt/network\");\n        network_driver->pidDir = g_strdup(RUNSTATEDIR \"/libvirt/network\");\n        network_driver->dnsmasqStateDir = g_strdup(LOCALSTATEDIR \"/lib/libvirt/dnsmasq\");\n        network_driver->radvdStateDir = g_strdup(LOCALSTATEDIR \"/lib/libvirt/radvd\");\n    } else {\n        configdir = virGetUserConfigDirectory();\n        rundir = virGetUserRuntimeDirectory();\n\n        network_driver->networkConfigDir = g_strdup_printf(\"%s/qemu/networks\", configdir);\n        network_driver->networkAutostartDir = g_strdup_printf(\"%s/qemu/networks/autostart\", configdir);\n        network_driver->stateDir = g_strdup_printf(\"%s/network/lib\", rundir);\n        network_driver->pidDir = g_strdup_printf(\"%s/network/run\", rundir);\n        network_driver->dnsmasqStateDir = g_strdup_printf(\"%s/dnsmasq/lib\", rundir);\n        network_driver->radvdStateDir = g_strdup_printf(\"%s/radvd/lib\", rundir);\n    }\n\n    if (virFileMakePath(network_driver->stateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             network_driver->stateDir);\n        goto error;\n    }\n\n    if ((network_driver->lockFD =\n         virPidFileAcquire(network_driver->stateDir, \"driver\",\n                           false, getpid())) < 0)\n        goto error;\n\n    /* if this fails now, it will be retried later with dnsmasqCapsRefresh() */\n    network_driver->dnsmasqCaps = dnsmasqCapsNewFromBinary(DNSMASQ);\n\n    if (!(network_driver->networks = virNetworkObjListNew()))\n        goto error;\n\n    if (virNetworkObjLoadAllState(network_driver->networks,\n                                  network_driver->stateDir,\n                                  network_driver->xmlopt) < 0)\n        goto error;\n\n    if (virNetworkObjLoadAllConfigs(network_driver->networks,\n                                    network_driver->networkConfigDir,\n                                    network_driver->networkAutostartDir,\n                                    network_driver->xmlopt) < 0)\n        goto error;\n\n    /* Update the internal status of all allegedly active\n     * networks according to external conditions on the host\n     * (i.e. anything that isn't stored directly in each\n     * network's state file). */\n    virNetworkObjListForEach(network_driver->networks,\n                             networkUpdateState,\n                             network_driver);\n    virNetworkObjListPrune(network_driver->networks,\n                           VIR_CONNECT_LIST_NETWORKS_INACTIVE |\n                           VIR_CONNECT_LIST_NETWORKS_TRANSIENT);\n    networkReloadFirewallRules(network_driver, true);\n    networkRefreshDaemons(network_driver);\n\n    if (virDriverShouldAutostart(network_driver->stateDir, &autostart) < 0)\n        goto error;\n\n    if (autostart) {\n        virNetworkObjListForEach(network_driver->networks,\n                                 networkAutostartConfig,\n                                 network_driver);\n    }\n\n    network_driver->networkEventState = virObjectEventStateNew();\n\n#ifdef WITH_FIREWALLD\n    if (!(sysbus = virDBusGetSystemBus())) {\n        VIR_WARN(\"DBus not available, disabling firewalld support \"\n                 \"in bridge_network_driver: %s\", virGetLastErrorMessage());\n    } else {\n        /* add matches for\n         * NameOwnerChanged on org.freedesktop.DBus for firewalld start/stop\n         * Reloaded on org.fedoraproject.FirewallD1 for firewalld reload\n         */\n        dbus_bus_add_match(sysbus,\n                           \"type='signal'\"\n                           \",interface='\"DBUS_INTERFACE_DBUS\"'\"\n                           \",member='NameOwnerChanged'\"\n                           \",arg0='org.fedoraproject.FirewallD1'\",\n                           NULL);\n        dbus_bus_add_match(sysbus,\n                           \"type='signal'\"\n                           \",interface='org.fedoraproject.FirewallD1'\"\n                           \",member='Reloaded'\",\n                           NULL);\n        dbus_connection_add_filter(sysbus, firewalld_dbus_filter_bridge,\n                                   network_driver, NULL);\n    }\n#endif\n\n    ret = VIR_DRV_STATE_INIT_COMPLETE;\n cleanup:\n    VIR_FREE(configdir);\n    VIR_FREE(rundir);\n    return ret;\n\n error:\n    networkStateCleanup();\n    goto cleanup;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverStatePtr network_driver;",
      "static int\nnetworkStateCleanup(void);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkStateCleanup",
          "args": [],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "networkStateCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "885-915",
          "snippet": "static int\nnetworkStateCleanup(void)\n{\n    if (!network_driver)\n        return -1;\n\n    virObjectUnref(network_driver->networkEventState);\n    virObjectUnref(network_driver->xmlopt);\n\n    /* free inactive networks */\n    virObjectUnref(network_driver->networks);\n\n    if (network_driver->lockFD != -1)\n        virPidFileRelease(network_driver->stateDir, \"driver\",\n                          network_driver->lockFD);\n\n    VIR_FREE(network_driver->networkConfigDir);\n    VIR_FREE(network_driver->networkAutostartDir);\n    VIR_FREE(network_driver->stateDir);\n    VIR_FREE(network_driver->pidDir);\n    VIR_FREE(network_driver->dnsmasqStateDir);\n    VIR_FREE(network_driver->radvdStateDir);\n\n    virObjectUnref(network_driver->dnsmasqCaps);\n\n    virMutexDestroy(&network_driver->lock);\n\n    VIR_FREE(network_driver);\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStateCleanup(void);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStateCleanup(void);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStateCleanup(void)\n{\n    if (!network_driver)\n        return -1;\n\n    virObjectUnref(network_driver->networkEventState);\n    virObjectUnref(network_driver->xmlopt);\n\n    /* free inactive networks */\n    virObjectUnref(network_driver->networks);\n\n    if (network_driver->lockFD != -1)\n        virPidFileRelease(network_driver->stateDir, \"driver\",\n                          network_driver->lockFD);\n\n    VIR_FREE(network_driver->networkConfigDir);\n    VIR_FREE(network_driver->networkAutostartDir);\n    VIR_FREE(network_driver->stateDir);\n    VIR_FREE(network_driver->pidDir);\n    VIR_FREE(network_driver->dnsmasqStateDir);\n    VIR_FREE(network_driver->radvdStateDir);\n\n    virObjectUnref(network_driver->dnsmasqCaps);\n\n    virMutexDestroy(&network_driver->lock);\n\n    VIR_FREE(network_driver);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "rundir"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "configdir"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_connection_add_filter",
          "args": [
            "sysbus",
            "firewalld_dbus_filter_bridge",
            "network_driver",
            "NULL"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_bus_add_match",
          "args": [
            "sysbus",
            "\"type='signal'\"\n                           \",interface='org.fedoraproject.FirewallD1'\"\n                           \",member='Reloaded'\"",
            "NULL"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_bus_add_match",
          "args": [
            "sysbus",
            "\"type='signal'\"\n                           \",interface='\"DBUS_INTERFACE_DBUS\"'\"\n                           \",member='NameOwnerChanged'\"\n                           \",arg0='org.fedoraproject.FirewallD1'\"",
            "NULL"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"DBus not available, disabling firewalld support \"\n                 \"in bridge_network_driver: %s\"",
            "virGetLastErrorMessage()"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDBusGetSystemBus",
          "args": [],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusGetSystemBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1744-1749",
          "snippet": "DBusConnection *virDBusGetSystemBus(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return NULL;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nDBusConnection *virDBusGetSystemBus(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateNew",
          "args": [],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "558-582",
          "snippet": "virObjectEventStatePtr\nvirObjectEventStateNew(void)\n{\n    virObjectEventStatePtr state = NULL;\n\n    if (virObjectEventInitialize() < 0)\n        return NULL;\n\n    if (!(state = virObjectLockableNew(virObjectEventStateClass)))\n        return NULL;\n\n    if (VIR_ALLOC(state->callbacks) < 0)\n        goto error;\n\n    if (!(state->queue = virObjectEventQueueNew()))\n        goto error;\n\n    state->timer = -1;\n\n    return state;\n\n error:\n    virObjectUnref(state);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectEventStateClass;",
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectEventStateClass;\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvirObjectEventStatePtr\nvirObjectEventStateNew(void)\n{\n    virObjectEventStatePtr state = NULL;\n\n    if (virObjectEventInitialize() < 0)\n        return NULL;\n\n    if (!(state = virObjectLockableNew(virObjectEventStateClass)))\n        return NULL;\n\n    if (VIR_ALLOC(state->callbacks) < 0)\n        goto error;\n\n    if (!(state->queue = virObjectEventQueueNew()))\n        goto error;\n\n    state->timer = -1;\n\n    return state;\n\n error:\n    virObjectUnref(state);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjListForEach",
          "args": [
            "network_driver->networks",
            "networkAutostartConfig",
            "network_driver"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjListForEach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1472-1483",
          "snippet": "int\nvirNetworkObjListForEach(virNetworkObjListPtr nets,\n                         virNetworkObjListIterator callback,\n                         void *opaque)\n{\n    struct virNetworkObjListForEachHelperData data = {\n        .callback = callback, .opaque = opaque, .ret = 0};\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListForEachHelper, &data);\n    virObjectRWUnlock(nets);\n    return data.ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirNetworkObjListForEach(virNetworkObjListPtr nets,\n                         virNetworkObjListIterator callback,\n                         void *opaque)\n{\n    struct virNetworkObjListForEachHelperData data = {\n        .callback = callback, .opaque = opaque, .ret = 0};\n    virObjectRWLockRead(nets);\n    virHashForEach(nets->objs, virNetworkObjListForEachHelper, &data);\n    virObjectRWUnlock(nets);\n    return data.ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDriverShouldAutostart",
          "args": [
            "network_driver->stateDir",
            "&autostart"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "virDriverShouldAutostart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "86-108",
          "snippet": "int\nvirDriverShouldAutostart(const char *dir,\n                         bool *autostart)\n{\n    g_autofree char *path = NULL;\n\n    *autostart = false;\n\n    path = g_strdup_printf(\"%s/autostarted\", dir);\n\n    if (virFileExists(path)) {\n        VIR_DEBUG(\"Autostart file %s exists, skipping autostart\", path);\n        return 0;\n    }\n\n    VIR_DEBUG(\"Autostart file %s does not exist, do autostart\", path);\n    *autostart = true;\n\n    if (virFileTouch(path, 0600) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirDriverShouldAutostart(const char *dir,\n                         bool *autostart)\n{\n    g_autofree char *path = NULL;\n\n    *autostart = false;\n\n    path = g_strdup_printf(\"%s/autostarted\", dir);\n\n    if (virFileExists(path)) {\n        VIR_DEBUG(\"Autostart file %s exists, skipping autostart\", path);\n        return 0;\n    }\n\n    VIR_DEBUG(\"Autostart file %s does not exist, do autostart\", path);\n    *autostart = true;\n\n    if (virFileTouch(path, 0600) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRefreshDaemons",
          "args": [
            "network_driver"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "networkRefreshDaemons",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2184-2191",
          "snippet": "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver)\n{\n    VIR_INFO(\"Refreshing network daemons\");\n    virNetworkObjListForEach(driver->networks,\n                             networkRefreshDaemonsHelper,\n                             driver);\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver)\n{\n    VIR_INFO(\"Refreshing network daemons\");\n    virNetworkObjListForEach(driver->networks,\n                             networkRefreshDaemonsHelper,\n                             driver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkReloadFirewallRules",
          "args": [
            "network_driver",
            "true"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "networkReloadFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2237-2250",
          "snippet": "static void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup)\n{\n    VIR_INFO(\"Reloading iptables rules\");\n    /* Ideally we'd not even register the driver when unprivilegd\n     * but until we untangle the virt driver that's not viable */\n    if (!driver->privileged)\n        return;\n    networkPreReloadFirewallRules(driver, startup);\n    virNetworkObjListForEach(driver->networks,\n                             networkReloadFirewallRulesHelper,\n                             NULL);\n    networkPostReloadFirewallRules(startup);\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup)\n{\n    VIR_INFO(\"Reloading iptables rules\");\n    /* Ideally we'd not even register the driver when unprivilegd\n     * but until we untangle the virt driver that's not viable */\n    if (!driver->privileged)\n        return;\n    networkPreReloadFirewallRules(driver, startup);\n    virNetworkObjListForEach(driver->networks,\n                             networkReloadFirewallRulesHelper,\n                             NULL);\n    networkPostReloadFirewallRules(startup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjListPrune",
          "args": [
            "network_driver->networks",
            "VIR_CONNECT_LIST_NETWORKS_INACTIVE |\n                           VIR_CONNECT_LIST_NETWORKS_TRANSIENT"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjListPrune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1607-1616",
          "snippet": "void\nvirNetworkObjListPrune(virNetworkObjListPtr nets,\n                       unsigned int flags)\n{\n    struct virNetworkObjListPruneHelperData data = {flags};\n\n    virObjectRWLockWrite(nets);\n    virHashRemoveSet(nets->objs, virNetworkObjListPruneHelper, &data);\n    virObjectRWUnlock(nets);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirNetworkObjListPrune(virNetworkObjListPtr nets,\n                       unsigned int flags)\n{\n    struct virNetworkObjListPruneHelperData data = {flags};\n\n    virObjectRWLockWrite(nets);\n    virHashRemoveSet(nets->objs, virNetworkObjListPruneHelper, &data);\n    virObjectRWUnlock(nets);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjLoadAllConfigs",
          "args": [
            "network_driver->networks",
            "network_driver->networkConfigDir",
            "network_driver->networkAutostartDir",
            "network_driver->xmlopt"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjLoadAllConfigs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1111-1143",
          "snippet": "int\nvirNetworkObjLoadAllConfigs(virNetworkObjListPtr nets,\n                            const char *configDir,\n                            const char *autostartDir,\n                            virNetworkXMLOptionPtr xmlopt)\n{\n    DIR *dir;\n    struct dirent *entry;\n    int ret = -1;\n    int rc;\n\n    if ((rc = virDirOpenIfExists(&dir, configDir)) <= 0)\n        return rc;\n\n    while ((ret = virDirRead(dir, &entry, configDir)) > 0) {\n        virNetworkObjPtr obj;\n\n        if (!virStringStripSuffix(entry->d_name, \".xml\"))\n            continue;\n\n        /* NB: ignoring errors, so one malformed config doesn't\n           kill the whole process */\n        obj = virNetworkLoadConfig(nets,\n                                   configDir,\n                                   autostartDir,\n                                   entry->d_name,\n                                   xmlopt);\n        virNetworkObjEndAPI(&obj);\n    }\n\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nint\nvirNetworkObjLoadAllConfigs(virNetworkObjListPtr nets,\n                            const char *configDir,\n                            const char *autostartDir,\n                            virNetworkXMLOptionPtr xmlopt)\n{\n    DIR *dir;\n    struct dirent *entry;\n    int ret = -1;\n    int rc;\n\n    if ((rc = virDirOpenIfExists(&dir, configDir)) <= 0)\n        return rc;\n\n    while ((ret = virDirRead(dir, &entry, configDir)) > 0) {\n        virNetworkObjPtr obj;\n\n        if (!virStringStripSuffix(entry->d_name, \".xml\"))\n            continue;\n\n        /* NB: ignoring errors, so one malformed config doesn't\n           kill the whole process */\n        obj = virNetworkLoadConfig(nets,\n                                   configDir,\n                                   autostartDir,\n                                   entry->d_name,\n                                   xmlopt);\n        virNetworkObjEndAPI(&obj);\n    }\n\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjLoadAllState",
          "args": [
            "network_driver->networks",
            "network_driver->stateDir",
            "network_driver->xmlopt"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjLoadAllState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1076-1108",
          "snippet": "int\nvirNetworkObjLoadAllState(virNetworkObjListPtr nets,\n                          const char *stateDir,\n                          virNetworkXMLOptionPtr xmlopt)\n{\n    DIR *dir;\n    struct dirent *entry;\n    int ret = -1;\n    int rc;\n\n    if ((rc = virDirOpenIfExists(&dir, stateDir)) <= 0)\n        return rc;\n\n    while ((ret = virDirRead(dir, &entry, stateDir)) > 0) {\n        virNetworkObjPtr obj;\n\n        if (!virStringStripSuffix(entry->d_name, \".xml\"))\n            continue;\n\n        obj = virNetworkLoadState(nets, stateDir, entry->d_name, xmlopt);\n\n        if (obj &&\n            virNetworkObjLoadAllPorts(obj, stateDir) < 0) {\n            virNetworkObjEndAPI(&obj);\n            goto cleanup;\n        }\n        virNetworkObjEndAPI(&obj);\n    }\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);",
            "static int\nvirNetworkObjLoadAllPorts(virNetworkObjPtr net,\n                          const char *stateDir);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\nstatic int\nvirNetworkObjLoadAllPorts(virNetworkObjPtr net,\n                          const char *stateDir);\n\nint\nvirNetworkObjLoadAllState(virNetworkObjListPtr nets,\n                          const char *stateDir,\n                          virNetworkXMLOptionPtr xmlopt)\n{\n    DIR *dir;\n    struct dirent *entry;\n    int ret = -1;\n    int rc;\n\n    if ((rc = virDirOpenIfExists(&dir, stateDir)) <= 0)\n        return rc;\n\n    while ((ret = virDirRead(dir, &entry, stateDir)) > 0) {\n        virNetworkObjPtr obj;\n\n        if (!virStringStripSuffix(entry->d_name, \".xml\"))\n            continue;\n\n        obj = virNetworkLoadState(nets, stateDir, entry->d_name, xmlopt);\n\n        if (obj &&\n            virNetworkObjLoadAllPorts(obj, stateDir) < 0) {\n            virNetworkObjEndAPI(&obj);\n            goto cleanup;\n        }\n        virNetworkObjEndAPI(&obj);\n    }\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjListNew",
          "args": [],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "344-361",
          "snippet": "virNetworkObjListPtr\nvirNetworkObjListNew(void)\n{\n    virNetworkObjListPtr nets;\n\n    if (virNetworkObjInitialize() < 0)\n        return NULL;\n\n    if (!(nets = virObjectRWLockableNew(virNetworkObjListClass)))\n        return NULL;\n\n    if (!(nets->objs = virHashCreate(50, virObjectFreeHashData))) {\n        virObjectUnref(nets);\n        return NULL;\n    }\n\n    return nets;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetworkObjListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic virClassPtr virNetworkObjListClass;\n\nvirNetworkObjListPtr\nvirNetworkObjListNew(void)\n{\n    virNetworkObjListPtr nets;\n\n    if (virNetworkObjInitialize() < 0)\n        return NULL;\n\n    if (!(nets = virObjectRWLockableNew(virNetworkObjListClass)))\n        return NULL;\n\n    if (!(nets->objs = virHashCreate(50, virObjectFreeHashData))) {\n        virObjectUnref(nets);\n        return NULL;\n    }\n\n    return nets;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnsmasqCapsNewFromBinary",
          "args": [
            "DNSMASQ"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqCapsNewFromBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "813-826",
          "snippet": "dnsmasqCapsPtr\ndnsmasqCapsNewFromBinary(const char *binaryPath)\n{\n    dnsmasqCapsPtr caps = dnsmasqCapsNewEmpty(binaryPath);\n\n    if (!caps)\n        return NULL;\n\n    if (dnsmasqCapsRefreshInternal(caps, true) < 0) {\n        virObjectUnref(caps);\n        return NULL;\n    }\n    return caps;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\ndnsmasqCapsPtr\ndnsmasqCapsNewFromBinary(const char *binaryPath)\n{\n    dnsmasqCapsPtr caps = dnsmasqCapsNewEmpty(binaryPath);\n\n    if (!caps)\n        return NULL;\n\n    if (dnsmasqCapsRefreshInternal(caps, true) < 0) {\n        virObjectUnref(caps);\n        return NULL;\n    }\n    return caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileAcquire",
          "args": [
            "network_driver->stateDir",
            "\"driver\"",
            "false",
            "getpid()"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileAcquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "413-427",
          "snippet": "int virPidFileAcquire(const char *dir,\n                      const char *name,\n                      bool waitForLock,\n                      pid_t pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileAcquirePath(pidfile, waitForLock, pid);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileAcquire(const char *dir,\n                      const char *name,\n                      bool waitForLock,\n                      pid_t pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileAcquirePath(pidfile, waitForLock, pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot create directory %s\")",
            "network_driver->stateDir"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot create directory %s\""
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "network_driver->stateDir"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserConfigDirectory",
          "args": [],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserConfigDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "574-581",
          "snippet": "char *virGetUserConfigDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_config_dir());\n#else\n    return g_build_filename(g_get_user_config_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserConfigDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_config_dir());\n#else\n    return g_build_filename(g_get_user_config_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkDnsmasqCreateXMLConf",
          "args": [],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "networkDnsmasqCreateXMLConf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "243-247",
          "snippet": "virNetworkXMLOptionPtr\nnetworkDnsmasqCreateXMLConf(void)\n{\n    return virNetworkXMLOptionNew(&networkDnsmasqXMLNamespace);\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virXMLNamespace networkDnsmasqXMLNamespace = {\n    .parse = networkDnsmasqDefNamespaceParse,\n    .free = networkDnsmasqDefNamespaceFree,\n    .format = networkDnsmasqDefNamespaceFormatXML,\n    .prefix = \"dnsmasq\",\n    .uri = \"http://libvirt.org/schemas/network/dnsmasq/1.0\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirXMLNamespace networkDnsmasqXMLNamespace = {\n    .parse = networkDnsmasqDefNamespaceParse,\n    .free = networkDnsmasqDefNamespaceFree,\n    .format = networkDnsmasqDefNamespaceFormatXML,\n    .prefix = \"dnsmasq\",\n    .uri = \"http://libvirt.org/schemas/network/dnsmasq/1.0\",\n};\n\nvirNetworkXMLOptionPtr\nnetworkDnsmasqCreateXMLConf(void)\n{\n    return virNetworkXMLOptionNew(&networkDnsmasqXMLNamespace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "network_driver"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "&network_driver->lock"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "network_driver"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Driver does not support embedded mode\")"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStateCleanup(void);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStateInitialize(bool privileged,\n                       const char *root,\n                       virStateInhibitCallback callback G_GNUC_UNUSED,\n                       void *opaque G_GNUC_UNUSED)\n{\n    int ret = VIR_DRV_STATE_INIT_ERROR;\n    char *configdir = NULL;\n    char *rundir = NULL;\n    bool autostart = true;\n#ifdef WITH_FIREWALLD\n    DBusConnection *sysbus = NULL;\n#endif\n\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(network_driver) < 0)\n        goto error;\n\n    network_driver->lockFD = -1;\n    if (virMutexInit(&network_driver->lock) < 0) {\n        VIR_FREE(network_driver);\n        goto error;\n    }\n\n    network_driver->privileged = privileged;\n\n    if (!(network_driver->xmlopt = networkDnsmasqCreateXMLConf()))\n        goto error;\n\n    /* configuration/state paths are one of\n     * ~/.config/libvirt/... (session/unprivileged)\n     * /etc/libvirt/... && /var/(run|lib)/libvirt/... (system/privileged).\n     */\n    if (privileged) {\n        network_driver->networkConfigDir = g_strdup(SYSCONFDIR \"/libvirt/qemu/networks\");\n        network_driver->networkAutostartDir = g_strdup(SYSCONFDIR \"/libvirt/qemu/networks/autostart\");\n        network_driver->stateDir = g_strdup(RUNSTATEDIR \"/libvirt/network\");\n        network_driver->pidDir = g_strdup(RUNSTATEDIR \"/libvirt/network\");\n        network_driver->dnsmasqStateDir = g_strdup(LOCALSTATEDIR \"/lib/libvirt/dnsmasq\");\n        network_driver->radvdStateDir = g_strdup(LOCALSTATEDIR \"/lib/libvirt/radvd\");\n    } else {\n        configdir = virGetUserConfigDirectory();\n        rundir = virGetUserRuntimeDirectory();\n\n        network_driver->networkConfigDir = g_strdup_printf(\"%s/qemu/networks\", configdir);\n        network_driver->networkAutostartDir = g_strdup_printf(\"%s/qemu/networks/autostart\", configdir);\n        network_driver->stateDir = g_strdup_printf(\"%s/network/lib\", rundir);\n        network_driver->pidDir = g_strdup_printf(\"%s/network/run\", rundir);\n        network_driver->dnsmasqStateDir = g_strdup_printf(\"%s/dnsmasq/lib\", rundir);\n        network_driver->radvdStateDir = g_strdup_printf(\"%s/radvd/lib\", rundir);\n    }\n\n    if (virFileMakePath(network_driver->stateDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create directory %s\"),\n                             network_driver->stateDir);\n        goto error;\n    }\n\n    if ((network_driver->lockFD =\n         virPidFileAcquire(network_driver->stateDir, \"driver\",\n                           false, getpid())) < 0)\n        goto error;\n\n    /* if this fails now, it will be retried later with dnsmasqCapsRefresh() */\n    network_driver->dnsmasqCaps = dnsmasqCapsNewFromBinary(DNSMASQ);\n\n    if (!(network_driver->networks = virNetworkObjListNew()))\n        goto error;\n\n    if (virNetworkObjLoadAllState(network_driver->networks,\n                                  network_driver->stateDir,\n                                  network_driver->xmlopt) < 0)\n        goto error;\n\n    if (virNetworkObjLoadAllConfigs(network_driver->networks,\n                                    network_driver->networkConfigDir,\n                                    network_driver->networkAutostartDir,\n                                    network_driver->xmlopt) < 0)\n        goto error;\n\n    /* Update the internal status of all allegedly active\n     * networks according to external conditions on the host\n     * (i.e. anything that isn't stored directly in each\n     * network's state file). */\n    virNetworkObjListForEach(network_driver->networks,\n                             networkUpdateState,\n                             network_driver);\n    virNetworkObjListPrune(network_driver->networks,\n                           VIR_CONNECT_LIST_NETWORKS_INACTIVE |\n                           VIR_CONNECT_LIST_NETWORKS_TRANSIENT);\n    networkReloadFirewallRules(network_driver, true);\n    networkRefreshDaemons(network_driver);\n\n    if (virDriverShouldAutostart(network_driver->stateDir, &autostart) < 0)\n        goto error;\n\n    if (autostart) {\n        virNetworkObjListForEach(network_driver->networks,\n                                 networkAutostartConfig,\n                                 network_driver);\n    }\n\n    network_driver->networkEventState = virObjectEventStateNew();\n\n#ifdef WITH_FIREWALLD\n    if (!(sysbus = virDBusGetSystemBus())) {\n        VIR_WARN(\"DBus not available, disabling firewalld support \"\n                 \"in bridge_network_driver: %s\", virGetLastErrorMessage());\n    } else {\n        /* add matches for\n         * NameOwnerChanged on org.freedesktop.DBus for firewalld start/stop\n         * Reloaded on org.fedoraproject.FirewallD1 for firewalld reload\n         */\n        dbus_bus_add_match(sysbus,\n                           \"type='signal'\"\n                           \",interface='\"DBUS_INTERFACE_DBUS\"'\"\n                           \",member='NameOwnerChanged'\"\n                           \",arg0='org.fedoraproject.FirewallD1'\",\n                           NULL);\n        dbus_bus_add_match(sysbus,\n                           \"type='signal'\"\n                           \",interface='org.fedoraproject.FirewallD1'\"\n                           \",member='Reloaded'\",\n                           NULL);\n        dbus_connection_add_filter(sysbus, firewalld_dbus_filter_bridge,\n                                   network_driver, NULL);\n    }\n#endif\n\n    ret = VIR_DRV_STATE_INIT_COMPLETE;\n cleanup:\n    VIR_FREE(configdir);\n    VIR_FREE(rundir);\n    return ret;\n\n error:\n    networkStateCleanup();\n    goto cleanup;\n}"
  },
  {
    "function_name": "firewalld_dbus_filter_bridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "659-696",
    "snippet": "static DBusHandlerResult\nfirewalld_dbus_filter_bridge(DBusConnection *connection G_GNUC_UNUSED,\n                             DBusMessage *message,\n                             void *user_data)\n{\n    virNetworkDriverStatePtr driver = user_data;\n    bool reload = false;\n\n    if (dbus_message_is_signal(message,\n                               \"org.fedoraproject.FirewallD1\", \"Reloaded\")) {\n        reload = true;\n\n    } else if (dbus_message_is_signal(message,\n                                      DBUS_INTERFACE_DBUS, \"NameOwnerChanged\")) {\n\n        g_autofree char *name = NULL;\n        g_autofree char *old_owner = NULL;\n        g_autofree char *new_owner = NULL;\n\n        if (virDBusMessageDecode(message, \"sss\", &name, &old_owner, &new_owner) < 0) {\n            VIR_WARN(\"Failed to decode DBus NameOwnerChanged message\");\n            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n        }\n        /*\n         * if new_owner is empty, firewalld is shutting down. If it is\n         * non-empty, then it is starting\n         */\n        if (new_owner && *new_owner)\n            reload = true;\n    }\n\n    if (reload) {\n        VIR_DEBUG(\"Reload in bridge_driver because of firewalld.\");\n        networkReloadFirewallRules(driver, false);\n    }\n\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkReloadFirewallRules",
          "args": [
            "driver",
            "false"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "networkReloadFirewallRules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2237-2250",
          "snippet": "static void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup)\n{\n    VIR_INFO(\"Reloading iptables rules\");\n    /* Ideally we'd not even register the driver when unprivilegd\n     * but until we untangle the virt driver that's not viable */\n    if (!driver->privileged)\n        return;\n    networkPreReloadFirewallRules(driver, startup);\n    virNetworkObjListForEach(driver->networks,\n                             networkReloadFirewallRulesHelper,\n                             NULL);\n    networkPostReloadFirewallRules(startup);\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup)\n{\n    VIR_INFO(\"Reloading iptables rules\");\n    /* Ideally we'd not even register the driver when unprivilegd\n     * but until we untangle the virt driver that's not viable */\n    if (!driver->privileged)\n        return;\n    networkPreReloadFirewallRules(driver, startup);\n    virNetworkObjListForEach(driver->networks,\n                             networkReloadFirewallRulesHelper,\n                             NULL);\n    networkPostReloadFirewallRules(startup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Reload in bridge_driver because of firewalld.\""
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to decode DBus NameOwnerChanged message\""
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusMessageDecode",
          "args": [
            "message",
            "\"sss\"",
            "&name",
            "&old_owner",
            "&new_owner"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusMessageDecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1837-1844",
          "snippet": "int virDBusMessageDecode(DBusMessage* msg G_GNUC_UNUSED,\n                         const char *types G_GNUC_UNUSED,\n                         ...)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusMessageDecode(DBusMessage* msg G_GNUC_UNUSED,\n                         const char *types G_GNUC_UNUSED,\n                         ...)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_message_is_signal",
          "args": [
            "message",
            "DBUS_INTERFACE_DBUS",
            "\"NameOwnerChanged\""
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_is_signal",
          "args": [
            "message",
            "\"org.fedoraproject.FirewallD1\"",
            "\"Reloaded\""
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic DBusHandlerResult\nfirewalld_dbus_filter_bridge(DBusConnection *connection G_GNUC_UNUSED,\n                             DBusMessage *message,\n                             void *user_data)\n{\n    virNetworkDriverStatePtr driver = user_data;\n    bool reload = false;\n\n    if (dbus_message_is_signal(message,\n                               \"org.fedoraproject.FirewallD1\", \"Reloaded\")) {\n        reload = true;\n\n    } else if (dbus_message_is_signal(message,\n                                      DBUS_INTERFACE_DBUS, \"NameOwnerChanged\")) {\n\n        g_autofree char *name = NULL;\n        g_autofree char *old_owner = NULL;\n        g_autofree char *new_owner = NULL;\n\n        if (virDBusMessageDecode(message, \"sss\", &name, &old_owner, &new_owner) < 0) {\n            VIR_WARN(\"Failed to decode DBus NameOwnerChanged message\");\n            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n        }\n        /*\n         * if new_owner is empty, firewalld is shutting down. If it is\n         * non-empty, then it is starting\n         */\n        if (new_owner && *new_owner)\n            reload = true;\n    }\n\n    if (reload) {\n        VIR_DEBUG(\"Reload in bridge_driver because of firewalld.\");\n        networkReloadFirewallRules(driver, false);\n    }\n\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n}"
  },
  {
    "function_name": "networkAutostartConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "638-655",
    "snippet": "static int\nnetworkAutostartConfig(virNetworkObjPtr obj,\n                       void *opaque)\n{\n    virNetworkDriverStatePtr driver = opaque;\n    int ret = -1;\n\n    virObjectLock(obj);\n    if (virNetworkObjIsAutostart(obj) &&\n        !virNetworkObjIsActive(obj) &&\n        networkStartNetwork(driver, obj) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(obj);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "obj"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkStartNetwork",
          "args": [
            "driver",
            "obj"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "networkStartNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "2890-2986",
          "snippet": "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n\n    VIR_DEBUG(\"driver=%p, network=%p\", driver, obj);\n\n    if (virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"network is already active\"));\n        return ret;\n    }\n\n    VIR_DEBUG(\"Beginning network startup process\");\n\n    virNetworkObjDeleteAllPorts(obj, driver->stateDir);\n\n    VIR_DEBUG(\"Setting current network def as transient\");\n    if (virNetworkObjSetDefTransient(obj, true, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices.\n     * If the script raised an error abort the launch. */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_START,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    switch ((virNetworkForwardType) def->forward.type) {\n\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        if (networkStartNetworkVirtual(driver, obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            if (networkStartNetworkBridge(obj) < 0)\n                goto cleanup;\n            break;\n        }\n        /* intentionally fall through to the macvtap/direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         * (since that is macvtap bridge mode).\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        if (networkStartNetworkExternal(obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto cleanup;\n    }\n\n    virNetworkObjSetFloorSum(obj, 0);\n\n    /* finally we can call the 'started' hook script if any */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_STARTED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    /* Persist the live configuration now that anything autogenerated\n     * is setup.\n     */\n    VIR_DEBUG(\"Writing network status to disk\");\n    if (virNetworkObjSaveStatus(driver->stateDir,\n                                obj, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    virNetworkObjSetActive(obj, true);\n    VIR_INFO(\"Network '%s' started up\", def->name);\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virErrorPtr save_err;\n\n        virErrorPreserveLast(&save_err);\n        virNetworkObjUnsetDefTransient(obj);\n        networkShutdownNetwork(driver, obj);\n        virErrorRestore(&save_err);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;",
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);",
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkReloadFirewallRules(virNetworkDriverStatePtr driver, bool startup);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n    int ret = -1;\n\n    VIR_DEBUG(\"driver=%p, network=%p\", driver, obj);\n\n    if (virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"network is already active\"));\n        return ret;\n    }\n\n    VIR_DEBUG(\"Beginning network startup process\");\n\n    virNetworkObjDeleteAllPorts(obj, driver->stateDir);\n\n    VIR_DEBUG(\"Setting current network def as transient\");\n    if (virNetworkObjSetDefTransient(obj, true, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    /* Run an early hook to set-up missing devices.\n     * If the script raised an error abort the launch. */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_START,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    switch ((virNetworkForwardType) def->forward.type) {\n\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        if (networkStartNetworkVirtual(driver, obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            if (networkStartNetworkBridge(obj) < 0)\n                goto cleanup;\n            break;\n        }\n        /* intentionally fall through to the macvtap/direct case for\n         * VIR_NETWORK_FORWARD_BRIDGE with no bridge device defined\n         * (since that is macvtap bridge mode).\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        if (networkStartNetworkExternal(obj) < 0)\n            goto cleanup;\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto cleanup;\n    }\n\n    virNetworkObjSetFloorSum(obj, 0);\n\n    /* finally we can call the 'started' hook script if any */\n    if (networkRunHook(obj, NULL,\n                       VIR_HOOK_NETWORK_OP_STARTED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    /* Persist the live configuration now that anything autogenerated\n     * is setup.\n     */\n    VIR_DEBUG(\"Writing network status to disk\");\n    if (virNetworkObjSaveStatus(driver->stateDir,\n                                obj, network_driver->xmlopt) < 0)\n        goto cleanup;\n\n    virNetworkObjSetActive(obj, true);\n    VIR_INFO(\"Network '%s' started up\", def->name);\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        virErrorPtr save_err;\n\n        virErrorPreserveLast(&save_err);\n        virNetworkObjUnsetDefTransient(obj);\n        networkShutdownNetwork(driver, obj);\n        virErrorRestore(&save_err);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsAutostart",
          "args": [
            "obj"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsAutostart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "192-196",
          "snippet": "bool\nvirNetworkObjIsAutostart(virNetworkObjPtr obj)\n{\n    return obj->autostart;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsAutostart(virNetworkObjPtr obj)\n{\n    return obj->autostart;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "obj"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkAutostartConfig(virNetworkObjPtr obj,\n                       void *opaque)\n{\n    virNetworkDriverStatePtr driver = opaque;\n    int ret = -1;\n\n    virObjectLock(obj);\n    if (virNetworkObjIsAutostart(obj) &&\n        !virNetworkObjIsActive(obj) &&\n        networkStartNetwork(driver, obj) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(obj);\n    return ret;\n}"
  },
  {
    "function_name": "networkUpdateState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "540-635",
    "snippet": "static int\nnetworkUpdateState(virNetworkObjPtr obj,\n                   void *opaque)\n{\n    virNetworkDefPtr def;\n    virNetworkDriverStatePtr driver = opaque;\n    dnsmasqCapsPtr dnsmasq_caps = networkGetDnsmasqCaps(driver);\n    virMacMapPtr macmap;\n    char *macMapFile = NULL;\n    int ret = -1;\n\n    virObjectLock(obj);\n    if (!virNetworkObjIsActive(obj)) {\n        ret = 0;\n        goto cleanup;\n    }\n    def = virNetworkObjGetDef(obj);\n\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* If bridge doesn't exist, then mark it inactive */\n        if (!(def->bridge && virNetDevExists(def->bridge) == 1))\n            virNetworkObjSetActive(obj, false);\n\n        if (!(macMapFile = virMacMapFileName(driver->dnsmasqStateDir,\n                                             def->bridge)))\n            goto cleanup;\n\n        if (!(macmap = virMacMapNew(macMapFile)))\n            goto cleanup;\n\n        virNetworkObjSetMacMap(obj, macmap);\n\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            if (virNetDevExists(def->bridge) != 1)\n                virNetworkObjSetActive(obj, false);\n            break;\n        }\n        /* intentionally drop through to common case for all\n         * macvtap networks (forward='bridge' with no bridge\n         * device defined is macvtap using its 'bridge' mode)\n         */\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        /* so far no extra checks */\n        break;\n\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        /* so far no extra checks */\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto cleanup;\n    }\n\n    virNetworkObjPortForEach(obj, networkUpdatePort, obj);\n\n    /* Try and read dnsmasq/radvd pids of active networks */\n    if (virNetworkObjIsActive(obj) && def->ips && (def->nips > 0)) {\n        pid_t radvdPid;\n        pid_t dnsmasqPid;\n        char *radvdpidbase;\n\n        ignore_value(virPidFileReadIfAlive(driver->pidDir,\n                                           def->name,\n                                           &dnsmasqPid,\n                                           dnsmasqCapsGetBinaryPath(dnsmasq_caps)));\n        virNetworkObjSetDnsmasqPid(obj, dnsmasqPid);\n\n        radvdpidbase = networkRadvdPidfileBasename(def->name);\n        if (!radvdpidbase)\n            goto cleanup;\n\n        ignore_value(virPidFileReadIfAlive(driver->pidDir,\n                                           radvdpidbase,\n                                           &radvdPid, RADVD));\n        virNetworkObjSetRadvdPid(obj, radvdPid);\n        VIR_FREE(radvdpidbase);\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(obj);\n    virObjectUnref(dnsmasq_caps);\n    VIR_FREE(macMapFile);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "macMapFile"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "dnsmasq_caps"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "obj"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "radvdpidbase"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetRadvdPid",
          "args": [
            "obj",
            "radvdPid"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetRadvdPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "229-234",
          "snippet": "void\nvirNetworkObjSetRadvdPid(virNetworkObjPtr obj,\n                         pid_t radvdPid)\n{\n    obj->radvdPid = radvdPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetRadvdPid(virNetworkObjPtr obj,\n                         pid_t radvdPid)\n{\n    obj->radvdPid = radvdPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virPidFileReadIfAlive(driver->pidDir,\n                                           radvdpidbase,\n                                           &radvdPid, RADVD)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileReadIfAlive",
          "args": [
            "driver->pidDir",
            "radvdpidbase",
            "&radvdPid",
            "RADVD"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadIfAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "285-302",
          "snippet": "int virPidFileReadIfAlive(const char *dir,\n                          const char *name,\n                          pid_t *pid,\n                          const char *binpath)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -1;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -1;\n\n    if (virPidFileReadPathIfAlive(pidfile, pid, binpath) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadIfAlive(const char *dir,\n                          const char *name,\n                          pid_t *pid,\n                          const char *binpath)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -1;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -1;\n\n    if (virPidFileReadPathIfAlive(pidfile, pid, binpath) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRadvdPidfileBasename",
          "args": [
            "def->name"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "networkRadvdPidfileBasename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "400-408",
          "snippet": "static char *\nnetworkRadvdPidfileBasename(const char *netname)\n{\n    /* this is simple but we want to be sure it's consistently done */\n    char *pidfilebase;\n\n    pidfilebase = g_strdup_printf(\"%s-radvd\", netname);\n    return pidfilebase;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nnetworkRadvdPidfileBasename(const char *netname)\n{\n    /* this is simple but we want to be sure it's consistently done */\n    char *pidfilebase;\n\n    pidfilebase = g_strdup_printf(\"%s-radvd\", netname);\n    return pidfilebase;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetDnsmasqPid",
          "args": [
            "obj",
            "dnsmasqPid"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetDnsmasqPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "214-219",
          "snippet": "void\nvirNetworkObjSetDnsmasqPid(virNetworkObjPtr obj,\n                           pid_t dnsmasqPid)\n{\n    obj->dnsmasqPid = dnsmasqPid;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetDnsmasqPid(virNetworkObjPtr obj,\n                           pid_t dnsmasqPid)\n{\n    obj->dnsmasqPid = dnsmasqPid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virPidFileReadIfAlive(driver->pidDir,\n                                           def->name,\n                                           &dnsmasqPid,\n                                           dnsmasqCapsGetBinaryPath(dnsmasq_caps))"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnsmasqCapsGetBinaryPath",
          "args": [
            "dnsmasq_caps"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqCapsGetBinaryPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "845-849",
          "snippet": "const char *\ndnsmasqCapsGetBinaryPath(dnsmasqCapsPtr caps)\n{\n    return caps ? caps->binaryPath : DNSMASQ;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\ndnsmasqCapsGetBinaryPath(dnsmasqCapsPtr caps)\n{\n    return caps ? caps->binaryPath : DNSMASQ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjIsActive",
          "args": [
            "obj"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "170-174",
          "snippet": "bool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nbool\nvirNetworkObjIsActive(virNetworkObjPtr obj)\n{\n    return obj->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjPortForEach",
          "args": [
            "obj",
            "networkUpdatePort",
            "obj"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjPortForEach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "1855-1865",
          "snippet": "int\nvirNetworkObjPortForEach(virNetworkObjPtr obj,\n                         virNetworkPortListIter iter,\n                         void *opaque)\n{\n    virNetworkObjPortListForEachData data = { iter, opaque, false };\n    virHashForEach(obj->ports, virNetworkObjPortForEachCallback, &data);\n    if (data.err)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nint\nvirNetworkObjPortForEach(virNetworkObjPtr obj,\n                         virNetworkPortListIter iter,\n                         void *opaque)\n{\n    virNetworkObjPortListForEachData data = { iter, opaque, false };\n    virHashForEach(obj->ports, virNetworkObjPortForEachCallback, &data);\n    if (data.err)\n        return -1;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetworkForwardType",
            "def->forward.type"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetActive",
          "args": [
            "obj",
            "false"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "177-182",
          "snippet": "void\nvirNetworkObjSetActive(virNetworkObjPtr obj,\n                       bool active)\n{\n    obj->active = active;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetActive(virNetworkObjPtr obj,\n                       bool active)\n{\n    obj->active = active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevExists",
          "args": [
            "def->bridge"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "218-223",
          "snippet": "int virNetDevExists(const char *ifname)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to check interface %s\"), ifname);\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint virNetDevExists(const char *ifname)\n{\n    virReportSystemError(ENOSYS,\n                         _(\"Unable to check interface %s\"), ifname);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjSetMacMap",
          "args": [
            "obj",
            "macmap"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjSetMacMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "266-271",
          "snippet": "void\nvirNetworkObjSetMacMap(virNetworkObjPtr obj,\n                       virMacMapPtr macmap)\n{\n    obj->macmap = macmap;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjSetMacMap(virNetworkObjPtr obj,\n                       virMacMapPtr macmap)\n{\n    obj->macmap = macmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacMapNew",
          "args": [
            "macMapFile"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "virMacMapNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacmap.c",
          "lines": "290-316",
          "snippet": "virMacMapPtr\nvirMacMapNew(const char *file)\n{\n    virMacMapPtr mgr;\n\n    if (virMacMapInitialize() < 0)\n        return NULL;\n\n    if (!(mgr = virObjectLockableNew(virMacMapClass)))\n        return NULL;\n\n    virObjectLock(mgr);\n    if (!(mgr->macs = virHashCreate(VIR_MAC_HASH_TABLE_SIZE, NULL)))\n        goto error;\n\n    if (file &&\n        virMacMapLoadFile(mgr, file) < 0)\n        goto error;\n\n    virObjectUnlock(mgr);\n    return mgr;\n\n error:\n    virObjectUnlock(mgr);\n    virObjectUnref(mgr);\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virjson.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"virmacmap.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_MAC_HASH_TABLE_SIZE 10"
          ],
          "globals_used": [
            "static virClassPtr virMacMapClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virjson.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"virmacmap.h\"\n#include <config.h>\n\n#define VIR_MAC_HASH_TABLE_SIZE 10\n\nstatic virClassPtr virMacMapClass;\n\nvirMacMapPtr\nvirMacMapNew(const char *file)\n{\n    virMacMapPtr mgr;\n\n    if (virMacMapInitialize() < 0)\n        return NULL;\n\n    if (!(mgr = virObjectLockableNew(virMacMapClass)))\n        return NULL;\n\n    virObjectLock(mgr);\n    if (!(mgr->macs = virHashCreate(VIR_MAC_HASH_TABLE_SIZE, NULL)))\n        goto error;\n\n    if (file &&\n        virMacMapLoadFile(mgr, file) < 0)\n        goto error;\n\n    virObjectUnlock(mgr);\n    return mgr;\n\n error:\n    virObjectUnlock(mgr);\n    virObjectUnref(mgr);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacMapFileName",
          "args": [
            "driver->dnsmasqStateDir",
            "def->bridge"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "virMacMapFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacmap.c",
          "lines": "276-285",
          "snippet": "char *\nvirMacMapFileName(const char *dnsmasqStateDir,\n                  const char *bridge)\n{\n    char *filename;\n\n    filename = g_strdup_printf(\"%s/%s.macs\", dnsmasqStateDir, bridge);\n\n    return filename;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virjson.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"virmacmap.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virjson.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"virmacmap.h\"\n#include <config.h>\n\nchar *\nvirMacMapFileName(const char *dnsmasqStateDir,\n                  const char *bridge)\n{\n    char *filename;\n\n    filename = g_strdup_printf(\"%s/%s.macs\", dnsmasqStateDir, bridge);\n\n    return filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "obj"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkGetDnsmasqCaps",
          "args": [
            "driver"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDnsmasqCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "115-123",
          "snippet": "static dnsmasqCapsPtr\nnetworkGetDnsmasqCaps(virNetworkDriverStatePtr driver)\n{\n    dnsmasqCapsPtr ret;\n    networkDriverLock(driver);\n    ret = virObjectRef(driver->dnsmasqCaps);\n    networkDriverUnlock(driver);\n    return ret;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic dnsmasqCapsPtr\nnetworkGetDnsmasqCaps(virNetworkDriverStatePtr driver)\n{\n    dnsmasqCapsPtr ret;\n    networkDriverLock(driver);\n    ret = virObjectRef(driver->dnsmasqCaps);\n    networkDriverUnlock(driver);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkUpdateState(virNetworkObjPtr obj,\n                   void *opaque)\n{\n    virNetworkDefPtr def;\n    virNetworkDriverStatePtr driver = opaque;\n    dnsmasqCapsPtr dnsmasq_caps = networkGetDnsmasqCaps(driver);\n    virMacMapPtr macmap;\n    char *macMapFile = NULL;\n    int ret = -1;\n\n    virObjectLock(obj);\n    if (!virNetworkObjIsActive(obj)) {\n        ret = 0;\n        goto cleanup;\n    }\n    def = virNetworkObjGetDef(obj);\n\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        /* If bridge doesn't exist, then mark it inactive */\n        if (!(def->bridge && virNetDevExists(def->bridge) == 1))\n            virNetworkObjSetActive(obj, false);\n\n        if (!(macMapFile = virMacMapFileName(driver->dnsmasqStateDir,\n                                             def->bridge)))\n            goto cleanup;\n\n        if (!(macmap = virMacMapNew(macMapFile)))\n            goto cleanup;\n\n        virNetworkObjSetMacMap(obj, macmap);\n\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if (def->bridge) {\n            if (virNetDevExists(def->bridge) != 1)\n                virNetworkObjSetActive(obj, false);\n            break;\n        }\n        /* intentionally drop through to common case for all\n         * macvtap networks (forward='bridge' with no bridge\n         * device defined is macvtap using its 'bridge' mode)\n         */\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        /* so far no extra checks */\n        break;\n\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        /* so far no extra checks */\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        goto cleanup;\n    }\n\n    virNetworkObjPortForEach(obj, networkUpdatePort, obj);\n\n    /* Try and read dnsmasq/radvd pids of active networks */\n    if (virNetworkObjIsActive(obj) && def->ips && (def->nips > 0)) {\n        pid_t radvdPid;\n        pid_t dnsmasqPid;\n        char *radvdpidbase;\n\n        ignore_value(virPidFileReadIfAlive(driver->pidDir,\n                                           def->name,\n                                           &dnsmasqPid,\n                                           dnsmasqCapsGetBinaryPath(dnsmasq_caps)));\n        virNetworkObjSetDnsmasqPid(obj, dnsmasqPid);\n\n        radvdpidbase = networkRadvdPidfileBasename(def->name);\n        if (!radvdpidbase)\n            goto cleanup;\n\n        ignore_value(virPidFileReadIfAlive(driver->pidDir,\n                                           radvdpidbase,\n                                           &radvdPid, RADVD));\n        virNetworkObjSetRadvdPid(obj, radvdPid);\n        VIR_FREE(radvdpidbase);\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(obj);\n    virObjectUnref(dnsmasq_caps);\n    VIR_FREE(macMapFile);\n    return ret;\n}"
  },
  {
    "function_name": "networkUpdatePort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "529-538",
    "snippet": "static bool\nnetworkUpdatePort(virNetworkPortDefPtr port,\n                  void *opaque)\n{\n    virNetworkObjPtr obj = opaque;\n\n    networkNotifyPort(obj, port);\n\n    return false;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkNotifyPort",
          "args": [
            "obj",
            "port"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "networkNotifyPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "4783-4924",
          "snippet": "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port)\n{\n    virNetworkDefPtr netdef;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n\n    netdef = virNetworkObjGetDef(obj);\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       netdef->name);\n        return -1;\n    }\n\n    switch (port->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpectedly got a network port without a plug\"));\n        return -1;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        /* see if we're connected to the correct bridge */\n        if (!netdef->bridge) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unexpectedly got a network port without a network bridge\"));\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* find the matching interface and increment its connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n                STREQ(port->plug.direct.linkdev,\n                      netdef->forward.ifs[i].device.dev)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        /* dev points at the physical device we want to use */\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have dev='%s' \"\n                             \"in use by network port '%s'\"),\n                           netdef->name, port->plug.direct.linkdev,\n                           port->uuid);\n            return -1;\n        }\n\n        /* PASSTHROUGH mode and PRIVATE Mode + 802.1Qbh both require\n         * exclusive access to a device, so current connections count\n         * must be 0 in those cases.\n         */\n        if ((dev->connections > 0) &&\n            ((netdef->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH) ||\n             ((netdef->forward.type == VIR_NETWORK_FORWARD_PRIVATE) &&\n              port->virtPortProfile &&\n              (port->virtPortProfile->virtPortType == VIR_NETDEV_VPORT_PROFILE_8021QBH)))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' claims dev='%s' is already in \"\n                             \"use by a different port\"),\n                           netdef->name, port->plug.direct.linkdev);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* find the matching interface and increment its connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI &&\n                virPCIDeviceAddressEqual(&port->plug.hostdevpci.addr,\n                                         &netdef->forward.ifs[i].device.pci)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        /* dev points at the physical device we want to use */\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have \"\n                             \"PCI device %04x:%02x:%02x.%x in use by network port\"),\n                           netdef->name,\n                           port->plug.hostdevpci.addr.domain,\n                           port->plug.hostdevpci.addr.bus,\n                           port->plug.hostdevpci.addr.slot,\n                           port->plug.hostdevpci.addr.function);\n            return -1;\n        }\n\n        /* PASSTHROUGH mode, PRIVATE Mode + 802.1Qbh, and hostdev (PCI\n         * passthrough) all require exclusive access to a device, so\n         * current connections count must be 0 in those cases.\n         */\n        if ((dev->connections > 0) &&\n            netdef->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' claims the PCI device at \"\n                             \"domain=%d bus=%d slot=%d function=%d \"\n                             \"is already in use by a different network port\"),\n                           netdef->name,\n                           dev->device.pci.domain, dev->device.pci.bus,\n                           dev->device.pci.slot, dev->device.pci.function);\n            return -1;\n        }\n\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, port->plugtype);\n        return -1;\n    }\n\n    netdef->connections++;\n    if (dev)\n        dev->connections++;\n    /* finally we can call the 'plugged' hook script if any */\n    if (networkRunHook(obj, port, VIR_HOOK_NETWORK_OP_PORT_CREATED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0) {\n        /* adjust for failure */\n        if (dev)\n            dev->connections--;\n        netdef->connections--;\n        return -1;\n    }\n    networkLogAllocation(netdef, dev, &port->mac, true);\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port)\n{\n    virNetworkDefPtr netdef;\n    virNetworkForwardIfDefPtr dev = NULL;\n    size_t i;\n\n    netdef = virNetworkObjGetDef(obj);\n\n    if (!virNetworkObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"network '%s' is not active\"),\n                       netdef->name);\n        return -1;\n    }\n\n    switch (port->plugtype) {\n    case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpectedly got a network port without a plug\"));\n        return -1;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n    case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n        /* see if we're connected to the correct bridge */\n        if (!netdef->bridge) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unexpectedly got a network port without a network bridge\"));\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* find the matching interface and increment its connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV &&\n                STREQ(port->plug.direct.linkdev,\n                      netdef->forward.ifs[i].device.dev)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        /* dev points at the physical device we want to use */\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have dev='%s' \"\n                             \"in use by network port '%s'\"),\n                           netdef->name, port->plug.direct.linkdev,\n                           port->uuid);\n            return -1;\n        }\n\n        /* PASSTHROUGH mode and PRIVATE Mode + 802.1Qbh both require\n         * exclusive access to a device, so current connections count\n         * must be 0 in those cases.\n         */\n        if ((dev->connections > 0) &&\n            ((netdef->forward.type == VIR_NETWORK_FORWARD_PASSTHROUGH) ||\n             ((netdef->forward.type == VIR_NETWORK_FORWARD_PRIVATE) &&\n              port->virtPortProfile &&\n              (port->virtPortProfile->virtPortType == VIR_NETDEV_VPORT_PROFILE_8021QBH)))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' claims dev='%s' is already in \"\n                             \"use by a different port\"),\n                           netdef->name, port->plug.direct.linkdev);\n            return -1;\n        }\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n\n        if (networkCreateInterfacePool(netdef) < 0)\n            return -1;\n\n        /* find the matching interface and increment its connections */\n        for (i = 0; i < netdef->forward.nifs; i++) {\n            if (netdef->forward.ifs[i].type\n                == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI &&\n                virPCIDeviceAddressEqual(&port->plug.hostdevpci.addr,\n                                         &netdef->forward.ifs[i].device.pci)) {\n                dev = &netdef->forward.ifs[i];\n                break;\n            }\n        }\n        /* dev points at the physical device we want to use */\n        if (!dev) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have \"\n                             \"PCI device %04x:%02x:%02x.%x in use by network port\"),\n                           netdef->name,\n                           port->plug.hostdevpci.addr.domain,\n                           port->plug.hostdevpci.addr.bus,\n                           port->plug.hostdevpci.addr.slot,\n                           port->plug.hostdevpci.addr.function);\n            return -1;\n        }\n\n        /* PASSTHROUGH mode, PRIVATE Mode + 802.1Qbh, and hostdev (PCI\n         * passthrough) all require exclusive access to a device, so\n         * current connections count must be 0 in those cases.\n         */\n        if ((dev->connections > 0) &&\n            netdef->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' claims the PCI device at \"\n                             \"domain=%d bus=%d slot=%d function=%d \"\n                             \"is already in use by a different network port\"),\n                           netdef->name,\n                           dev->device.pci.domain, dev->device.pci.bus,\n                           dev->device.pci.slot, dev->device.pci.function);\n            return -1;\n        }\n\n        break;\n\n    case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virNetworkPortPlugType, port->plugtype);\n        return -1;\n    }\n\n    netdef->connections++;\n    if (dev)\n        dev->connections++;\n    /* finally we can call the 'plugged' hook script if any */\n    if (networkRunHook(obj, port, VIR_HOOK_NETWORK_OP_PORT_CREATED,\n                       VIR_HOOK_SUBOP_BEGIN) < 0) {\n        /* adjust for failure */\n        if (dev)\n            dev->connections--;\n        netdef->connections--;\n        return -1;\n    }\n    networkLogAllocation(netdef, dev, &port->mac, true);\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic bool\nnetworkUpdatePort(virNetworkPortDefPtr port,\n                  void *opaque)\n{\n    virNetworkObjPtr obj = opaque;\n\n    networkNotifyPort(obj, port);\n\n    return false;\n}"
  },
  {
    "function_name": "networkBridgeDummyNicName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "500-522",
    "snippet": "static char *\nnetworkBridgeDummyNicName(const char *brname)\n{\n    static const char dummyNicSuffix[] = \"-nic\";\n    char *nicname;\n\n    if (strlen(brname) + sizeof(dummyNicSuffix) > IFNAMSIZ) {\n        /* because the length of an ifname is limited to IFNAMSIZ-1\n         * (usually 15), and we're adding 4 more characters, we must\n         * truncate the original name to 11 to fit. In order to catch\n         * a possible numeric ending (eg virbr0, virbr1, etc), we grab\n         * the first 8 and last 3 characters of the string.\n         */\n        nicname = g_strdup_printf(\"%.*s%s%s\",\n                                  /* space for last 3 chars + \"-nic\" + NULL */\n                                  (int)(IFNAMSIZ - (3 + sizeof(dummyNicSuffix))),\n                                  brname, brname + strlen(brname) - 3,\n                                  dummyNicSuffix);\n    } else {\n        nicname = g_strdup_printf(\"%s%s\", brname, dummyNicSuffix);\n    }\n    return nicname;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s%s\"",
            "brname",
            "dummyNicSuffix"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "brname"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "brname"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nnetworkBridgeDummyNicName(const char *brname)\n{\n    static const char dummyNicSuffix[] = \"-nic\";\n    char *nicname;\n\n    if (strlen(brname) + sizeof(dummyNicSuffix) > IFNAMSIZ) {\n        /* because the length of an ifname is limited to IFNAMSIZ-1\n         * (usually 15), and we're adding 4 more characters, we must\n         * truncate the original name to 11 to fit. In order to catch\n         * a possible numeric ending (eg virbr0, virbr1, etc), we grab\n         * the first 8 and last 3 characters of the string.\n         */\n        nicname = g_strdup_printf(\"%.*s%s%s\",\n                                  /* space for last 3 chars + \"-nic\" + NULL */\n                                  (int)(IFNAMSIZ - (3 + sizeof(dummyNicSuffix))),\n                                  brname, brname + strlen(brname) - 3,\n                                  dummyNicSuffix);\n    } else {\n        nicname = g_strdup_printf(\"%s%s\", brname, dummyNicSuffix);\n    }\n    return nicname;\n}"
  },
  {
    "function_name": "networkRemoveInactive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "423-497",
    "snippet": "static int\nnetworkRemoveInactive(virNetworkDriverStatePtr driver,\n                      virNetworkObjPtr obj)\n{\n    char *leasefile = NULL;\n    char *customleasefile = NULL;\n    char *radvdconfigfile = NULL;\n    char *configfile = NULL;\n    char *radvdpidbase = NULL;\n    char *statusfile = NULL;\n    char *macMapFile = NULL;\n    dnsmasqContext *dctx = NULL;\n    virNetworkDefPtr def = virNetworkObjGetPersistentDef(obj);\n\n    int ret = -1;\n\n    /* remove the (possibly) existing dnsmasq and radvd files */\n    if (!(dctx = dnsmasqContextNew(def->name,\n                                   driver->dnsmasqStateDir))) {\n        goto cleanup;\n    }\n\n    if (!(leasefile = networkDnsmasqLeaseFileNameDefault(driver, def->name)))\n        goto cleanup;\n\n    if (!(customleasefile = networkDnsmasqLeaseFileNameCustom(driver, def->bridge)))\n        goto cleanup;\n\n    if (!(radvdconfigfile = networkRadvdConfigFileName(driver, def->name)))\n        goto cleanup;\n\n    if (!(radvdpidbase = networkRadvdPidfileBasename(def->name)))\n        goto cleanup;\n\n    if (!(configfile = networkDnsmasqConfigFileName(driver, def->name)))\n        goto cleanup;\n\n    if (!(statusfile = virNetworkConfigFile(driver->stateDir, def->name)))\n        goto cleanup;\n\n    if (!(macMapFile = virMacMapFileName(driver->dnsmasqStateDir, def->bridge)))\n        goto cleanup;\n\n    /* dnsmasq */\n    dnsmasqDelete(dctx);\n    unlink(leasefile);\n    unlink(customleasefile);\n    unlink(configfile);\n\n    /* MAC map manager */\n    unlink(macMapFile);\n\n    /* radvd */\n    unlink(radvdconfigfile);\n    virPidFileDelete(driver->pidDir, radvdpidbase);\n\n    /* remove status file */\n    unlink(statusfile);\n\n    /* remove the network definition */\n    virNetworkObjRemoveInactive(driver->networks, obj);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(leasefile);\n    VIR_FREE(configfile);\n    VIR_FREE(customleasefile);\n    VIR_FREE(radvdconfigfile);\n    VIR_FREE(radvdpidbase);\n    VIR_FREE(statusfile);\n    VIR_FREE(macMapFile);\n    dnsmasqContextFree(dctx);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dnsmasqContextFree",
          "args": [
            "dctx"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqContextFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "473-487",
          "snippet": "void\ndnsmasqContextFree(dnsmasqContext *ctx)\n{\n    if (!ctx)\n        return;\n\n    VIR_FREE(ctx->config_dir);\n\n    if (ctx->hostsfile)\n        hostsfileFree(ctx->hostsfile);\n    if (ctx->addnhostsfile)\n        addnhostsFree(ctx->addnhostsfile);\n\n    VIR_FREE(ctx);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\ndnsmasqContextFree(dnsmasqContext *ctx)\n{\n    if (!ctx)\n        return;\n\n    VIR_FREE(ctx->config_dir);\n\n    if (ctx->hostsfile)\n        hostsfileFree(ctx->hostsfile);\n    if (ctx->addnhostsfile)\n        addnhostsFree(ctx->addnhostsfile);\n\n    VIR_FREE(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "macMapFile"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "statusfile"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "radvdpidbase"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "radvdconfigfile"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "customleasefile"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "configfile"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "leasefile"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjRemoveInactive",
          "args": [
            "driver->networks",
            "obj"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjRemoveInactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "796-810",
          "snippet": "void\nvirNetworkObjRemoveInactive(virNetworkObjListPtr nets,\n                            virNetworkObjPtr obj)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(obj->def->uuid, uuidstr);\n    virObjectRef(obj);\n    virObjectUnlock(obj);\n    virObjectRWLockWrite(nets);\n    virObjectLock(obj);\n    virHashRemoveEntry(nets->objs, uuidstr);\n    virObjectRWUnlock(nets);\n    virObjectUnref(obj);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvoid\nvirNetworkObjRemoveInactive(virNetworkObjListPtr nets,\n                            virNetworkObjPtr obj)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    virUUIDFormat(obj->def->uuid, uuidstr);\n    virObjectRef(obj);\n    virObjectUnlock(obj);\n    virObjectRWLockWrite(nets);\n    virObjectLock(obj);\n    virHashRemoveEntry(nets->objs, uuidstr);\n    virObjectRWUnlock(nets);\n    virObjectUnref(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "statusfile"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileDelete",
          "args": [
            "driver->pidDir",
            "radvdpidbase"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "316-328",
          "snippet": "int virPidFileDelete(const char *dir,\n                     const char *name)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileDeletePath(pidfile);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileDelete(const char *dir,\n                     const char *name)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileDeletePath(pidfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "radvdconfigfile"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "macMapFile"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "configfile"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "customleasefile"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "leasefile"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dnsmasqDelete",
          "args": [
            "dctx"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "560-571",
          "snippet": "int\ndnsmasqDelete(const dnsmasqContext *ctx)\n{\n    int ret = 0;\n\n    if (ctx->hostsfile)\n        ret = genericFileDelete(ctx->hostsfile->path);\n    if (ctx->addnhostsfile)\n        ret = genericFileDelete(ctx->addnhostsfile->path);\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nint\ndnsmasqDelete(const dnsmasqContext *ctx)\n{\n    int ret = 0;\n\n    if (ctx->hostsfile)\n        ret = genericFileDelete(ctx->hostsfile->path);\n    if (ctx->addnhostsfile)\n        ret = genericFileDelete(ctx->addnhostsfile->path);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacMapFileName",
          "args": [
            "driver->dnsmasqStateDir",
            "def->bridge"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "virMacMapFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacmap.c",
          "lines": "276-285",
          "snippet": "char *\nvirMacMapFileName(const char *dnsmasqStateDir,\n                  const char *bridge)\n{\n    char *filename;\n\n    filename = g_strdup_printf(\"%s/%s.macs\", dnsmasqStateDir, bridge);\n\n    return filename;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virjson.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"virmacmap.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virjson.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"virmacmap.h\"\n#include <config.h>\n\nchar *\nvirMacMapFileName(const char *dnsmasqStateDir,\n                  const char *bridge)\n{\n    char *filename;\n\n    filename = g_strdup_printf(\"%s/%s.macs\", dnsmasqStateDir, bridge);\n\n    return filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkConfigFile",
          "args": [
            "driver->stateDir",
            "def->name"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkConfigFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2770-2778",
          "snippet": "char *\nvirNetworkConfigFile(const char *dir,\n                     const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNetworkConfigFile(const char *dir,\n                     const char *name)\n{\n    char *ret = NULL;\n\n    ret = g_strdup_printf(\"%s/%s.xml\", dir, name);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkDnsmasqConfigFileName",
          "args": [
            "driver",
            "def->name"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "networkDnsmasqConfigFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "389-397",
          "snippet": "static char *\nnetworkDnsmasqConfigFileName(virNetworkDriverStatePtr driver,\n                             const char *netname)\n{\n    char *conffile;\n\n    conffile = g_strdup_printf(\"%s/%s.conf\", driver->dnsmasqStateDir, netname);\n    return conffile;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic char *\nnetworkDnsmasqConfigFileName(virNetworkDriverStatePtr driver,\n                             const char *netname)\n{\n    char *conffile;\n\n    conffile = g_strdup_printf(\"%s/%s.conf\", driver->dnsmasqStateDir, netname);\n    return conffile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRadvdPidfileBasename",
          "args": [
            "def->name"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "networkRadvdPidfileBasename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "400-408",
          "snippet": "static char *\nnetworkRadvdPidfileBasename(const char *netname)\n{\n    /* this is simple but we want to be sure it's consistently done */\n    char *pidfilebase;\n\n    pidfilebase = g_strdup_printf(\"%s-radvd\", netname);\n    return pidfilebase;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nnetworkRadvdPidfileBasename(const char *netname)\n{\n    /* this is simple but we want to be sure it's consistently done */\n    char *pidfilebase;\n\n    pidfilebase = g_strdup_printf(\"%s-radvd\", netname);\n    return pidfilebase;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkRadvdConfigFileName",
          "args": [
            "driver",
            "def->name"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "networkRadvdConfigFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "411-419",
          "snippet": "static char *\nnetworkRadvdConfigFileName(virNetworkDriverStatePtr driver,\n                           const char *netname)\n{\n    char *configfile;\n\n    configfile = g_strdup_printf(\"%s/%s-radvd.conf\", driver->radvdStateDir, netname);\n    return configfile;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic char *\nnetworkRadvdConfigFileName(virNetworkDriverStatePtr driver,\n                           const char *netname)\n{\n    char *configfile;\n\n    configfile = g_strdup_printf(\"%s/%s-radvd.conf\", driver->radvdStateDir, netname);\n    return configfile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkDnsmasqLeaseFileNameCustom",
          "args": [
            "driver",
            "def->bridge"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "networkDnsmasqLeaseFileNameCustom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "378-386",
          "snippet": "static char *\nnetworkDnsmasqLeaseFileNameCustom(virNetworkDriverStatePtr driver,\n                                  const char *bridge)\n{\n    char *leasefile;\n\n    leasefile = g_strdup_printf(\"%s/%s.status\", driver->dnsmasqStateDir, bridge);\n    return leasefile;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic char *\nnetworkDnsmasqLeaseFileNameCustom(virNetworkDriverStatePtr driver,\n                                  const char *bridge)\n{\n    char *leasefile;\n\n    leasefile = g_strdup_printf(\"%s/%s.status\", driver->dnsmasqStateDir, bridge);\n    return leasefile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkDnsmasqLeaseFileNameDefault",
          "args": [
            "driver",
            "def->name"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "networkDnsmasqLeaseFileNameDefault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "367-375",
          "snippet": "static char *\nnetworkDnsmasqLeaseFileNameDefault(virNetworkDriverStatePtr driver,\n                                   const char *netname)\n{\n    char *leasefile;\n\n    leasefile = g_strdup_printf(\"%s/%s.leases\", driver->dnsmasqStateDir, netname);\n    return leasefile;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic char *\nnetworkDnsmasqLeaseFileNameDefault(virNetworkDriverStatePtr driver,\n                                   const char *netname)\n{\n    char *leasefile;\n\n    leasefile = g_strdup_printf(\"%s/%s.leases\", driver->dnsmasqStateDir, netname);\n    return leasefile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnsmasqContextNew",
          "args": [
            "def->name",
            "driver->dnsmasqStateDir"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "444-465",
          "snippet": "dnsmasqContext *\ndnsmasqContextNew(const char *network_name,\n                  const char *config_dir)\n{\n    dnsmasqContext *ctx;\n\n    if (VIR_ALLOC(ctx) < 0)\n        return NULL;\n\n    ctx->config_dir = g_strdup(config_dir);\n\n    if (!(ctx->hostsfile = hostsfileNew(network_name, config_dir)))\n        goto error;\n    if (!(ctx->addnhostsfile = addnhostsNew(network_name, config_dir)))\n        goto error;\n\n    return ctx;\n\n error:\n    dnsmasqContextFree(ctx);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\ndnsmasqContext *\ndnsmasqContextNew(const char *network_name,\n                  const char *config_dir)\n{\n    dnsmasqContext *ctx;\n\n    if (VIR_ALLOC(ctx) < 0)\n        return NULL;\n\n    ctx->config_dir = g_strdup(config_dir);\n\n    if (!(ctx->hostsfile = hostsfileNew(network_name, config_dir)))\n        goto error;\n    if (!(ctx->addnhostsfile = addnhostsNew(network_name, config_dir)))\n        goto error;\n\n    return ctx;\n\n error:\n    dnsmasqContextFree(ctx);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetPersistentDef",
          "args": [
            "obj"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetPersistentDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "716-723",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetPersistentDef(virNetworkObjPtr obj)\n{\n    if (obj->newDef)\n        return obj->newDef;\n    else\n        return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetPersistentDef(virNetworkObjPtr obj)\n{\n    if (obj->newDef)\n        return obj->newDef;\n    else\n        return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkRemoveInactive(virNetworkDriverStatePtr driver,\n                      virNetworkObjPtr obj)\n{\n    char *leasefile = NULL;\n    char *customleasefile = NULL;\n    char *radvdconfigfile = NULL;\n    char *configfile = NULL;\n    char *radvdpidbase = NULL;\n    char *statusfile = NULL;\n    char *macMapFile = NULL;\n    dnsmasqContext *dctx = NULL;\n    virNetworkDefPtr def = virNetworkObjGetPersistentDef(obj);\n\n    int ret = -1;\n\n    /* remove the (possibly) existing dnsmasq and radvd files */\n    if (!(dctx = dnsmasqContextNew(def->name,\n                                   driver->dnsmasqStateDir))) {\n        goto cleanup;\n    }\n\n    if (!(leasefile = networkDnsmasqLeaseFileNameDefault(driver, def->name)))\n        goto cleanup;\n\n    if (!(customleasefile = networkDnsmasqLeaseFileNameCustom(driver, def->bridge)))\n        goto cleanup;\n\n    if (!(radvdconfigfile = networkRadvdConfigFileName(driver, def->name)))\n        goto cleanup;\n\n    if (!(radvdpidbase = networkRadvdPidfileBasename(def->name)))\n        goto cleanup;\n\n    if (!(configfile = networkDnsmasqConfigFileName(driver, def->name)))\n        goto cleanup;\n\n    if (!(statusfile = virNetworkConfigFile(driver->stateDir, def->name)))\n        goto cleanup;\n\n    if (!(macMapFile = virMacMapFileName(driver->dnsmasqStateDir, def->bridge)))\n        goto cleanup;\n\n    /* dnsmasq */\n    dnsmasqDelete(dctx);\n    unlink(leasefile);\n    unlink(customleasefile);\n    unlink(configfile);\n\n    /* MAC map manager */\n    unlink(macMapFile);\n\n    /* radvd */\n    unlink(radvdconfigfile);\n    virPidFileDelete(driver->pidDir, radvdpidbase);\n\n    /* remove status file */\n    unlink(statusfile);\n\n    /* remove the network definition */\n    virNetworkObjRemoveInactive(driver->networks, obj);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(leasefile);\n    VIR_FREE(configfile);\n    VIR_FREE(customleasefile);\n    VIR_FREE(radvdconfigfile);\n    VIR_FREE(radvdpidbase);\n    VIR_FREE(statusfile);\n    VIR_FREE(macMapFile);\n    dnsmasqContextFree(dctx);\n    return ret;\n}"
  },
  {
    "function_name": "networkRadvdConfigFileName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "411-419",
    "snippet": "static char *\nnetworkRadvdConfigFileName(virNetworkDriverStatePtr driver,\n                           const char *netname)\n{\n    char *configfile;\n\n    configfile = g_strdup_printf(\"%s/%s-radvd.conf\", driver->radvdStateDir, netname);\n    return configfile;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s-radvd.conf\"",
            "driver->radvdStateDir",
            "netname"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic char *\nnetworkRadvdConfigFileName(virNetworkDriverStatePtr driver,\n                           const char *netname)\n{\n    char *configfile;\n\n    configfile = g_strdup_printf(\"%s/%s-radvd.conf\", driver->radvdStateDir, netname);\n    return configfile;\n}"
  },
  {
    "function_name": "networkRadvdPidfileBasename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "400-408",
    "snippet": "static char *\nnetworkRadvdPidfileBasename(const char *netname)\n{\n    /* this is simple but we want to be sure it's consistently done */\n    char *pidfilebase;\n\n    pidfilebase = g_strdup_printf(\"%s-radvd\", netname);\n    return pidfilebase;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s-radvd\"",
            "netname"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic char *\nnetworkRadvdPidfileBasename(const char *netname)\n{\n    /* this is simple but we want to be sure it's consistently done */\n    char *pidfilebase;\n\n    pidfilebase = g_strdup_printf(\"%s-radvd\", netname);\n    return pidfilebase;\n}"
  },
  {
    "function_name": "networkDnsmasqConfigFileName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "389-397",
    "snippet": "static char *\nnetworkDnsmasqConfigFileName(virNetworkDriverStatePtr driver,\n                             const char *netname)\n{\n    char *conffile;\n\n    conffile = g_strdup_printf(\"%s/%s.conf\", driver->dnsmasqStateDir, netname);\n    return conffile;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s.conf\"",
            "driver->dnsmasqStateDir",
            "netname"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic char *\nnetworkDnsmasqConfigFileName(virNetworkDriverStatePtr driver,\n                             const char *netname)\n{\n    char *conffile;\n\n    conffile = g_strdup_printf(\"%s/%s.conf\", driver->dnsmasqStateDir, netname);\n    return conffile;\n}"
  },
  {
    "function_name": "networkDnsmasqLeaseFileNameCustom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "378-386",
    "snippet": "static char *\nnetworkDnsmasqLeaseFileNameCustom(virNetworkDriverStatePtr driver,\n                                  const char *bridge)\n{\n    char *leasefile;\n\n    leasefile = g_strdup_printf(\"%s/%s.status\", driver->dnsmasqStateDir, bridge);\n    return leasefile;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s.status\"",
            "driver->dnsmasqStateDir",
            "bridge"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic char *\nnetworkDnsmasqLeaseFileNameCustom(virNetworkDriverStatePtr driver,\n                                  const char *bridge)\n{\n    char *leasefile;\n\n    leasefile = g_strdup_printf(\"%s/%s.status\", driver->dnsmasqStateDir, bridge);\n    return leasefile;\n}"
  },
  {
    "function_name": "networkDnsmasqLeaseFileNameDefault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "367-375",
    "snippet": "static char *\nnetworkDnsmasqLeaseFileNameDefault(virNetworkDriverStatePtr driver,\n                                   const char *netname)\n{\n    char *leasefile;\n\n    leasefile = g_strdup_printf(\"%s/%s.leases\", driver->dnsmasqStateDir, netname);\n    return leasefile;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s.leases\"",
            "driver->dnsmasqStateDir",
            "netname"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic char *\nnetworkDnsmasqLeaseFileNameDefault(virNetworkDriverStatePtr driver,\n                                   const char *netname)\n{\n    char *leasefile;\n\n    leasefile = g_strdup_printf(\"%s/%s.leases\", driver->dnsmasqStateDir, netname);\n    return leasefile;\n}"
  },
  {
    "function_name": "networkRunHook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "316-364",
    "snippet": "static int\nnetworkRunHook(virNetworkObjPtr obj,\n               virNetworkPortDefPtr port,\n               int op,\n               int sub_op)\n{\n    virNetworkDefPtr def;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xml = NULL;\n    int hookret;\n    int ret = -1;\n\n    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {\n        if (!obj) {\n            VIR_DEBUG(\"Not running hook as @obj is NULL\");\n            ret = 0;\n            goto cleanup;\n        }\n        def = virNetworkObjGetDef(obj);\n\n        virBufferAddLit(&buf, \"<hookData>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        if (virNetworkDefFormatBuf(&buf, def, network_driver->xmlopt, 0) < 0)\n            goto cleanup;\n        if (port && virNetworkPortDefFormatBuf(&buf, port) < 0)\n            goto cleanup;\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</hookData>\");\n\n        xml = virBufferContentAndReset(&buf);\n        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, def->name,\n                              op, sub_op, NULL, xml, NULL);\n\n        /*\n         * If the script raised an error, pass it to the callee.\n         */\n        if (hookret < 0)\n            goto cleanup;\n\n        networkNetworkObjTaint(obj, VIR_NETWORK_TAINT_HOOK);\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n    VIR_FREE(xml);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverStatePtr network_driver;",
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkNetworkObjTaint",
          "args": [
            "obj",
            "VIR_NETWORK_TAINT_HOOK"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "networkNetworkObjTaint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "5312-5325",
          "snippet": "static void\nnetworkNetworkObjTaint(virNetworkObjPtr obj,\n                       virNetworkTaintFlags taint)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n\n    if (virNetworkObjTaint(obj, taint)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n        virUUIDFormat(def->uuid, uuidstr);\n\n        VIR_WARN(\"Network name='%s' uuid=%s is tainted: %s\",\n                 def->name, uuidstr, virNetworkTaintTypeToString(taint));\n    }\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
            "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
            "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
            "static void\nnetworkNetworkObjTaint(virNetworkObjPtr obj,\n                       virNetworkTaintFlags taint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkNetworkObjTaint(virNetworkObjPtr obj,\n                       virNetworkTaintFlags taint);\n\nstatic void\nnetworkNetworkObjTaint(virNetworkObjPtr obj,\n                       virNetworkTaintFlags taint)\n{\n    virNetworkDefPtr def = virNetworkObjGetDef(obj);\n\n    if (virNetworkObjTaint(obj, taint)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n        virUUIDFormat(def->uuid, uuidstr);\n\n        VIR_WARN(\"Network name='%s' uuid=%s is tainted: %s\",\n                 def->name, uuidstr, virNetworkTaintTypeToString(taint));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHookCall",
          "args": [
            "VIR_HOOK_DRIVER_NETWORK",
            "def->name",
            "op",
            "sub_op",
            "NULL",
            "xml",
            "NULL"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "virHookCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "243-341",
          "snippet": "int\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\""
          ],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\"\n\nstatic int virHooksFound = -1;\n\nint\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"</hookData>\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "&buf",
            "-2"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkPortDefFormatBuf",
          "args": [
            "&buf",
            "port"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkPortDefFormatBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkportdef.c",
          "lines": "338-428",
          "snippet": "int\nvirNetworkPortDefFormatBuf(virBufferPtr buf,\n                           const virNetworkPortDef *def)\n{\n    char uuid[VIR_UUID_STRING_BUFLEN];\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n\n    virBufferAddLit(buf, \"<networkport>\\n\");\n\n    virBufferAdjustIndent(buf, 2);\n\n    virUUIDFormat(def->uuid, uuid);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuid);\n\n    virBufferAddLit(buf, \"<owner>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->ownername);\n    virUUIDFormat(def->owneruuid, uuid);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuid);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</owner>\\n\");\n\n    virBufferEscapeString(buf, \"<group>%s</group>\\n\", def->group);\n\n    virMacAddrFormat(&def->mac, macaddr);\n    virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", macaddr);\n\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n    if (def->bandwidth)\n        virNetDevBandwidthFormat(def->bandwidth, def->class_id, buf);\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    virNetworkPortOptionsFormat(def->isolatedPort, buf);\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \"<rxfilters trustGuest='%s'/>\\n\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n\n    if (def->plugtype != VIR_NETWORK_PORT_PLUG_TYPE_NONE) {\n        virBufferAsprintf(buf, \"<plug type='%s'\",\n                          virNetworkPortPlugTypeToString(def->plugtype));\n\n        switch (def->plugtype) {\n        case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n        case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n            virBufferEscapeString(buf, \" bridge='%s'\", def->plug.bridge.brname);\n            if (def->plug.bridge.macTableManager)\n                virBufferAsprintf(buf, \" macTableManager='%s'\",\n                                  virNetworkBridgeMACTableManagerTypeToString(\n                                      def->plug.bridge.macTableManager));\n            virBufferAddLit(buf, \"/>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n            virBufferEscapeString(buf, \" dev='%s'\", def->plug.direct.linkdev);\n            virBufferAsprintf(buf, \" mode='%s'\",\n                              virNetDevMacVLanModeTypeToString(\n                                  def->plug.direct.mode));\n            virBufferAddLit(buf, \"/>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n            virBufferAsprintf(buf, \" managed='%s'>\\n\",\n                              def->plug.hostdevpci.managed ? \"yes\" : \"no\");\n            virBufferAdjustIndent(buf, 2);\n            if (def->plug.hostdevpci.driver)\n                virBufferEscapeString(buf, \"<driver name='%s'/>\\n\",\n                                      virNetworkForwardDriverNameTypeToString(\n                                          def->plug.hostdevpci.driver));\n\n            virPCIDeviceAddressFormat(buf, def->plug.hostdevpci.addr, false);\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</plug>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n        default:\n            virReportEnumRangeError(virNetworkPortPlugType, def->plugtype);\n            return -1;\n        }\n    }\n\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</networkport>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"network_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkPortDefFormatBuf(virBufferPtr buf,\n                           const virNetworkPortDef *def)\n{\n    char uuid[VIR_UUID_STRING_BUFLEN];\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n\n    virBufferAddLit(buf, \"<networkport>\\n\");\n\n    virBufferAdjustIndent(buf, 2);\n\n    virUUIDFormat(def->uuid, uuid);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuid);\n\n    virBufferAddLit(buf, \"<owner>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->ownername);\n    virUUIDFormat(def->owneruuid, uuid);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuid);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</owner>\\n\");\n\n    virBufferEscapeString(buf, \"<group>%s</group>\\n\", def->group);\n\n    virMacAddrFormat(&def->mac, macaddr);\n    virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", macaddr);\n\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n    if (def->bandwidth)\n        virNetDevBandwidthFormat(def->bandwidth, def->class_id, buf);\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    virNetworkPortOptionsFormat(def->isolatedPort, buf);\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \"<rxfilters trustGuest='%s'/>\\n\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n\n    if (def->plugtype != VIR_NETWORK_PORT_PLUG_TYPE_NONE) {\n        virBufferAsprintf(buf, \"<plug type='%s'\",\n                          virNetworkPortPlugTypeToString(def->plugtype));\n\n        switch (def->plugtype) {\n        case VIR_NETWORK_PORT_PLUG_TYPE_NONE:\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_NETWORK:\n        case VIR_NETWORK_PORT_PLUG_TYPE_BRIDGE:\n            virBufferEscapeString(buf, \" bridge='%s'\", def->plug.bridge.brname);\n            if (def->plug.bridge.macTableManager)\n                virBufferAsprintf(buf, \" macTableManager='%s'\",\n                                  virNetworkBridgeMACTableManagerTypeToString(\n                                      def->plug.bridge.macTableManager));\n            virBufferAddLit(buf, \"/>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_DIRECT:\n            virBufferEscapeString(buf, \" dev='%s'\", def->plug.direct.linkdev);\n            virBufferAsprintf(buf, \" mode='%s'\",\n                              virNetDevMacVLanModeTypeToString(\n                                  def->plug.direct.mode));\n            virBufferAddLit(buf, \"/>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_HOSTDEV_PCI:\n            virBufferAsprintf(buf, \" managed='%s'>\\n\",\n                              def->plug.hostdevpci.managed ? \"yes\" : \"no\");\n            virBufferAdjustIndent(buf, 2);\n            if (def->plug.hostdevpci.driver)\n                virBufferEscapeString(buf, \"<driver name='%s'/>\\n\",\n                                      virNetworkForwardDriverNameTypeToString(\n                                          def->plug.hostdevpci.driver));\n\n            virPCIDeviceAddressFormat(buf, def->plug.hostdevpci.addr, false);\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</plug>\\n\");\n            break;\n\n        case VIR_NETWORK_PORT_PLUG_TYPE_LAST:\n        default:\n            virReportEnumRangeError(virNetworkPortPlugType, def->plugtype);\n            return -1;\n        }\n    }\n\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</networkport>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefFormatBuf",
          "args": [
            "&buf",
            "def",
            "network_driver->xmlopt",
            "0"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefFormatBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2440-2670",
          "snippet": "int\nvirNetworkDefFormatBuf(virBufferPtr buf,\n                       const virNetworkDef *def,\n                       virNetworkXMLOptionPtr xmlopt G_GNUC_UNUSED,\n                       unsigned int flags)\n{\n    const unsigned char *uuid;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    size_t i;\n    bool shortforward;\n    bool hasbridge = false;\n\n    virBufferAddLit(buf, \"<network\");\n    if (def->namespaceData && def->ns.format)\n        virXMLNamespaceFormatNS(buf, &def->ns);\n    if (!(flags & VIR_NETWORK_XML_INACTIVE) && (def->connections > 0))\n        virBufferAsprintf(buf, \" connections='%d'\", def->connections);\n    if (def->ipv6nogw)\n        virBufferAddLit(buf, \" ipv6='yes'\");\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \" trustGuestRxFilters='%s'\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->name);\n\n    uuid = def->uuid;\n    virUUIDFormat(uuid, uuidstr);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n\n    if (def->metadata) {\n        xmlBufferPtr xmlbuf;\n        int oldIndentTreeOutput = xmlIndentTreeOutput;\n\n        /* Indentation on output requires that we previously set\n         * xmlKeepBlanksDefault to 0 when parsing; also, libxml does 2\n         * spaces per level of indentation of intermediate elements,\n         * but no leading indentation before the starting element.\n         * Thankfully, libxml maps what looks like globals into\n         * thread-local uses, so we are thread-safe.  */\n        xmlIndentTreeOutput = 1;\n        xmlbuf = xmlBufferCreate();\n        if (xmlNodeDump(xmlbuf, def->metadata->doc, def->metadata,\n                        virBufferGetIndent(buf) / 2, 1) < 0) {\n            xmlBufferFree(xmlbuf);\n            xmlIndentTreeOutput = oldIndentTreeOutput;\n            return -1;\n        }\n        virBufferAsprintf(buf, \"%s\\n\", (char *) xmlBufferContent(xmlbuf));\n        xmlBufferFree(xmlbuf);\n        xmlIndentTreeOutput = oldIndentTreeOutput;\n    }\n\n    if (def->forward.type != VIR_NETWORK_FORWARD_NONE) {\n        const char *dev = NULL;\n        if (!def->forward.npfs)\n            dev = virNetworkDefForwardIf(def, 0);\n        const char *mode = virNetworkForwardTypeToString(def->forward.type);\n\n        if (!mode) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown forward type %d in network '%s'\"),\n                           def->forward.type, def->name);\n            return -1;\n        }\n        virBufferAddLit(buf, \"<forward\");\n        virBufferEscapeString(buf, \" dev='%s'\", dev);\n        virBufferAsprintf(buf, \" mode='%s'\", mode);\n        if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n            if (def->forward.managed)\n                virBufferAddLit(buf, \" managed='yes'\");\n            else\n                virBufferAddLit(buf, \" managed='no'\");\n        }\n        shortforward = !(def->forward.nifs || def->forward.npfs\n                         || VIR_SOCKET_ADDR_VALID(&def->forward.addr.start)\n                         || VIR_SOCKET_ADDR_VALID(&def->forward.addr.end)\n                         || def->forward.port.start\n                         || def->forward.port.end\n                         || (def->forward.driverName\n                             != VIR_NETWORK_FORWARD_DRIVER_NAME_DEFAULT));\n        virBufferAsprintf(buf, \"%s>\\n\", shortforward ? \"/\" : \"\");\n        virBufferAdjustIndent(buf, 2);\n\n        if (def->forward.driverName\n            != VIR_NETWORK_FORWARD_DRIVER_NAME_DEFAULT) {\n            const char *driverName\n                = virNetworkForwardDriverNameTypeToString(def->forward.driverName);\n            if (!driverName) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unexpected hostdev driver name type %d \"),\n                               def->forward.driverName);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<driver name='%s'/>\\n\", driverName);\n        }\n        if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n            if (virNetworkForwardNatDefFormat(buf, &def->forward) < 0)\n                return -1;\n        }\n\n        /* For now, hard-coded to at most 1 forward.pfs */\n        if (def->forward.npfs)\n            virBufferEscapeString(buf, \"<pf dev='%s'/>\\n\",\n                                  def->forward.pfs[0].dev);\n\n        if (def->forward.nifs &&\n            (!def->forward.npfs || !(flags & VIR_NETWORK_XML_INACTIVE))) {\n            for (i = 0; i < def->forward.nifs; i++) {\n                if (def->forward.ifs[i].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV) {\n                    virBufferEscapeString(buf, \"<interface dev='%s'\",\n                                          def->forward.ifs[i].device.dev);\n                    if (!(flags & VIR_NETWORK_XML_INACTIVE) &&\n                        (def->forward.ifs[i].connections > 0)) {\n                        virBufferAsprintf(buf, \" connections='%d'\",\n                                          def->forward.ifs[i].connections);\n                    }\n                    virBufferAddLit(buf, \"/>\\n\");\n                } else {\n                    if (def->forward.ifs[i].type ==  VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI) {\n                        virPCIDeviceAddressFormat(buf,\n                                                  def->forward.ifs[i].device.pci,\n                                                  true);\n                    }\n                }\n            }\n        }\n        virBufferAdjustIndent(buf, -2);\n        if (!shortforward)\n            virBufferAddLit(buf, \"</forward>\\n\");\n    }\n\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        hasbridge = true;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    if (hasbridge || def->bridge || def->macTableManager) {\n        virBufferAddLit(buf, \"<bridge\");\n        virBufferEscapeString(buf, \" name='%s'\", def->bridge);\n        virBufferEscapeString(buf, \" zone='%s'\", def->bridgeZone);\n        if (hasbridge)\n            virBufferAsprintf(buf, \" stp='%s' delay='%ld'\",\n                              def->stp ? \"on\" : \"off\", def->delay);\n        if (def->macTableManager) {\n            virBufferAsprintf(buf, \" macTableManager='%s'\",\n                             virNetworkBridgeMACTableManagerTypeToString(def->macTableManager));\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->mtu)\n        virBufferAsprintf(buf, \"<mtu size='%u'/>\\n\", def->mtu);\n\n    if (def->mac_specified) {\n        char macaddr[VIR_MAC_STRING_BUFLEN];\n        virMacAddrFormat(&def->mac, macaddr);\n        virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", macaddr);\n    }\n\n    if (def->domain) {\n        virBufferAsprintf(buf, \"<domain name='%s'\", def->domain);\n\n        /* default to \"no\", but don't format it in the XML */\n        if (def->domainLocalOnly) {\n            const char *local = virTristateBoolTypeToString(def->domainLocalOnly);\n\n            if (!local) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown localOnly type %d in network\"),\n                               def->domainLocalOnly);\n                return -1;\n            }\n            virBufferAsprintf(buf, \" localOnly='%s'\", local);\n        }\n\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (virNetworkDNSDefFormat(buf, &def->dns) < 0)\n        return -1;\n\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    if (virNetDevBandwidthFormat(def->bandwidth, 0, buf) < 0)\n        return -1;\n    virNetworkPortOptionsFormat(def->isolatedPort, buf);\n\n    for (i = 0; i < def->nips; i++) {\n        if (virNetworkIPDefFormat(buf, &def->ips[i]) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nroutes; i++) {\n        if (virNetDevIPRouteFormat(buf, def->routes[i]) < 0)\n            return -1;\n    }\n\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n\n    for (i = 0; i < def->nPortGroups; i++)\n        if (virPortGroupDefFormat(buf, &def->portGroups[i]) < 0)\n            return -1;\n\n    if (def->namespaceData && def->ns.format) {\n        if ((def->ns.format)(buf, def->namespaceData) < 0)\n            return -1;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</network>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetworkDefFormatBuf(virBufferPtr buf,\n                       const virNetworkDef *def,\n                       virNetworkXMLOptionPtr xmlopt G_GNUC_UNUSED,\n                       unsigned int flags)\n{\n    const unsigned char *uuid;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    size_t i;\n    bool shortforward;\n    bool hasbridge = false;\n\n    virBufferAddLit(buf, \"<network\");\n    if (def->namespaceData && def->ns.format)\n        virXMLNamespaceFormatNS(buf, &def->ns);\n    if (!(flags & VIR_NETWORK_XML_INACTIVE) && (def->connections > 0))\n        virBufferAsprintf(buf, \" connections='%d'\", def->connections);\n    if (def->ipv6nogw)\n        virBufferAddLit(buf, \" ipv6='yes'\");\n    if (def->trustGuestRxFilters)\n        virBufferAsprintf(buf, \" trustGuestRxFilters='%s'\",\n                          virTristateBoolTypeToString(def->trustGuestRxFilters));\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->name);\n\n    uuid = def->uuid;\n    virUUIDFormat(uuid, uuidstr);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n\n    if (def->metadata) {\n        xmlBufferPtr xmlbuf;\n        int oldIndentTreeOutput = xmlIndentTreeOutput;\n\n        /* Indentation on output requires that we previously set\n         * xmlKeepBlanksDefault to 0 when parsing; also, libxml does 2\n         * spaces per level of indentation of intermediate elements,\n         * but no leading indentation before the starting element.\n         * Thankfully, libxml maps what looks like globals into\n         * thread-local uses, so we are thread-safe.  */\n        xmlIndentTreeOutput = 1;\n        xmlbuf = xmlBufferCreate();\n        if (xmlNodeDump(xmlbuf, def->metadata->doc, def->metadata,\n                        virBufferGetIndent(buf) / 2, 1) < 0) {\n            xmlBufferFree(xmlbuf);\n            xmlIndentTreeOutput = oldIndentTreeOutput;\n            return -1;\n        }\n        virBufferAsprintf(buf, \"%s\\n\", (char *) xmlBufferContent(xmlbuf));\n        xmlBufferFree(xmlbuf);\n        xmlIndentTreeOutput = oldIndentTreeOutput;\n    }\n\n    if (def->forward.type != VIR_NETWORK_FORWARD_NONE) {\n        const char *dev = NULL;\n        if (!def->forward.npfs)\n            dev = virNetworkDefForwardIf(def, 0);\n        const char *mode = virNetworkForwardTypeToString(def->forward.type);\n\n        if (!mode) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown forward type %d in network '%s'\"),\n                           def->forward.type, def->name);\n            return -1;\n        }\n        virBufferAddLit(buf, \"<forward\");\n        virBufferEscapeString(buf, \" dev='%s'\", dev);\n        virBufferAsprintf(buf, \" mode='%s'\", mode);\n        if (def->forward.type == VIR_NETWORK_FORWARD_HOSTDEV) {\n            if (def->forward.managed)\n                virBufferAddLit(buf, \" managed='yes'\");\n            else\n                virBufferAddLit(buf, \" managed='no'\");\n        }\n        shortforward = !(def->forward.nifs || def->forward.npfs\n                         || VIR_SOCKET_ADDR_VALID(&def->forward.addr.start)\n                         || VIR_SOCKET_ADDR_VALID(&def->forward.addr.end)\n                         || def->forward.port.start\n                         || def->forward.port.end\n                         || (def->forward.driverName\n                             != VIR_NETWORK_FORWARD_DRIVER_NAME_DEFAULT));\n        virBufferAsprintf(buf, \"%s>\\n\", shortforward ? \"/\" : \"\");\n        virBufferAdjustIndent(buf, 2);\n\n        if (def->forward.driverName\n            != VIR_NETWORK_FORWARD_DRIVER_NAME_DEFAULT) {\n            const char *driverName\n                = virNetworkForwardDriverNameTypeToString(def->forward.driverName);\n            if (!driverName) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unexpected hostdev driver name type %d \"),\n                               def->forward.driverName);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<driver name='%s'/>\\n\", driverName);\n        }\n        if (def->forward.type == VIR_NETWORK_FORWARD_NAT) {\n            if (virNetworkForwardNatDefFormat(buf, &def->forward) < 0)\n                return -1;\n        }\n\n        /* For now, hard-coded to at most 1 forward.pfs */\n        if (def->forward.npfs)\n            virBufferEscapeString(buf, \"<pf dev='%s'/>\\n\",\n                                  def->forward.pfs[0].dev);\n\n        if (def->forward.nifs &&\n            (!def->forward.npfs || !(flags & VIR_NETWORK_XML_INACTIVE))) {\n            for (i = 0; i < def->forward.nifs; i++) {\n                if (def->forward.ifs[i].type == VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_NETDEV) {\n                    virBufferEscapeString(buf, \"<interface dev='%s'\",\n                                          def->forward.ifs[i].device.dev);\n                    if (!(flags & VIR_NETWORK_XML_INACTIVE) &&\n                        (def->forward.ifs[i].connections > 0)) {\n                        virBufferAsprintf(buf, \" connections='%d'\",\n                                          def->forward.ifs[i].connections);\n                    }\n                    virBufferAddLit(buf, \"/>\\n\");\n                } else {\n                    if (def->forward.ifs[i].type ==  VIR_NETWORK_FORWARD_HOSTDEV_DEVICE_PCI) {\n                        virPCIDeviceAddressFormat(buf,\n                                                  def->forward.ifs[i].device.pci,\n                                                  true);\n                    }\n                }\n            }\n        }\n        virBufferAdjustIndent(buf, -2);\n        if (!shortforward)\n            virBufferAddLit(buf, \"</forward>\\n\");\n    }\n\n    switch ((virNetworkForwardType) def->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        hasbridge = true;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, def->forward.type);\n        return -1;\n    }\n\n    if (hasbridge || def->bridge || def->macTableManager) {\n        virBufferAddLit(buf, \"<bridge\");\n        virBufferEscapeString(buf, \" name='%s'\", def->bridge);\n        virBufferEscapeString(buf, \" zone='%s'\", def->bridgeZone);\n        if (hasbridge)\n            virBufferAsprintf(buf, \" stp='%s' delay='%ld'\",\n                              def->stp ? \"on\" : \"off\", def->delay);\n        if (def->macTableManager) {\n            virBufferAsprintf(buf, \" macTableManager='%s'\",\n                             virNetworkBridgeMACTableManagerTypeToString(def->macTableManager));\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->mtu)\n        virBufferAsprintf(buf, \"<mtu size='%u'/>\\n\", def->mtu);\n\n    if (def->mac_specified) {\n        char macaddr[VIR_MAC_STRING_BUFLEN];\n        virMacAddrFormat(&def->mac, macaddr);\n        virBufferAsprintf(buf, \"<mac address='%s'/>\\n\", macaddr);\n    }\n\n    if (def->domain) {\n        virBufferAsprintf(buf, \"<domain name='%s'\", def->domain);\n\n        /* default to \"no\", but don't format it in the XML */\n        if (def->domainLocalOnly) {\n            const char *local = virTristateBoolTypeToString(def->domainLocalOnly);\n\n            if (!local) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown localOnly type %d in network\"),\n                               def->domainLocalOnly);\n                return -1;\n            }\n            virBufferAsprintf(buf, \" localOnly='%s'\", local);\n        }\n\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (virNetworkDNSDefFormat(buf, &def->dns) < 0)\n        return -1;\n\n    if (virNetDevVlanFormat(&def->vlan, buf) < 0)\n        return -1;\n    if (virNetDevBandwidthFormat(def->bandwidth, 0, buf) < 0)\n        return -1;\n    virNetworkPortOptionsFormat(def->isolatedPort, buf);\n\n    for (i = 0; i < def->nips; i++) {\n        if (virNetworkIPDefFormat(buf, &def->ips[i]) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nroutes; i++) {\n        if (virNetDevIPRouteFormat(buf, def->routes[i]) < 0)\n            return -1;\n    }\n\n    if (virNetDevVPortProfileFormat(def->virtPortProfile, buf) < 0)\n        return -1;\n\n    for (i = 0; i < def->nPortGroups; i++)\n        if (virPortGroupDefFormat(buf, &def->portGroups[i]) < 0)\n            return -1;\n\n    if (def->namespaceData && def->ns.format) {\n        if ((def->ns.format)(buf, def->namespaceData) < 0)\n            return -1;\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</network>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"<hookData>\\n\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkObjGetDef",
          "args": [
            "obj"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "148-152",
          "snippet": "virNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkDefPtr\nvirNetworkObjGetDef(virNetworkObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Not running hook as @obj is NULL\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHookPresent",
          "args": [
            "VIR_HOOK_DRIVER_NETWORK"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "virHookPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "210-222",
          "snippet": "int\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virHooksFound = -1;\n\nint\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkNotifyPort(virNetworkObjPtr obj,\n                  virNetworkPortDefPtr port);\n\nstatic int\nnetworkRunHook(virNetworkObjPtr obj,\n               virNetworkPortDefPtr port,\n               int op,\n               int sub_op)\n{\n    virNetworkDefPtr def;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xml = NULL;\n    int hookret;\n    int ret = -1;\n\n    if (virHookPresent(VIR_HOOK_DRIVER_NETWORK)) {\n        if (!obj) {\n            VIR_DEBUG(\"Not running hook as @obj is NULL\");\n            ret = 0;\n            goto cleanup;\n        }\n        def = virNetworkObjGetDef(obj);\n\n        virBufferAddLit(&buf, \"<hookData>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        if (virNetworkDefFormatBuf(&buf, def, network_driver->xmlopt, 0) < 0)\n            goto cleanup;\n        if (port && virNetworkPortDefFormatBuf(&buf, port) < 0)\n            goto cleanup;\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</hookData>\");\n\n        xml = virBufferContentAndReset(&buf);\n        hookret = virHookCall(VIR_HOOK_DRIVER_NETWORK, def->name,\n                              op, sub_op, NULL, xml, NULL);\n\n        /*\n         * If the script raised an error, pass it to the callee.\n         */\n        if (hookret < 0)\n            goto cleanup;\n\n        networkNetworkObjTaint(obj, VIR_NETWORK_TAINT_HOOK);\n    }\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n    VIR_FREE(xml);\n    return ret;\n}"
  },
  {
    "function_name": "networkObjFromNetwork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "297-313",
    "snippet": "static virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);",
      "static int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);",
      "static int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);",
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_NETWORK",
            "_(\"no network with matching uuid '%s' (%s)\")",
            "uuidstr",
            "net->name"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no network with matching uuid '%s' (%s)\""
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "net->uuid",
            "uuidstr"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkObjFindByUUID",
          "args": [
            "driver->networks",
            "net->uuid"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkObjFindByUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnetworkobj.c",
          "lines": "390-402",
          "snippet": "virNetworkObjPtr\nvirNetworkObjFindByUUID(virNetworkObjListPtr nets,\n                        const unsigned char *uuid)\n{\n    virNetworkObjPtr obj;\n\n    virObjectRWLockRead(nets);\n    obj = virNetworkObjFindByUUIDLocked(nets, uuid);\n    virObjectRWUnlock(nets);\n    if (obj)\n        virObjectLock(obj);\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetworkobj.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetworkObjDispose(void *obj);",
            "static void virNetworkObjListDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetworkobj.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nstatic void virNetworkObjDispose(void *obj);\nstatic void virNetworkObjListDispose(void *obj);\n\nvirNetworkObjPtr\nvirNetworkObjFindByUUID(virNetworkObjListPtr nets,\n                        const unsigned char *uuid)\n{\n    virNetworkObjPtr obj;\n\n    virObjectRWLockRead(nets);\n    obj = virNetworkObjFindByUUIDLocked(nets, uuid);\n    virObjectRWUnlock(nets);\n    if (obj)\n        virObjectLock(obj);\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkGetDriver",
          "args": [],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "networkGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "91-98",
          "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNetworkDriverStatePtr network_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkStartNetwork(virNetworkDriverStatePtr driver,\n                    virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetwork(virNetworkDriverStatePtr driver,\n                       virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkVirtual(virNetworkDriverStatePtr driver,\n                           virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkVirtual(virNetworkDriverStatePtr driver,\n                              virNetworkObjPtr obj);\nstatic int\nnetworkStartNetworkExternal(virNetworkObjPtr obj);\nstatic int\nnetworkShutdownNetworkExternal(virNetworkObjPtr obj);\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic virNetworkObjPtr\nnetworkObjFromNetwork(virNetworkPtr net)\n{\n    virNetworkDriverStatePtr driver = networkGetDriver();\n    virNetworkObjPtr obj;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    obj = virNetworkObjFindByUUID(driver->networks, net->uuid);\n    if (!obj) {\n        virUUIDFormat(net->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"no network with matching uuid '%s' (%s)\"),\n                       uuidstr, net->name);\n    }\n\n    return obj;\n}"
  },
  {
    "function_name": "networkDnsmasqCreateXMLConf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "243-247",
    "snippet": "virNetworkXMLOptionPtr\nnetworkDnsmasqCreateXMLConf(void)\n{\n    return virNetworkXMLOptionNew(&networkDnsmasqXMLNamespace);\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virXMLNamespace networkDnsmasqXMLNamespace = {\n    .parse = networkDnsmasqDefNamespaceParse,\n    .free = networkDnsmasqDefNamespaceFree,\n    .format = networkDnsmasqDefNamespaceFormatXML,\n    .prefix = \"dnsmasq\",\n    .uri = \"http://libvirt.org/schemas/network/dnsmasq/1.0\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkXMLOptionNew",
          "args": [
            "&networkDnsmasqXMLNamespace"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkXMLOptionNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "92-107",
          "snippet": "virNetworkXMLOptionPtr\nvirNetworkXMLOptionNew(virXMLNamespacePtr xmlns)\n{\n    virNetworkXMLOptionPtr xmlopt;\n\n    if (virNetworkXMLInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virNetworkXMLOptionClass)))\n        return NULL;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    return xmlopt;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetworkXMLOptionClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetworkXMLOptionClass;\n\nvirNetworkXMLOptionPtr\nvirNetworkXMLOptionNew(virXMLNamespacePtr xmlns)\n{\n    virNetworkXMLOptionPtr xmlopt;\n\n    if (virNetworkXMLInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virNetworkXMLOptionClass)))\n        return NULL;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    return xmlopt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirXMLNamespace networkDnsmasqXMLNamespace = {\n    .parse = networkDnsmasqDefNamespaceParse,\n    .free = networkDnsmasqDefNamespaceFree,\n    .format = networkDnsmasqDefNamespaceFormatXML,\n    .prefix = \"dnsmasq\",\n    .uri = \"http://libvirt.org/schemas/network/dnsmasq/1.0\",\n};\n\nvirNetworkXMLOptionPtr\nnetworkDnsmasqCreateXMLConf(void)\n{\n    return virNetworkXMLOptionNew(&networkDnsmasqXMLNamespace);\n}"
  },
  {
    "function_name": "networkDnsmasqDefNamespaceFormatXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "209-231",
    "snippet": "static int\nnetworkDnsmasqDefNamespaceFormatXML(virBufferPtr buf,\n                                    void *nsdata)\n{\n    networkDnsmasqXmlNsDefPtr def = nsdata;\n    size_t i;\n\n    if (!def->noptions)\n        return 0;\n\n    virBufferAddLit(buf, \"<dnsmasq:options>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < def->noptions; i++) {\n        virBufferEscapeString(buf, \"<dnsmasq:option value='%s'/>\\n\",\n                              def->options[i]);\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</dnsmasq:options>\\n\");\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</dnsmasq:options>\\n\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<dnsmasq:option value='%s'/>\\n\"",
            "def->options[i]"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<dnsmasq:options>\\n\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkDnsmasqDefNamespaceFormatXML(virBufferPtr buf,\n                                    void *nsdata)\n{\n    networkDnsmasqXmlNsDefPtr def = nsdata;\n    size_t i;\n\n    if (!def->noptions)\n        return 0;\n\n    virBufferAddLit(buf, \"<dnsmasq:options>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < def->noptions; i++) {\n        virBufferEscapeString(buf, \"<dnsmasq:option value='%s'/>\\n\",\n                              def->options[i]);\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</dnsmasq:options>\\n\");\n\n    return 0;\n}"
  },
  {
    "function_name": "networkDnsmasqDefNamespaceParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "185-206",
    "snippet": "static int\nnetworkDnsmasqDefNamespaceParse(xmlXPathContextPtr ctxt,\n                                void **data)\n{\n    networkDnsmasqXmlNsDefPtr nsdata = NULL;\n    int ret = -1;\n\n    if (VIR_ALLOC(nsdata) < 0)\n        return -1;\n\n    if (networkDnsmasqDefNamespaceParseOptions(nsdata, ctxt))\n        goto cleanup;\n\n    if (nsdata->noptions > 0)\n        *data = g_steal_pointer(&nsdata);\n\n    ret = 0;\n\n cleanup:\n    networkDnsmasqDefNamespaceFree(nsdata);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkDnsmasqDefNamespaceFree",
          "args": [
            "nsdata"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "networkDnsmasqDefNamespaceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "142-152",
          "snippet": "static void\nnetworkDnsmasqDefNamespaceFree(void *nsdata)\n{\n    networkDnsmasqXmlNsDefPtr def = nsdata;\n    if (!def)\n        return;\n\n    virStringListFreeCount(def->options, def->noptions);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkDnsmasqDefNamespaceFree(void *nsdata)\n{\n    networkDnsmasqXmlNsDefPtr def = nsdata;\n    if (!def)\n        return;\n\n    virStringListFreeCount(def->options, def->noptions);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&nsdata"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "networkDnsmasqDefNamespaceParseOptions",
          "args": [
            "nsdata",
            "ctxt"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "networkDnsmasqDefNamespaceParseOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "155-182",
          "snippet": "static int\nnetworkDnsmasqDefNamespaceParseOptions(networkDnsmasqXmlNsDefPtr nsdef,\n                                       xmlXPathContextPtr ctxt)\n{\n    g_autofree xmlNodePtr *nodes = NULL;\n    ssize_t nnodes;\n    size_t i;\n\n    if ((nnodes = virXPathNodeSet(\"./dnsmasq:options/dnsmasq:option\",\n                                  ctxt, &nodes)) < 0)\n        return -1;\n\n    if (nnodes == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(nsdef->options, nnodes) < 0)\n        return -1;\n\n    for (i = 0; i < nnodes; i++) {\n        if (!(nsdef->options[nsdef->noptions++] = virXMLPropString(nodes[i], \"value\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No dnsmasq options value specified\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkDnsmasqDefNamespaceParseOptions(networkDnsmasqXmlNsDefPtr nsdef,\n                                       xmlXPathContextPtr ctxt)\n{\n    g_autofree xmlNodePtr *nodes = NULL;\n    ssize_t nnodes;\n    size_t i;\n\n    if ((nnodes = virXPathNodeSet(\"./dnsmasq:options/dnsmasq:option\",\n                                  ctxt, &nodes)) < 0)\n        return -1;\n\n    if (nnodes == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(nsdef->options, nnodes) < 0)\n        return -1;\n\n    for (i = 0; i < nnodes; i++) {\n        if (!(nsdef->options[nsdef->noptions++] = virXMLPropString(nodes[i], \"value\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No dnsmasq options value specified\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "nsdata"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkDnsmasqDefNamespaceParse(xmlXPathContextPtr ctxt,\n                                void **data)\n{\n    networkDnsmasqXmlNsDefPtr nsdata = NULL;\n    int ret = -1;\n\n    if (VIR_ALLOC(nsdata) < 0)\n        return -1;\n\n    if (networkDnsmasqDefNamespaceParseOptions(nsdata, ctxt))\n        goto cleanup;\n\n    if (nsdata->noptions > 0)\n        *data = g_steal_pointer(&nsdata);\n\n    ret = 0;\n\n cleanup:\n    networkDnsmasqDefNamespaceFree(nsdata);\n    return ret;\n}"
  },
  {
    "function_name": "networkDnsmasqDefNamespaceParseOptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "155-182",
    "snippet": "static int\nnetworkDnsmasqDefNamespaceParseOptions(networkDnsmasqXmlNsDefPtr nsdef,\n                                       xmlXPathContextPtr ctxt)\n{\n    g_autofree xmlNodePtr *nodes = NULL;\n    ssize_t nnodes;\n    size_t i;\n\n    if ((nnodes = virXPathNodeSet(\"./dnsmasq:options/dnsmasq:option\",\n                                  ctxt, &nodes)) < 0)\n        return -1;\n\n    if (nnodes == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(nsdef->options, nnodes) < 0)\n        return -1;\n\n    for (i = 0; i < nnodes; i++) {\n        if (!(nsdef->options[nsdef->noptions++] = virXMLPropString(nodes[i], \"value\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No dnsmasq options value specified\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"No dnsmasq options value specified\")"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No dnsmasq options value specified\""
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "nodes[i]",
            "\"value\""
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "nsdef->options",
            "nnodes"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./dnsmasq:options/dnsmasq:option\"",
            "ctxt",
            "&nodes"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nnetworkDnsmasqDefNamespaceParseOptions(networkDnsmasqXmlNsDefPtr nsdef,\n                                       xmlXPathContextPtr ctxt)\n{\n    g_autofree xmlNodePtr *nodes = NULL;\n    ssize_t nnodes;\n    size_t i;\n\n    if ((nnodes = virXPathNodeSet(\"./dnsmasq:options/dnsmasq:option\",\n                                  ctxt, &nodes)) < 0)\n        return -1;\n\n    if (nnodes == 0)\n        return 0;\n\n    if (VIR_ALLOC_N(nsdef->options, nnodes) < 0)\n        return -1;\n\n    for (i = 0; i < nnodes; i++) {\n        if (!(nsdef->options[nsdef->noptions++] = virXMLPropString(nodes[i], \"value\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No dnsmasq options value specified\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "networkDnsmasqDefNamespaceFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "142-152",
    "snippet": "static void\nnetworkDnsmasqDefNamespaceFree(void *nsdata)\n{\n    networkDnsmasqXmlNsDefPtr def = nsdata;\n    if (!def)\n        return;\n\n    virStringListFreeCount(def->options, def->noptions);\n\n    VIR_FREE(def);\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFreeCount",
          "args": [
            "def->options",
            "def->noptions"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFreeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "334-347",
          "snippet": "void\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkDnsmasqDefNamespaceFree(void *nsdata)\n{\n    networkDnsmasqXmlNsDefPtr def = nsdata;\n    if (!def)\n        return;\n\n    virStringListFreeCount(def->options, def->noptions);\n\n    VIR_FREE(def);\n}"
  },
  {
    "function_name": "networkDnsmasqCapsRefresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "126-139",
    "snippet": "static int\nnetworkDnsmasqCapsRefresh(virNetworkDriverStatePtr driver)\n{\n    dnsmasqCapsPtr caps;\n\n    if (!(caps = dnsmasqCapsNewFromBinary(DNSMASQ)))\n        return -1;\n\n    networkDriverLock(driver);\n    virObjectUnref(driver->dnsmasqCaps);\n    driver->dnsmasqCaps = caps;\n    networkDriverUnlock(driver);\n    return 0;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "networkDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "108-112",
          "snippet": "static void\nnetworkDriverUnlock(virNetworkDriverStatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic void\nnetworkDriverUnlock(virNetworkDriverStatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "driver->dnsmasqCaps"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkDriverLock",
          "args": [
            "driver"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "networkDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "101-105",
          "snippet": "static void\nnetworkDriverLock(virNetworkDriverStatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic void\nnetworkDriverLock(virNetworkDriverStatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dnsmasqCapsNewFromBinary",
          "args": [
            "DNSMASQ"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "dnsmasqCapsNewFromBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdnsmasq.c",
          "lines": "813-826",
          "snippet": "dnsmasqCapsPtr\ndnsmasqCapsNewFromBinary(const char *binaryPath)\n{\n    dnsmasqCapsPtr caps = dnsmasqCapsNewEmpty(binaryPath);\n\n    if (!caps)\n        return NULL;\n\n    if (dnsmasqCapsRefreshInternal(caps, true) < 0) {\n        virObjectUnref(caps);\n        return NULL;\n    }\n    return caps;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virutil.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virbitmap.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <signal.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virutil.h\"\n#include \"virdnsmasq.h\"\n#include \"virbitmap.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\ndnsmasqCapsPtr\ndnsmasqCapsNewFromBinary(const char *binaryPath)\n{\n    dnsmasqCapsPtr caps = dnsmasqCapsNewEmpty(binaryPath);\n\n    if (!caps)\n        return NULL;\n\n    if (dnsmasqCapsRefreshInternal(caps, true) < 0) {\n        virObjectUnref(caps);\n        return NULL;\n    }\n    return caps;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic int\nnetworkDnsmasqCapsRefresh(virNetworkDriverStatePtr driver)\n{\n    dnsmasqCapsPtr caps;\n\n    if (!(caps = dnsmasqCapsNewFromBinary(DNSMASQ)))\n        return -1;\n\n    networkDriverLock(driver);\n    virObjectUnref(driver->dnsmasqCaps);\n    driver->dnsmasqCaps = caps;\n    networkDriverUnlock(driver);\n    return 0;\n}"
  },
  {
    "function_name": "networkGetDnsmasqCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "115-123",
    "snippet": "static dnsmasqCapsPtr\nnetworkGetDnsmasqCaps(virNetworkDriverStatePtr driver)\n{\n    dnsmasqCapsPtr ret;\n    networkDriverLock(driver);\n    ret = virObjectRef(driver->dnsmasqCaps);\n    networkDriverUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "networkDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "networkDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "108-112",
          "snippet": "static void\nnetworkDriverUnlock(virNetworkDriverStatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic void\nnetworkDriverUnlock(virNetworkDriverStatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "driver->dnsmasqCaps"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "networkDriverLock",
          "args": [
            "driver"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "networkDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
          "lines": "101-105",
          "snippet": "static void\nnetworkDriverLock(virNetworkDriverStatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virjson.h\"",
            "#include \"virhook.h\"",
            "#include \"network_event.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virdbus.h\"",
            "#include \"virpci.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevbridge.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include \"configmake.h\"",
            "#include \"virdnsmasq.h\"",
            "#include \"virlog.h\"",
            "#include \"viriptables.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"driver.h\"",
            "#include \"device_conf.h\"",
            "#include \"bridge_driver_platform.h\"",
            "#include \"bridge_driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <sys/sysctl.h>",
            "#include <net/if.h>",
            "#include <sys/ioctl.h>",
            "#include <pwd.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/utsname.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic void\nnetworkDriverLock(virNetworkDriverStatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic dnsmasqCapsPtr\nnetworkGetDnsmasqCaps(virNetworkDriverStatePtr driver)\n{\n    dnsmasqCapsPtr ret;\n    networkDriverLock(driver);\n    ret = virObjectRef(driver->dnsmasqCaps);\n    networkDriverUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "networkDriverUnlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "108-112",
    "snippet": "static void\nnetworkDriverUnlock(virNetworkDriverStatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&driver->lock"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic void\nnetworkDriverUnlock(virNetworkDriverStatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
  },
  {
    "function_name": "networkDriverLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "101-105",
    "snippet": "static void\nnetworkDriverLock(virNetworkDriverStatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&driver->lock"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic void\nnetworkRefreshDaemons(virNetworkDriverStatePtr driver);\n\nstatic void\nnetworkDriverLock(virNetworkDriverStatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}"
  },
  {
    "function_name": "networkGetDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/network/bridge_driver.c",
    "lines": "91-98",
    "snippet": "static virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}",
    "includes": [
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"virutil.h\"",
      "#include \"virnetworkportdef.h\"",
      "#include \"virjson.h\"",
      "#include \"virhook.h\"",
      "#include \"network_event.h\"",
      "#include \"viraccessapicheck.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include \"virdbus.h\"",
      "#include \"virpci.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include \"virnetdevtap.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virnetdevbridge.h\"",
      "#include \"virnetdevip.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include \"configmake.h\"",
      "#include \"virdnsmasq.h\"",
      "#include \"virlog.h\"",
      "#include \"viriptables.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"vircommand.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virbuffer.h\"",
      "#include \"driver.h\"",
      "#include \"device_conf.h\"",
      "#include \"bridge_driver_platform.h\"",
      "#include \"bridge_driver.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "# include <sys/sysctl.h>",
      "#include <net/if.h>",
      "#include <sys/ioctl.h>",
      "#include <pwd.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/utsname.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <sys/poll.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNetworkDriverStatePtr network_driver;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"netdev_bandwidth_conf.h\"\n#include \"virutil.h\"\n#include \"virnetworkportdef.h\"\n#include \"virjson.h\"\n#include \"virhook.h\"\n#include \"network_event.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virdbus.h\"\n#include \"virpci.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevbridge.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include \"configmake.h\"\n#include \"virdnsmasq.h\"\n#include \"virlog.h\"\n#include \"viriptables.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virpidfile.h\"\n#include \"virbuffer.h\"\n#include \"driver.h\"\n#include \"device_conf.h\"\n#include \"bridge_driver_platform.h\"\n#include \"bridge_driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <sys/sysctl.h>\n#include <net/if.h>\n#include <sys/ioctl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNetworkDriverStatePtr network_driver;\n\nstatic virNetworkDriverStatePtr\nnetworkGetDriver(void)\n{\n    /* Maybe one day we can store @network_driver in the\n     * connection object, but until then, it's just a global\n     * variable which is returned. */\n    return network_driver;\n}"
  }
]