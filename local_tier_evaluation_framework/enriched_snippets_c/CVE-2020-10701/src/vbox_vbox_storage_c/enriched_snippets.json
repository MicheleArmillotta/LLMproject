[
  {
    "function_name": "vboxGetStorageDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
    "lines": "878-893",
    "snippet": "virStorageDriverPtr vboxGetStorageDriver(uint32_t uVersion)\n{\n    /* Install gVBoxAPI according to the vbox API version.\n     * Return -1 for unsupported version.\n     */\n    if (uVersion >= 5000000 && uVersion < 5000051) {\n        vbox50InstallUniformedAPI(&gVBoxAPI);\n    } else if (uVersion >= 5000051 && uVersion < 5001051) {\n        vbox51InstallUniformedAPI(&gVBoxAPI);\n    } else if (uVersion >= 5001051 && uVersion < 5002051) {\n        vbox52InstallUniformedAPI(&gVBoxAPI);\n    } else {\n        return NULL;\n    }\n    return &vboxStorageDriver;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"virutil.h\"",
      "#include \"storage_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;",
      "virStorageDriver vboxStorageDriver = {\n    .connectNumOfStoragePools = vboxConnectNumOfStoragePools, /* 0.7.1 */\n    .connectListStoragePools = vboxConnectListStoragePools, /* 0.7.1 */\n    .storagePoolLookupByName = vboxStoragePoolLookupByName, /* 0.7.1 */\n    .storagePoolNumOfVolumes = vboxStoragePoolNumOfVolumes, /* 0.7.1 */\n    .storagePoolListVolumes = vboxStoragePoolListVolumes, /* 0.7.1 */\n\n    .storageVolLookupByName = vboxStorageVolLookupByName, /* 0.7.1 */\n    .storageVolLookupByKey = vboxStorageVolLookupByKey, /* 0.7.1 */\n    .storageVolLookupByPath = vboxStorageVolLookupByPath, /* 0.7.1 */\n    .storageVolCreateXML = vboxStorageVolCreateXML, /* 0.7.1 */\n    .storageVolDelete = vboxStorageVolDelete, /* 0.7.1 */\n    .storageVolGetInfo = vboxStorageVolGetInfo, /* 0.7.1 */\n    .storageVolGetXMLDesc = vboxStorageVolGetXMLDesc, /* 0.7.1 */\n    .storageVolGetPath = vboxStorageVolGetPath /* 0.7.1 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vbox52InstallUniformedAPI",
          "args": [
            "&gVBoxAPI"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vbox51InstallUniformedAPI",
          "args": [
            "&gVBoxAPI"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vbox50InstallUniformedAPI",
          "args": [
            "&gVBoxAPI"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\nvirStorageDriver vboxStorageDriver = {\n    .connectNumOfStoragePools = vboxConnectNumOfStoragePools, /* 0.7.1 */\n    .connectListStoragePools = vboxConnectListStoragePools, /* 0.7.1 */\n    .storagePoolLookupByName = vboxStoragePoolLookupByName, /* 0.7.1 */\n    .storagePoolNumOfVolumes = vboxStoragePoolNumOfVolumes, /* 0.7.1 */\n    .storagePoolListVolumes = vboxStoragePoolListVolumes, /* 0.7.1 */\n\n    .storageVolLookupByName = vboxStorageVolLookupByName, /* 0.7.1 */\n    .storageVolLookupByKey = vboxStorageVolLookupByKey, /* 0.7.1 */\n    .storageVolLookupByPath = vboxStorageVolLookupByPath, /* 0.7.1 */\n    .storageVolCreateXML = vboxStorageVolCreateXML, /* 0.7.1 */\n    .storageVolDelete = vboxStorageVolDelete, /* 0.7.1 */\n    .storageVolGetInfo = vboxStorageVolGetInfo, /* 0.7.1 */\n    .storageVolGetXMLDesc = vboxStorageVolGetXMLDesc, /* 0.7.1 */\n    .storageVolGetPath = vboxStorageVolGetPath /* 0.7.1 */\n};\n\nvirStorageDriverPtr vboxGetStorageDriver(uint32_t uVersion)\n{\n    /* Install gVBoxAPI according to the vbox API version.\n     * Return -1 for unsupported version.\n     */\n    if (uVersion >= 5000000 && uVersion < 5000051) {\n        vbox50InstallUniformedAPI(&gVBoxAPI);\n    } else if (uVersion >= 5000051 && uVersion < 5001051) {\n        vbox51InstallUniformedAPI(&gVBoxAPI);\n    } else if (uVersion >= 5001051 && uVersion < 5002051) {\n        vbox52InstallUniformedAPI(&gVBoxAPI);\n    } else {\n        return NULL;\n    }\n    return &vboxStorageDriver;\n}"
  },
  {
    "function_name": "vboxStorageVolGetPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
    "lines": "803-855",
    "snippet": "static char *vboxStorageVolGetPath(virStorageVolPtr vol)\n{\n    vboxDriverPtr data = vol->conn->privateData;\n    IMedium *hardDisk = NULL;\n    PRUnichar *hddLocationUtf16 = NULL;\n    char *hddLocationUtf8 = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    vboxIID hddIID;\n    PRUint32 hddstate;\n    nsresult rc;\n    char *ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (virUUIDParse(vol->key, uuid) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Could not parse UUID from '%s'\"), vol->key);\n        return ret;\n    }\n\n    VBOX_IID_INITIALIZE(&hddIID);\n    vboxIIDFromUUID(&hddIID, uuid);\n    rc = gVBoxAPI.UIVirtualBox.GetHardDiskByIID(data->vboxObj, &hddIID, &hardDisk);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n    if (hddstate == MediaState_Inaccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetLocation(hardDisk, &hddLocationUtf16);\n    if (!hddLocationUtf16)\n        goto cleanup;\n\n    VBOX_UTF16_TO_UTF8(hddLocationUtf16, &hddLocationUtf8);\n    if (!hddLocationUtf8)\n        goto cleanup;\n\n    ret = g_strdup(hddLocationUtf8);\n\n    VIR_DEBUG(\"Storage Volume Name: %s\", vol->name);\n    VIR_DEBUG(\"Storage Volume Path: %s\", hddLocationUtf8);\n    VIR_DEBUG(\"Storage Volume Pool: %s\", vol->pool);\n\n    VBOX_UTF8_FREE(hddLocationUtf8);\n\n cleanup:\n    VBOX_UTF16_FREE(hddLocationUtf16);\n    VBOX_MEDIUM_RELEASE(hardDisk);\n    vboxIIDUnalloc(&hddIID);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"virutil.h\"",
      "#include \"storage_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&hddIID"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_MEDIUM_RELEASE",
          "args": [
            "hardDisk"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "hddLocationUtf16"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "hddLocationUtf8"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume Pool: %s\"",
            "vol->pool"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume Path: %s\"",
            "hddLocationUtf8"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume Name: %s\"",
            "vol->name"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "hddLocationUtf8"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "hddLocationUtf16",
            "&hddLocationUtf8"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetLocation",
          "args": [
            "hardDisk",
            "&hddLocationUtf16"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetState",
          "args": [
            "hardDisk",
            "&hddstate"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHardDiskByIID",
          "args": [
            "data->vboxObj",
            "&hddIID",
            "&hardDisk"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDFromUUID",
          "args": [
            "&hddIID",
            "uuid"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&hddIID"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Could not parse UUID from '%s'\")",
            "vol->key"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not parse UUID from '%s'\""
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "vol->key",
            "uuid"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic char *vboxStorageVolGetPath(virStorageVolPtr vol)\n{\n    vboxDriverPtr data = vol->conn->privateData;\n    IMedium *hardDisk = NULL;\n    PRUnichar *hddLocationUtf16 = NULL;\n    char *hddLocationUtf8 = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    vboxIID hddIID;\n    PRUint32 hddstate;\n    nsresult rc;\n    char *ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (virUUIDParse(vol->key, uuid) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Could not parse UUID from '%s'\"), vol->key);\n        return ret;\n    }\n\n    VBOX_IID_INITIALIZE(&hddIID);\n    vboxIIDFromUUID(&hddIID, uuid);\n    rc = gVBoxAPI.UIVirtualBox.GetHardDiskByIID(data->vboxObj, &hddIID, &hardDisk);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n    if (hddstate == MediaState_Inaccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetLocation(hardDisk, &hddLocationUtf16);\n    if (!hddLocationUtf16)\n        goto cleanup;\n\n    VBOX_UTF16_TO_UTF8(hddLocationUtf16, &hddLocationUtf8);\n    if (!hddLocationUtf8)\n        goto cleanup;\n\n    ret = g_strdup(hddLocationUtf8);\n\n    VIR_DEBUG(\"Storage Volume Name: %s\", vol->name);\n    VIR_DEBUG(\"Storage Volume Path: %s\", hddLocationUtf8);\n    VIR_DEBUG(\"Storage Volume Pool: %s\", vol->pool);\n\n    VBOX_UTF8_FREE(hddLocationUtf8);\n\n cleanup:\n    VBOX_UTF16_FREE(hddLocationUtf16);\n    VBOX_MEDIUM_RELEASE(hardDisk);\n    vboxIIDUnalloc(&hddIID);\n    return ret;\n}"
  },
  {
    "function_name": "vboxStorageVolGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
    "lines": "713-801",
    "snippet": "static char *vboxStorageVolGetXMLDesc(virStorageVolPtr vol, unsigned int flags)\n{\n    vboxDriverPtr data = vol->conn->privateData;\n    IMedium *hardDisk = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    PRUnichar *hddFormatUtf16 = NULL;\n    char *hddFormatUtf8 = NULL;\n    PRUint64 hddLogicalSize = 0;\n    PRUint64 hddActualSize = 0;\n    virStoragePoolDef pool;\n    virStorageVolDef def;\n    vboxIID hddIID;\n    PRUint32 hddstate;\n    nsresult rc;\n    char *ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    memset(&pool, 0, sizeof(pool));\n    memset(&def, 0, sizeof(def));\n\n    if (virUUIDParse(vol->key, uuid) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Could not parse UUID from '%s'\"), vol->key);\n        return ret;\n    }\n\n    VBOX_IID_INITIALIZE(&hddIID);\n    vboxIIDFromUUID(&hddIID, uuid);\n    rc = gVBoxAPI.UIVirtualBox.GetHardDiskByIID(data->vboxObj, &hddIID, &hardDisk);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n    if (hddstate == MediaState_Inaccessible)\n        goto cleanup;\n\n    /* since there is currently one default pool now\n     * and virStorageVolDefFormat() just checks it type\n     * so just assign it for now, change the behaviour\n     * when vbox supports pools.\n     */\n    pool.type = VIR_STORAGE_POOL_DIR;\n    def.type = VIR_STORAGE_VOL_FILE;\n\n    rc = gVBoxAPI.UIMedium.GetLogicalSize(hardDisk, &hddLogicalSize);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    def.target.capacity = hddLogicalSize;\n\n    rc = gVBoxAPI.UIMedium.GetSize(hardDisk, &hddActualSize);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    def.name = g_strdup(vol->name);\n\n    def.key = g_strdup(vol->key);\n\n    rc = gVBoxAPI.UIMedium.GetFormat(hardDisk, &hddFormatUtf16);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    VBOX_UTF16_TO_UTF8(hddFormatUtf16, &hddFormatUtf8);\n    if (!hddFormatUtf8)\n        goto cleanup;\n\n    VIR_DEBUG(\"Storage Volume Format: %s\", hddFormatUtf8);\n\n    if (STRCASEEQ(\"vmdk\", hddFormatUtf8))\n        def.target.format = VIR_STORAGE_FILE_VMDK;\n    else if (STRCASEEQ(\"vhd\", hddFormatUtf8))\n        def.target.format = VIR_STORAGE_FILE_VPC;\n    else if (STRCASEEQ(\"vdi\", hddFormatUtf8))\n        def.target.format = VIR_STORAGE_FILE_VDI;\n    else\n        def.target.format = VIR_STORAGE_FILE_RAW;\n    ret = virStorageVolDefFormat(&pool, &def);\n\n cleanup:\n    VBOX_UTF16_FREE(hddFormatUtf16);\n    VBOX_UTF8_FREE(hddFormatUtf8);\n    VBOX_MEDIUM_RELEASE(hardDisk);\n    vboxIIDUnalloc(&hddIID);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"virutil.h\"",
      "#include \"storage_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&hddIID"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_MEDIUM_RELEASE",
          "args": [
            "hardDisk"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "hddFormatUtf8"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "hddFormatUtf16"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageVolDefFormat",
          "args": [
            "&pool",
            "&def"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "1594-1670",
          "snippet": "char *\nvirStorageVolDefFormat(virStoragePoolDefPtr pool,\n                       virStorageVolDefPtr def)\n{\n    virStorageVolOptionsPtr options;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    options = virStorageVolOptionsForPoolType(pool->type);\n    if (options == NULL)\n        return NULL;\n\n    virBufferAsprintf(&buf, \"<volume type='%s'>\\n\",\n                      virStorageVolTypeToString(def->type));\n    virBufferAdjustIndent(&buf, 2);\n\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", def->name);\n    virBufferEscapeString(&buf, \"<key>%s</key>\\n\", def->key);\n    virBufferAddLit(&buf, \"<source>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    if (def->source.nextent) {\n        size_t i;\n        const char *thispath = NULL;\n        for (i = 0; i < def->source.nextent; i++) {\n            if (thispath == NULL ||\n                STRNEQ(thispath, def->source.extents[i].path)) {\n                if (thispath != NULL)\n                    virBufferAddLit(&buf, \"</device>\\n\");\n\n                virBufferEscapeString(&buf, \"<device path='%s'>\\n\",\n                                      def->source.extents[i].path);\n            }\n\n            virBufferAdjustIndent(&buf, 2);\n            virBufferAsprintf(&buf, \"<extent start='%llu' end='%llu'/>\\n\",\n                              def->source.extents[i].start,\n                              def->source.extents[i].end);\n            virBufferAdjustIndent(&buf, -2);\n            thispath = def->source.extents[i].path;\n        }\n        if (thispath != NULL)\n            virBufferAddLit(&buf, \"</device>\\n\");\n    }\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</source>\\n\");\n\n    virBufferAsprintf(&buf, \"<capacity unit='bytes'>%llu</capacity>\\n\",\n                      def->target.capacity);\n    virBufferAsprintf(&buf, \"<allocation unit='bytes'>%llu</allocation>\\n\",\n                      def->target.allocation);\n    /* NB: Display only - since virStorageVolInfo is limited to just\n     * 'capacity' and 'allocation' on output. Since we don't read this\n     * in, be sure it was filled in before printing */\n    if (def->target.physical)\n        virBufferAsprintf(&buf, \"<physical unit='bytes'>%llu</physical>\\n\",\n                          def->target.physical);\n\n    if (virStorageVolTargetDefFormat(options, &buf,\n                                     &def->target, \"target\") < 0)\n        goto cleanup;\n\n    if (virStorageSourceHasBacking(&def->target) &&\n        virStorageVolTargetDefFormat(options, &buf,\n                                     def->target.backingStore,\n                                     \"backingStore\") < 0)\n        goto cleanup;\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</volume>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirStorageVolDefFormat(virStoragePoolDefPtr pool,\n                       virStorageVolDefPtr def)\n{\n    virStorageVolOptionsPtr options;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    options = virStorageVolOptionsForPoolType(pool->type);\n    if (options == NULL)\n        return NULL;\n\n    virBufferAsprintf(&buf, \"<volume type='%s'>\\n\",\n                      virStorageVolTypeToString(def->type));\n    virBufferAdjustIndent(&buf, 2);\n\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", def->name);\n    virBufferEscapeString(&buf, \"<key>%s</key>\\n\", def->key);\n    virBufferAddLit(&buf, \"<source>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    if (def->source.nextent) {\n        size_t i;\n        const char *thispath = NULL;\n        for (i = 0; i < def->source.nextent; i++) {\n            if (thispath == NULL ||\n                STRNEQ(thispath, def->source.extents[i].path)) {\n                if (thispath != NULL)\n                    virBufferAddLit(&buf, \"</device>\\n\");\n\n                virBufferEscapeString(&buf, \"<device path='%s'>\\n\",\n                                      def->source.extents[i].path);\n            }\n\n            virBufferAdjustIndent(&buf, 2);\n            virBufferAsprintf(&buf, \"<extent start='%llu' end='%llu'/>\\n\",\n                              def->source.extents[i].start,\n                              def->source.extents[i].end);\n            virBufferAdjustIndent(&buf, -2);\n            thispath = def->source.extents[i].path;\n        }\n        if (thispath != NULL)\n            virBufferAddLit(&buf, \"</device>\\n\");\n    }\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</source>\\n\");\n\n    virBufferAsprintf(&buf, \"<capacity unit='bytes'>%llu</capacity>\\n\",\n                      def->target.capacity);\n    virBufferAsprintf(&buf, \"<allocation unit='bytes'>%llu</allocation>\\n\",\n                      def->target.allocation);\n    /* NB: Display only - since virStorageVolInfo is limited to just\n     * 'capacity' and 'allocation' on output. Since we don't read this\n     * in, be sure it was filled in before printing */\n    if (def->target.physical)\n        virBufferAsprintf(&buf, \"<physical unit='bytes'>%llu</physical>\\n\",\n                          def->target.physical);\n\n    if (virStorageVolTargetDefFormat(options, &buf,\n                                     &def->target, \"target\") < 0)\n        goto cleanup;\n\n    if (virStorageSourceHasBacking(&def->target) &&\n        virStorageVolTargetDefFormat(options, &buf,\n                                     def->target.backingStore,\n                                     \"backingStore\") < 0)\n        goto cleanup;\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</volume>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "\"vdi\"",
            "hddFormatUtf8"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "\"vhd\"",
            "hddFormatUtf8"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "\"vmdk\"",
            "hddFormatUtf8"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume Format: %s\"",
            "hddFormatUtf8"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "hddFormatUtf16",
            "&hddFormatUtf8"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetFormat",
          "args": [
            "hardDisk",
            "&hddFormatUtf16"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "vol->key"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetSize",
          "args": [
            "hardDisk",
            "&hddActualSize"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetLogicalSize",
          "args": [
            "hardDisk",
            "&hddLogicalSize"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetState",
          "args": [
            "hardDisk",
            "&hddstate"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHardDiskByIID",
          "args": [
            "data->vboxObj",
            "&hddIID",
            "&hardDisk"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDFromUUID",
          "args": [
            "&hddIID",
            "uuid"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&hddIID"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Could not parse UUID from '%s'\")",
            "vol->key"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not parse UUID from '%s'\""
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "vol->key",
            "uuid"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&def",
            "0",
            "sizeof(def)"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&pool",
            "0",
            "sizeof(pool)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic char *vboxStorageVolGetXMLDesc(virStorageVolPtr vol, unsigned int flags)\n{\n    vboxDriverPtr data = vol->conn->privateData;\n    IMedium *hardDisk = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    PRUnichar *hddFormatUtf16 = NULL;\n    char *hddFormatUtf8 = NULL;\n    PRUint64 hddLogicalSize = 0;\n    PRUint64 hddActualSize = 0;\n    virStoragePoolDef pool;\n    virStorageVolDef def;\n    vboxIID hddIID;\n    PRUint32 hddstate;\n    nsresult rc;\n    char *ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    memset(&pool, 0, sizeof(pool));\n    memset(&def, 0, sizeof(def));\n\n    if (virUUIDParse(vol->key, uuid) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Could not parse UUID from '%s'\"), vol->key);\n        return ret;\n    }\n\n    VBOX_IID_INITIALIZE(&hddIID);\n    vboxIIDFromUUID(&hddIID, uuid);\n    rc = gVBoxAPI.UIVirtualBox.GetHardDiskByIID(data->vboxObj, &hddIID, &hardDisk);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n    if (hddstate == MediaState_Inaccessible)\n        goto cleanup;\n\n    /* since there is currently one default pool now\n     * and virStorageVolDefFormat() just checks it type\n     * so just assign it for now, change the behaviour\n     * when vbox supports pools.\n     */\n    pool.type = VIR_STORAGE_POOL_DIR;\n    def.type = VIR_STORAGE_VOL_FILE;\n\n    rc = gVBoxAPI.UIMedium.GetLogicalSize(hardDisk, &hddLogicalSize);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    def.target.capacity = hddLogicalSize;\n\n    rc = gVBoxAPI.UIMedium.GetSize(hardDisk, &hddActualSize);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    def.name = g_strdup(vol->name);\n\n    def.key = g_strdup(vol->key);\n\n    rc = gVBoxAPI.UIMedium.GetFormat(hardDisk, &hddFormatUtf16);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    VBOX_UTF16_TO_UTF8(hddFormatUtf16, &hddFormatUtf8);\n    if (!hddFormatUtf8)\n        goto cleanup;\n\n    VIR_DEBUG(\"Storage Volume Format: %s\", hddFormatUtf8);\n\n    if (STRCASEEQ(\"vmdk\", hddFormatUtf8))\n        def.target.format = VIR_STORAGE_FILE_VMDK;\n    else if (STRCASEEQ(\"vhd\", hddFormatUtf8))\n        def.target.format = VIR_STORAGE_FILE_VPC;\n    else if (STRCASEEQ(\"vdi\", hddFormatUtf8))\n        def.target.format = VIR_STORAGE_FILE_VDI;\n    else\n        def.target.format = VIR_STORAGE_FILE_RAW;\n    ret = virStorageVolDefFormat(&pool, &def);\n\n cleanup:\n    VBOX_UTF16_FREE(hddFormatUtf16);\n    VBOX_UTF8_FREE(hddFormatUtf8);\n    VBOX_MEDIUM_RELEASE(hardDisk);\n    vboxIIDUnalloc(&hddIID);\n    return ret;\n}"
  },
  {
    "function_name": "vboxStorageVolGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
    "lines": "658-711",
    "snippet": "static int vboxStorageVolGetInfo(virStorageVolPtr vol, virStorageVolInfoPtr info)\n{\n    vboxDriverPtr data = vol->conn->privateData;\n    IMedium *hardDisk = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    PRUint32 hddstate;\n    PRUint64 hddLogicalSize = 0;\n    PRUint64 hddActualSize = 0;\n    vboxIID hddIID;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!info)\n        return ret;\n\n    if (virUUIDParse(vol->key, uuid) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Could not parse UUID from '%s'\"), vol->key);\n        return ret;\n    }\n\n    VBOX_IID_INITIALIZE(&hddIID);\n    vboxIIDFromUUID(&hddIID, uuid);\n    rc = gVBoxAPI.UIVirtualBox.GetHardDiskByIID(data->vboxObj, &hddIID, &hardDisk);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n    if (hddstate == MediaState_Inaccessible)\n        goto cleanup;\n\n    info->type = VIR_STORAGE_VOL_FILE;\n\n    gVBoxAPI.UIMedium.GetLogicalSize(hardDisk, &hddLogicalSize);\n    info->capacity = hddLogicalSize;\n\n    gVBoxAPI.UIMedium.GetSize(hardDisk, &hddActualSize);\n    info->allocation = hddActualSize;\n\n    ret = 0;\n\n    VIR_DEBUG(\"Storage Volume Name: %s\", vol->name);\n    VIR_DEBUG(\"Storage Volume Type: %s\", info->type == VIR_STORAGE_VOL_BLOCK ? \"Block\" : \"File\");\n    VIR_DEBUG(\"Storage Volume Capacity: %llu\", info->capacity);\n    VIR_DEBUG(\"Storage Volume Allocation: %llu\", info->allocation);\n\n cleanup:\n    VBOX_MEDIUM_RELEASE(hardDisk);\n    vboxIIDUnalloc(&hddIID);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"virutil.h\"",
      "#include \"storage_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&hddIID"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_MEDIUM_RELEASE",
          "args": [
            "hardDisk"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume Allocation: %llu\"",
            "info->allocation"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume Capacity: %llu\"",
            "info->capacity"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume Type: %s\"",
            "info->type == VIR_STORAGE_VOL_BLOCK ? \"Block\" : \"File\""
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume Name: %s\"",
            "vol->name"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetSize",
          "args": [
            "hardDisk",
            "&hddActualSize"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetLogicalSize",
          "args": [
            "hardDisk",
            "&hddLogicalSize"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetState",
          "args": [
            "hardDisk",
            "&hddstate"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHardDiskByIID",
          "args": [
            "data->vboxObj",
            "&hddIID",
            "&hardDisk"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDFromUUID",
          "args": [
            "&hddIID",
            "uuid"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&hddIID"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Could not parse UUID from '%s'\")",
            "vol->key"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not parse UUID from '%s'\""
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "vol->key",
            "uuid"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxStorageVolGetInfo(virStorageVolPtr vol, virStorageVolInfoPtr info)\n{\n    vboxDriverPtr data = vol->conn->privateData;\n    IMedium *hardDisk = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    PRUint32 hddstate;\n    PRUint64 hddLogicalSize = 0;\n    PRUint64 hddActualSize = 0;\n    vboxIID hddIID;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!info)\n        return ret;\n\n    if (virUUIDParse(vol->key, uuid) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Could not parse UUID from '%s'\"), vol->key);\n        return ret;\n    }\n\n    VBOX_IID_INITIALIZE(&hddIID);\n    vboxIIDFromUUID(&hddIID, uuid);\n    rc = gVBoxAPI.UIVirtualBox.GetHardDiskByIID(data->vboxObj, &hddIID, &hardDisk);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n    if (hddstate == MediaState_Inaccessible)\n        goto cleanup;\n\n    info->type = VIR_STORAGE_VOL_FILE;\n\n    gVBoxAPI.UIMedium.GetLogicalSize(hardDisk, &hddLogicalSize);\n    info->capacity = hddLogicalSize;\n\n    gVBoxAPI.UIMedium.GetSize(hardDisk, &hddActualSize);\n    info->allocation = hddActualSize;\n\n    ret = 0;\n\n    VIR_DEBUG(\"Storage Volume Name: %s\", vol->name);\n    VIR_DEBUG(\"Storage Volume Type: %s\", info->type == VIR_STORAGE_VOL_BLOCK ? \"Block\" : \"File\");\n    VIR_DEBUG(\"Storage Volume Capacity: %llu\", info->capacity);\n    VIR_DEBUG(\"Storage Volume Allocation: %llu\", info->allocation);\n\n cleanup:\n    VBOX_MEDIUM_RELEASE(hardDisk);\n    vboxIIDUnalloc(&hddIID);\n    return ret;\n}"
  },
  {
    "function_name": "vboxStorageVolDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
    "lines": "505-656",
    "snippet": "static int vboxStorageVolDelete(virStorageVolPtr vol, unsigned int flags)\n{\n    vboxDriverPtr data = vol->conn->privateData;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    IMedium *hardDisk = NULL;\n    int deregister = 0;\n    PRUint32 hddstate = 0;\n    size_t i = 0;\n    size_t j = 0;\n    PRUint32 machineIdsSize = 0;\n    vboxArray machineIds = VBOX_ARRAY_INITIALIZER;\n    vboxIID hddIID;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&hddIID);\n    virCheckFlags(0, -1);\n\n    if (virUUIDParse(vol->key, uuid) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Could not parse UUID from '%s'\"), vol->key);\n        return -1;\n    }\n\n    vboxIIDFromUUID(&hddIID, uuid);\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetHardDiskByIID(data->vboxObj,\n                                                         &hddIID,\n                                                         &hardDisk)))\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n    if (hddstate == MediaState_Inaccessible)\n        goto cleanup;\n\n    gVBoxAPI.UArray.vboxArrayGet(&machineIds, hardDisk,\n                                 gVBoxAPI.UArray.handleMediumGetMachineIds(hardDisk));\n\n#if defined WIN32\n    /* VirtualBox 2.2 on Windows represents IIDs as GUIDs and the\n     * machineIds array contains direct instances of the GUID struct\n     * instead of pointers to the actual struct instances. But there\n     * is no 128bit width simple item type for a SafeArray to fit a\n     * GUID in. The largest simple type it 64bit width and VirtualBox\n     * uses two of this 64bit items to represents one GUID. Therefore,\n     * we divide the size of the SafeArray by two, to compensate for\n     * this workaround in VirtualBox */\n    if (gVBoxAPI.uVersion >= 2001052 && gVBoxAPI.uVersion < 2002051)\n        machineIds.count /= 2;\n#endif /* !defined WIN32 */\n\n    machineIdsSize = machineIds.count;\n\n    for (i = 0; i < machineIds.count; i++) {\n        IMachine *machine = NULL;\n        vboxIID machineId;\n        vboxArray hddAttachments = VBOX_ARRAY_INITIALIZER;\n\n        VBOX_IID_INITIALIZE(&machineId);\n        vboxIIDFromArrayItem(&machineId, &machineIds, i);\n\n        if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj,\n                                                       &machineId,\n                                                       &machine))) {\n            virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                           _(\"no domain with matching uuid\"));\n            break;\n        }\n\n        if (NS_FAILED(gVBoxAPI.UISession.Open(data, &machineId, machine))) {\n            vboxIIDUnalloc(&machineId);\n            continue;\n        }\n\n        if (NS_FAILED(gVBoxAPI.UISession.GetMachine(data->vboxSession,\n                                                    &machine)))\n            goto cleanupLoop;\n\n        gVBoxAPI.UArray.vboxArrayGet(&hddAttachments, machine,\n                                     gVBoxAPI.UArray.handleMachineGetMediumAttachments(machine));\n\n        for (j = 0; j < hddAttachments.count; j++) {\n            IMediumAttachment *hddAttachment = hddAttachments.items[j];\n            IMedium *hdd = NULL;\n            vboxIID iid;\n\n            if (!hddAttachment)\n                continue;\n\n            if (NS_FAILED(gVBoxAPI.UIMediumAttachment.GetMedium(hddAttachment,\n                                                                &hdd)) || !hdd)\n                continue;\n\n            VBOX_IID_INITIALIZE(&iid);\n            if (NS_FAILED(gVBoxAPI.UIMedium.GetId(hdd, &iid))) {\n                VBOX_MEDIUM_RELEASE(hdd);\n                continue;\n            }\n\n            DEBUGIID(\"HardDisk (to delete) UUID\", &hddIID);\n            DEBUGIID(\"HardDisk (currently processing) UUID\", &iid);\n\n            if (vboxIIDIsEqual(&hddIID, &iid)) {\n                PRUnichar *controller = NULL;\n                PRInt32 port = 0;\n                PRInt32 device = 0;\n\n                DEBUGIID(\"Found HardDisk to delete, UUID\", &hddIID);\n\n                gVBoxAPI.UIMediumAttachment.GetController(hddAttachment, &controller);\n                gVBoxAPI.UIMediumAttachment.GetPort(hddAttachment, &port);\n                gVBoxAPI.UIMediumAttachment.GetDevice(hddAttachment, &device);\n\n                if (NS_SUCCEEDED(gVBoxAPI.UIMachine.DetachDevice(machine, controller, port, device))) {\n                    ignore_value(gVBoxAPI.UIMachine.SaveSettings(machine));\n                    VIR_DEBUG(\"saving machine settings\");\n                    deregister++;\n                    VIR_DEBUG(\"deregistering hdd:%d\", deregister);\n                }\n\n                VBOX_UTF16_FREE(controller);\n            }\n            vboxIIDUnalloc(&iid);\n            VBOX_MEDIUM_RELEASE(hdd);\n        }\n\n cleanupLoop:\n        gVBoxAPI.UArray.vboxArrayRelease(&hddAttachments);\n        VBOX_RELEASE(machine);\n        gVBoxAPI.UISession.Close(data->vboxSession);\n        vboxIIDUnalloc(&machineId);\n    }\n\n    gVBoxAPI.UArray.vboxArrayUnalloc(&machineIds);\n\n    if (machineIdsSize == 0 || machineIdsSize == deregister) {\n        IProgress *progress = NULL;\n        if (NS_SUCCEEDED(gVBoxAPI.UIMedium.DeleteStorage(hardDisk, &progress)) &&\n            progress) {\n            gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n            VBOX_RELEASE(progress);\n            DEBUGIID(\"HardDisk deleted, UUID\", &hddIID);\n            ret = 0;\n        }\n    }\n\n cleanup:\n    VBOX_MEDIUM_RELEASE(hardDisk);\n    vboxIIDUnalloc(&hddIID);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"virutil.h\"",
      "#include \"storage_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&hddIID"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_MEDIUM_RELEASE",
          "args": [
            "hardDisk"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUGIID",
          "args": [
            "\"HardDisk deleted, UUID\"",
            "&hddIID"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "progress"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.WaitForCompletion",
          "args": [
            "progress",
            "-1"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "gVBoxAPI.UIMedium.DeleteStorage(hardDisk, &progress)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.DeleteStorage",
          "args": [
            "hardDisk",
            "&progress"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayUnalloc",
          "args": [
            "&machineIds"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayUnalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "341-361",
          "snippet": "void\nvboxArrayUnalloc(vboxArray *array)\n{\n    size_t i;\n    void *item;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        item = array->items[i];\n\n        if (item != NULL)\n            pVBoxFuncs_v2_2->pfnComUnallocMem(item);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayUnalloc(vboxArray *array)\n{\n    size_t i;\n    void *item;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        item = array->items[i];\n\n        if (item != NULL)\n            pVBoxFuncs_v2_2->pfnComUnallocMem(item);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&machineId"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&hddAttachments"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_MEDIUM_RELEASE",
          "args": [
            "hdd"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "controller"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"deregistering hdd:%d\"",
            "deregister"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"saving machine settings\""
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "gVBoxAPI.UIMachine.SaveSettings(machine)"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SaveSettings",
          "args": [
            "machine"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "gVBoxAPI.UIMachine.DetachDevice(machine, controller, port, device)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.DetachDevice",
          "args": [
            "machine",
            "controller",
            "port",
            "device"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetDevice",
          "args": [
            "hddAttachment",
            "&device"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetPort",
          "args": [
            "hddAttachment",
            "&port"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetController",
          "args": [
            "hddAttachment",
            "&controller"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUGIID",
          "args": [
            "\"Found HardDisk to delete, UUID\"",
            "&hddIID"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDIsEqual",
          "args": [
            "&hddIID",
            "&iid"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUGIID",
          "args": [
            "\"HardDisk (currently processing) UUID\"",
            "&iid"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUGIID",
          "args": [
            "\"HardDisk (to delete) UUID\"",
            "&hddIID"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_MEDIUM_RELEASE",
          "args": [
            "hdd"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "gVBoxAPI.UIMedium.GetId(hdd, &iid)"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetId",
          "args": [
            "hdd",
            "&iid"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "gVBoxAPI.UIMediumAttachment.GetMedium(hddAttachment,\n                                                                &hdd)"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetMedium",
          "args": [
            "hddAttachment",
            "&hdd"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&hddAttachments",
            "machine",
            "gVBoxAPI.UArray.handleMachineGetMediumAttachments(machine)"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleMachineGetMediumAttachments",
          "args": [
            "machine"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "gVBoxAPI.UISession.GetMachine(data->vboxSession,\n                                                    &machine)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetMachine",
          "args": [
            "data->vboxSession",
            "&machine"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&machineId"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "gVBoxAPI.UISession.Open(data, &machineId, machine)"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Open",
          "args": [
            "data",
            "&machineId",
            "machine"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "\"%s\"",
            "_(\"no domain with matching uuid\")"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no domain with matching uuid\""
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj,\n                                                       &machineId,\n                                                       &machine)"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetMachine",
          "args": [
            "data->vboxObj",
            "&machineId",
            "&machine"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDFromArrayItem",
          "args": [
            "&machineId",
            "&machineIds",
            "i"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&machineId"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleMediumGetMachineIds",
          "args": [
            "hardDisk"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetState",
          "args": [
            "hardDisk",
            "&hddstate"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "gVBoxAPI.UIVirtualBox.GetHardDiskByIID(data->vboxObj,\n                                                         &hddIID,\n                                                         &hardDisk)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHardDiskByIID",
          "args": [
            "data->vboxObj",
            "&hddIID",
            "&hardDisk"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDFromUUID",
          "args": [
            "&hddIID",
            "uuid"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Could not parse UUID from '%s'\")",
            "vol->key"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "vol->key",
            "uuid"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&hddIID"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxStorageVolDelete(virStorageVolPtr vol, unsigned int flags)\n{\n    vboxDriverPtr data = vol->conn->privateData;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    IMedium *hardDisk = NULL;\n    int deregister = 0;\n    PRUint32 hddstate = 0;\n    size_t i = 0;\n    size_t j = 0;\n    PRUint32 machineIdsSize = 0;\n    vboxArray machineIds = VBOX_ARRAY_INITIALIZER;\n    vboxIID hddIID;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&hddIID);\n    virCheckFlags(0, -1);\n\n    if (virUUIDParse(vol->key, uuid) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Could not parse UUID from '%s'\"), vol->key);\n        return -1;\n    }\n\n    vboxIIDFromUUID(&hddIID, uuid);\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetHardDiskByIID(data->vboxObj,\n                                                         &hddIID,\n                                                         &hardDisk)))\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n    if (hddstate == MediaState_Inaccessible)\n        goto cleanup;\n\n    gVBoxAPI.UArray.vboxArrayGet(&machineIds, hardDisk,\n                                 gVBoxAPI.UArray.handleMediumGetMachineIds(hardDisk));\n\n#if defined WIN32\n    /* VirtualBox 2.2 on Windows represents IIDs as GUIDs and the\n     * machineIds array contains direct instances of the GUID struct\n     * instead of pointers to the actual struct instances. But there\n     * is no 128bit width simple item type for a SafeArray to fit a\n     * GUID in. The largest simple type it 64bit width and VirtualBox\n     * uses two of this 64bit items to represents one GUID. Therefore,\n     * we divide the size of the SafeArray by two, to compensate for\n     * this workaround in VirtualBox */\n    if (gVBoxAPI.uVersion >= 2001052 && gVBoxAPI.uVersion < 2002051)\n        machineIds.count /= 2;\n#endif /* !defined WIN32 */\n\n    machineIdsSize = machineIds.count;\n\n    for (i = 0; i < machineIds.count; i++) {\n        IMachine *machine = NULL;\n        vboxIID machineId;\n        vboxArray hddAttachments = VBOX_ARRAY_INITIALIZER;\n\n        VBOX_IID_INITIALIZE(&machineId);\n        vboxIIDFromArrayItem(&machineId, &machineIds, i);\n\n        if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj,\n                                                       &machineId,\n                                                       &machine))) {\n            virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                           _(\"no domain with matching uuid\"));\n            break;\n        }\n\n        if (NS_FAILED(gVBoxAPI.UISession.Open(data, &machineId, machine))) {\n            vboxIIDUnalloc(&machineId);\n            continue;\n        }\n\n        if (NS_FAILED(gVBoxAPI.UISession.GetMachine(data->vboxSession,\n                                                    &machine)))\n            goto cleanupLoop;\n\n        gVBoxAPI.UArray.vboxArrayGet(&hddAttachments, machine,\n                                     gVBoxAPI.UArray.handleMachineGetMediumAttachments(machine));\n\n        for (j = 0; j < hddAttachments.count; j++) {\n            IMediumAttachment *hddAttachment = hddAttachments.items[j];\n            IMedium *hdd = NULL;\n            vboxIID iid;\n\n            if (!hddAttachment)\n                continue;\n\n            if (NS_FAILED(gVBoxAPI.UIMediumAttachment.GetMedium(hddAttachment,\n                                                                &hdd)) || !hdd)\n                continue;\n\n            VBOX_IID_INITIALIZE(&iid);\n            if (NS_FAILED(gVBoxAPI.UIMedium.GetId(hdd, &iid))) {\n                VBOX_MEDIUM_RELEASE(hdd);\n                continue;\n            }\n\n            DEBUGIID(\"HardDisk (to delete) UUID\", &hddIID);\n            DEBUGIID(\"HardDisk (currently processing) UUID\", &iid);\n\n            if (vboxIIDIsEqual(&hddIID, &iid)) {\n                PRUnichar *controller = NULL;\n                PRInt32 port = 0;\n                PRInt32 device = 0;\n\n                DEBUGIID(\"Found HardDisk to delete, UUID\", &hddIID);\n\n                gVBoxAPI.UIMediumAttachment.GetController(hddAttachment, &controller);\n                gVBoxAPI.UIMediumAttachment.GetPort(hddAttachment, &port);\n                gVBoxAPI.UIMediumAttachment.GetDevice(hddAttachment, &device);\n\n                if (NS_SUCCEEDED(gVBoxAPI.UIMachine.DetachDevice(machine, controller, port, device))) {\n                    ignore_value(gVBoxAPI.UIMachine.SaveSettings(machine));\n                    VIR_DEBUG(\"saving machine settings\");\n                    deregister++;\n                    VIR_DEBUG(\"deregistering hdd:%d\", deregister);\n                }\n\n                VBOX_UTF16_FREE(controller);\n            }\n            vboxIIDUnalloc(&iid);\n            VBOX_MEDIUM_RELEASE(hdd);\n        }\n\n cleanupLoop:\n        gVBoxAPI.UArray.vboxArrayRelease(&hddAttachments);\n        VBOX_RELEASE(machine);\n        gVBoxAPI.UISession.Close(data->vboxSession);\n        vboxIIDUnalloc(&machineId);\n    }\n\n    gVBoxAPI.UArray.vboxArrayUnalloc(&machineIds);\n\n    if (machineIdsSize == 0 || machineIdsSize == deregister) {\n        IProgress *progress = NULL;\n        if (NS_SUCCEEDED(gVBoxAPI.UIMedium.DeleteStorage(hardDisk, &progress)) &&\n            progress) {\n            gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n            VBOX_RELEASE(progress);\n            DEBUGIID(\"HardDisk deleted, UUID\", &hddIID);\n            ret = 0;\n        }\n    }\n\n cleanup:\n    VBOX_MEDIUM_RELEASE(hardDisk);\n    vboxIIDUnalloc(&hddIID);\n    return ret;\n}"
  },
  {
    "function_name": "vboxStorageVolCreateXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
    "lines": "395-503",
    "snippet": "static virStorageVolPtr\nvboxStorageVolCreateXML(virStoragePoolPtr pool,\n                        const char *xml, unsigned int flags)\n{\n    vboxDriverPtr data = pool->conn->privateData;\n    PRUnichar *hddFormatUtf16 = NULL;\n    PRUnichar *hddNameUtf16 = NULL;\n    virStoragePoolDef poolDef;\n    nsresult rc;\n    vboxIID hddIID;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    char key[VIR_UUID_STRING_BUFLEN] = \"\";\n    IMedium *hardDisk = NULL;\n    IProgress *progress = NULL;\n    PRUint64 logicalSize = 0;\n    PRUint32 variant = HardDiskVariant_Standard;\n    resultCodeUnion resultCode;\n    virStorageVolPtr ret = NULL;\n    g_autoptr(virStorageVolDef) def = NULL;\n    g_autofree char *homedir = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    /* since there is currently one default pool now\n     * and virStorageVolDefFormat() just checks it type\n     * so just assign it for now, change the behaviour\n     * when vbox supports pools.\n     */\n    memset(&poolDef, 0, sizeof(poolDef));\n    poolDef.type = VIR_STORAGE_POOL_DIR;\n\n    if ((def = virStorageVolDefParseString(&poolDef, xml, 0)) == NULL)\n        goto cleanup;\n\n    if (!def->name ||\n        (def->type != VIR_STORAGE_VOL_FILE))\n        goto cleanup;\n\n    /* For now only the vmdk, vpc and vdi type harddisk\n     * variants can be created.  For historical reason, we default to vdi */\n    if (def->target.format == VIR_STORAGE_FILE_VMDK) {\n        VBOX_UTF8_TO_UTF16(\"VMDK\", &hddFormatUtf16);\n    } else if (def->target.format == VIR_STORAGE_FILE_VPC) {\n        VBOX_UTF8_TO_UTF16(\"VHD\", &hddFormatUtf16);\n    } else {\n        VBOX_UTF8_TO_UTF16(\"VDI\", &hddFormatUtf16);\n    }\n\n    /* If target.path isn't given, use default path ~/.VirtualBox/image_name */\n    if (!def->target.path) {\n        homedir = virGetUserDirectory();\n        def->target.path = g_strdup_printf(\"%s/.VirtualBox/%s\", homedir, def->name);\n    }\n    VBOX_UTF8_TO_UTF16(def->target.path, &hddNameUtf16);\n\n    if (!hddFormatUtf16 || !hddNameUtf16)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIVirtualBox.CreateHardDisk(data->vboxObj, hddFormatUtf16, hddNameUtf16, &hardDisk);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not create harddisk, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    logicalSize = VIR_DIV_UP(def->target.capacity, 1024 * 1024);\n\n    if (def->target.capacity == def->target.allocation)\n        variant = HardDiskVariant_Fixed;\n\n    rc = gVBoxAPI.UIMedium.CreateBaseStorage(hardDisk, logicalSize, variant, &progress);\n    if (NS_FAILED(rc) || !progress) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not create base storage, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n    gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n    if (RC_FAILED(resultCode)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not create base storage, rc=%08x\"),\n                       (unsigned)resultCode.uResultCode);\n        goto cleanup;\n    }\n\n    VBOX_IID_INITIALIZE(&hddIID);\n    rc = gVBoxAPI.UIMedium.GetId(hardDisk, &hddIID);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    vboxIIDToUUID(&hddIID, uuid);\n    virUUIDFormat(uuid, key);\n\n    ret = virGetStorageVol(pool->conn, pool->name, def->name, key,\n                           NULL, NULL);\n\n cleanup:\n    vboxIIDUnalloc(&hddIID);\n    VBOX_RELEASE(progress);\n    VBOX_UTF16_FREE(hddFormatUtf16);\n    VBOX_UTF16_FREE(hddNameUtf16);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"virutil.h\"",
      "#include \"storage_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "hddNameUtf16"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "hddFormatUtf16"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "progress"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&hddIID"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStorageVol",
          "args": [
            "pool->conn",
            "pool->name",
            "def->name",
            "key",
            "NULL",
            "NULL"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStorageVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "600-632",
          "snippet": "virStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStorageVolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStorageVolClass;\n\nvirStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "key"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxIIDToUUID",
          "args": [
            "&hddIID",
            "uuid"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetId",
          "args": [
            "hardDisk",
            "&hddIID"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&hddIID"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not create base storage, rc=%08x\")",
            "(unsigned)resultCode.uResultCode"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not create base storage, rc=%08x\""
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RC_FAILED",
          "args": [
            "resultCode"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.GetResultCode",
          "args": [
            "progress",
            "&resultCode"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.WaitForCompletion",
          "args": [
            "progress",
            "-1"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not create base storage, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.CreateBaseStorage",
          "args": [
            "hardDisk",
            "logicalSize",
            "variant",
            "&progress"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "def->target.capacity",
            "1024 * 1024"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not create harddisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.CreateHardDisk",
          "args": [
            "data->vboxObj",
            "hddFormatUtf16",
            "hddNameUtf16",
            "&hardDisk"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "def->target.path",
            "&hddNameUtf16"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/.VirtualBox/%s\"",
            "homedir",
            "def->name"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserDirectory",
          "args": [],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "567-571",
          "snippet": "char *\nvirGetUserDirectory(void)\n{\n    return g_strdup(g_get_home_dir());\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirGetUserDirectory(void)\n{\n    return g_strdup(g_get_home_dir());\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"VDI\"",
            "&hddFormatUtf16"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"VHD\"",
            "&hddFormatUtf16"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"VMDK\"",
            "&hddFormatUtf16"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageVolDefParseString",
          "args": [
            "&poolDef",
            "xml",
            "0"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "1470-1476",
          "snippet": "virStorageVolDefPtr\nvirStorageVolDefParseString(virStoragePoolDefPtr pool,\n                            const char *xmlStr,\n                            unsigned int flags)\n{\n    return virStorageVolDefParse(pool, xmlStr, NULL, flags);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirStorageVolDefPtr\nvirStorageVolDefParseString(virStoragePoolDefPtr pool,\n                            const char *xmlStr,\n                            unsigned int flags)\n{\n    return virStorageVolDefParse(pool, xmlStr, NULL, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&poolDef",
            "0",
            "sizeof(poolDef)"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virStorageVolPtr\nvboxStorageVolCreateXML(virStoragePoolPtr pool,\n                        const char *xml, unsigned int flags)\n{\n    vboxDriverPtr data = pool->conn->privateData;\n    PRUnichar *hddFormatUtf16 = NULL;\n    PRUnichar *hddNameUtf16 = NULL;\n    virStoragePoolDef poolDef;\n    nsresult rc;\n    vboxIID hddIID;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    char key[VIR_UUID_STRING_BUFLEN] = \"\";\n    IMedium *hardDisk = NULL;\n    IProgress *progress = NULL;\n    PRUint64 logicalSize = 0;\n    PRUint32 variant = HardDiskVariant_Standard;\n    resultCodeUnion resultCode;\n    virStorageVolPtr ret = NULL;\n    g_autoptr(virStorageVolDef) def = NULL;\n    g_autofree char *homedir = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    /* since there is currently one default pool now\n     * and virStorageVolDefFormat() just checks it type\n     * so just assign it for now, change the behaviour\n     * when vbox supports pools.\n     */\n    memset(&poolDef, 0, sizeof(poolDef));\n    poolDef.type = VIR_STORAGE_POOL_DIR;\n\n    if ((def = virStorageVolDefParseString(&poolDef, xml, 0)) == NULL)\n        goto cleanup;\n\n    if (!def->name ||\n        (def->type != VIR_STORAGE_VOL_FILE))\n        goto cleanup;\n\n    /* For now only the vmdk, vpc and vdi type harddisk\n     * variants can be created.  For historical reason, we default to vdi */\n    if (def->target.format == VIR_STORAGE_FILE_VMDK) {\n        VBOX_UTF8_TO_UTF16(\"VMDK\", &hddFormatUtf16);\n    } else if (def->target.format == VIR_STORAGE_FILE_VPC) {\n        VBOX_UTF8_TO_UTF16(\"VHD\", &hddFormatUtf16);\n    } else {\n        VBOX_UTF8_TO_UTF16(\"VDI\", &hddFormatUtf16);\n    }\n\n    /* If target.path isn't given, use default path ~/.VirtualBox/image_name */\n    if (!def->target.path) {\n        homedir = virGetUserDirectory();\n        def->target.path = g_strdup_printf(\"%s/.VirtualBox/%s\", homedir, def->name);\n    }\n    VBOX_UTF8_TO_UTF16(def->target.path, &hddNameUtf16);\n\n    if (!hddFormatUtf16 || !hddNameUtf16)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIVirtualBox.CreateHardDisk(data->vboxObj, hddFormatUtf16, hddNameUtf16, &hardDisk);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not create harddisk, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    logicalSize = VIR_DIV_UP(def->target.capacity, 1024 * 1024);\n\n    if (def->target.capacity == def->target.allocation)\n        variant = HardDiskVariant_Fixed;\n\n    rc = gVBoxAPI.UIMedium.CreateBaseStorage(hardDisk, logicalSize, variant, &progress);\n    if (NS_FAILED(rc) || !progress) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not create base storage, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n    gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n    if (RC_FAILED(resultCode)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not create base storage, rc=%08x\"),\n                       (unsigned)resultCode.uResultCode);\n        goto cleanup;\n    }\n\n    VBOX_IID_INITIALIZE(&hddIID);\n    rc = gVBoxAPI.UIMedium.GetId(hardDisk, &hddIID);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    vboxIIDToUUID(&hddIID, uuid);\n    virUUIDFormat(uuid, key);\n\n    ret = virGetStorageVol(pool->conn, pool->name, def->name, key,\n                           NULL, NULL);\n\n cleanup:\n    vboxIIDUnalloc(&hddIID);\n    VBOX_RELEASE(progress);\n    VBOX_UTF16_FREE(hddFormatUtf16);\n    VBOX_UTF16_FREE(hddNameUtf16);\n    return ret;\n}"
  },
  {
    "function_name": "vboxStorageVolLookupByPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
    "lines": "318-393",
    "snippet": "static virStorageVolPtr\nvboxStorageVolLookupByPath(virConnectPtr conn, const char *path)\n{\n    vboxDriverPtr data = conn->privateData;\n    PRUnichar *hddPathUtf16 = NULL;\n    IMedium *hardDisk = NULL;\n    PRUnichar *hddNameUtf16 = NULL;\n    char *hddNameUtf8 = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    char key[VIR_UUID_STRING_BUFLEN] = \"\";\n    vboxIID hddIID;\n    PRUint32 hddstate;\n    nsresult rc;\n    virStorageVolPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&hddIID);\n\n    if (!path)\n        return ret;\n\n    VBOX_UTF8_TO_UTF16(path, &hddPathUtf16);\n\n    if (!hddPathUtf16)\n        return ret;\n\n    rc = gVBoxAPI.UIVirtualBox.FindHardDisk(data->vboxObj, hddPathUtf16,\n                                            DeviceType_HardDisk, AccessMode_ReadWrite, &hardDisk);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n    if (hddstate == MediaState_Inaccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetName(hardDisk, &hddNameUtf16);\n\n    if (!hddNameUtf16)\n        goto cleanup;\n\n    VBOX_UTF16_TO_UTF8(hddNameUtf16, &hddNameUtf8);\n    VBOX_UTF16_FREE(hddNameUtf16);\n\n    if (!hddNameUtf8)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIMedium.GetId(hardDisk, &hddIID);\n    if (NS_FAILED(rc)) {\n        VBOX_UTF8_FREE(hddNameUtf8);\n        goto cleanup;\n    }\n\n    vboxIIDToUUID(&hddIID, uuid);\n    virUUIDFormat(uuid, key);\n\n    /* TODO: currently only one default pool and thus\n     * the check below, change it when pools are supported\n     */\n    if (vboxConnectNumOfStoragePools(conn) == 1)\n        ret = virGetStorageVol(conn, \"default-pool\", hddNameUtf8, key,\n                               NULL, NULL);\n\n    VIR_DEBUG(\"Storage Volume Pool: %s\", \"default-pool\");\n    VIR_DEBUG(\"Storage Volume Name: %s\", hddNameUtf8);\n    VIR_DEBUG(\"Storage Volume key : %s\", key);\n\n    vboxIIDUnalloc(&hddIID);\n    VBOX_UTF8_FREE(hddNameUtf8);\n\n cleanup:\n    VBOX_MEDIUM_RELEASE(hardDisk);\n    VBOX_UTF16_FREE(hddPathUtf16);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"virutil.h\"",
      "#include \"storage_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "hddPathUtf16"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_MEDIUM_RELEASE",
          "args": [
            "hardDisk"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "hddNameUtf8"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&hddIID"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume key : %s\"",
            "key"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume Name: %s\"",
            "hddNameUtf8"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume Pool: %s\"",
            "\"default-pool\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStorageVol",
          "args": [
            "conn",
            "\"default-pool\"",
            "hddNameUtf8",
            "key",
            "NULL",
            "NULL"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStorageVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "600-632",
          "snippet": "virStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStorageVolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStorageVolClass;\n\nvirStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxConnectNumOfStoragePools",
          "args": [
            "conn"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "vboxConnectNumOfStoragePools",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
          "lines": "46-53",
          "snippet": "static int vboxConnectNumOfStoragePools(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /** Currently only one pool supported, the default one\n     * given by ISystemProperties::defaultHardDiskFolder()\n     */\n\n    return 1;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int vboxConnectNumOfStoragePools(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /** Currently only one pool supported, the default one\n     * given by ISystemProperties::defaultHardDiskFolder()\n     */\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "key"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxIIDToUUID",
          "args": [
            "&hddIID",
            "uuid"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "hddNameUtf8"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetId",
          "args": [
            "hardDisk",
            "&hddIID"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "hddNameUtf16"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "hddNameUtf16",
            "&hddNameUtf8"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetName",
          "args": [
            "hardDisk",
            "&hddNameUtf16"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetState",
          "args": [
            "hardDisk",
            "&hddstate"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.FindHardDisk",
          "args": [
            "data->vboxObj",
            "hddPathUtf16",
            "DeviceType_HardDisk",
            "AccessMode_ReadWrite",
            "&hardDisk"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "path",
            "&hddPathUtf16"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&hddIID"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virStorageVolPtr\nvboxStorageVolLookupByPath(virConnectPtr conn, const char *path)\n{\n    vboxDriverPtr data = conn->privateData;\n    PRUnichar *hddPathUtf16 = NULL;\n    IMedium *hardDisk = NULL;\n    PRUnichar *hddNameUtf16 = NULL;\n    char *hddNameUtf8 = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    char key[VIR_UUID_STRING_BUFLEN] = \"\";\n    vboxIID hddIID;\n    PRUint32 hddstate;\n    nsresult rc;\n    virStorageVolPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&hddIID);\n\n    if (!path)\n        return ret;\n\n    VBOX_UTF8_TO_UTF16(path, &hddPathUtf16);\n\n    if (!hddPathUtf16)\n        return ret;\n\n    rc = gVBoxAPI.UIVirtualBox.FindHardDisk(data->vboxObj, hddPathUtf16,\n                                            DeviceType_HardDisk, AccessMode_ReadWrite, &hardDisk);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n    if (hddstate == MediaState_Inaccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetName(hardDisk, &hddNameUtf16);\n\n    if (!hddNameUtf16)\n        goto cleanup;\n\n    VBOX_UTF16_TO_UTF8(hddNameUtf16, &hddNameUtf8);\n    VBOX_UTF16_FREE(hddNameUtf16);\n\n    if (!hddNameUtf8)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIMedium.GetId(hardDisk, &hddIID);\n    if (NS_FAILED(rc)) {\n        VBOX_UTF8_FREE(hddNameUtf8);\n        goto cleanup;\n    }\n\n    vboxIIDToUUID(&hddIID, uuid);\n    virUUIDFormat(uuid, key);\n\n    /* TODO: currently only one default pool and thus\n     * the check below, change it when pools are supported\n     */\n    if (vboxConnectNumOfStoragePools(conn) == 1)\n        ret = virGetStorageVol(conn, \"default-pool\", hddNameUtf8, key,\n                               NULL, NULL);\n\n    VIR_DEBUG(\"Storage Volume Pool: %s\", \"default-pool\");\n    VIR_DEBUG(\"Storage Volume Name: %s\", hddNameUtf8);\n    VIR_DEBUG(\"Storage Volume key : %s\", key);\n\n    vboxIIDUnalloc(&hddIID);\n    VBOX_UTF8_FREE(hddNameUtf8);\n\n cleanup:\n    VBOX_MEDIUM_RELEASE(hardDisk);\n    VBOX_UTF16_FREE(hddPathUtf16);\n    return ret;\n}"
  },
  {
    "function_name": "vboxStorageVolLookupByKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
    "lines": "251-316",
    "snippet": "static virStorageVolPtr\nvboxStorageVolLookupByKey(virConnectPtr conn, const char *key)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxIID hddIID;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    IMedium *hardDisk = NULL;\n    PRUnichar *hddNameUtf16 = NULL;\n    char *hddNameUtf8 = NULL;\n    PRUint32 hddstate;\n    nsresult rc;\n    virStorageVolPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&hddIID);\n    if (!key)\n        return ret;\n\n    if (virUUIDParse(key, uuid) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Could not parse UUID from '%s'\"), key);\n        return NULL;\n    }\n\n    vboxIIDFromUUID(&hddIID, uuid);\n    rc = gVBoxAPI.UIVirtualBox.GetHardDiskByIID(data->vboxObj, &hddIID, &hardDisk);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n    if (hddstate == MediaState_Inaccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetName(hardDisk, &hddNameUtf16);\n    if (!hddNameUtf16)\n        goto cleanup;\n\n    VBOX_UTF16_TO_UTF8(hddNameUtf16, &hddNameUtf8);\n    if (!hddNameUtf8) {\n        VBOX_UTF16_FREE(hddNameUtf16);\n        goto cleanup;\n    }\n\n    if (vboxConnectNumOfStoragePools(conn) == 1) {\n        ret = virGetStorageVol(conn, \"default-pool\", hddNameUtf8, key,\n                               NULL, NULL);\n        VIR_DEBUG(\"Storage Volume Pool: %s\", \"default-pool\");\n    } else {\n        /* TODO: currently only one default pool and thus\n         * nothing here, change it when pools are supported\n         */\n    }\n\n    VIR_DEBUG(\"Storage Volume Name: %s\", key);\n    VIR_DEBUG(\"Storage Volume key : %s\", hddNameUtf8);\n\n    VBOX_UTF8_FREE(hddNameUtf8);\n    VBOX_UTF16_FREE(hddNameUtf16);\n\n cleanup:\n    VBOX_MEDIUM_RELEASE(hardDisk);\n    vboxIIDUnalloc(&hddIID);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"virutil.h\"",
      "#include \"storage_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&hddIID"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_MEDIUM_RELEASE",
          "args": [
            "hardDisk"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "hddNameUtf16"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "hddNameUtf8"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume key : %s\"",
            "hddNameUtf8"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume Name: %s\"",
            "key"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume Pool: %s\"",
            "\"default-pool\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStorageVol",
          "args": [
            "conn",
            "\"default-pool\"",
            "hddNameUtf8",
            "key",
            "NULL",
            "NULL"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStorageVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "600-632",
          "snippet": "virStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStorageVolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStorageVolClass;\n\nvirStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxConnectNumOfStoragePools",
          "args": [
            "conn"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "vboxConnectNumOfStoragePools",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
          "lines": "46-53",
          "snippet": "static int vboxConnectNumOfStoragePools(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /** Currently only one pool supported, the default one\n     * given by ISystemProperties::defaultHardDiskFolder()\n     */\n\n    return 1;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int vboxConnectNumOfStoragePools(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /** Currently only one pool supported, the default one\n     * given by ISystemProperties::defaultHardDiskFolder()\n     */\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "hddNameUtf16"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "hddNameUtf16",
            "&hddNameUtf8"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetName",
          "args": [
            "hardDisk",
            "&hddNameUtf16"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetState",
          "args": [
            "hardDisk",
            "&hddstate"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHardDiskByIID",
          "args": [
            "data->vboxObj",
            "&hddIID",
            "&hardDisk"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDFromUUID",
          "args": [
            "&hddIID",
            "uuid"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Could not parse UUID from '%s'\")",
            "key"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not parse UUID from '%s'\""
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "key",
            "uuid"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&hddIID"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virStorageVolPtr\nvboxStorageVolLookupByKey(virConnectPtr conn, const char *key)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxIID hddIID;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    IMedium *hardDisk = NULL;\n    PRUnichar *hddNameUtf16 = NULL;\n    char *hddNameUtf8 = NULL;\n    PRUint32 hddstate;\n    nsresult rc;\n    virStorageVolPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&hddIID);\n    if (!key)\n        return ret;\n\n    if (virUUIDParse(key, uuid) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Could not parse UUID from '%s'\"), key);\n        return NULL;\n    }\n\n    vboxIIDFromUUID(&hddIID, uuid);\n    rc = gVBoxAPI.UIVirtualBox.GetHardDiskByIID(data->vboxObj, &hddIID, &hardDisk);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n    if (hddstate == MediaState_Inaccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMedium.GetName(hardDisk, &hddNameUtf16);\n    if (!hddNameUtf16)\n        goto cleanup;\n\n    VBOX_UTF16_TO_UTF8(hddNameUtf16, &hddNameUtf8);\n    if (!hddNameUtf8) {\n        VBOX_UTF16_FREE(hddNameUtf16);\n        goto cleanup;\n    }\n\n    if (vboxConnectNumOfStoragePools(conn) == 1) {\n        ret = virGetStorageVol(conn, \"default-pool\", hddNameUtf8, key,\n                               NULL, NULL);\n        VIR_DEBUG(\"Storage Volume Pool: %s\", \"default-pool\");\n    } else {\n        /* TODO: currently only one default pool and thus\n         * nothing here, change it when pools are supported\n         */\n    }\n\n    VIR_DEBUG(\"Storage Volume Name: %s\", key);\n    VIR_DEBUG(\"Storage Volume key : %s\", hddNameUtf8);\n\n    VBOX_UTF8_FREE(hddNameUtf8);\n    VBOX_UTF16_FREE(hddNameUtf16);\n\n cleanup:\n    VBOX_MEDIUM_RELEASE(hardDisk);\n    vboxIIDUnalloc(&hddIID);\n    return ret;\n}"
  },
  {
    "function_name": "vboxStorageVolLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
    "lines": "178-249",
    "snippet": "static virStorageVolPtr\nvboxStorageVolLookupByName(virStoragePoolPtr pool, const char *name)\n{\n    vboxDriverPtr data = pool->conn->privateData;\n    vboxArray hardDisks = VBOX_ARRAY_INITIALIZER;\n    nsresult rc;\n    size_t i;\n    virStorageVolPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!name)\n        return ret;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&hardDisks, data->vboxObj,\n                                      gVBoxAPI.UArray.handleGetHardDisks(data->vboxObj));\n    if (NS_FAILED(rc))\n        return ret;\n\n    for (i = 0; i < hardDisks.count; ++i) {\n        IMedium *hardDisk = hardDisks.items[i];\n        PRUint32 hddstate;\n        char *nameUtf8 = NULL;\n        PRUnichar *nameUtf16 = NULL;\n\n        if (!hardDisk)\n            continue;\n\n        gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n        if (hddstate == MediaState_Inaccessible)\n            continue;\n\n        gVBoxAPI.UIMedium.GetName(hardDisk, &nameUtf16);\n\n        if (nameUtf16) {\n            VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n            VBOX_UTF16_FREE(nameUtf16);\n        }\n\n        if (nameUtf8 && STREQ(nameUtf8, name)) {\n            vboxIID hddIID;\n            unsigned char uuid[VIR_UUID_BUFLEN];\n            char key[VIR_UUID_STRING_BUFLEN] = \"\";\n\n            VBOX_IID_INITIALIZE(&hddIID);\n            rc = gVBoxAPI.UIMedium.GetId(hardDisk, &hddIID);\n            if (NS_SUCCEEDED(rc)) {\n                vboxIIDToUUID(&hddIID, uuid);\n                virUUIDFormat(uuid, key);\n\n                ret = virGetStorageVol(pool->conn, pool->name, name, key,\n                                       NULL, NULL);\n\n                VIR_DEBUG(\"virStorageVolPtr: %p\", ret);\n                VIR_DEBUG(\"Storage Volume Name: %s\", name);\n                VIR_DEBUG(\"Storage Volume key : %s\", key);\n                VIR_DEBUG(\"Storage Volume Pool: %s\", pool->name);\n            }\n\n            vboxIIDUnalloc(&hddIID);\n            VBOX_UTF8_FREE(nameUtf8);\n            break;\n        }\n\n        VBOX_UTF8_FREE(nameUtf8);\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&hardDisks);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"virutil.h\"",
      "#include \"storage_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&hardDisks"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "nameUtf8"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "nameUtf8"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&hddIID"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume Pool: %s\"",
            "pool->name"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume key : %s\"",
            "key"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storage Volume Name: %s\"",
            "name"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"virStorageVolPtr: %p\"",
            "ret"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetStorageVol",
          "args": [
            "pool->conn",
            "pool->name",
            "name",
            "key",
            "NULL",
            "NULL"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStorageVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "600-632",
          "snippet": "virStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStorageVolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStorageVolClass;\n\nvirStorageVolPtr\nvirGetStorageVol(virConnectPtr conn, const char *pool, const char *name,\n                 const char *key, void *privateData, virFreeCallback freeFunc)\n{\n    virStorageVolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(pool, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(key, error);\n\n    if (!(ret = virObjectNew(virStorageVolClass)))\n        goto error;\n\n    ret->pool = g_strdup(pool);\n    ret->name = g_strdup(name);\n    ret->key = g_strdup(key);\n\n    ret->conn = virObjectRef(conn);\n\n    /* set driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "key"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxIIDToUUID",
          "args": [
            "&hddIID",
            "uuid"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "rc"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetId",
          "args": [
            "hardDisk",
            "&hddIID"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&hddIID"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "nameUtf8",
            "name"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "nameUtf16",
            "&nameUtf8"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetName",
          "args": [
            "hardDisk",
            "&nameUtf16"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetState",
          "args": [
            "hardDisk",
            "&hddstate"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&hardDisks",
            "data->vboxObj",
            "gVBoxAPI.UArray.handleGetHardDisks(data->vboxObj)"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleGetHardDisks",
          "args": [
            "data->vboxObj"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virStorageVolPtr\nvboxStorageVolLookupByName(virStoragePoolPtr pool, const char *name)\n{\n    vboxDriverPtr data = pool->conn->privateData;\n    vboxArray hardDisks = VBOX_ARRAY_INITIALIZER;\n    nsresult rc;\n    size_t i;\n    virStorageVolPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!name)\n        return ret;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&hardDisks, data->vboxObj,\n                                      gVBoxAPI.UArray.handleGetHardDisks(data->vboxObj));\n    if (NS_FAILED(rc))\n        return ret;\n\n    for (i = 0; i < hardDisks.count; ++i) {\n        IMedium *hardDisk = hardDisks.items[i];\n        PRUint32 hddstate;\n        char *nameUtf8 = NULL;\n        PRUnichar *nameUtf16 = NULL;\n\n        if (!hardDisk)\n            continue;\n\n        gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n        if (hddstate == MediaState_Inaccessible)\n            continue;\n\n        gVBoxAPI.UIMedium.GetName(hardDisk, &nameUtf16);\n\n        if (nameUtf16) {\n            VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n            VBOX_UTF16_FREE(nameUtf16);\n        }\n\n        if (nameUtf8 && STREQ(nameUtf8, name)) {\n            vboxIID hddIID;\n            unsigned char uuid[VIR_UUID_BUFLEN];\n            char key[VIR_UUID_STRING_BUFLEN] = \"\";\n\n            VBOX_IID_INITIALIZE(&hddIID);\n            rc = gVBoxAPI.UIMedium.GetId(hardDisk, &hddIID);\n            if (NS_SUCCEEDED(rc)) {\n                vboxIIDToUUID(&hddIID, uuid);\n                virUUIDFormat(uuid, key);\n\n                ret = virGetStorageVol(pool->conn, pool->name, name, key,\n                                       NULL, NULL);\n\n                VIR_DEBUG(\"virStorageVolPtr: %p\", ret);\n                VIR_DEBUG(\"Storage Volume Name: %s\", name);\n                VIR_DEBUG(\"Storage Volume key : %s\", key);\n                VIR_DEBUG(\"Storage Volume Pool: %s\", pool->name);\n            }\n\n            vboxIIDUnalloc(&hddIID);\n            VBOX_UTF8_FREE(nameUtf8);\n            break;\n        }\n\n        VBOX_UTF8_FREE(nameUtf8);\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&hardDisks);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxStoragePoolListVolumes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
    "lines": "125-176",
    "snippet": "static int\nvboxStoragePoolListVolumes(virStoragePoolPtr pool, char **const names, int nnames)\n{\n    vboxDriverPtr data = pool->conn->privateData;\n    vboxArray hardDisks = VBOX_ARRAY_INITIALIZER;\n    PRUint32 numActive = 0;\n    nsresult rc;\n    size_t i;\n\n    if (!data->vboxObj)\n        return -1;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&hardDisks, data->vboxObj,\n                                      gVBoxAPI.UArray.handleGetHardDisks(data->vboxObj));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get the volume list in the pool: %s, rc=%08x\"),\n                       pool->name, (unsigned)rc);\n        return -1;\n    }\n\n    for (i = 0; i < hardDisks.count && numActive < nnames; ++i) {\n        IMedium *hardDisk = hardDisks.items[i];\n        PRUint32 hddstate;\n        char *nameUtf8 = NULL;\n        PRUnichar *nameUtf16 = NULL;\n\n        if (!hardDisk)\n            continue;\n\n        gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n        if (hddstate == MediaState_Inaccessible)\n            continue;\n\n        gVBoxAPI.UIMedium.GetName(hardDisk, &nameUtf16);\n\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n\n        if (!nameUtf8)\n            continue;\n\n        VIR_DEBUG(\"nnames[%d]: %s\", numActive, nameUtf8);\n        names[numActive] = g_strdup(nameUtf8);\n        numActive++;\n\n        VBOX_UTF8_FREE(nameUtf8);\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&hardDisks);\n    return numActive;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"virutil.h\"",
      "#include \"storage_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&hardDisks"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "nameUtf8"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "nameUtf8"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"nnames[%d]: %s\"",
            "numActive",
            "nameUtf8"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "nameUtf16",
            "&nameUtf8"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetName",
          "args": [
            "hardDisk",
            "&nameUtf16"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetState",
          "args": [
            "hardDisk",
            "&hddstate"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get the volume list in the pool: %s, rc=%08x\")",
            "pool->name",
            "(unsigned)rc"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not get the volume list in the pool: %s, rc=%08x\""
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&hardDisks",
            "data->vboxObj",
            "gVBoxAPI.UArray.handleGetHardDisks(data->vboxObj)"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleGetHardDisks",
          "args": [
            "data->vboxObj"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxStoragePoolListVolumes(virStoragePoolPtr pool, char **const names, int nnames)\n{\n    vboxDriverPtr data = pool->conn->privateData;\n    vboxArray hardDisks = VBOX_ARRAY_INITIALIZER;\n    PRUint32 numActive = 0;\n    nsresult rc;\n    size_t i;\n\n    if (!data->vboxObj)\n        return -1;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&hardDisks, data->vboxObj,\n                                      gVBoxAPI.UArray.handleGetHardDisks(data->vboxObj));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get the volume list in the pool: %s, rc=%08x\"),\n                       pool->name, (unsigned)rc);\n        return -1;\n    }\n\n    for (i = 0; i < hardDisks.count && numActive < nnames; ++i) {\n        IMedium *hardDisk = hardDisks.items[i];\n        PRUint32 hddstate;\n        char *nameUtf8 = NULL;\n        PRUnichar *nameUtf16 = NULL;\n\n        if (!hardDisk)\n            continue;\n\n        gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n        if (hddstate == MediaState_Inaccessible)\n            continue;\n\n        gVBoxAPI.UIMedium.GetName(hardDisk, &nameUtf16);\n\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n\n        if (!nameUtf8)\n            continue;\n\n        VIR_DEBUG(\"nnames[%d]: %s\", numActive, nameUtf8);\n        names[numActive] = g_strdup(nameUtf8);\n        numActive++;\n\n        VBOX_UTF8_FREE(nameUtf8);\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&hardDisks);\n    return numActive;\n}"
  },
  {
    "function_name": "vboxStoragePoolNumOfVolumes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
    "lines": "88-123",
    "snippet": "static int vboxStoragePoolNumOfVolumes(virStoragePoolPtr pool)\n{\n    vboxDriverPtr data = pool->conn->privateData;\n    vboxArray hardDisks = VBOX_ARRAY_INITIALIZER;\n    PRUint32 hardDiskAccessible = 0;\n    nsresult rc;\n    size_t i;\n\n    if (!data->vboxObj)\n        return -1;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&hardDisks, data->vboxObj,\n                                      gVBoxAPI.UArray.handleGetHardDisks(data->vboxObj));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get number of volumes in the pool: %s, rc=%08x\"),\n                       pool->name, (unsigned)rc);\n        return -1;\n    }\n\n    for (i = 0; i < hardDisks.count; ++i) {\n        IMedium *hardDisk = hardDisks.items[i];\n        PRUint32 hddstate;\n\n        if (!hardDisk)\n            continue;\n\n        gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n        if (hddstate != MediaState_Inaccessible)\n            hardDiskAccessible++;\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&hardDisks);\n\n    return hardDiskAccessible;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"virutil.h\"",
      "#include \"storage_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&hardDisks"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetState",
          "args": [
            "hardDisk",
            "&hddstate"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get number of volumes in the pool: %s, rc=%08x\")",
            "pool->name",
            "(unsigned)rc"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not get number of volumes in the pool: %s, rc=%08x\""
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&hardDisks",
            "data->vboxObj",
            "gVBoxAPI.UArray.handleGetHardDisks(data->vboxObj)"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleGetHardDisks",
          "args": [
            "data->vboxObj"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxStoragePoolNumOfVolumes(virStoragePoolPtr pool)\n{\n    vboxDriverPtr data = pool->conn->privateData;\n    vboxArray hardDisks = VBOX_ARRAY_INITIALIZER;\n    PRUint32 hardDiskAccessible = 0;\n    nsresult rc;\n    size_t i;\n\n    if (!data->vboxObj)\n        return -1;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&hardDisks, data->vboxObj,\n                                      gVBoxAPI.UArray.handleGetHardDisks(data->vboxObj));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get number of volumes in the pool: %s, rc=%08x\"),\n                       pool->name, (unsigned)rc);\n        return -1;\n    }\n\n    for (i = 0; i < hardDisks.count; ++i) {\n        IMedium *hardDisk = hardDisks.items[i];\n        PRUint32 hddstate;\n\n        if (!hardDisk)\n            continue;\n\n        gVBoxAPI.UIMedium.GetState(hardDisk, &hddstate);\n        if (hddstate != MediaState_Inaccessible)\n            hardDiskAccessible++;\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&hardDisks);\n\n    return hardDiskAccessible;\n}"
  },
  {
    "function_name": "vboxStoragePoolLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
    "lines": "67-86",
    "snippet": "static virStoragePoolPtr\nvboxStoragePoolLookupByName(virConnectPtr conn, const char *name)\n{\n    virStoragePoolPtr ret = NULL;\n\n    /** Current limitation of the function: since\n     * the default pool doesn't have UUID just assign\n     * one till vbox can handle pools\n     */\n    if (STREQ(\"default-pool\", name)) {\n        unsigned char uuid[VIR_UUID_BUFLEN];\n        const char *uuidstr = \"1deff1ff-1481-464f-967f-a50fe8936cc4\";\n\n        ignore_value(virUUIDParse(uuidstr, uuid));\n\n        ret = virGetStoragePool(conn, name, uuid, NULL, NULL);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"virutil.h\"",
      "#include \"storage_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virGetStoragePool",
          "args": [
            "conn",
            "name",
            "uuid",
            "NULL",
            "NULL"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "virGetStoragePool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "525-556",
          "snippet": "virStoragePoolPtr\nvirGetStoragePool(virConnectPtr conn, const char *name,\n                  const unsigned char *uuid,\n                  void *privateData, virFreeCallback freeFunc)\n{\n    virStoragePoolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virStoragePoolClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    /* set the driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virStoragePoolClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virStoragePoolClass;\n\nvirStoragePoolPtr\nvirGetStoragePool(virConnectPtr conn, const char *name,\n                  const unsigned char *uuid,\n                  void *privateData, virFreeCallback freeFunc)\n{\n    virStoragePoolPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virStoragePoolClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    /* set the driver specific data */\n    ret->privateData = privateData;\n    ret->privateDataFreeFunc = freeFunc;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virUUIDParse(uuidstr, uuid)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "uuidstr",
            "uuid"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "\"default-pool\"",
            "name"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virStoragePoolPtr\nvboxStoragePoolLookupByName(virConnectPtr conn, const char *name)\n{\n    virStoragePoolPtr ret = NULL;\n\n    /** Current limitation of the function: since\n     * the default pool doesn't have UUID just assign\n     * one till vbox can handle pools\n     */\n    if (STREQ(\"default-pool\", name)) {\n        unsigned char uuid[VIR_UUID_BUFLEN];\n        const char *uuidstr = \"1deff1ff-1481-464f-967f-a50fe8936cc4\";\n\n        ignore_value(virUUIDParse(uuidstr, uuid));\n\n        ret = virGetStoragePool(conn, name, uuid, NULL, NULL);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxConnectListStoragePools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
    "lines": "55-65",
    "snippet": "static int vboxConnectListStoragePools(virConnectPtr conn G_GNUC_UNUSED,\n                                       char **const names, int nnames)\n{\n    int numActive = 0;\n\n    if (nnames > 0) {\n        names[numActive] = g_strdup(\"default-pool\");\n        numActive++;\n    }\n    return numActive;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"virutil.h\"",
      "#include \"storage_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"default-pool\""
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int vboxConnectListStoragePools(virConnectPtr conn G_GNUC_UNUSED,\n                                       char **const names, int nnames)\n{\n    int numActive = 0;\n\n    if (nnames > 0) {\n        names[numActive] = g_strdup(\"default-pool\");\n        numActive++;\n    }\n    return numActive;\n}"
  },
  {
    "function_name": "vboxConnectNumOfStoragePools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_storage.c",
    "lines": "46-53",
    "snippet": "static int vboxConnectNumOfStoragePools(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /** Currently only one pool supported, the default one\n     * given by ISystemProperties::defaultHardDiskFolder()\n     */\n\n    return 1;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"virutil.h\"",
      "#include \"storage_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int vboxConnectNumOfStoragePools(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /** Currently only one pool supported, the default one\n     * given by ISystemProperties::defaultHardDiskFolder()\n     */\n\n    return 1;\n}"
  }
]