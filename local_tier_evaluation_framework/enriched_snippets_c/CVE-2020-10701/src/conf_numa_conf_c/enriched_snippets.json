[
  {
    "function_name": "virDomainNumaGetMemorySize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1365-1375",
    "snippet": "unsigned long long\nvirDomainNumaGetMemorySize(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned long long ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++)\n        ret += numa->mem_nodes[i].mem;\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned long long\nvirDomainNumaGetMemorySize(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned long long ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++)\n        ret += numa->mem_nodes[i].mem;\n\n    return ret;\n}"
  },
  {
    "function_name": "virDomainNumaSetNodeMemorySize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1356-1362",
    "snippet": "void\nvirDomainNumaSetNodeMemorySize(virDomainNumaPtr numa,\n                               size_t node,\n                               unsigned long long size)\n{\n    numa->mem_nodes[node].mem = size;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvoid\nvirDomainNumaSetNodeMemorySize(virDomainNumaPtr numa,\n                               size_t node,\n                               unsigned long long size)\n{\n    numa->mem_nodes[node].mem = size;\n}"
  },
  {
    "function_name": "virDomainNumaGetNodeMemorySize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1348-1353",
    "snippet": "unsigned long long\nvirDomainNumaGetNodeMemorySize(virDomainNumaPtr numa,\n                               size_t node)\n{\n    return numa->mem_nodes[node].mem;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned long long\nvirDomainNumaGetNodeMemorySize(virDomainNumaPtr numa,\n                               size_t node)\n{\n    return numa->mem_nodes[node].mem;\n}"
  },
  {
    "function_name": "virDomainNumaGetNodeDiscard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1340-1345",
    "snippet": "virTristateBool\nvirDomainNumaGetNodeDiscard(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].discard;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirTristateBool\nvirDomainNumaGetNodeDiscard(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].discard;\n}"
  },
  {
    "function_name": "virDomainNumaGetNodeMemoryAccessMode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1332-1337",
    "snippet": "virDomainMemoryAccess\nvirDomainNumaGetNodeMemoryAccessMode(virDomainNumaPtr numa,\n                                     size_t node)\n{\n    return numa->mem_nodes[node].memAccess;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirDomainMemoryAccess\nvirDomainNumaGetNodeMemoryAccessMode(virDomainNumaPtr numa,\n                                     size_t node)\n{\n    return numa->mem_nodes[node].memAccess;\n}"
  },
  {
    "function_name": "virDomainNumaSetNodeCpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1321-1329",
    "snippet": "virBitmapPtr\nvirDomainNumaSetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node,\n                            virBitmapPtr cpumask)\n{\n    numa->mem_nodes[node].cpumask = cpumask;\n\n    return numa->mem_nodes[node].cpumask;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirBitmapPtr\nvirDomainNumaSetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node,\n                            virBitmapPtr cpumask)\n{\n    numa->mem_nodes[node].cpumask = cpumask;\n\n    return numa->mem_nodes[node].cpumask;\n}"
  },
  {
    "function_name": "virDomainNumaGetNodeCpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1313-1318",
    "snippet": "virBitmapPtr\nvirDomainNumaGetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].cpumask;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirBitmapPtr\nvirDomainNumaGetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].cpumask;\n}"
  },
  {
    "function_name": "virDomainNumaSetNodeDistanceCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1288-1310",
    "snippet": "size_t\nvirDomainNumaSetNodeDistanceCount(virDomainNumaPtr numa,\n                                  size_t node,\n                                  size_t ndistances)\n{\n    virDomainNumaDistancePtr distances;\n\n    distances = numa->mem_nodes[node].distances;\n    if (distances) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot alter an existing nmem_nodes distances set for node: %zu\"),\n                       node);\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(distances, ndistances) < 0)\n        return 0;\n\n    numa->mem_nodes[node].distances = distances;\n    numa->mem_nodes[node].ndistances = ndistances;\n\n    return numa->mem_nodes[node].ndistances;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "distances",
            "ndistances"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cannot alter an existing nmem_nodes distances set for node: %zu\")",
            "node"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot alter an existing nmem_nodes distances set for node: %zu\""
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nsize_t\nvirDomainNumaSetNodeDistanceCount(virDomainNumaPtr numa,\n                                  size_t node,\n                                  size_t ndistances)\n{\n    virDomainNumaDistancePtr distances;\n\n    distances = numa->mem_nodes[node].distances;\n    if (distances) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot alter an existing nmem_nodes distances set for node: %zu\"),\n                       node);\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(distances, ndistances) < 0)\n        return 0;\n\n    numa->mem_nodes[node].distances = distances;\n    numa->mem_nodes[node].ndistances = ndistances;\n\n    return numa->mem_nodes[node].ndistances;\n}"
  },
  {
    "function_name": "virDomainNumaSetNodeDistance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1234-1285",
    "snippet": "int\nvirDomainNumaSetNodeDistance(virDomainNumaPtr numa,\n                             size_t node,\n                             size_t cellid,\n                             unsigned int value)\n{\n    virDomainNumaDistancePtr distances;\n\n    if (node >= numa->nmem_nodes) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Argument 'node' %zu outranges \"\n                         \"defined number of NUMA nodes\"),\n                       node);\n        return -1;\n    }\n\n    distances = numa->mem_nodes[node].distances;\n    if (!distances ||\n        cellid >= numa->mem_nodes[node].ndistances) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Arguments under memnode element do not \"\n                         \"correspond with existing guest's NUMA cell\"));\n        return -1;\n    }\n\n    /*\n     * Advanced Configuration and Power Interface\n     * Specification version 6.1. Chapter 5.2.17\n     * System Locality Distance Information Table\n     * ... Distance values of 0-9 are reserved.\n     */\n    if (value < LOCAL_DISTANCE ||\n        value > UNREACHABLE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Distance value of %d is not in valid range\"),\n                       value);\n        return -1;\n    }\n\n    if (value == LOCAL_DISTANCE && node != cellid) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Distance value %d under node %zu is \"\n                         \"LOCAL_DISTANCE and should be set to 10\"),\n                       value, node);\n        return -1;\n    }\n\n    distances[cellid].cellid = cellid;\n    distances[cellid].value = value;\n\n    return distances[cellid].value;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define UNREACHABLE            255",
      "#define LOCAL_DISTANCE          10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Distance value %d under node %zu is \"\n                         \"LOCAL_DISTANCE and should be set to 10\")",
            "value",
            "node"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Distance value %d under node %zu is \"\n                         \"LOCAL_DISTANCE and should be set to 10\""
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Distance value of %d is not in valid range\")",
            "value"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Arguments under memnode element do not \"\n                         \"correspond with existing guest's NUMA cell\")"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Argument 'node' %zu outranges \"\n                         \"defined number of NUMA nodes\")",
            "node"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\n#define UNREACHABLE            255\n#define LOCAL_DISTANCE          10\n\nint\nvirDomainNumaSetNodeDistance(virDomainNumaPtr numa,\n                             size_t node,\n                             size_t cellid,\n                             unsigned int value)\n{\n    virDomainNumaDistancePtr distances;\n\n    if (node >= numa->nmem_nodes) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Argument 'node' %zu outranges \"\n                         \"defined number of NUMA nodes\"),\n                       node);\n        return -1;\n    }\n\n    distances = numa->mem_nodes[node].distances;\n    if (!distances ||\n        cellid >= numa->mem_nodes[node].ndistances) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Arguments under memnode element do not \"\n                         \"correspond with existing guest's NUMA cell\"));\n        return -1;\n    }\n\n    /*\n     * Advanced Configuration and Power Interface\n     * Specification version 6.1. Chapter 5.2.17\n     * System Locality Distance Information Table\n     * ... Distance values of 0-9 are reserved.\n     */\n    if (value < LOCAL_DISTANCE ||\n        value > UNREACHABLE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Distance value of %d is not in valid range\"),\n                       value);\n        return -1;\n    }\n\n    if (value == LOCAL_DISTANCE && node != cellid) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Distance value %d under node %zu is \"\n                         \"LOCAL_DISTANCE and should be set to 10\"),\n                       value, node);\n        return -1;\n    }\n\n    distances[cellid].cellid = cellid;\n    distances[cellid].value = value;\n\n    return distances[cellid].value;\n}"
  },
  {
    "function_name": "virDomainNumaGetNodeDistance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1210-1231",
    "snippet": "size_t\nvirDomainNumaGetNodeDistance(virDomainNumaPtr numa,\n                             size_t node,\n                             size_t cellid)\n{\n    virDomainNumaDistancePtr distances = NULL;\n\n    if (node < numa->nmem_nodes)\n        distances = numa->mem_nodes[node].distances;\n\n    /*\n     * Present the configured distance value. If\n     * out of range or not available set the platform\n     * defined default for local and remote nodes.\n     */\n    if (!distances ||\n        cellid >= numa->nmem_nodes ||\n        !distances[cellid].value)\n        return (node == cellid) ? LOCAL_DISTANCE : REMOTE_DISTANCE;\n\n    return distances[cellid].value;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define REMOTE_DISTANCE         20",
      "#define LOCAL_DISTANCE          10"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\n#define REMOTE_DISTANCE         20\n#define LOCAL_DISTANCE          10\n\nsize_t\nvirDomainNumaGetNodeDistance(virDomainNumaPtr numa,\n                             size_t node,\n                             size_t cellid)\n{\n    virDomainNumaDistancePtr distances = NULL;\n\n    if (node < numa->nmem_nodes)\n        distances = numa->mem_nodes[node].distances;\n\n    /*\n     * Present the configured distance value. If\n     * out of range or not available set the platform\n     * defined default for local and remote nodes.\n     */\n    if (!distances ||\n        cellid >= numa->nmem_nodes ||\n        !distances[cellid].value)\n        return (node == cellid) ? LOCAL_DISTANCE : REMOTE_DISTANCE;\n\n    return distances[cellid].value;\n}"
  },
  {
    "function_name": "virDomainNumaNodesDistancesAreBeingSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1191-1207",
    "snippet": "bool\nvirDomainNumaNodesDistancesAreBeingSet(virDomainNumaPtr numa)\n{\n    size_t ncells = virDomainNumaGetNodeCount(numa);\n    size_t i, j;\n\n    for (i = 0; i < ncells; i++) {\n        for (j = 0; j < ncells; j++) {\n            if (virDomainNumaNodeDistanceIsUsingDefaults(numa, i, j))\n                continue;\n\n            return true;\n        }\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainNumaNodeDistanceIsUsingDefaults",
          "args": [
            "numa",
            "i",
            "j"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaNodeDistanceIsUsingDefaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1171-1188",
          "snippet": "bool\nvirDomainNumaNodeDistanceIsUsingDefaults(virDomainNumaPtr numa,\n                                         size_t node,\n                                         size_t sibling)\n{\n    if (node >= numa->nmem_nodes ||\n        sibling >= numa->nmem_nodes)\n        return false;\n\n    if (!numa->mem_nodes[node].distances)\n        return true;\n\n    if (numa->mem_nodes[node].distances[sibling].value == LOCAL_DISTANCE ||\n        numa->mem_nodes[node].distances[sibling].value == REMOTE_DISTANCE)\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define REMOTE_DISTANCE         20",
            "#define LOCAL_DISTANCE          10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\n#define REMOTE_DISTANCE         20\n#define LOCAL_DISTANCE          10\n\nbool\nvirDomainNumaNodeDistanceIsUsingDefaults(virDomainNumaPtr numa,\n                                         size_t node,\n                                         size_t sibling)\n{\n    if (node >= numa->nmem_nodes ||\n        sibling >= numa->nmem_nodes)\n        return false;\n\n    if (!numa->mem_nodes[node].distances)\n        return true;\n\n    if (numa->mem_nodes[node].distances[sibling].value == LOCAL_DISTANCE ||\n        numa->mem_nodes[node].distances[sibling].value == REMOTE_DISTANCE)\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeCount",
          "args": [
            "numa"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1137-1144",
          "snippet": "size_t\nvirDomainNumaGetNodeCount(virDomainNumaPtr numa)\n{\n    if (!numa)\n        return 0;\n\n    return numa->nmem_nodes;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nsize_t\nvirDomainNumaGetNodeCount(virDomainNumaPtr numa)\n{\n    if (!numa)\n        return 0;\n\n    return numa->nmem_nodes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nbool\nvirDomainNumaNodesDistancesAreBeingSet(virDomainNumaPtr numa)\n{\n    size_t ncells = virDomainNumaGetNodeCount(numa);\n    size_t i, j;\n\n    for (i = 0; i < ncells; i++) {\n        for (j = 0; j < ncells; j++) {\n            if (virDomainNumaNodeDistanceIsUsingDefaults(numa, i, j))\n                continue;\n\n            return true;\n        }\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virDomainNumaNodeDistanceIsUsingDefaults",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1171-1188",
    "snippet": "bool\nvirDomainNumaNodeDistanceIsUsingDefaults(virDomainNumaPtr numa,\n                                         size_t node,\n                                         size_t sibling)\n{\n    if (node >= numa->nmem_nodes ||\n        sibling >= numa->nmem_nodes)\n        return false;\n\n    if (!numa->mem_nodes[node].distances)\n        return true;\n\n    if (numa->mem_nodes[node].distances[sibling].value == LOCAL_DISTANCE ||\n        numa->mem_nodes[node].distances[sibling].value == REMOTE_DISTANCE)\n        return true;\n\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define REMOTE_DISTANCE         20",
      "#define LOCAL_DISTANCE          10"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\n#define REMOTE_DISTANCE         20\n#define LOCAL_DISTANCE          10\n\nbool\nvirDomainNumaNodeDistanceIsUsingDefaults(virDomainNumaPtr numa,\n                                         size_t node,\n                                         size_t sibling)\n{\n    if (node >= numa->nmem_nodes ||\n        sibling >= numa->nmem_nodes)\n        return false;\n\n    if (!numa->mem_nodes[node].distances)\n        return true;\n\n    if (numa->mem_nodes[node].distances[sibling].value == LOCAL_DISTANCE ||\n        numa->mem_nodes[node].distances[sibling].value == REMOTE_DISTANCE)\n        return true;\n\n    return false;\n}"
  },
  {
    "function_name": "virDomainNumaSetNodeCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1147-1168",
    "snippet": "size_t\nvirDomainNumaSetNodeCount(virDomainNumaPtr numa, size_t nmem_nodes)\n{\n    if (!nmem_nodes) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set an empty mem_nodes set\"));\n        return 0;\n    }\n\n    if (numa->mem_nodes) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot alter an existing mem_nodes set\"));\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(numa->mem_nodes, nmem_nodes) < 0)\n        return 0;\n\n    numa->nmem_nodes = nmem_nodes;\n\n    return numa->nmem_nodes;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "numa->mem_nodes",
            "nmem_nodes"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot alter an existing mem_nodes set\")"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot alter an existing mem_nodes set\""
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot set an empty mem_nodes set\")"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nsize_t\nvirDomainNumaSetNodeCount(virDomainNumaPtr numa, size_t nmem_nodes)\n{\n    if (!nmem_nodes) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set an empty mem_nodes set\"));\n        return 0;\n    }\n\n    if (numa->mem_nodes) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot alter an existing mem_nodes set\"));\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(numa->mem_nodes, nmem_nodes) < 0)\n        return 0;\n\n    numa->nmem_nodes = nmem_nodes;\n\n    return numa->nmem_nodes;\n}"
  },
  {
    "function_name": "virDomainNumaGetNodeCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1137-1144",
    "snippet": "size_t\nvirDomainNumaGetNodeCount(virDomainNumaPtr numa)\n{\n    if (!numa)\n        return 0;\n\n    return numa->nmem_nodes;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nsize_t\nvirDomainNumaGetNodeCount(virDomainNumaPtr numa)\n{\n    if (!numa)\n        return 0;\n\n    return numa->nmem_nodes;\n}"
  },
  {
    "function_name": "virDomainNumaCheckABIStability",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1086-1134",
    "snippet": "bool\nvirDomainNumaCheckABIStability(virDomainNumaPtr src,\n                               virDomainNumaPtr tgt)\n{\n    size_t i;\n    size_t j;\n\n    if (virDomainNumaGetNodeCount(src) != virDomainNumaGetNodeCount(tgt)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Target NUMA node count '%zu' doesn't match \"\n                         \"source '%zu'\"),\n                       virDomainNumaGetNodeCount(tgt),\n                       virDomainNumaGetNodeCount(src));\n        return false;\n    }\n\n    for (i = 0; i < virDomainNumaGetNodeCount(src); i++) {\n        if (virDomainNumaGetNodeMemorySize(src, i) !=\n            virDomainNumaGetNodeMemorySize(tgt, i)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Size of target NUMA node %zu (%llu) doesn't \"\n                             \"match source (%llu)\"), i,\n                           virDomainNumaGetNodeMemorySize(tgt, i),\n                           virDomainNumaGetNodeMemorySize(src, i));\n            return false;\n        }\n\n        if (!virBitmapEqual(virDomainNumaGetNodeCpumask(src, i),\n                            virDomainNumaGetNodeCpumask(tgt, i))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Processor mask of target NUMA node %zu doesn't \"\n                             \"match source\"), i);\n            return false;\n        }\n\n        for (j = 0; j < virDomainNumaGetNodeCount(src); j++) {\n            if (virDomainNumaGetNodeDistance(src, i, j) !=\n                virDomainNumaGetNodeDistance(tgt, i, j)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Target NUMA distance from %zu to %zu \"\n                                 \"doesn't match source\"), i, j);\n\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Target NUMA distance from %zu to %zu \"\n                                 \"doesn't match source\")",
            "i",
            "j"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Target NUMA distance from %zu to %zu \"\n                                 \"doesn't match source\""
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeDistance",
          "args": [
            "tgt",
            "i",
            "j"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeDistance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1210-1231",
          "snippet": "size_t\nvirDomainNumaGetNodeDistance(virDomainNumaPtr numa,\n                             size_t node,\n                             size_t cellid)\n{\n    virDomainNumaDistancePtr distances = NULL;\n\n    if (node < numa->nmem_nodes)\n        distances = numa->mem_nodes[node].distances;\n\n    /*\n     * Present the configured distance value. If\n     * out of range or not available set the platform\n     * defined default for local and remote nodes.\n     */\n    if (!distances ||\n        cellid >= numa->nmem_nodes ||\n        !distances[cellid].value)\n        return (node == cellid) ? LOCAL_DISTANCE : REMOTE_DISTANCE;\n\n    return distances[cellid].value;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define REMOTE_DISTANCE         20",
            "#define LOCAL_DISTANCE          10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\n#define REMOTE_DISTANCE         20\n#define LOCAL_DISTANCE          10\n\nsize_t\nvirDomainNumaGetNodeDistance(virDomainNumaPtr numa,\n                             size_t node,\n                             size_t cellid)\n{\n    virDomainNumaDistancePtr distances = NULL;\n\n    if (node < numa->nmem_nodes)\n        distances = numa->mem_nodes[node].distances;\n\n    /*\n     * Present the configured distance value. If\n     * out of range or not available set the platform\n     * defined default for local and remote nodes.\n     */\n    if (!distances ||\n        cellid >= numa->nmem_nodes ||\n        !distances[cellid].value)\n        return (node == cellid) ? LOCAL_DISTANCE : REMOTE_DISTANCE;\n\n    return distances[cellid].value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeCount",
          "args": [
            "src"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1137-1144",
          "snippet": "size_t\nvirDomainNumaGetNodeCount(virDomainNumaPtr numa)\n{\n    if (!numa)\n        return 0;\n\n    return numa->nmem_nodes;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nsize_t\nvirDomainNumaGetNodeCount(virDomainNumaPtr numa)\n{\n    if (!numa)\n        return 0;\n\n    return numa->nmem_nodes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Processor mask of target NUMA node %zu doesn't \"\n                             \"match source\")",
            "i"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapEqual",
          "args": [
            "virDomainNumaGetNodeCpumask(src, i)",
            "virDomainNumaGetNodeCpumask(tgt, i)"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "841-873",
          "snippet": "bool\nvirBitmapEqual(virBitmapPtr b1,\n               virBitmapPtr b2)\n{\n    virBitmapPtr tmp;\n    size_t i;\n\n    if (!b1 && !b2)\n        return true;\n\n    if (!b1 || !b2)\n        return false;\n\n    if (b1->nbits > b2->nbits) {\n        tmp = b1;\n        b1 = b2;\n        b2 = tmp;\n    }\n\n    /* Now b1 is the smaller one, if not equal */\n\n    for (i = 0; i < b1->map_len; i++) {\n        if (b1->map[i] != b2->map[i])\n            return false;\n    }\n\n    for (; i < b2->map_len; i++) {\n        if (b2->map[i])\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapEqual(virBitmapPtr b1,\n               virBitmapPtr b2)\n{\n    virBitmapPtr tmp;\n    size_t i;\n\n    if (!b1 && !b2)\n        return true;\n\n    if (!b1 || !b2)\n        return false;\n\n    if (b1->nbits > b2->nbits) {\n        tmp = b1;\n        b1 = b2;\n        b2 = tmp;\n    }\n\n    /* Now b1 is the smaller one, if not equal */\n\n    for (i = 0; i < b1->map_len; i++) {\n        if (b1->map[i] != b2->map[i])\n            return false;\n    }\n\n    for (; i < b2->map_len; i++) {\n        if (b2->map[i])\n            return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeCpumask",
          "args": [
            "tgt",
            "i"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeCpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1313-1318",
          "snippet": "virBitmapPtr\nvirDomainNumaGetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].cpumask;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirBitmapPtr\nvirDomainNumaGetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].cpumask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Size of target NUMA node %zu (%llu) doesn't \"\n                             \"match source (%llu)\")",
            "i",
            "virDomainNumaGetNodeMemorySize(tgt, i)",
            "virDomainNumaGetNodeMemorySize(src, i)"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeMemorySize",
          "args": [
            "src",
            "i"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeMemorySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1348-1353",
          "snippet": "unsigned long long\nvirDomainNumaGetNodeMemorySize(virDomainNumaPtr numa,\n                               size_t node)\n{\n    return numa->mem_nodes[node].mem;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned long long\nvirDomainNumaGetNodeMemorySize(virDomainNumaPtr numa,\n                               size_t node)\n{\n    return numa->mem_nodes[node].mem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Target NUMA node count '%zu' doesn't match \"\n                         \"source '%zu'\")",
            "virDomainNumaGetNodeCount(tgt)",
            "virDomainNumaGetNodeCount(src)"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nbool\nvirDomainNumaCheckABIStability(virDomainNumaPtr src,\n                               virDomainNumaPtr tgt)\n{\n    size_t i;\n    size_t j;\n\n    if (virDomainNumaGetNodeCount(src) != virDomainNumaGetNodeCount(tgt)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Target NUMA node count '%zu' doesn't match \"\n                         \"source '%zu'\"),\n                       virDomainNumaGetNodeCount(tgt),\n                       virDomainNumaGetNodeCount(src));\n        return false;\n    }\n\n    for (i = 0; i < virDomainNumaGetNodeCount(src); i++) {\n        if (virDomainNumaGetNodeMemorySize(src, i) !=\n            virDomainNumaGetNodeMemorySize(tgt, i)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Size of target NUMA node %zu (%llu) doesn't \"\n                             \"match source (%llu)\"), i,\n                           virDomainNumaGetNodeMemorySize(tgt, i),\n                           virDomainNumaGetNodeMemorySize(src, i));\n            return false;\n        }\n\n        if (!virBitmapEqual(virDomainNumaGetNodeCpumask(src, i),\n                            virDomainNumaGetNodeCpumask(tgt, i))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Processor mask of target NUMA node %zu doesn't \"\n                             \"match source\"), i);\n            return false;\n        }\n\n        for (j = 0; j < virDomainNumaGetNodeCount(src); j++) {\n            if (virDomainNumaGetNodeDistance(src, i, j) !=\n                virDomainNumaGetNodeDistance(tgt, i, j)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Target NUMA distance from %zu to %zu \"\n                                 \"doesn't match source\"), i, j);\n\n                return false;\n            }\n        }\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "virDomainNumaNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1075-1083",
    "snippet": "virDomainNumaPtr\nvirDomainNumaNew(void)\n{\n    virDomainNumaPtr ret = NULL;\n\n    ignore_value(VIR_ALLOC(ret));\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "VIR_ALLOC(ret)"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirDomainNumaPtr\nvirDomainNumaNew(void)\n{\n    virDomainNumaPtr ret = NULL;\n\n    ignore_value(VIR_ALLOC(ret));\n\n    return ret;\n}"
  },
  {
    "function_name": "virDomainNumaGetMaxCPUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1057-1072",
    "snippet": "unsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapLastSetBit",
          "args": [
            "virDomainNumaGetNodeCpumask(numa, i)"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapLastSetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1025-1064",
          "snippet": "ssize_t\nvirBitmapLastSetBit(virBitmapPtr bitmap)\n{\n    ssize_t i;\n    int unusedBits;\n    ssize_t sz;\n    unsigned long bits;\n\n    /* If bitmap is empty then there is no set bit */\n    if (bitmap->map_len == 0)\n        return -1;\n\n    unusedBits = bitmap->map_len * VIR_BITMAP_BITS_PER_UNIT - bitmap->nbits;\n\n    sz = bitmap->map_len - 1;\n    if (unusedBits > 0) {\n        bits = bitmap->map[sz] & (VIR_BITMAP_BIT(VIR_BITMAP_BITS_PER_UNIT - unusedBits) - 1);\n        if (bits != 0)\n            goto found;\n\n        sz--;\n    }\n\n    for (; sz >= 0; sz--) {\n        bits = bitmap->map[sz];\n        if (bits != 0)\n            goto found;\n    }\n\n    /* Only reached if no set bit was found */\n    return -1;\n\n found:\n    for (i = VIR_BITMAP_BITS_PER_UNIT - 1; i >= 0; i--) {\n        if (bits & 1UL << i)\n            return i + sz * VIR_BITMAP_BITS_PER_UNIT;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapLastSetBit(virBitmapPtr bitmap)\n{\n    ssize_t i;\n    int unusedBits;\n    ssize_t sz;\n    unsigned long bits;\n\n    /* If bitmap is empty then there is no set bit */\n    if (bitmap->map_len == 0)\n        return -1;\n\n    unusedBits = bitmap->map_len * VIR_BITMAP_BITS_PER_UNIT - bitmap->nbits;\n\n    sz = bitmap->map_len - 1;\n    if (unusedBits > 0) {\n        bits = bitmap->map[sz] & (VIR_BITMAP_BIT(VIR_BITMAP_BITS_PER_UNIT - unusedBits) - 1);\n        if (bits != 0)\n            goto found;\n\n        sz--;\n    }\n\n    for (; sz >= 0; sz--) {\n        bits = bitmap->map[sz];\n        if (bits != 0)\n            goto found;\n    }\n\n    /* Only reached if no set bit was found */\n    return -1;\n\n found:\n    for (i = VIR_BITMAP_BITS_PER_UNIT - 1; i >= 0; i--) {\n        if (bits & 1UL << i)\n            return i + sz * VIR_BITMAP_BITS_PER_UNIT;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeCpumask",
          "args": [
            "numa",
            "i"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeCpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1313-1318",
          "snippet": "virBitmapPtr\nvirDomainNumaGetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].cpumask;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirBitmapPtr\nvirDomainNumaGetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].cpumask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned int\nvirDomainNumaGetMaxCPUID(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        int bit;\n\n        bit = virBitmapLastSetBit(virDomainNumaGetNodeCpumask(numa, i));\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virDomainNumaGetCPUCountTotal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "1045-1055",
    "snippet": "unsigned int\nvirDomainNumaGetCPUCountTotal(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++)\n        ret += virBitmapCountBits(virDomainNumaGetNodeCpumask(numa, i));\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapCountBits",
          "args": [
            "virDomainNumaGetNodeCpumask(numa, i)"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapCountBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1122-1132",
          "snippet": "size_t\nvirBitmapCountBits(virBitmapPtr bitmap)\n{\n    size_t i;\n    size_t ret = 0;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        ret += __builtin_popcountl(bitmap->map[i]);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nsize_t\nvirBitmapCountBits(virBitmapPtr bitmap)\n{\n    size_t i;\n    size_t ret = 0;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        ret += __builtin_popcountl(bitmap->map[i]);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeCpumask",
          "args": [
            "numa",
            "i"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeCpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1313-1318",
          "snippet": "virBitmapPtr\nvirDomainNumaGetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].cpumask;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirBitmapPtr\nvirDomainNumaGetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].cpumask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned int\nvirDomainNumaGetCPUCountTotal(virDomainNumaPtr numa)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < numa->nmem_nodes; i++)\n        ret += virBitmapCountBits(virDomainNumaGetNodeCpumask(numa, i));\n\n    return ret;\n}"
  },
  {
    "function_name": "virDomainNumaDefCPUFormatXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "973-1042",
    "snippet": "int\nvirDomainNumaDefCPUFormatXML(virBufferPtr buf,\n                             virDomainNumaPtr def)\n{\n    virDomainMemoryAccess memAccess;\n    virTristateBool discard;\n    char *cpustr;\n    size_t ncells = virDomainNumaGetNodeCount(def);\n    size_t i;\n\n    if (ncells == 0)\n        return 0;\n\n    virBufferAddLit(buf, \"<numa>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < ncells; i++) {\n        int ndistances;\n\n        memAccess = virDomainNumaGetNodeMemoryAccessMode(def, i);\n        discard = virDomainNumaGetNodeDiscard(def, i);\n\n        if (!(cpustr = virBitmapFormat(virDomainNumaGetNodeCpumask(def, i))))\n            return -1;\n\n        virBufferAddLit(buf, \"<cell\");\n        virBufferAsprintf(buf, \" id='%zu'\", i);\n        virBufferAsprintf(buf, \" cpus='%s'\", cpustr);\n        virBufferAsprintf(buf, \" memory='%llu'\",\n                          virDomainNumaGetNodeMemorySize(def, i));\n        virBufferAddLit(buf, \" unit='KiB'\");\n        if (memAccess)\n            virBufferAsprintf(buf, \" memAccess='%s'\",\n                              virDomainMemoryAccessTypeToString(memAccess));\n\n        if (discard)\n            virBufferAsprintf(buf, \" discard='%s'\",\n                              virTristateBoolTypeToString(discard));\n\n        ndistances = def->mem_nodes[i].ndistances;\n        if (ndistances == 0) {\n            virBufferAddLit(buf, \"/>\\n\");\n        } else {\n            size_t j;\n            virDomainNumaDistancePtr distances = def->mem_nodes[i].distances;\n\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            virBufferAddLit(buf, \"<distances>\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (j = 0; j < ndistances; j++) {\n                if (distances[j].value) {\n                    virBufferAddLit(buf, \"<sibling\");\n                    virBufferAsprintf(buf, \" id='%d'\", distances[j].cellid);\n                    virBufferAsprintf(buf, \" value='%d'\", distances[j].value);\n                    virBufferAddLit(buf, \"/>\\n\");\n                }\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</distances>\\n\");\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</cell>\\n\");\n        }\n\n        VIR_FREE(cpustr);\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</numa>\\n\");\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</numa>\\n\""
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpustr"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</cell>\\n\""
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</distances>\\n\""
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" value='%d'\"",
            "distances[j].value"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<sibling\""
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<distances>\\n\""
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "discard"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainMemoryAccessTypeToString",
          "args": [
            "memAccess"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" unit='KiB'\""
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeMemorySize",
          "args": [
            "def",
            "i"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeMemorySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1348-1353",
          "snippet": "unsigned long long\nvirDomainNumaGetNodeMemorySize(virDomainNumaPtr numa,\n                               size_t node)\n{\n    return numa->mem_nodes[node].mem;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nunsigned long long\nvirDomainNumaGetNodeMemorySize(virDomainNumaPtr numa,\n                               size_t node)\n{\n    return numa->mem_nodes[node].mem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<cell\""
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFormat",
          "args": [
            "virDomainNumaGetNodeCpumask(def, i)"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "404-442",
          "snippet": "char *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeCpumask",
          "args": [
            "def",
            "i"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeCpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1313-1318",
          "snippet": "virBitmapPtr\nvirDomainNumaGetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].cpumask;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirBitmapPtr\nvirDomainNumaGetNodeCpumask(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].cpumask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeDiscard",
          "args": [
            "def",
            "i"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeDiscard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1340-1345",
          "snippet": "virTristateBool\nvirDomainNumaGetNodeDiscard(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].discard;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirTristateBool\nvirDomainNumaGetNodeDiscard(virDomainNumaPtr numa,\n                            size_t node)\n{\n    return numa->mem_nodes[node].discard;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeMemoryAccessMode",
          "args": [
            "def",
            "i"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeMemoryAccessMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1332-1337",
          "snippet": "virDomainMemoryAccess\nvirDomainNumaGetNodeMemoryAccessMode(virDomainNumaPtr numa,\n                                     size_t node)\n{\n    return numa->mem_nodes[node].memAccess;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirDomainMemoryAccess\nvirDomainNumaGetNodeMemoryAccessMode(virDomainNumaPtr numa,\n                                     size_t node)\n{\n    return numa->mem_nodes[node].memAccess;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<numa>\\n\""
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumaGetNodeCount",
          "args": [
            "def"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaGetNodeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "1137-1144",
          "snippet": "size_t\nvirDomainNumaGetNodeCount(virDomainNumaPtr numa)\n{\n    if (!numa)\n        return 0;\n\n    return numa->nmem_nodes;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nsize_t\nvirDomainNumaGetNodeCount(virDomainNumaPtr numa)\n{\n    if (!numa)\n        return 0;\n\n    return numa->nmem_nodes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nint\nvirDomainNumaDefCPUFormatXML(virBufferPtr buf,\n                             virDomainNumaPtr def)\n{\n    virDomainMemoryAccess memAccess;\n    virTristateBool discard;\n    char *cpustr;\n    size_t ncells = virDomainNumaGetNodeCount(def);\n    size_t i;\n\n    if (ncells == 0)\n        return 0;\n\n    virBufferAddLit(buf, \"<numa>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < ncells; i++) {\n        int ndistances;\n\n        memAccess = virDomainNumaGetNodeMemoryAccessMode(def, i);\n        discard = virDomainNumaGetNodeDiscard(def, i);\n\n        if (!(cpustr = virBitmapFormat(virDomainNumaGetNodeCpumask(def, i))))\n            return -1;\n\n        virBufferAddLit(buf, \"<cell\");\n        virBufferAsprintf(buf, \" id='%zu'\", i);\n        virBufferAsprintf(buf, \" cpus='%s'\", cpustr);\n        virBufferAsprintf(buf, \" memory='%llu'\",\n                          virDomainNumaGetNodeMemorySize(def, i));\n        virBufferAddLit(buf, \" unit='KiB'\");\n        if (memAccess)\n            virBufferAsprintf(buf, \" memAccess='%s'\",\n                              virDomainMemoryAccessTypeToString(memAccess));\n\n        if (discard)\n            virBufferAsprintf(buf, \" discard='%s'\",\n                              virTristateBoolTypeToString(discard));\n\n        ndistances = def->mem_nodes[i].ndistances;\n        if (ndistances == 0) {\n            virBufferAddLit(buf, \"/>\\n\");\n        } else {\n            size_t j;\n            virDomainNumaDistancePtr distances = def->mem_nodes[i].distances;\n\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            virBufferAddLit(buf, \"<distances>\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (j = 0; j < ndistances; j++) {\n                if (distances[j].value) {\n                    virBufferAddLit(buf, \"<sibling\");\n                    virBufferAsprintf(buf, \" id='%d'\", distances[j].cellid);\n                    virBufferAsprintf(buf, \" value='%d'\", distances[j].value);\n                    virBufferAddLit(buf, \"/>\\n\");\n                }\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</distances>\\n\");\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</cell>\\n\");\n        }\n\n        VIR_FREE(cpustr);\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</numa>\\n\");\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainNumaDefCPUParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "844-970",
    "snippet": "int\nvirDomainNumaDefCPUParseXML(virDomainNumaPtr def,\n                            xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr *nodes = NULL;\n    xmlNodePtr oldNode = ctxt->node;\n    char *tmp = NULL;\n    int n;\n    size_t i, j;\n    int ret = -1;\n\n    /* check if NUMA definition is present */\n    if (!virXPathNode(\"./cpu/numa[1]\", ctxt))\n        return 0;\n\n    if ((n = virXPathNodeSet(\"./cpu/numa[1]/cell\", ctxt, &nodes)) <= 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"NUMA topology defined without NUMA cells\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->mem_nodes, n) < 0)\n        goto cleanup;\n    def->nmem_nodes = n;\n\n    for (i = 0; i < n; i++) {\n        int rc;\n        unsigned int cur_cell = i;\n\n        /* cells are in order of parsing or explicitly numbered */\n        if ((tmp = virXMLPropString(nodes[i], \"id\"))) {\n            if (virStrToLong_uip(tmp, NULL, 10, &cur_cell) < 0) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"Invalid 'id' attribute in NUMA cell: '%s'\"),\n                               tmp);\n                goto cleanup;\n            }\n\n            if (cur_cell >= n) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Exactly one 'cell' element per guest \"\n                                 \"NUMA cell allowed, non-contiguous ranges or \"\n                                 \"ranges not starting from 0 are not allowed\"));\n                goto cleanup;\n            }\n        }\n        VIR_FREE(tmp);\n\n        if (def->mem_nodes[cur_cell].cpumask) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Duplicate NUMA cell info for cell id '%u'\"),\n                           cur_cell);\n            goto cleanup;\n        }\n\n        if (!(tmp = virXMLPropString(nodes[i], \"cpus\"))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'cpus' attribute in NUMA cell\"));\n            goto cleanup;\n        }\n\n        if (virBitmapParse(tmp, &def->mem_nodes[cur_cell].cpumask,\n                           VIR_DOMAIN_CPUMASK_LEN) < 0)\n            goto cleanup;\n\n        if (virBitmapIsAllClear(def->mem_nodes[cur_cell].cpumask)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                          _(\"NUMA cell %d has no vCPUs assigned\"), cur_cell);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        for (j = 0; j < n; j++) {\n            if (j == cur_cell || !def->mem_nodes[j].cpumask)\n                continue;\n\n            if (virBitmapOverlaps(def->mem_nodes[j].cpumask,\n                                  def->mem_nodes[cur_cell].cpumask)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"NUMA cells %u and %zu have overlapping vCPU ids\"),\n                               cur_cell, j);\n                goto cleanup;\n            }\n        }\n\n        ctxt->node = nodes[i];\n        if (virDomainParseMemory(\"./@memory\", \"./@unit\", ctxt,\n                                 &def->mem_nodes[cur_cell].mem, true, false) < 0)\n            goto cleanup;\n\n        if ((tmp = virXMLPropString(nodes[i], \"memAccess\"))) {\n            if ((rc = virDomainMemoryAccessTypeFromString(tmp)) <= 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid 'memAccess' attribute value '%s'\"),\n                               tmp);\n                goto cleanup;\n            }\n\n            def->mem_nodes[cur_cell].memAccess = rc;\n            VIR_FREE(tmp);\n        }\n\n        if ((tmp = virXMLPropString(nodes[i], \"discard\"))) {\n            if ((rc = virTristateBoolTypeFromString(tmp)) <= 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid 'discard' attribute value '%s'\"),\n                               tmp);\n                goto cleanup;\n            }\n\n            def->mem_nodes[cur_cell].discard = rc;\n            VIR_FREE(tmp);\n        }\n\n        /* Parse NUMA distances info */\n        if (virDomainNumaDefNodeDistanceParseXML(def, ctxt, cur_cell) < 0)\n                goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    ctxt->node = oldNode;\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumaDefNodeDistanceParseXML",
          "args": [
            "def",
            "ctxt",
            "cur_cell"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaDefNodeDistanceParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "705-842",
          "snippet": "static int\nvirDomainNumaDefNodeDistanceParseXML(virDomainNumaPtr def,\n                                     xmlXPathContextPtr ctxt,\n                                     unsigned int cur_cell)\n{\n    int ret = -1;\n    int sibling;\n    char *tmp = NULL;\n    xmlNodePtr *nodes = NULL;\n    size_t i, ndistances = def->nmem_nodes;\n\n    if (ndistances == 0)\n        return 0;\n\n    /* check if NUMA distances definition is present */\n    if (!virXPathNode(\"./distances[1]\", ctxt))\n        return 0;\n\n    if ((sibling = virXPathNodeSet(\"./distances[1]/sibling\", ctxt, &nodes)) <= 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"NUMA distances defined without siblings\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < sibling; i++) {\n        virDomainNumaDistancePtr ldist, rdist;\n        unsigned int sibling_id, sibling_value;\n\n        /* siblings are in order of parsing or explicitly numbered */\n        if (!(tmp = virXMLPropString(nodes[i], \"id\"))) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing 'id' attribute in NUMA \"\n                             \"distances under 'cell id %d'\"),\n                           cur_cell);\n            goto cleanup;\n        }\n\n        /* The \"id\" needs to be applicable */\n        if (virStrToLong_uip(tmp, NULL, 10, &sibling_id) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid 'id' attribute in NUMA \"\n                             \"distances for sibling: '%s'\"),\n                           tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        /* The \"id\" needs to be within numa/cell range */\n        if (sibling_id >= ndistances) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"'sibling_id %d' does not refer to a \"\n                             \"valid cell within NUMA 'cell id %d'\"),\n                           sibling_id, cur_cell);\n            goto cleanup;\n        }\n\n        /* We need a locality value. Check and correct\n         * distance to local and distance to remote node.\n         */\n        if (!(tmp = virXMLPropString(nodes[i], \"value\"))) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing 'value' attribute in NUMA distances \"\n                             \"under 'cell id %d' for 'sibling id %d'\"),\n                           cur_cell, sibling_id);\n            goto cleanup;\n        }\n\n        /* The \"value\" needs to be applicable */\n        if (virStrToLong_uip(tmp, NULL, 10, &sibling_value) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"'value %s' is invalid for \"\n                             \"'sibling id %d' under NUMA 'cell id %d'\"),\n                           tmp, sibling_id, cur_cell);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        /* Assure LOCAL_DISTANCE <= \"value\" <= UNREACHABLE\n         * and correct LOCAL_DISTANCE setting if such applies.\n         */\n        if ((sibling_value < LOCAL_DISTANCE ||\n             sibling_value > UNREACHABLE) ||\n            (sibling_id == cur_cell &&\n             sibling_value != LOCAL_DISTANCE) ||\n            (sibling_id != cur_cell &&\n             sibling_value == LOCAL_DISTANCE)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"'value %d' is invalid for \"\n                             \"'sibling id %d' under NUMA 'cell id %d'\"),\n                           sibling_value, sibling_id, cur_cell);\n            goto cleanup;\n        }\n\n        /* Apply the local / remote distance */\n        ldist = def->mem_nodes[cur_cell].distances;\n        if (!ldist) {\n            if (VIR_ALLOC_N(ldist, ndistances) < 0)\n                goto cleanup;\n\n            ldist[cur_cell].value = LOCAL_DISTANCE;\n            ldist[cur_cell].cellid = cur_cell;\n            def->mem_nodes[cur_cell].ndistances = ndistances;\n            def->mem_nodes[cur_cell].distances = ldist;\n        }\n\n        ldist[sibling_id].cellid = sibling_id;\n        ldist[sibling_id].value = sibling_value;\n\n        /* Apply symmetry if none given */\n        rdist = def->mem_nodes[sibling_id].distances;\n        if (!rdist) {\n            if (VIR_ALLOC_N(rdist, ndistances) < 0)\n                goto cleanup;\n\n            rdist[sibling_id].value = LOCAL_DISTANCE;\n            rdist[sibling_id].cellid = sibling_id;\n            def->mem_nodes[sibling_id].ndistances = ndistances;\n            def->mem_nodes[sibling_id].distances = rdist;\n        }\n\n        rdist[cur_cell].cellid = cur_cell;\n        if (!rdist[cur_cell].value)\n            rdist[cur_cell].value = sibling_value;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        for (i = 0; i < ndistances; i++)\n            VIR_FREE(def->mem_nodes[i].distances);\n        def->mem_nodes[i].ndistances = 0;\n    }\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define UNREACHABLE            255",
            "#define LOCAL_DISTANCE          10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\n#define UNREACHABLE            255\n#define LOCAL_DISTANCE          10\n\nstatic int\nvirDomainNumaDefNodeDistanceParseXML(virDomainNumaPtr def,\n                                     xmlXPathContextPtr ctxt,\n                                     unsigned int cur_cell)\n{\n    int ret = -1;\n    int sibling;\n    char *tmp = NULL;\n    xmlNodePtr *nodes = NULL;\n    size_t i, ndistances = def->nmem_nodes;\n\n    if (ndistances == 0)\n        return 0;\n\n    /* check if NUMA distances definition is present */\n    if (!virXPathNode(\"./distances[1]\", ctxt))\n        return 0;\n\n    if ((sibling = virXPathNodeSet(\"./distances[1]/sibling\", ctxt, &nodes)) <= 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"NUMA distances defined without siblings\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < sibling; i++) {\n        virDomainNumaDistancePtr ldist, rdist;\n        unsigned int sibling_id, sibling_value;\n\n        /* siblings are in order of parsing or explicitly numbered */\n        if (!(tmp = virXMLPropString(nodes[i], \"id\"))) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing 'id' attribute in NUMA \"\n                             \"distances under 'cell id %d'\"),\n                           cur_cell);\n            goto cleanup;\n        }\n\n        /* The \"id\" needs to be applicable */\n        if (virStrToLong_uip(tmp, NULL, 10, &sibling_id) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid 'id' attribute in NUMA \"\n                             \"distances for sibling: '%s'\"),\n                           tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        /* The \"id\" needs to be within numa/cell range */\n        if (sibling_id >= ndistances) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"'sibling_id %d' does not refer to a \"\n                             \"valid cell within NUMA 'cell id %d'\"),\n                           sibling_id, cur_cell);\n            goto cleanup;\n        }\n\n        /* We need a locality value. Check and correct\n         * distance to local and distance to remote node.\n         */\n        if (!(tmp = virXMLPropString(nodes[i], \"value\"))) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing 'value' attribute in NUMA distances \"\n                             \"under 'cell id %d' for 'sibling id %d'\"),\n                           cur_cell, sibling_id);\n            goto cleanup;\n        }\n\n        /* The \"value\" needs to be applicable */\n        if (virStrToLong_uip(tmp, NULL, 10, &sibling_value) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"'value %s' is invalid for \"\n                             \"'sibling id %d' under NUMA 'cell id %d'\"),\n                           tmp, sibling_id, cur_cell);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        /* Assure LOCAL_DISTANCE <= \"value\" <= UNREACHABLE\n         * and correct LOCAL_DISTANCE setting if such applies.\n         */\n        if ((sibling_value < LOCAL_DISTANCE ||\n             sibling_value > UNREACHABLE) ||\n            (sibling_id == cur_cell &&\n             sibling_value != LOCAL_DISTANCE) ||\n            (sibling_id != cur_cell &&\n             sibling_value == LOCAL_DISTANCE)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"'value %d' is invalid for \"\n                             \"'sibling id %d' under NUMA 'cell id %d'\"),\n                           sibling_value, sibling_id, cur_cell);\n            goto cleanup;\n        }\n\n        /* Apply the local / remote distance */\n        ldist = def->mem_nodes[cur_cell].distances;\n        if (!ldist) {\n            if (VIR_ALLOC_N(ldist, ndistances) < 0)\n                goto cleanup;\n\n            ldist[cur_cell].value = LOCAL_DISTANCE;\n            ldist[cur_cell].cellid = cur_cell;\n            def->mem_nodes[cur_cell].ndistances = ndistances;\n            def->mem_nodes[cur_cell].distances = ldist;\n        }\n\n        ldist[sibling_id].cellid = sibling_id;\n        ldist[sibling_id].value = sibling_value;\n\n        /* Apply symmetry if none given */\n        rdist = def->mem_nodes[sibling_id].distances;\n        if (!rdist) {\n            if (VIR_ALLOC_N(rdist, ndistances) < 0)\n                goto cleanup;\n\n            rdist[sibling_id].value = LOCAL_DISTANCE;\n            rdist[sibling_id].cellid = sibling_id;\n            def->mem_nodes[sibling_id].ndistances = ndistances;\n            def->mem_nodes[sibling_id].distances = rdist;\n        }\n\n        rdist[cur_cell].cellid = cur_cell;\n        if (!rdist[cur_cell].value)\n            rdist[cur_cell].value = sibling_value;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        for (i = 0; i < ndistances; i++)\n            VIR_FREE(def->mem_nodes[i].distances);\n        def->mem_nodes[i].ndistances = 0;\n    }\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Invalid 'discard' attribute value '%s'\")",
            "tmp"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid 'discard' attribute value '%s'\""
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "nodes[i]",
            "\"discard\""
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Invalid 'memAccess' attribute value '%s'\")",
            "tmp"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainMemoryAccessTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainParseMemory",
          "args": [
            "\"./@memory\"",
            "\"./@unit\"",
            "ctxt",
            "&def->mem_nodes[cur_cell].mem",
            "true",
            "false"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainParseMemory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10825-10849",
          "snippet": "int\nvirDomainParseMemory(const char *xpath,\n                     const char *units_xpath,\n                     xmlXPathContextPtr ctxt,\n                     unsigned long long *mem,\n                     bool required,\n                     bool capped)\n{\n    unsigned long long bytes, max;\n\n    max = virMemoryMaxValue(capped);\n\n    if (virDomainParseScaledValue(xpath, units_xpath, ctxt,\n                                  &bytes, 1024, max, required) < 0)\n        return -1;\n\n    /* Yes, we really do use kibibytes for our internal sizing.  */\n    *mem = VIR_DIV_UP(bytes, 1024);\n\n    if (*mem >= VIR_DIV_UP(max, 1024)) {\n        virReportError(VIR_ERR_OVERFLOW, \"%s\", _(\"size value too large\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainParseMemory(const char *xpath,\n                     const char *units_xpath,\n                     xmlXPathContextPtr ctxt,\n                     unsigned long long *mem,\n                     bool required,\n                     bool capped)\n{\n    unsigned long long bytes, max;\n\n    max = virMemoryMaxValue(capped);\n\n    if (virDomainParseScaledValue(xpath, units_xpath, ctxt,\n                                  &bytes, 1024, max, required) < 0)\n        return -1;\n\n    /* Yes, we really do use kibibytes for our internal sizing.  */\n    *mem = VIR_DIV_UP(bytes, 1024);\n\n    if (*mem >= VIR_DIV_UP(max, 1024)) {\n        virReportError(VIR_ERR_OVERFLOW, \"%s\", _(\"size value too large\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"NUMA cells %u and %zu have overlapping vCPU ids\")",
            "cur_cell",
            "j"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapOverlaps",
          "args": [
            "def->mem_nodes[j].cpumask",
            "def->mem_nodes[cur_cell].cpumask"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapOverlaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1202-1220",
          "snippet": "bool\nvirBitmapOverlaps(virBitmapPtr b1,\n                  virBitmapPtr b2)\n{\n    size_t i;\n\n    if (b1->nbits > b2->nbits) {\n        virBitmapPtr tmp = b1;\n        b1 = b2;\n        b2 = tmp;\n    }\n\n    for (i = 0; i < b1->map_len; i++) {\n        if (b1->map[i] & b2->map[i])\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapOverlaps(virBitmapPtr b1,\n                  virBitmapPtr b2)\n{\n    size_t i;\n\n    if (b1->nbits > b2->nbits) {\n        virBitmapPtr tmp = b1;\n        b1 = b2;\n        b2 = tmp;\n    }\n\n    for (i = 0; i < b1->map_len; i++) {\n        if (b1->map[i] & b2->map[i])\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"NUMA cell %d has no vCPUs assigned\")",
            "cur_cell"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapIsAllClear",
          "args": [
            "def->mem_nodes[cur_cell].cpumask"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapIsAllClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "962-972",
          "snippet": "bool\nvirBitmapIsAllClear(virBitmapPtr bitmap)\n{\n    size_t i;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        if (bitmap->map[i] != 0)\n            return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapIsAllClear(virBitmapPtr bitmap)\n{\n    size_t i;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        if (bitmap->map[i] != 0)\n            return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapParse",
          "args": [
            "tmp",
            "&def->mem_nodes[cur_cell].cpumask",
            "VIR_DOMAIN_CPUMASK_LEN"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "581-587",
          "snippet": "int\nvirBitmapParse(const char *str,\n               virBitmapPtr *bitmap,\n               size_t bitmapSize)\n{\n    return virBitmapParseSeparator(str, '\\0', bitmap, bitmapSize);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapParse(const char *str,\n               virBitmapPtr *bitmap,\n               size_t bitmapSize)\n{\n    return virBitmapParseSeparator(str, '\\0', bitmap, bitmapSize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing 'cpus' attribute in NUMA cell\")"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Duplicate NUMA cell info for cell id '%u'\")",
            "cur_cell"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Exactly one 'cell' element per guest \"\n                                 \"NUMA cell allowed, non-contiguous ranges or \"\n                                 \"ranges not starting from 0 are not allowed\")"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid 'id' attribute in NUMA cell: '%s'\")",
            "tmp"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_uip",
          "args": [
            "tmp",
            "NULL",
            "10",
            "&cur_cell"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->mem_nodes",
            "n"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"NUMA topology defined without NUMA cells\")"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./cpu/numa[1]/cell\"",
            "ctxt",
            "&nodes"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./cpu/numa[1]\"",
            "ctxt"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nint\nvirDomainNumaDefCPUParseXML(virDomainNumaPtr def,\n                            xmlXPathContextPtr ctxt)\n{\n    xmlNodePtr *nodes = NULL;\n    xmlNodePtr oldNode = ctxt->node;\n    char *tmp = NULL;\n    int n;\n    size_t i, j;\n    int ret = -1;\n\n    /* check if NUMA definition is present */\n    if (!virXPathNode(\"./cpu/numa[1]\", ctxt))\n        return 0;\n\n    if ((n = virXPathNodeSet(\"./cpu/numa[1]/cell\", ctxt, &nodes)) <= 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"NUMA topology defined without NUMA cells\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->mem_nodes, n) < 0)\n        goto cleanup;\n    def->nmem_nodes = n;\n\n    for (i = 0; i < n; i++) {\n        int rc;\n        unsigned int cur_cell = i;\n\n        /* cells are in order of parsing or explicitly numbered */\n        if ((tmp = virXMLPropString(nodes[i], \"id\"))) {\n            if (virStrToLong_uip(tmp, NULL, 10, &cur_cell) < 0) {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"Invalid 'id' attribute in NUMA cell: '%s'\"),\n                               tmp);\n                goto cleanup;\n            }\n\n            if (cur_cell >= n) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Exactly one 'cell' element per guest \"\n                                 \"NUMA cell allowed, non-contiguous ranges or \"\n                                 \"ranges not starting from 0 are not allowed\"));\n                goto cleanup;\n            }\n        }\n        VIR_FREE(tmp);\n\n        if (def->mem_nodes[cur_cell].cpumask) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Duplicate NUMA cell info for cell id '%u'\"),\n                           cur_cell);\n            goto cleanup;\n        }\n\n        if (!(tmp = virXMLPropString(nodes[i], \"cpus\"))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing 'cpus' attribute in NUMA cell\"));\n            goto cleanup;\n        }\n\n        if (virBitmapParse(tmp, &def->mem_nodes[cur_cell].cpumask,\n                           VIR_DOMAIN_CPUMASK_LEN) < 0)\n            goto cleanup;\n\n        if (virBitmapIsAllClear(def->mem_nodes[cur_cell].cpumask)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                          _(\"NUMA cell %d has no vCPUs assigned\"), cur_cell);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        for (j = 0; j < n; j++) {\n            if (j == cur_cell || !def->mem_nodes[j].cpumask)\n                continue;\n\n            if (virBitmapOverlaps(def->mem_nodes[j].cpumask,\n                                  def->mem_nodes[cur_cell].cpumask)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"NUMA cells %u and %zu have overlapping vCPU ids\"),\n                               cur_cell, j);\n                goto cleanup;\n            }\n        }\n\n        ctxt->node = nodes[i];\n        if (virDomainParseMemory(\"./@memory\", \"./@unit\", ctxt,\n                                 &def->mem_nodes[cur_cell].mem, true, false) < 0)\n            goto cleanup;\n\n        if ((tmp = virXMLPropString(nodes[i], \"memAccess\"))) {\n            if ((rc = virDomainMemoryAccessTypeFromString(tmp)) <= 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid 'memAccess' attribute value '%s'\"),\n                               tmp);\n                goto cleanup;\n            }\n\n            def->mem_nodes[cur_cell].memAccess = rc;\n            VIR_FREE(tmp);\n        }\n\n        if ((tmp = virXMLPropString(nodes[i], \"discard\"))) {\n            if ((rc = virTristateBoolTypeFromString(tmp)) <= 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid 'discard' attribute value '%s'\"),\n                               tmp);\n                goto cleanup;\n            }\n\n            def->mem_nodes[cur_cell].discard = rc;\n            VIR_FREE(tmp);\n        }\n\n        /* Parse NUMA distances info */\n        if (virDomainNumaDefNodeDistanceParseXML(def, ctxt, cur_cell) < 0)\n                goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    ctxt->node = oldNode;\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n    return ret;\n}"
  },
  {
    "function_name": "virDomainNumaDefNodeDistanceParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "705-842",
    "snippet": "static int\nvirDomainNumaDefNodeDistanceParseXML(virDomainNumaPtr def,\n                                     xmlXPathContextPtr ctxt,\n                                     unsigned int cur_cell)\n{\n    int ret = -1;\n    int sibling;\n    char *tmp = NULL;\n    xmlNodePtr *nodes = NULL;\n    size_t i, ndistances = def->nmem_nodes;\n\n    if (ndistances == 0)\n        return 0;\n\n    /* check if NUMA distances definition is present */\n    if (!virXPathNode(\"./distances[1]\", ctxt))\n        return 0;\n\n    if ((sibling = virXPathNodeSet(\"./distances[1]/sibling\", ctxt, &nodes)) <= 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"NUMA distances defined without siblings\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < sibling; i++) {\n        virDomainNumaDistancePtr ldist, rdist;\n        unsigned int sibling_id, sibling_value;\n\n        /* siblings are in order of parsing or explicitly numbered */\n        if (!(tmp = virXMLPropString(nodes[i], \"id\"))) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing 'id' attribute in NUMA \"\n                             \"distances under 'cell id %d'\"),\n                           cur_cell);\n            goto cleanup;\n        }\n\n        /* The \"id\" needs to be applicable */\n        if (virStrToLong_uip(tmp, NULL, 10, &sibling_id) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid 'id' attribute in NUMA \"\n                             \"distances for sibling: '%s'\"),\n                           tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        /* The \"id\" needs to be within numa/cell range */\n        if (sibling_id >= ndistances) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"'sibling_id %d' does not refer to a \"\n                             \"valid cell within NUMA 'cell id %d'\"),\n                           sibling_id, cur_cell);\n            goto cleanup;\n        }\n\n        /* We need a locality value. Check and correct\n         * distance to local and distance to remote node.\n         */\n        if (!(tmp = virXMLPropString(nodes[i], \"value\"))) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing 'value' attribute in NUMA distances \"\n                             \"under 'cell id %d' for 'sibling id %d'\"),\n                           cur_cell, sibling_id);\n            goto cleanup;\n        }\n\n        /* The \"value\" needs to be applicable */\n        if (virStrToLong_uip(tmp, NULL, 10, &sibling_value) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"'value %s' is invalid for \"\n                             \"'sibling id %d' under NUMA 'cell id %d'\"),\n                           tmp, sibling_id, cur_cell);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        /* Assure LOCAL_DISTANCE <= \"value\" <= UNREACHABLE\n         * and correct LOCAL_DISTANCE setting if such applies.\n         */\n        if ((sibling_value < LOCAL_DISTANCE ||\n             sibling_value > UNREACHABLE) ||\n            (sibling_id == cur_cell &&\n             sibling_value != LOCAL_DISTANCE) ||\n            (sibling_id != cur_cell &&\n             sibling_value == LOCAL_DISTANCE)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"'value %d' is invalid for \"\n                             \"'sibling id %d' under NUMA 'cell id %d'\"),\n                           sibling_value, sibling_id, cur_cell);\n            goto cleanup;\n        }\n\n        /* Apply the local / remote distance */\n        ldist = def->mem_nodes[cur_cell].distances;\n        if (!ldist) {\n            if (VIR_ALLOC_N(ldist, ndistances) < 0)\n                goto cleanup;\n\n            ldist[cur_cell].value = LOCAL_DISTANCE;\n            ldist[cur_cell].cellid = cur_cell;\n            def->mem_nodes[cur_cell].ndistances = ndistances;\n            def->mem_nodes[cur_cell].distances = ldist;\n        }\n\n        ldist[sibling_id].cellid = sibling_id;\n        ldist[sibling_id].value = sibling_value;\n\n        /* Apply symmetry if none given */\n        rdist = def->mem_nodes[sibling_id].distances;\n        if (!rdist) {\n            if (VIR_ALLOC_N(rdist, ndistances) < 0)\n                goto cleanup;\n\n            rdist[sibling_id].value = LOCAL_DISTANCE;\n            rdist[sibling_id].cellid = sibling_id;\n            def->mem_nodes[sibling_id].ndistances = ndistances;\n            def->mem_nodes[sibling_id].distances = rdist;\n        }\n\n        rdist[cur_cell].cellid = cur_cell;\n        if (!rdist[cur_cell].value)\n            rdist[cur_cell].value = sibling_value;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        for (i = 0; i < ndistances; i++)\n            VIR_FREE(def->mem_nodes[i].distances);\n        def->mem_nodes[i].ndistances = 0;\n    }\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define UNREACHABLE            255",
      "#define LOCAL_DISTANCE          10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->mem_nodes[i].distances"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "rdist",
            "ndistances"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ldist",
            "ndistances"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"'value %d' is invalid for \"\n                             \"'sibling id %d' under NUMA 'cell id %d'\")",
            "sibling_value",
            "sibling_id",
            "cur_cell"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"'value %d' is invalid for \"\n                             \"'sibling id %d' under NUMA 'cell id %d'\""
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"'value %s' is invalid for \"\n                             \"'sibling id %d' under NUMA 'cell id %d'\")",
            "tmp",
            "sibling_id",
            "cur_cell"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_uip",
          "args": [
            "tmp",
            "NULL",
            "10",
            "&sibling_value"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Missing 'value' attribute in NUMA distances \"\n                             \"under 'cell id %d' for 'sibling id %d'\")",
            "cur_cell",
            "sibling_id"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "nodes[i]",
            "\"value\""
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"'sibling_id %d' does not refer to a \"\n                             \"valid cell within NUMA 'cell id %d'\")",
            "sibling_id",
            "cur_cell"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid 'id' attribute in NUMA \"\n                             \"distances for sibling: '%s'\")",
            "tmp"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Missing 'id' attribute in NUMA \"\n                             \"distances under 'cell id %d'\")",
            "cur_cell"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"NUMA distances defined without siblings\")"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./distances[1]/sibling\"",
            "ctxt",
            "&nodes"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./distances[1]\"",
            "ctxt"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\n#define UNREACHABLE            255\n#define LOCAL_DISTANCE          10\n\nstatic int\nvirDomainNumaDefNodeDistanceParseXML(virDomainNumaPtr def,\n                                     xmlXPathContextPtr ctxt,\n                                     unsigned int cur_cell)\n{\n    int ret = -1;\n    int sibling;\n    char *tmp = NULL;\n    xmlNodePtr *nodes = NULL;\n    size_t i, ndistances = def->nmem_nodes;\n\n    if (ndistances == 0)\n        return 0;\n\n    /* check if NUMA distances definition is present */\n    if (!virXPathNode(\"./distances[1]\", ctxt))\n        return 0;\n\n    if ((sibling = virXPathNodeSet(\"./distances[1]/sibling\", ctxt, &nodes)) <= 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"NUMA distances defined without siblings\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < sibling; i++) {\n        virDomainNumaDistancePtr ldist, rdist;\n        unsigned int sibling_id, sibling_value;\n\n        /* siblings are in order of parsing or explicitly numbered */\n        if (!(tmp = virXMLPropString(nodes[i], \"id\"))) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing 'id' attribute in NUMA \"\n                             \"distances under 'cell id %d'\"),\n                           cur_cell);\n            goto cleanup;\n        }\n\n        /* The \"id\" needs to be applicable */\n        if (virStrToLong_uip(tmp, NULL, 10, &sibling_id) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid 'id' attribute in NUMA \"\n                             \"distances for sibling: '%s'\"),\n                           tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        /* The \"id\" needs to be within numa/cell range */\n        if (sibling_id >= ndistances) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"'sibling_id %d' does not refer to a \"\n                             \"valid cell within NUMA 'cell id %d'\"),\n                           sibling_id, cur_cell);\n            goto cleanup;\n        }\n\n        /* We need a locality value. Check and correct\n         * distance to local and distance to remote node.\n         */\n        if (!(tmp = virXMLPropString(nodes[i], \"value\"))) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Missing 'value' attribute in NUMA distances \"\n                             \"under 'cell id %d' for 'sibling id %d'\"),\n                           cur_cell, sibling_id);\n            goto cleanup;\n        }\n\n        /* The \"value\" needs to be applicable */\n        if (virStrToLong_uip(tmp, NULL, 10, &sibling_value) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"'value %s' is invalid for \"\n                             \"'sibling id %d' under NUMA 'cell id %d'\"),\n                           tmp, sibling_id, cur_cell);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        /* Assure LOCAL_DISTANCE <= \"value\" <= UNREACHABLE\n         * and correct LOCAL_DISTANCE setting if such applies.\n         */\n        if ((sibling_value < LOCAL_DISTANCE ||\n             sibling_value > UNREACHABLE) ||\n            (sibling_id == cur_cell &&\n             sibling_value != LOCAL_DISTANCE) ||\n            (sibling_id != cur_cell &&\n             sibling_value == LOCAL_DISTANCE)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"'value %d' is invalid for \"\n                             \"'sibling id %d' under NUMA 'cell id %d'\"),\n                           sibling_value, sibling_id, cur_cell);\n            goto cleanup;\n        }\n\n        /* Apply the local / remote distance */\n        ldist = def->mem_nodes[cur_cell].distances;\n        if (!ldist) {\n            if (VIR_ALLOC_N(ldist, ndistances) < 0)\n                goto cleanup;\n\n            ldist[cur_cell].value = LOCAL_DISTANCE;\n            ldist[cur_cell].cellid = cur_cell;\n            def->mem_nodes[cur_cell].ndistances = ndistances;\n            def->mem_nodes[cur_cell].distances = ldist;\n        }\n\n        ldist[sibling_id].cellid = sibling_id;\n        ldist[sibling_id].value = sibling_value;\n\n        /* Apply symmetry if none given */\n        rdist = def->mem_nodes[sibling_id].distances;\n        if (!rdist) {\n            if (VIR_ALLOC_N(rdist, ndistances) < 0)\n                goto cleanup;\n\n            rdist[sibling_id].value = LOCAL_DISTANCE;\n            rdist[sibling_id].cellid = sibling_id;\n            def->mem_nodes[sibling_id].ndistances = ndistances;\n            def->mem_nodes[sibling_id].distances = rdist;\n        }\n\n        rdist[cur_cell].cellid = cur_cell;\n        if (!rdist[cur_cell].value)\n            rdist[cur_cell].value = sibling_value;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        for (i = 0; i < ndistances; i++)\n            VIR_FREE(def->mem_nodes[i].distances);\n        def->mem_nodes[i].ndistances = 0;\n    }\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n\n    return ret;\n}"
  },
  {
    "function_name": "virDomainNumatuneNodesetIsAvailable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "681-702",
    "snippet": "bool\nvirDomainNumatuneNodesetIsAvailable(virDomainNumaPtr numatune,\n                                    virBitmapPtr auto_nodeset)\n{\n    size_t i = 0;\n    virBitmapPtr b = NULL;\n\n    if (!numatune)\n        return true;\n\n    b = virDomainNumatuneGetNodeset(numatune, auto_nodeset, -1);\n    if (!virNumaNodesetIsAvailable(b))\n        return false;\n\n    for (i = 0; i < numatune->nmem_nodes; i++) {\n        b = virDomainNumatuneGetNodeset(numatune, auto_nodeset, i);\n        if (!virNumaNodesetIsAvailable(b))\n            return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNumaNodesetIsAvailable",
          "args": [
            "b"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaNodesetIsAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "993-1010",
          "snippet": "bool\nvirNumaNodesetIsAvailable(virBitmapPtr nodeset)\n{\n    ssize_t bit = -1;\n\n    if (!nodeset)\n        return true;\n\n    while ((bit = virBitmapNextSetBit(nodeset, bit)) >= 0) {\n        if (virNumaNodeIsAvailable(bit))\n            continue;\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"NUMA node %zd is unavailable\"), bit);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaNodesetIsAvailable(virBitmapPtr nodeset)\n{\n    ssize_t bit = -1;\n\n    if (!nodeset)\n        return true;\n\n    while ((bit = virBitmapNextSetBit(nodeset, bit)) >= 0) {\n        if (virNumaNodeIsAvailable(bit))\n            continue;\n\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"NUMA node %zd is unavailable\"), bit);\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumatuneGetNodeset",
          "args": [
            "numatune",
            "auto_nodeset",
            "i"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumatuneGetNodeset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "411-430",
          "snippet": "virBitmapPtr\nvirDomainNumatuneGetNodeset(virDomainNumaPtr numatune,\n                            virBitmapPtr auto_nodeset,\n                            int cellid)\n{\n    if (!numatune)\n        return NULL;\n\n    if (numatune->memory.specified &&\n        numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO)\n        return auto_nodeset;\n\n    if (virDomainNumatuneNodeSpecified(numatune, cellid))\n        return numatune->mem_nodes[cellid].nodeset;\n\n    if (!numatune->memory.specified)\n        return NULL;\n\n    return numatune->memory.nodeset;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirBitmapPtr\nvirDomainNumatuneGetNodeset(virDomainNumaPtr numatune,\n                            virBitmapPtr auto_nodeset,\n                            int cellid)\n{\n    if (!numatune)\n        return NULL;\n\n    if (numatune->memory.specified &&\n        numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO)\n        return auto_nodeset;\n\n    if (virDomainNumatuneNodeSpecified(numatune, cellid))\n        return numatune->mem_nodes[cellid].nodeset;\n\n    if (!numatune->memory.specified)\n        return NULL;\n\n    return numatune->memory.nodeset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nbool\nvirDomainNumatuneNodesetIsAvailable(virDomainNumaPtr numatune,\n                                    virBitmapPtr auto_nodeset)\n{\n    size_t i = 0;\n    virBitmapPtr b = NULL;\n\n    if (!numatune)\n        return true;\n\n    b = virDomainNumatuneGetNodeset(numatune, auto_nodeset, -1);\n    if (!virNumaNodesetIsAvailable(b))\n        return false;\n\n    for (i = 0; i < numatune->nmem_nodes; i++) {\n        b = virDomainNumatuneGetNodeset(numatune, auto_nodeset, i);\n        if (!virNumaNodesetIsAvailable(b))\n            return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "virDomainNumatuneSpecifiedMaxNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "653-679",
    "snippet": "int\nvirDomainNumatuneSpecifiedMaxNode(virDomainNumaPtr numatune)\n{\n    int ret = -1;\n    virBitmapPtr nodemask = NULL;\n    size_t i;\n    int bit;\n\n    if (!numatune)\n        return ret;\n\n    nodemask = virDomainNumatuneGetNodeset(numatune, NULL, -1);\n    if (nodemask)\n        ret = virBitmapLastSetBit(nodemask);\n\n    for (i = 0; i < numatune->nmem_nodes; i++) {\n        nodemask = numatune->mem_nodes[i].nodeset;\n        if (!nodemask)\n            continue;\n\n        bit = virBitmapLastSetBit(nodemask);\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapLastSetBit",
          "args": [
            "nodemask"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapLastSetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1025-1064",
          "snippet": "ssize_t\nvirBitmapLastSetBit(virBitmapPtr bitmap)\n{\n    ssize_t i;\n    int unusedBits;\n    ssize_t sz;\n    unsigned long bits;\n\n    /* If bitmap is empty then there is no set bit */\n    if (bitmap->map_len == 0)\n        return -1;\n\n    unusedBits = bitmap->map_len * VIR_BITMAP_BITS_PER_UNIT - bitmap->nbits;\n\n    sz = bitmap->map_len - 1;\n    if (unusedBits > 0) {\n        bits = bitmap->map[sz] & (VIR_BITMAP_BIT(VIR_BITMAP_BITS_PER_UNIT - unusedBits) - 1);\n        if (bits != 0)\n            goto found;\n\n        sz--;\n    }\n\n    for (; sz >= 0; sz--) {\n        bits = bitmap->map[sz];\n        if (bits != 0)\n            goto found;\n    }\n\n    /* Only reached if no set bit was found */\n    return -1;\n\n found:\n    for (i = VIR_BITMAP_BITS_PER_UNIT - 1; i >= 0; i--) {\n        if (bits & 1UL << i)\n            return i + sz * VIR_BITMAP_BITS_PER_UNIT;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapLastSetBit(virBitmapPtr bitmap)\n{\n    ssize_t i;\n    int unusedBits;\n    ssize_t sz;\n    unsigned long bits;\n\n    /* If bitmap is empty then there is no set bit */\n    if (bitmap->map_len == 0)\n        return -1;\n\n    unusedBits = bitmap->map_len * VIR_BITMAP_BITS_PER_UNIT - bitmap->nbits;\n\n    sz = bitmap->map_len - 1;\n    if (unusedBits > 0) {\n        bits = bitmap->map[sz] & (VIR_BITMAP_BIT(VIR_BITMAP_BITS_PER_UNIT - unusedBits) - 1);\n        if (bits != 0)\n            goto found;\n\n        sz--;\n    }\n\n    for (; sz >= 0; sz--) {\n        bits = bitmap->map[sz];\n        if (bits != 0)\n            goto found;\n    }\n\n    /* Only reached if no set bit was found */\n    return -1;\n\n found:\n    for (i = VIR_BITMAP_BITS_PER_UNIT - 1; i >= 0; i--) {\n        if (bits & 1UL << i)\n            return i + sz * VIR_BITMAP_BITS_PER_UNIT;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumatuneGetNodeset",
          "args": [
            "numatune",
            "NULL",
            "-1"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumatuneGetNodeset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "411-430",
          "snippet": "virBitmapPtr\nvirDomainNumatuneGetNodeset(virDomainNumaPtr numatune,\n                            virBitmapPtr auto_nodeset,\n                            int cellid)\n{\n    if (!numatune)\n        return NULL;\n\n    if (numatune->memory.specified &&\n        numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO)\n        return auto_nodeset;\n\n    if (virDomainNumatuneNodeSpecified(numatune, cellid))\n        return numatune->mem_nodes[cellid].nodeset;\n\n    if (!numatune->memory.specified)\n        return NULL;\n\n    return numatune->memory.nodeset;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirBitmapPtr\nvirDomainNumatuneGetNodeset(virDomainNumaPtr numatune,\n                            virBitmapPtr auto_nodeset,\n                            int cellid)\n{\n    if (!numatune)\n        return NULL;\n\n    if (numatune->memory.specified &&\n        numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO)\n        return auto_nodeset;\n\n    if (virDomainNumatuneNodeSpecified(numatune, cellid))\n        return numatune->mem_nodes[cellid].nodeset;\n\n    if (!numatune->memory.specified)\n        return NULL;\n\n    return numatune->memory.nodeset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nint\nvirDomainNumatuneSpecifiedMaxNode(virDomainNumaPtr numatune)\n{\n    int ret = -1;\n    virBitmapPtr nodemask = NULL;\n    size_t i;\n    int bit;\n\n    if (!numatune)\n        return ret;\n\n    nodemask = virDomainNumatuneGetNodeset(numatune, NULL, -1);\n    if (nodemask)\n        ret = virBitmapLastSetBit(nodemask);\n\n    for (i = 0; i < numatune->nmem_nodes; i++) {\n        nodemask = numatune->mem_nodes[i].nodeset;\n        if (!nodemask)\n            continue;\n\n        bit = virBitmapLastSetBit(nodemask);\n        if (bit > ret)\n            ret = bit;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virDomainNumatuneHasPerNodeBinding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "637-651",
    "snippet": "bool\nvirDomainNumatuneHasPerNodeBinding(virDomainNumaPtr numatune)\n{\n    size_t i = 0;\n\n    if (!numatune)\n        return false;\n\n    for (i = 0; i < numatune->nmem_nodes; i++) {\n        if (numatune->mem_nodes[i].nodeset)\n            return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nbool\nvirDomainNumatuneHasPerNodeBinding(virDomainNumaPtr numatune)\n{\n    size_t i = 0;\n\n    if (!numatune)\n        return false;\n\n    for (i = 0; i < numatune->nmem_nodes; i++) {\n        if (numatune->mem_nodes[i].nodeset)\n            return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virDomainNumatuneHasPlacementAuto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "622-635",
    "snippet": "bool\nvirDomainNumatuneHasPlacementAuto(virDomainNumaPtr numatune)\n{\n    if (!numatune)\n        return false;\n\n    if (!numatune->memory.specified)\n        return false;\n\n    if (numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO)\n        return true;\n\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nbool\nvirDomainNumatuneHasPlacementAuto(virDomainNumaPtr numatune)\n{\n    if (!numatune)\n        return false;\n\n    if (!numatune->memory.specified)\n        return false;\n\n    if (numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO)\n        return true;\n\n    return false;\n}"
  },
  {
    "function_name": "virDomainNumaEquals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "594-620",
    "snippet": "bool\nvirDomainNumaEquals(virDomainNumaPtr n1,\n                    virDomainNumaPtr n2)\n{\n    if (!n1 && !n2)\n        return true;\n\n    if (!n1 || !n2)\n        return false;\n\n    if (!n1->memory.specified && !n2->memory.specified)\n        return virDomainNumaNodesEqual(n1, n2);\n\n    if (!n1->memory.specified || !n2->memory.specified)\n        return false;\n\n    if (n1->memory.mode != n2->memory.mode)\n        return false;\n\n    if (n1->memory.placement != n2->memory.placement)\n        return false;\n\n    if (!virBitmapEqual(n1->memory.nodeset, n2->memory.nodeset))\n        return false;\n\n    return virDomainNumaNodesEqual(n1, n2);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainNumaNodesEqual",
          "args": [
            "n1",
            "n2"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumaNodesEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "568-592",
          "snippet": "static bool\nvirDomainNumaNodesEqual(virDomainNumaPtr n1,\n                        virDomainNumaPtr n2)\n{\n    size_t i = 0;\n\n    if (n1->nmem_nodes != n2->nmem_nodes)\n        return false;\n\n    for (i = 0; i < n1->nmem_nodes; i++) {\n        virDomainNumaNodePtr nd1 = &n1->mem_nodes[i];\n        virDomainNumaNodePtr nd2 = &n2->mem_nodes[i];\n\n        if (!nd1->nodeset && !nd2->nodeset)\n            continue;\n\n        if (nd1->mode != nd2->mode)\n            return false;\n\n        if (!virBitmapEqual(nd1->nodeset, nd2->nodeset))\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nstatic bool\nvirDomainNumaNodesEqual(virDomainNumaPtr n1,\n                        virDomainNumaPtr n2)\n{\n    size_t i = 0;\n\n    if (n1->nmem_nodes != n2->nmem_nodes)\n        return false;\n\n    for (i = 0; i < n1->nmem_nodes; i++) {\n        virDomainNumaNodePtr nd1 = &n1->mem_nodes[i];\n        virDomainNumaNodePtr nd2 = &n2->mem_nodes[i];\n\n        if (!nd1->nodeset && !nd2->nodeset)\n            continue;\n\n        if (nd1->mode != nd2->mode)\n            return false;\n\n        if (!virBitmapEqual(nd1->nodeset, nd2->nodeset))\n            return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapEqual",
          "args": [
            "n1->memory.nodeset",
            "n2->memory.nodeset"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "841-873",
          "snippet": "bool\nvirBitmapEqual(virBitmapPtr b1,\n               virBitmapPtr b2)\n{\n    virBitmapPtr tmp;\n    size_t i;\n\n    if (!b1 && !b2)\n        return true;\n\n    if (!b1 || !b2)\n        return false;\n\n    if (b1->nbits > b2->nbits) {\n        tmp = b1;\n        b1 = b2;\n        b2 = tmp;\n    }\n\n    /* Now b1 is the smaller one, if not equal */\n\n    for (i = 0; i < b1->map_len; i++) {\n        if (b1->map[i] != b2->map[i])\n            return false;\n    }\n\n    for (; i < b2->map_len; i++) {\n        if (b2->map[i])\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapEqual(virBitmapPtr b1,\n               virBitmapPtr b2)\n{\n    virBitmapPtr tmp;\n    size_t i;\n\n    if (!b1 && !b2)\n        return true;\n\n    if (!b1 || !b2)\n        return false;\n\n    if (b1->nbits > b2->nbits) {\n        tmp = b1;\n        b1 = b2;\n        b2 = tmp;\n    }\n\n    /* Now b1 is the smaller one, if not equal */\n\n    for (i = 0; i < b1->map_len; i++) {\n        if (b1->map[i] != b2->map[i])\n            return false;\n    }\n\n    for (; i < b2->map_len; i++) {\n        if (b2->map[i])\n            return false;\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nbool\nvirDomainNumaEquals(virDomainNumaPtr n1,\n                    virDomainNumaPtr n2)\n{\n    if (!n1 && !n2)\n        return true;\n\n    if (!n1 || !n2)\n        return false;\n\n    if (!n1->memory.specified && !n2->memory.specified)\n        return virDomainNumaNodesEqual(n1, n2);\n\n    if (!n1->memory.specified || !n2->memory.specified)\n        return false;\n\n    if (n1->memory.mode != n2->memory.mode)\n        return false;\n\n    if (n1->memory.placement != n2->memory.placement)\n        return false;\n\n    if (!virBitmapEqual(n1->memory.nodeset, n2->memory.nodeset))\n        return false;\n\n    return virDomainNumaNodesEqual(n1, n2);\n}"
  },
  {
    "function_name": "virDomainNumaNodesEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "568-592",
    "snippet": "static bool\nvirDomainNumaNodesEqual(virDomainNumaPtr n1,\n                        virDomainNumaPtr n2)\n{\n    size_t i = 0;\n\n    if (n1->nmem_nodes != n2->nmem_nodes)\n        return false;\n\n    for (i = 0; i < n1->nmem_nodes; i++) {\n        virDomainNumaNodePtr nd1 = &n1->mem_nodes[i];\n        virDomainNumaNodePtr nd2 = &n2->mem_nodes[i];\n\n        if (!nd1->nodeset && !nd2->nodeset)\n            continue;\n\n        if (nd1->mode != nd2->mode)\n            return false;\n\n        if (!virBitmapEqual(nd1->nodeset, nd2->nodeset))\n            return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapEqual",
          "args": [
            "nd1->nodeset",
            "nd2->nodeset"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "841-873",
          "snippet": "bool\nvirBitmapEqual(virBitmapPtr b1,\n               virBitmapPtr b2)\n{\n    virBitmapPtr tmp;\n    size_t i;\n\n    if (!b1 && !b2)\n        return true;\n\n    if (!b1 || !b2)\n        return false;\n\n    if (b1->nbits > b2->nbits) {\n        tmp = b1;\n        b1 = b2;\n        b2 = tmp;\n    }\n\n    /* Now b1 is the smaller one, if not equal */\n\n    for (i = 0; i < b1->map_len; i++) {\n        if (b1->map[i] != b2->map[i])\n            return false;\n    }\n\n    for (; i < b2->map_len; i++) {\n        if (b2->map[i])\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapEqual(virBitmapPtr b1,\n               virBitmapPtr b2)\n{\n    virBitmapPtr tmp;\n    size_t i;\n\n    if (!b1 && !b2)\n        return true;\n\n    if (!b1 || !b2)\n        return false;\n\n    if (b1->nbits > b2->nbits) {\n        tmp = b1;\n        b1 = b2;\n        b2 = tmp;\n    }\n\n    /* Now b1 is the smaller one, if not equal */\n\n    for (i = 0; i < b1->map_len; i++) {\n        if (b1->map[i] != b2->map[i])\n            return false;\n    }\n\n    for (; i < b2->map_len; i++) {\n        if (b2->map[i])\n            return false;\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nstatic bool\nvirDomainNumaNodesEqual(virDomainNumaPtr n1,\n                        virDomainNumaPtr n2)\n{\n    size_t i = 0;\n\n    if (n1->nmem_nodes != n2->nmem_nodes)\n        return false;\n\n    for (i = 0; i < n1->nmem_nodes; i++) {\n        virDomainNumaNodePtr nd1 = &n1->mem_nodes[i];\n        virDomainNumaNodePtr nd2 = &n2->mem_nodes[i];\n\n        if (!nd1->nodeset && !nd2->nodeset)\n            continue;\n\n        if (nd1->mode != nd2->mode)\n            return false;\n\n        if (!virBitmapEqual(nd1->nodeset, nd2->nodeset))\n            return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "virDomainNumatuneSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "492-566",
    "snippet": "int\nvirDomainNumatuneSet(virDomainNumaPtr numa,\n                     bool placement_static,\n                     int placement,\n                     int mode,\n                     virBitmapPtr nodeset)\n{\n    /* No need to do anything in this case */\n    if (mode == -1 && placement == -1 && !nodeset)\n        return 0;\n\n    if (!numa->memory.specified) {\n        if (mode == -1)\n            mode = VIR_DOMAIN_NUMATUNE_MEM_STRICT;\n        if (placement == -1)\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_DEFAULT;\n    }\n\n    /* Range checks */\n    if (mode != -1 &&\n        (mode < 0 || mode >= VIR_DOMAIN_NUMATUNE_MEM_LAST)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported numatune mode '%d'\"),\n                       mode);\n        return -1;\n    }\n\n    if (placement != -1 &&\n        (placement < 0 || placement >= VIR_DOMAIN_NUMATUNE_PLACEMENT_LAST)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported numatune placement '%d'\"),\n                       mode);\n        return -1;\n    }\n\n    if (mode != -1)\n        numa->memory.mode = mode;\n\n    if (nodeset) {\n        virBitmapFree(numa->memory.nodeset);\n        if (!(numa->memory.nodeset = virBitmapNewCopy(nodeset)))\n            return -1;\n        if (placement == -1)\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_STATIC;\n    }\n\n    if (placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_DEFAULT) {\n        if (numa->memory.nodeset || placement_static)\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_STATIC;\n        else\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO;\n    }\n\n    if (placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_STATIC &&\n        !numa->memory.nodeset) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"nodeset for NUMA memory tuning must be set \"\n                         \"if 'placement' is 'static'\"));\n        return -1;\n    }\n\n    /* setting nodeset when placement auto is invalid */\n    if (placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO &&\n        numa->memory.nodeset) {\n        virBitmapFree(numa->memory.nodeset);\n        numa->memory.nodeset = NULL;\n    }\n\n    if (placement != -1)\n        numa->memory.placement = placement;\n\n    numa->memory.specified = true;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "numa->memory.nodeset"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"nodeset for NUMA memory tuning must be set \"\n                         \"if 'placement' is 'static'\")"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"nodeset for NUMA memory tuning must be set \"\n                         \"if 'placement' is 'static'\""
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNewCopy",
          "args": [
            "nodeset"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "707-721",
          "snippet": "virBitmapPtr\nvirBitmapNewCopy(virBitmapPtr src)\n{\n    virBitmapPtr dst;\n\n    if ((dst = virBitmapNew(src->nbits)) == NULL)\n        return NULL;\n\n    if (virBitmapCopy(dst, src) != 0) {\n        virBitmapFree(dst);\n        return NULL;\n    }\n\n    return dst;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewCopy(virBitmapPtr src)\n{\n    virBitmapPtr dst;\n\n    if ((dst = virBitmapNew(src->nbits)) == NULL)\n        return NULL;\n\n    if (virBitmapCopy(dst, src) != 0) {\n        virBitmapFree(dst);\n        return NULL;\n    }\n\n    return dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported numatune placement '%d'\")",
            "mode"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported numatune mode '%d'\")",
            "mode"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nint\nvirDomainNumatuneSet(virDomainNumaPtr numa,\n                     bool placement_static,\n                     int placement,\n                     int mode,\n                     virBitmapPtr nodeset)\n{\n    /* No need to do anything in this case */\n    if (mode == -1 && placement == -1 && !nodeset)\n        return 0;\n\n    if (!numa->memory.specified) {\n        if (mode == -1)\n            mode = VIR_DOMAIN_NUMATUNE_MEM_STRICT;\n        if (placement == -1)\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_DEFAULT;\n    }\n\n    /* Range checks */\n    if (mode != -1 &&\n        (mode < 0 || mode >= VIR_DOMAIN_NUMATUNE_MEM_LAST)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported numatune mode '%d'\"),\n                       mode);\n        return -1;\n    }\n\n    if (placement != -1 &&\n        (placement < 0 || placement >= VIR_DOMAIN_NUMATUNE_PLACEMENT_LAST)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported numatune placement '%d'\"),\n                       mode);\n        return -1;\n    }\n\n    if (mode != -1)\n        numa->memory.mode = mode;\n\n    if (nodeset) {\n        virBitmapFree(numa->memory.nodeset);\n        if (!(numa->memory.nodeset = virBitmapNewCopy(nodeset)))\n            return -1;\n        if (placement == -1)\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_STATIC;\n    }\n\n    if (placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_DEFAULT) {\n        if (numa->memory.nodeset || placement_static)\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_STATIC;\n        else\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO;\n    }\n\n    if (placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_STATIC &&\n        !numa->memory.nodeset) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"nodeset for NUMA memory tuning must be set \"\n                         \"if 'placement' is 'static'\"));\n        return -1;\n    }\n\n    /* setting nodeset when placement auto is invalid */\n    if (placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO &&\n        numa->memory.nodeset) {\n        virBitmapFree(numa->memory.nodeset);\n        numa->memory.nodeset = NULL;\n    }\n\n    if (placement != -1)\n        numa->memory.placement = placement;\n\n    numa->memory.specified = true;\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainNumatuneMaybeFormatNodeset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "473-490",
    "snippet": "int\nvirDomainNumatuneMaybeFormatNodeset(virDomainNumaPtr numatune,\n                                    virBitmapPtr auto_nodeset,\n                                    char **mask,\n                                    int cellid)\n{\n    virBitmapPtr nodeset;\n\n    if (virDomainNumatuneMaybeGetNodeset(numatune, auto_nodeset, &nodeset,\n                                         cellid) < 0)\n        return -1;\n\n    if (nodeset &&\n        !(*mask = virBitmapFormat(nodeset)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFormat",
          "args": [
            "nodeset"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "404-442",
          "snippet": "char *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumatuneMaybeGetNodeset",
          "args": [
            "numatune",
            "auto_nodeset",
            "&nodeset",
            "cellid"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumatuneMaybeGetNodeset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "443-470",
          "snippet": "int\nvirDomainNumatuneMaybeGetNodeset(virDomainNumaPtr numatune,\n                                 virBitmapPtr auto_nodeset,\n                                 virBitmapPtr *retNodeset,\n                                 int cellid)\n{\n    *retNodeset = NULL;\n\n    if (!numatune)\n        return 0;\n\n    if (!virDomainNumatuneNodeSpecified(numatune, cellid) &&\n        !numatune->memory.specified)\n        return 0;\n\n    if (numatune->memory.specified &&\n        numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO &&\n        !auto_nodeset) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Advice from numad is needed in case of \"\n                         \"automatic numa placement\"));\n        return -1;\n    }\n\n    *retNodeset = virDomainNumatuneGetNodeset(numatune, auto_nodeset, cellid);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nint\nvirDomainNumatuneMaybeGetNodeset(virDomainNumaPtr numatune,\n                                 virBitmapPtr auto_nodeset,\n                                 virBitmapPtr *retNodeset,\n                                 int cellid)\n{\n    *retNodeset = NULL;\n\n    if (!numatune)\n        return 0;\n\n    if (!virDomainNumatuneNodeSpecified(numatune, cellid) &&\n        !numatune->memory.specified)\n        return 0;\n\n    if (numatune->memory.specified &&\n        numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO &&\n        !auto_nodeset) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Advice from numad is needed in case of \"\n                         \"automatic numa placement\"));\n        return -1;\n    }\n\n    *retNodeset = virDomainNumatuneGetNodeset(numatune, auto_nodeset, cellid);\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nint\nvirDomainNumatuneMaybeFormatNodeset(virDomainNumaPtr numatune,\n                                    virBitmapPtr auto_nodeset,\n                                    char **mask,\n                                    int cellid)\n{\n    virBitmapPtr nodeset;\n\n    if (virDomainNumatuneMaybeGetNodeset(numatune, auto_nodeset, &nodeset,\n                                         cellid) < 0)\n        return -1;\n\n    if (nodeset &&\n        !(*mask = virBitmapFormat(nodeset)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainNumatuneMaybeGetNodeset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "443-470",
    "snippet": "int\nvirDomainNumatuneMaybeGetNodeset(virDomainNumaPtr numatune,\n                                 virBitmapPtr auto_nodeset,\n                                 virBitmapPtr *retNodeset,\n                                 int cellid)\n{\n    *retNodeset = NULL;\n\n    if (!numatune)\n        return 0;\n\n    if (!virDomainNumatuneNodeSpecified(numatune, cellid) &&\n        !numatune->memory.specified)\n        return 0;\n\n    if (numatune->memory.specified &&\n        numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO &&\n        !auto_nodeset) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Advice from numad is needed in case of \"\n                         \"automatic numa placement\"));\n        return -1;\n    }\n\n    *retNodeset = virDomainNumatuneGetNodeset(numatune, auto_nodeset, cellid);\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainNumatuneGetNodeset",
          "args": [
            "numatune",
            "auto_nodeset",
            "cellid"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumatuneGetNodeset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "411-430",
          "snippet": "virBitmapPtr\nvirDomainNumatuneGetNodeset(virDomainNumaPtr numatune,\n                            virBitmapPtr auto_nodeset,\n                            int cellid)\n{\n    if (!numatune)\n        return NULL;\n\n    if (numatune->memory.specified &&\n        numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO)\n        return auto_nodeset;\n\n    if (virDomainNumatuneNodeSpecified(numatune, cellid))\n        return numatune->mem_nodes[cellid].nodeset;\n\n    if (!numatune->memory.specified)\n        return NULL;\n\n    return numatune->memory.nodeset;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirBitmapPtr\nvirDomainNumatuneGetNodeset(virDomainNumaPtr numatune,\n                            virBitmapPtr auto_nodeset,\n                            int cellid)\n{\n    if (!numatune)\n        return NULL;\n\n    if (numatune->memory.specified &&\n        numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO)\n        return auto_nodeset;\n\n    if (virDomainNumatuneNodeSpecified(numatune, cellid))\n        return numatune->mem_nodes[cellid].nodeset;\n\n    if (!numatune->memory.specified)\n        return NULL;\n\n    return numatune->memory.nodeset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Advice from numad is needed in case of \"\n                         \"automatic numa placement\")"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Advice from numad is needed in case of \"\n                         \"automatic numa placement\""
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumatuneNodeSpecified",
          "args": [
            "numatune",
            "cellid"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumatuneNodeSpecified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "96-106",
          "snippet": "bool\nvirDomainNumatuneNodeSpecified(virDomainNumaPtr numatune,\n                               int cellid)\n{\n    if (numatune &&\n        cellid >= 0 &&\n        cellid < numatune->nmem_nodes)\n        return numatune->mem_nodes[cellid].nodeset;\n\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nbool\nvirDomainNumatuneNodeSpecified(virDomainNumaPtr numatune,\n                               int cellid)\n{\n    if (numatune &&\n        cellid >= 0 &&\n        cellid < numatune->nmem_nodes)\n        return numatune->mem_nodes[cellid].nodeset;\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nint\nvirDomainNumatuneMaybeGetNodeset(virDomainNumaPtr numatune,\n                                 virBitmapPtr auto_nodeset,\n                                 virBitmapPtr *retNodeset,\n                                 int cellid)\n{\n    *retNodeset = NULL;\n\n    if (!numatune)\n        return 0;\n\n    if (!virDomainNumatuneNodeSpecified(numatune, cellid) &&\n        !numatune->memory.specified)\n        return 0;\n\n    if (numatune->memory.specified &&\n        numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO &&\n        !auto_nodeset) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Advice from numad is needed in case of \"\n                         \"automatic numa placement\"));\n        return -1;\n    }\n\n    *retNodeset = virDomainNumatuneGetNodeset(numatune, auto_nodeset, cellid);\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainNumatuneFormatNodeset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "432-440",
    "snippet": "char *\nvirDomainNumatuneFormatNodeset(virDomainNumaPtr numatune,\n                               virBitmapPtr auto_nodeset,\n                               int cellid)\n{\n    return virBitmapFormat(virDomainNumatuneGetNodeset(numatune,\n                                                       auto_nodeset,\n                                                       cellid));\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFormat",
          "args": [
            "virDomainNumatuneGetNodeset(numatune,\n                                                       auto_nodeset,\n                                                       cellid)"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "404-442",
          "snippet": "char *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumatuneGetNodeset",
          "args": [
            "numatune",
            "auto_nodeset",
            "cellid"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumatuneGetNodeset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "411-430",
          "snippet": "virBitmapPtr\nvirDomainNumatuneGetNodeset(virDomainNumaPtr numatune,\n                            virBitmapPtr auto_nodeset,\n                            int cellid)\n{\n    if (!numatune)\n        return NULL;\n\n    if (numatune->memory.specified &&\n        numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO)\n        return auto_nodeset;\n\n    if (virDomainNumatuneNodeSpecified(numatune, cellid))\n        return numatune->mem_nodes[cellid].nodeset;\n\n    if (!numatune->memory.specified)\n        return NULL;\n\n    return numatune->memory.nodeset;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirBitmapPtr\nvirDomainNumatuneGetNodeset(virDomainNumaPtr numatune,\n                            virBitmapPtr auto_nodeset,\n                            int cellid)\n{\n    if (!numatune)\n        return NULL;\n\n    if (numatune->memory.specified &&\n        numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO)\n        return auto_nodeset;\n\n    if (virDomainNumatuneNodeSpecified(numatune, cellid))\n        return numatune->mem_nodes[cellid].nodeset;\n\n    if (!numatune->memory.specified)\n        return NULL;\n\n    return numatune->memory.nodeset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nchar *\nvirDomainNumatuneFormatNodeset(virDomainNumaPtr numatune,\n                               virBitmapPtr auto_nodeset,\n                               int cellid)\n{\n    return virBitmapFormat(virDomainNumatuneGetNodeset(numatune,\n                                                       auto_nodeset,\n                                                       cellid));\n}"
  },
  {
    "function_name": "virDomainNumatuneGetNodeset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "411-430",
    "snippet": "virBitmapPtr\nvirDomainNumatuneGetNodeset(virDomainNumaPtr numatune,\n                            virBitmapPtr auto_nodeset,\n                            int cellid)\n{\n    if (!numatune)\n        return NULL;\n\n    if (numatune->memory.specified &&\n        numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO)\n        return auto_nodeset;\n\n    if (virDomainNumatuneNodeSpecified(numatune, cellid))\n        return numatune->mem_nodes[cellid].nodeset;\n\n    if (!numatune->memory.specified)\n        return NULL;\n\n    return numatune->memory.nodeset;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainNumatuneNodeSpecified",
          "args": [
            "numatune",
            "cellid"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumatuneNodeSpecified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "96-106",
          "snippet": "bool\nvirDomainNumatuneNodeSpecified(virDomainNumaPtr numatune,\n                               int cellid)\n{\n    if (numatune &&\n        cellid >= 0 &&\n        cellid < numatune->nmem_nodes)\n        return numatune->mem_nodes[cellid].nodeset;\n\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nbool\nvirDomainNumatuneNodeSpecified(virDomainNumaPtr numatune,\n                               int cellid)\n{\n    if (numatune &&\n        cellid >= 0 &&\n        cellid < numatune->nmem_nodes)\n        return numatune->mem_nodes[cellid].nodeset;\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvirBitmapPtr\nvirDomainNumatuneGetNodeset(virDomainNumaPtr numatune,\n                            virBitmapPtr auto_nodeset,\n                            int cellid)\n{\n    if (!numatune)\n        return NULL;\n\n    if (numatune->memory.specified &&\n        numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO)\n        return auto_nodeset;\n\n    if (virDomainNumatuneNodeSpecified(numatune, cellid))\n        return numatune->mem_nodes[cellid].nodeset;\n\n    if (!numatune->memory.specified)\n        return NULL;\n\n    return numatune->memory.nodeset;\n}"
  },
  {
    "function_name": "virDomainNumatuneGetMode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "389-409",
    "snippet": "int virDomainNumatuneGetMode(virDomainNumaPtr numatune,\n                             int cellid,\n                             virDomainNumatuneMemMode *mode)\n{\n    virDomainNumatuneMemMode tmp_mode;\n\n    if (!numatune)\n        return -1;\n\n    if (virDomainNumatuneNodeSpecified(numatune, cellid))\n        tmp_mode = numatune->mem_nodes[cellid].mode;\n    else if (numatune->memory.specified)\n        tmp_mode = numatune->memory.mode;\n    else\n        return -1;\n\n    if (mode)\n        *mode = tmp_mode;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainNumatuneNodeSpecified",
          "args": [
            "numatune",
            "cellid"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumatuneNodeSpecified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "96-106",
          "snippet": "bool\nvirDomainNumatuneNodeSpecified(virDomainNumaPtr numatune,\n                               int cellid)\n{\n    if (numatune &&\n        cellid >= 0 &&\n        cellid < numatune->nmem_nodes)\n        return numatune->mem_nodes[cellid].nodeset;\n\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nbool\nvirDomainNumatuneNodeSpecified(virDomainNumaPtr numatune,\n                               int cellid)\n{\n    if (numatune &&\n        cellid >= 0 &&\n        cellid < numatune->nmem_nodes)\n        return numatune->mem_nodes[cellid].nodeset;\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nint virDomainNumatuneGetMode(virDomainNumaPtr numatune,\n                             int cellid,\n                             virDomainNumatuneMemMode *mode)\n{\n    virDomainNumatuneMemMode tmp_mode;\n\n    if (!numatune)\n        return -1;\n\n    if (virDomainNumatuneNodeSpecified(numatune, cellid))\n        tmp_mode = numatune->mem_nodes[cellid].mode;\n    else if (numatune->memory.specified)\n        tmp_mode = numatune->memory.mode;\n    else\n        return -1;\n\n    if (mode)\n        *mode = tmp_mode;\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainNumaFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "356-375",
    "snippet": "void\nvirDomainNumaFree(virDomainNumaPtr numa)\n{\n    size_t i = 0;\n\n    if (!numa)\n        return;\n\n    virBitmapFree(numa->memory.nodeset);\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        virBitmapFree(numa->mem_nodes[i].cpumask);\n        virBitmapFree(numa->mem_nodes[i].nodeset);\n\n        if (numa->mem_nodes[i].ndistances > 0)\n            VIR_FREE(numa->mem_nodes[i].distances);\n    }\n    VIR_FREE(numa->mem_nodes);\n\n    VIR_FREE(numa);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "numa"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "numa->mem_nodes"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "numa->mem_nodes[i].distances"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "numa->mem_nodes[i].nodeset"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nvoid\nvirDomainNumaFree(virDomainNumaPtr numa)\n{\n    size_t i = 0;\n\n    if (!numa)\n        return;\n\n    virBitmapFree(numa->memory.nodeset);\n    for (i = 0; i < numa->nmem_nodes; i++) {\n        virBitmapFree(numa->mem_nodes[i].cpumask);\n        virBitmapFree(numa->mem_nodes[i].nodeset);\n\n        if (numa->mem_nodes[i].ndistances > 0)\n            VIR_FREE(numa->mem_nodes[i].distances);\n    }\n    VIR_FREE(numa->mem_nodes);\n\n    VIR_FREE(numa);\n}"
  },
  {
    "function_name": "virDomainNumatuneFormatXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "294-354",
    "snippet": "int\nvirDomainNumatuneFormatXML(virBufferPtr buf,\n                           virDomainNumaPtr numatune)\n{\n    const char *tmp = NULL;\n    char *nodeset = NULL;\n    bool nodesetSpecified = false;\n    size_t i = 0;\n\n    if (!numatune)\n        return 0;\n\n    for (i = 0; i < numatune->nmem_nodes; i++) {\n        if (numatune->mem_nodes[i].nodeset) {\n            nodesetSpecified = true;\n            break;\n        }\n    }\n\n    if (!nodesetSpecified && !numatune->memory.specified)\n        return 0;\n\n    virBufferAddLit(buf, \"<numatune>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (numatune->memory.specified) {\n        tmp = virDomainNumatuneMemModeTypeToString(numatune->memory.mode);\n        virBufferAsprintf(buf, \"<memory mode='%s' \", tmp);\n\n        if (numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_STATIC) {\n            if (!(nodeset = virBitmapFormat(numatune->memory.nodeset)))\n                return -1;\n            virBufferAsprintf(buf, \"nodeset='%s'/>\\n\", nodeset);\n            VIR_FREE(nodeset);\n        } else if (numatune->memory.placement) {\n            tmp = virDomainNumatunePlacementTypeToString(numatune->memory.placement);\n            virBufferAsprintf(buf, \"placement='%s'/>\\n\", tmp);\n        }\n    }\n\n    for (i = 0; i < numatune->nmem_nodes; i++) {\n        virDomainNumaNodePtr mem_node = &numatune->mem_nodes[i];\n\n        if (!mem_node->nodeset)\n            continue;\n\n        if (!(nodeset = virBitmapFormat(mem_node->nodeset)))\n            return -1;\n\n        virBufferAsprintf(buf,\n                          \"<memnode cellid='%zu' mode='%s' nodeset='%s'/>\\n\",\n                          i,\n                          virDomainNumatuneMemModeTypeToString(mem_node->mode),\n                          nodeset);\n        VIR_FREE(nodeset);\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</numatune>\\n\");\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</numatune>\\n\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodeset"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<memnode cellid='%zu' mode='%s' nodeset='%s'/>\\n\"",
            "i",
            "virDomainNumatuneMemModeTypeToString(mem_node->mode)",
            "nodeset"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumatuneMemModeTypeToString",
          "args": [
            "mem_node->mode"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFormat",
          "args": [
            "mem_node->nodeset"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "404-442",
          "snippet": "char *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumatunePlacementTypeToString",
          "args": [
            "numatune->memory.placement"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodeset"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumatuneMemModeTypeToString",
          "args": [
            "numatune->memory.mode"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<numatune>\\n\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nint\nvirDomainNumatuneFormatXML(virBufferPtr buf,\n                           virDomainNumaPtr numatune)\n{\n    const char *tmp = NULL;\n    char *nodeset = NULL;\n    bool nodesetSpecified = false;\n    size_t i = 0;\n\n    if (!numatune)\n        return 0;\n\n    for (i = 0; i < numatune->nmem_nodes; i++) {\n        if (numatune->mem_nodes[i].nodeset) {\n            nodesetSpecified = true;\n            break;\n        }\n    }\n\n    if (!nodesetSpecified && !numatune->memory.specified)\n        return 0;\n\n    virBufferAddLit(buf, \"<numatune>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (numatune->memory.specified) {\n        tmp = virDomainNumatuneMemModeTypeToString(numatune->memory.mode);\n        virBufferAsprintf(buf, \"<memory mode='%s' \", tmp);\n\n        if (numatune->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_STATIC) {\n            if (!(nodeset = virBitmapFormat(numatune->memory.nodeset)))\n                return -1;\n            virBufferAsprintf(buf, \"nodeset='%s'/>\\n\", nodeset);\n            VIR_FREE(nodeset);\n        } else if (numatune->memory.placement) {\n            tmp = virDomainNumatunePlacementTypeToString(numatune->memory.placement);\n            virBufferAsprintf(buf, \"placement='%s'/>\\n\", tmp);\n        }\n    }\n\n    for (i = 0; i < numatune->nmem_nodes; i++) {\n        virDomainNumaNodePtr mem_node = &numatune->mem_nodes[i];\n\n        if (!mem_node->nodeset)\n            continue;\n\n        if (!(nodeset = virBitmapFormat(mem_node->nodeset)))\n            return -1;\n\n        virBufferAsprintf(buf,\n                          \"<memnode cellid='%zu' mode='%s' nodeset='%s'/>\\n\",\n                          i,\n                          virDomainNumatuneMemModeTypeToString(mem_node->mode),\n                          nodeset);\n        VIR_FREE(nodeset);\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</numatune>\\n\");\n    return 0;\n}"
  },
  {
    "function_name": "virDomainNumatuneParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "217-292",
    "snippet": "int\nvirDomainNumatuneParseXML(virDomainNumaPtr numa,\n                          bool placement_static,\n                          xmlXPathContextPtr ctxt)\n{\n    char *tmp = NULL;\n    int mode = -1;\n    int n = 0;\n    int placement = -1;\n    int ret = -1;\n    virBitmapPtr nodeset = NULL;\n    xmlNodePtr node = NULL;\n\n    if (virXPathInt(\"count(./numatune)\", ctxt, &n) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot extract numatune nodes\"));\n        goto cleanup;\n    } else if (n > 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"only one numatune is supported\"));\n        goto cleanup;\n    }\n\n    node = virXPathNode(\"./numatune/memory[1]\", ctxt);\n\n    if (!placement_static && !node)\n        placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO;\n\n    if (node) {\n        if ((tmp = virXMLPropString(node, \"mode\")) &&\n            (mode = virDomainNumatuneMemModeTypeFromString(tmp)) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported NUMA memory tuning mode '%s'\"), tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        if ((tmp = virXMLPropString(node, \"placement\")) &&\n            (placement = virDomainNumatunePlacementTypeFromString(tmp)) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported NUMA memory placement mode '%s'\"), tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        tmp = virXMLPropString(node, \"nodeset\");\n        if (tmp) {\n            if (virBitmapParse(tmp, &nodeset, VIR_DOMAIN_CPUMASK_LEN) < 0)\n                goto cleanup;\n\n            if (virBitmapIsAllClear(nodeset)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid value of 'nodeset': %s\"), tmp);\n                goto cleanup;\n            }\n\n            VIR_FREE(tmp);\n        }\n    }\n\n    if (virDomainNumatuneSet(numa,\n                             placement_static,\n                             placement,\n                             mode,\n                             nodeset) < 0)\n        goto cleanup;\n\n    if (virDomainNumatuneNodeParseXML(numa, ctxt) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virBitmapFree(nodeset);\n    VIR_FREE(tmp);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "nodeset"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumatuneNodeParseXML",
          "args": [
            "numa",
            "ctxt"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumatuneNodeParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "108-215",
          "snippet": "static int\nvirDomainNumatuneNodeParseXML(virDomainNumaPtr numa,\n                              xmlXPathContextPtr ctxt)\n{\n    char *tmp = NULL;\n    int n = 0;\n    int ret = -1;\n    size_t i = 0;\n    xmlNodePtr *nodes = NULL;\n\n    if ((n = virXPathNodeSet(\"./numatune/memnode\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot extract memnode nodes\"));\n        goto cleanup;\n    }\n\n    if (!n)\n        return 0;\n\n    if (numa->memory.specified &&\n        numa->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Per-node binding is not compatible with \"\n                         \"automatic NUMA placement.\"));\n        goto cleanup;\n    }\n\n    if (!numa->nmem_nodes) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Element 'memnode' is invalid without \"\n                         \"any guest NUMA cells\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < n; i++) {\n        int mode = 0;\n        unsigned int cellid = 0;\n        virDomainNumaNodePtr mem_node = NULL;\n        xmlNodePtr cur_node = nodes[i];\n\n        tmp = virXMLPropString(cur_node, \"cellid\");\n        if (!tmp) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing required cellid attribute \"\n                             \"in memnode element\"));\n            goto cleanup;\n        }\n        if (virStrToLong_uip(tmp, NULL, 10, &cellid) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid cellid attribute in memnode element: %s\"),\n                           tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        if (cellid >= numa->nmem_nodes) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Argument 'cellid' in memnode element must \"\n                             \"correspond to existing guest's NUMA cell\"));\n            goto cleanup;\n        }\n\n        mem_node = &numa->mem_nodes[cellid];\n\n        if (mem_node->nodeset) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Multiple memnode elements with cellid %u\"),\n                           cellid);\n            goto cleanup;\n        }\n\n        tmp = virXMLPropString(cur_node, \"mode\");\n        if (!tmp) {\n            mem_node->mode = VIR_DOMAIN_NUMATUNE_MEM_STRICT;\n        } else {\n            if ((mode = virDomainNumatuneMemModeTypeFromString(tmp)) < 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Invalid mode attribute in memnode element\"));\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n            mem_node->mode = mode;\n        }\n\n        tmp = virXMLPropString(cur_node, \"nodeset\");\n        if (!tmp) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing required nodeset attribute \"\n                             \"in memnode element\"));\n            goto cleanup;\n        }\n        if (virBitmapParse(tmp, &mem_node->nodeset, VIR_DOMAIN_CPUMASK_LEN) < 0)\n            goto cleanup;\n\n        if (virBitmapIsAllClear(mem_node->nodeset)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Invalid value of 'nodeset': %s\"), tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nstatic int\nvirDomainNumatuneNodeParseXML(virDomainNumaPtr numa,\n                              xmlXPathContextPtr ctxt)\n{\n    char *tmp = NULL;\n    int n = 0;\n    int ret = -1;\n    size_t i = 0;\n    xmlNodePtr *nodes = NULL;\n\n    if ((n = virXPathNodeSet(\"./numatune/memnode\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot extract memnode nodes\"));\n        goto cleanup;\n    }\n\n    if (!n)\n        return 0;\n\n    if (numa->memory.specified &&\n        numa->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Per-node binding is not compatible with \"\n                         \"automatic NUMA placement.\"));\n        goto cleanup;\n    }\n\n    if (!numa->nmem_nodes) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Element 'memnode' is invalid without \"\n                         \"any guest NUMA cells\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < n; i++) {\n        int mode = 0;\n        unsigned int cellid = 0;\n        virDomainNumaNodePtr mem_node = NULL;\n        xmlNodePtr cur_node = nodes[i];\n\n        tmp = virXMLPropString(cur_node, \"cellid\");\n        if (!tmp) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing required cellid attribute \"\n                             \"in memnode element\"));\n            goto cleanup;\n        }\n        if (virStrToLong_uip(tmp, NULL, 10, &cellid) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid cellid attribute in memnode element: %s\"),\n                           tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        if (cellid >= numa->nmem_nodes) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Argument 'cellid' in memnode element must \"\n                             \"correspond to existing guest's NUMA cell\"));\n            goto cleanup;\n        }\n\n        mem_node = &numa->mem_nodes[cellid];\n\n        if (mem_node->nodeset) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Multiple memnode elements with cellid %u\"),\n                           cellid);\n            goto cleanup;\n        }\n\n        tmp = virXMLPropString(cur_node, \"mode\");\n        if (!tmp) {\n            mem_node->mode = VIR_DOMAIN_NUMATUNE_MEM_STRICT;\n        } else {\n            if ((mode = virDomainNumatuneMemModeTypeFromString(tmp)) < 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Invalid mode attribute in memnode element\"));\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n            mem_node->mode = mode;\n        }\n\n        tmp = virXMLPropString(cur_node, \"nodeset\");\n        if (!tmp) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing required nodeset attribute \"\n                             \"in memnode element\"));\n            goto cleanup;\n        }\n        if (virBitmapParse(tmp, &mem_node->nodeset, VIR_DOMAIN_CPUMASK_LEN) < 0)\n            goto cleanup;\n\n        if (virBitmapIsAllClear(mem_node->nodeset)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Invalid value of 'nodeset': %s\"), tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNumatuneSet",
          "args": [
            "numa",
            "placement_static",
            "placement",
            "mode",
            "nodeset"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNumatuneSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
          "lines": "492-566",
          "snippet": "int\nvirDomainNumatuneSet(virDomainNumaPtr numa,\n                     bool placement_static,\n                     int placement,\n                     int mode,\n                     virBitmapPtr nodeset)\n{\n    /* No need to do anything in this case */\n    if (mode == -1 && placement == -1 && !nodeset)\n        return 0;\n\n    if (!numa->memory.specified) {\n        if (mode == -1)\n            mode = VIR_DOMAIN_NUMATUNE_MEM_STRICT;\n        if (placement == -1)\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_DEFAULT;\n    }\n\n    /* Range checks */\n    if (mode != -1 &&\n        (mode < 0 || mode >= VIR_DOMAIN_NUMATUNE_MEM_LAST)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported numatune mode '%d'\"),\n                       mode);\n        return -1;\n    }\n\n    if (placement != -1 &&\n        (placement < 0 || placement >= VIR_DOMAIN_NUMATUNE_PLACEMENT_LAST)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported numatune placement '%d'\"),\n                       mode);\n        return -1;\n    }\n\n    if (mode != -1)\n        numa->memory.mode = mode;\n\n    if (nodeset) {\n        virBitmapFree(numa->memory.nodeset);\n        if (!(numa->memory.nodeset = virBitmapNewCopy(nodeset)))\n            return -1;\n        if (placement == -1)\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_STATIC;\n    }\n\n    if (placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_DEFAULT) {\n        if (numa->memory.nodeset || placement_static)\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_STATIC;\n        else\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO;\n    }\n\n    if (placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_STATIC &&\n        !numa->memory.nodeset) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"nodeset for NUMA memory tuning must be set \"\n                         \"if 'placement' is 'static'\"));\n        return -1;\n    }\n\n    /* setting nodeset when placement auto is invalid */\n    if (placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO &&\n        numa->memory.nodeset) {\n        virBitmapFree(numa->memory.nodeset);\n        numa->memory.nodeset = NULL;\n    }\n\n    if (placement != -1)\n        numa->memory.placement = placement;\n\n    numa->memory.specified = true;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"numa_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nint\nvirDomainNumatuneSet(virDomainNumaPtr numa,\n                     bool placement_static,\n                     int placement,\n                     int mode,\n                     virBitmapPtr nodeset)\n{\n    /* No need to do anything in this case */\n    if (mode == -1 && placement == -1 && !nodeset)\n        return 0;\n\n    if (!numa->memory.specified) {\n        if (mode == -1)\n            mode = VIR_DOMAIN_NUMATUNE_MEM_STRICT;\n        if (placement == -1)\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_DEFAULT;\n    }\n\n    /* Range checks */\n    if (mode != -1 &&\n        (mode < 0 || mode >= VIR_DOMAIN_NUMATUNE_MEM_LAST)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported numatune mode '%d'\"),\n                       mode);\n        return -1;\n    }\n\n    if (placement != -1 &&\n        (placement < 0 || placement >= VIR_DOMAIN_NUMATUNE_PLACEMENT_LAST)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported numatune placement '%d'\"),\n                       mode);\n        return -1;\n    }\n\n    if (mode != -1)\n        numa->memory.mode = mode;\n\n    if (nodeset) {\n        virBitmapFree(numa->memory.nodeset);\n        if (!(numa->memory.nodeset = virBitmapNewCopy(nodeset)))\n            return -1;\n        if (placement == -1)\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_STATIC;\n    }\n\n    if (placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_DEFAULT) {\n        if (numa->memory.nodeset || placement_static)\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_STATIC;\n        else\n            placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO;\n    }\n\n    if (placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_STATIC &&\n        !numa->memory.nodeset) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"nodeset for NUMA memory tuning must be set \"\n                         \"if 'placement' is 'static'\"));\n        return -1;\n    }\n\n    /* setting nodeset when placement auto is invalid */\n    if (placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO &&\n        numa->memory.nodeset) {\n        virBitmapFree(numa->memory.nodeset);\n        numa->memory.nodeset = NULL;\n    }\n\n    if (placement != -1)\n        numa->memory.placement = placement;\n\n    numa->memory.specified = true;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Invalid value of 'nodeset': %s\")",
            "tmp"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid value of 'nodeset': %s\""
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapIsAllClear",
          "args": [
            "nodeset"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapIsAllClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "962-972",
          "snippet": "bool\nvirBitmapIsAllClear(virBitmapPtr bitmap)\n{\n    size_t i;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        if (bitmap->map[i] != 0)\n            return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapIsAllClear(virBitmapPtr bitmap)\n{\n    size_t i;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        if (bitmap->map[i] != 0)\n            return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapParse",
          "args": [
            "tmp",
            "&nodeset",
            "VIR_DOMAIN_CPUMASK_LEN"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "581-587",
          "snippet": "int\nvirBitmapParse(const char *str,\n               virBitmapPtr *bitmap,\n               size_t bitmapSize)\n{\n    return virBitmapParseSeparator(str, '\\0', bitmap, bitmapSize);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapParse(const char *str,\n               virBitmapPtr *bitmap,\n               size_t bitmapSize)\n{\n    return virBitmapParseSeparator(str, '\\0', bitmap, bitmapSize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "node",
            "\"nodeset\""
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported NUMA memory placement mode '%s'\")",
            "tmp"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumatunePlacementTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported NUMA memory tuning mode '%s'\")",
            "tmp"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumatuneMemModeTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./numatune/memory[1]\"",
            "ctxt"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"only one numatune is supported\")"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot extract numatune nodes\")"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathInt",
          "args": [
            "\"count(./numatune)\"",
            "ctxt",
            "&n"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "223-238",
          "snippet": "int\nvirXPathInt(const char *xpath,\n            xmlXPathContextPtr ctxt,\n            int *value)\n{\n    long tmp;\n    int ret;\n\n    ret = virXPathLongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathInt(const char *xpath,\n            xmlXPathContextPtr ctxt,\n            int *value)\n{\n    long tmp;\n    int ret;\n\n    ret = virXPathLongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nint\nvirDomainNumatuneParseXML(virDomainNumaPtr numa,\n                          bool placement_static,\n                          xmlXPathContextPtr ctxt)\n{\n    char *tmp = NULL;\n    int mode = -1;\n    int n = 0;\n    int placement = -1;\n    int ret = -1;\n    virBitmapPtr nodeset = NULL;\n    xmlNodePtr node = NULL;\n\n    if (virXPathInt(\"count(./numatune)\", ctxt, &n) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot extract numatune nodes\"));\n        goto cleanup;\n    } else if (n > 1) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"only one numatune is supported\"));\n        goto cleanup;\n    }\n\n    node = virXPathNode(\"./numatune/memory[1]\", ctxt);\n\n    if (!placement_static && !node)\n        placement = VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO;\n\n    if (node) {\n        if ((tmp = virXMLPropString(node, \"mode\")) &&\n            (mode = virDomainNumatuneMemModeTypeFromString(tmp)) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported NUMA memory tuning mode '%s'\"), tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        if ((tmp = virXMLPropString(node, \"placement\")) &&\n            (placement = virDomainNumatunePlacementTypeFromString(tmp)) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported NUMA memory placement mode '%s'\"), tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        tmp = virXMLPropString(node, \"nodeset\");\n        if (tmp) {\n            if (virBitmapParse(tmp, &nodeset, VIR_DOMAIN_CPUMASK_LEN) < 0)\n                goto cleanup;\n\n            if (virBitmapIsAllClear(nodeset)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Invalid value of 'nodeset': %s\"), tmp);\n                goto cleanup;\n            }\n\n            VIR_FREE(tmp);\n        }\n    }\n\n    if (virDomainNumatuneSet(numa,\n                             placement_static,\n                             placement,\n                             mode,\n                             nodeset) < 0)\n        goto cleanup;\n\n    if (virDomainNumatuneNodeParseXML(numa, ctxt) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virBitmapFree(nodeset);\n    VIR_FREE(tmp);\n    return ret;\n}"
  },
  {
    "function_name": "virDomainNumatuneNodeParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "108-215",
    "snippet": "static int\nvirDomainNumatuneNodeParseXML(virDomainNumaPtr numa,\n                              xmlXPathContextPtr ctxt)\n{\n    char *tmp = NULL;\n    int n = 0;\n    int ret = -1;\n    size_t i = 0;\n    xmlNodePtr *nodes = NULL;\n\n    if ((n = virXPathNodeSet(\"./numatune/memnode\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot extract memnode nodes\"));\n        goto cleanup;\n    }\n\n    if (!n)\n        return 0;\n\n    if (numa->memory.specified &&\n        numa->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Per-node binding is not compatible with \"\n                         \"automatic NUMA placement.\"));\n        goto cleanup;\n    }\n\n    if (!numa->nmem_nodes) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Element 'memnode' is invalid without \"\n                         \"any guest NUMA cells\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < n; i++) {\n        int mode = 0;\n        unsigned int cellid = 0;\n        virDomainNumaNodePtr mem_node = NULL;\n        xmlNodePtr cur_node = nodes[i];\n\n        tmp = virXMLPropString(cur_node, \"cellid\");\n        if (!tmp) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing required cellid attribute \"\n                             \"in memnode element\"));\n            goto cleanup;\n        }\n        if (virStrToLong_uip(tmp, NULL, 10, &cellid) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid cellid attribute in memnode element: %s\"),\n                           tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        if (cellid >= numa->nmem_nodes) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Argument 'cellid' in memnode element must \"\n                             \"correspond to existing guest's NUMA cell\"));\n            goto cleanup;\n        }\n\n        mem_node = &numa->mem_nodes[cellid];\n\n        if (mem_node->nodeset) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Multiple memnode elements with cellid %u\"),\n                           cellid);\n            goto cleanup;\n        }\n\n        tmp = virXMLPropString(cur_node, \"mode\");\n        if (!tmp) {\n            mem_node->mode = VIR_DOMAIN_NUMATUNE_MEM_STRICT;\n        } else {\n            if ((mode = virDomainNumatuneMemModeTypeFromString(tmp)) < 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Invalid mode attribute in memnode element\"));\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n            mem_node->mode = mode;\n        }\n\n        tmp = virXMLPropString(cur_node, \"nodeset\");\n        if (!tmp) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing required nodeset attribute \"\n                             \"in memnode element\"));\n            goto cleanup;\n        }\n        if (virBitmapParse(tmp, &mem_node->nodeset, VIR_DOMAIN_CPUMASK_LEN) < 0)\n            goto cleanup;\n\n        if (virBitmapIsAllClear(mem_node->nodeset)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Invalid value of 'nodeset': %s\"), tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Invalid value of 'nodeset': %s\")",
            "tmp"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid value of 'nodeset': %s\""
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapIsAllClear",
          "args": [
            "mem_node->nodeset"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapIsAllClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "962-972",
          "snippet": "bool\nvirBitmapIsAllClear(virBitmapPtr bitmap)\n{\n    size_t i;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        if (bitmap->map[i] != 0)\n            return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapIsAllClear(virBitmapPtr bitmap)\n{\n    size_t i;\n\n    for (i = 0; i < bitmap->map_len; i++)\n        if (bitmap->map[i] != 0)\n            return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapParse",
          "args": [
            "tmp",
            "&mem_node->nodeset",
            "VIR_DOMAIN_CPUMASK_LEN"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "581-587",
          "snippet": "int\nvirBitmapParse(const char *str,\n               virBitmapPtr *bitmap,\n               size_t bitmapSize)\n{\n    return virBitmapParseSeparator(str, '\\0', bitmap, bitmapSize);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapParse(const char *str,\n               virBitmapPtr *bitmap,\n               size_t bitmapSize)\n{\n    return virBitmapParseSeparator(str, '\\0', bitmap, bitmapSize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing required nodeset attribute \"\n                             \"in memnode element\")"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "cur_node",
            "\"nodeset\""
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Invalid mode attribute in memnode element\")"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNumatuneMemModeTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Multiple memnode elements with cellid %u\")",
            "cellid"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Argument 'cellid' in memnode element must \"\n                             \"correspond to existing guest's NUMA cell\")"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid cellid attribute in memnode element: %s\")",
            "tmp"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_uip",
          "args": [
            "tmp",
            "NULL",
            "10",
            "&cellid"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing required cellid attribute \"\n                             \"in memnode element\")"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Element 'memnode' is invalid without \"\n                         \"any guest NUMA cells\")"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Per-node binding is not compatible with \"\n                         \"automatic NUMA placement.\")"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot extract memnode nodes\")"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./numatune/memnode\"",
            "ctxt",
            "&nodes"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nstatic int\nvirDomainNumatuneNodeParseXML(virDomainNumaPtr numa,\n                              xmlXPathContextPtr ctxt)\n{\n    char *tmp = NULL;\n    int n = 0;\n    int ret = -1;\n    size_t i = 0;\n    xmlNodePtr *nodes = NULL;\n\n    if ((n = virXPathNodeSet(\"./numatune/memnode\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot extract memnode nodes\"));\n        goto cleanup;\n    }\n\n    if (!n)\n        return 0;\n\n    if (numa->memory.specified &&\n        numa->memory.placement == VIR_DOMAIN_NUMATUNE_PLACEMENT_AUTO) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Per-node binding is not compatible with \"\n                         \"automatic NUMA placement.\"));\n        goto cleanup;\n    }\n\n    if (!numa->nmem_nodes) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Element 'memnode' is invalid without \"\n                         \"any guest NUMA cells\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < n; i++) {\n        int mode = 0;\n        unsigned int cellid = 0;\n        virDomainNumaNodePtr mem_node = NULL;\n        xmlNodePtr cur_node = nodes[i];\n\n        tmp = virXMLPropString(cur_node, \"cellid\");\n        if (!tmp) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing required cellid attribute \"\n                             \"in memnode element\"));\n            goto cleanup;\n        }\n        if (virStrToLong_uip(tmp, NULL, 10, &cellid) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid cellid attribute in memnode element: %s\"),\n                           tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n\n        if (cellid >= numa->nmem_nodes) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Argument 'cellid' in memnode element must \"\n                             \"correspond to existing guest's NUMA cell\"));\n            goto cleanup;\n        }\n\n        mem_node = &numa->mem_nodes[cellid];\n\n        if (mem_node->nodeset) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Multiple memnode elements with cellid %u\"),\n                           cellid);\n            goto cleanup;\n        }\n\n        tmp = virXMLPropString(cur_node, \"mode\");\n        if (!tmp) {\n            mem_node->mode = VIR_DOMAIN_NUMATUNE_MEM_STRICT;\n        } else {\n            if ((mode = virDomainNumatuneMemModeTypeFromString(tmp)) < 0) {\n                virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                               _(\"Invalid mode attribute in memnode element\"));\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n            mem_node->mode = mode;\n        }\n\n        tmp = virXMLPropString(cur_node, \"nodeset\");\n        if (!tmp) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Missing required nodeset attribute \"\n                             \"in memnode element\"));\n            goto cleanup;\n        }\n        if (virBitmapParse(tmp, &mem_node->nodeset, VIR_DOMAIN_CPUMASK_LEN) < 0)\n            goto cleanup;\n\n        if (virBitmapIsAllClear(mem_node->nodeset)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Invalid value of 'nodeset': %s\"), tmp);\n            goto cleanup;\n        }\n        VIR_FREE(tmp);\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n    return ret;\n}"
  },
  {
    "function_name": "virDomainNumatuneNodeSpecified",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/numa_conf.c",
    "lines": "96-106",
    "snippet": "bool\nvirDomainNumatuneNodeSpecified(virDomainNumaPtr numatune,\n                               int cellid)\n{\n    if (numatune &&\n        cellid >= 0 &&\n        cellid < numatune->nmem_nodes)\n        return numatune->mem_nodes[cellid].nodeset;\n\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"viralloc.h\"",
      "#include \"domain_conf.h\"",
      "#include \"numa_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"numa_conf.h\"\n#include <config.h>\n\nbool\nvirDomainNumatuneNodeSpecified(virDomainNumaPtr numatune,\n                               int cellid)\n{\n    if (numatune &&\n        cellid >= 0 &&\n        cellid < numatune->nmem_nodes)\n        return numatune->mem_nodes[cellid].nodeset;\n\n    return false;\n}"
  }
]