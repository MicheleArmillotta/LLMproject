[
  {
    "function_name": "ebiptablesDriverShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3799-3803",
    "snippet": "static void\nebiptablesDriverShutdown(void)\n{\n    ebiptables_driver.flags = 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ebiptablesDriverShutdown(void);",
      "virNWFilterTechDriver ebiptables_driver = {\n    .name = EBIPTABLES_DRIVER_ID,\n    .flags = 0,\n\n    .init     = ebiptablesDriverInit,\n    .shutdown = ebiptablesDriverShutdown,\n\n    .applyNewRules       = ebiptablesApplyNewRules,\n    .tearNewRules        = ebiptablesTearNewRules,\n    .tearOldRules        = ebiptablesTearOldRules,\n    .allTeardown         = ebiptablesAllTeardown,\n\n    .canApplyBasicRules  = ebiptablesCanApplyBasicRules,\n    .applyBasicRules     = ebtablesApplyBasicRules,\n    .applyDHCPOnlyRules  = ebtablesApplyDHCPOnlyRules,\n    .applyDropAllRules   = ebtablesApplyDropAllRules,\n    .removeBasicRules    = ebtablesRemoveBasicRules,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic void ebiptablesDriverShutdown(void);\nvirNWFilterTechDriver ebiptables_driver = {\n    .name = EBIPTABLES_DRIVER_ID,\n    .flags = 0,\n\n    .init     = ebiptablesDriverInit,\n    .shutdown = ebiptablesDriverShutdown,\n\n    .applyNewRules       = ebiptablesApplyNewRules,\n    .tearNewRules        = ebiptablesTearNewRules,\n    .tearOldRules        = ebiptablesTearOldRules,\n    .allTeardown         = ebiptablesAllTeardown,\n\n    .canApplyBasicRules  = ebiptablesCanApplyBasicRules,\n    .applyBasicRules     = ebtablesApplyBasicRules,\n    .applyDHCPOnlyRules  = ebtablesApplyDHCPOnlyRules,\n    .applyDropAllRules   = ebtablesApplyDropAllRules,\n    .removeBasicRules    = ebtablesRemoveBasicRules,\n};\n\nstatic void\nebiptablesDriverShutdown(void)\n{\n    ebiptables_driver.flags = 0;\n}"
  },
  {
    "function_name": "ebiptablesDriverInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3783-3796",
    "snippet": "static int\nebiptablesDriverInit(bool privileged)\n{\n    if (!privileged)\n        return 0;\n\n    ebiptablesDriverProbeCtdir();\n    if (ebiptablesDriverProbeStateMatch() < 0)\n        return -1;\n\n    ebiptables_driver.flags = TECHDRV_FLAG_INITIALIZED;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebiptablesDriverInit(bool privileged);",
      "virNWFilterTechDriver ebiptables_driver = {\n    .name = EBIPTABLES_DRIVER_ID,\n    .flags = 0,\n\n    .init     = ebiptablesDriverInit,\n    .shutdown = ebiptablesDriverShutdown,\n\n    .applyNewRules       = ebiptablesApplyNewRules,\n    .tearNewRules        = ebiptablesTearNewRules,\n    .tearOldRules        = ebiptablesTearOldRules,\n    .allTeardown         = ebiptablesAllTeardown,\n\n    .canApplyBasicRules  = ebiptablesCanApplyBasicRules,\n    .applyBasicRules     = ebtablesApplyBasicRules,\n    .applyDHCPOnlyRules  = ebtablesApplyDHCPOnlyRules,\n    .applyDropAllRules   = ebtablesApplyDropAllRules,\n    .removeBasicRules    = ebtablesRemoveBasicRules,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebiptablesDriverProbeStateMatch",
          "args": [],
          "line": 3790
        },
        "resolved": true,
        "details": {
          "function_name": "ebiptablesDriverProbeStateMatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3755-3781",
          "snippet": "static int\nebiptablesDriverProbeStateMatch(void)\n{\n    unsigned long version;\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, 0);\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_IPV4,\n                           false, ebiptablesDriverProbeStateMatchQuery, &version,\n                           \"--version\", NULL);\n\n    if (virFirewallApply(fw) < 0)\n        goto cleanup;\n\n    /*\n     * since version 1.4.16 '-m state --state ...' will be converted to\n     * '-m conntrack --ctstate ...'\n     */\n    if (version >= 1 * 1000000 + 4 * 1000 + 16)\n        newMatchState = true;\n\n    ret = 0;\n cleanup:\n    virFirewallFree(fw);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool newMatchState;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic bool newMatchState;\n\nstatic int\nebiptablesDriverProbeStateMatch(void)\n{\n    unsigned long version;\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, 0);\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_IPV4,\n                           false, ebiptablesDriverProbeStateMatchQuery, &version,\n                           \"--version\", NULL);\n\n    if (virFirewallApply(fw) < 0)\n        goto cleanup;\n\n    /*\n     * since version 1.4.16 '-m state --state ...' will be converted to\n     * '-m conntrack --ctstate ...'\n     */\n    if (version >= 1 * 1000000 + 4 * 1000 + 16)\n        newMatchState = true;\n\n    ret = 0;\n cleanup:\n    virFirewallFree(fw);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebiptablesDriverProbeCtdir",
          "args": [],
          "line": 3789
        },
        "resolved": true,
        "details": {
          "function_name": "ebiptablesDriverProbeCtdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3697-3721",
          "snippet": "static void\nebiptablesDriverProbeCtdir(void)\n{\n    struct utsname utsname;\n    unsigned long thisversion;\n\n    iptables_ctdir_corrected = CTDIR_STATUS_UNKNOWN;\n\n    if (uname(&utsname) < 0) {\n        VIR_ERROR(_(\"Call to utsname failed: %d\"), errno);\n        return;\n    }\n\n    /* following Linux lxr, the logic was inverted in 2.6.39 */\n    if (virParseVersionString(utsname.release, &thisversion, true) < 0) {\n        VIR_ERROR(_(\"Could not determine kernel version from string %s\"),\n                  utsname.release);\n        return;\n    }\n\n    if (thisversion >= 2 * 1000000 + 6 * 1000 + 39)\n        iptables_ctdir_corrected = CTDIR_STATUS_CORRECTED;\n    else\n        iptables_ctdir_corrected = CTDIR_STATUS_OLD;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ctdirStatus iptables_ctdir_corrected;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic enum ctdirStatus iptables_ctdir_corrected;\n\nstatic void\nebiptablesDriverProbeCtdir(void)\n{\n    struct utsname utsname;\n    unsigned long thisversion;\n\n    iptables_ctdir_corrected = CTDIR_STATUS_UNKNOWN;\n\n    if (uname(&utsname) < 0) {\n        VIR_ERROR(_(\"Call to utsname failed: %d\"), errno);\n        return;\n    }\n\n    /* following Linux lxr, the logic was inverted in 2.6.39 */\n    if (virParseVersionString(utsname.release, &thisversion, true) < 0) {\n        VIR_ERROR(_(\"Could not determine kernel version from string %s\"),\n                  utsname.release);\n        return;\n    }\n\n    if (thisversion >= 2 * 1000000 + 6 * 1000 + 39)\n        iptables_ctdir_corrected = CTDIR_STATUS_CORRECTED;\n    else\n        iptables_ctdir_corrected = CTDIR_STATUS_OLD;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebiptablesDriverInit(bool privileged);\nvirNWFilterTechDriver ebiptables_driver = {\n    .name = EBIPTABLES_DRIVER_ID,\n    .flags = 0,\n\n    .init     = ebiptablesDriverInit,\n    .shutdown = ebiptablesDriverShutdown,\n\n    .applyNewRules       = ebiptablesApplyNewRules,\n    .tearNewRules        = ebiptablesTearNewRules,\n    .tearOldRules        = ebiptablesTearOldRules,\n    .allTeardown         = ebiptablesAllTeardown,\n\n    .canApplyBasicRules  = ebiptablesCanApplyBasicRules,\n    .applyBasicRules     = ebtablesApplyBasicRules,\n    .applyDHCPOnlyRules  = ebtablesApplyDHCPOnlyRules,\n    .applyDropAllRules   = ebtablesApplyDropAllRules,\n    .removeBasicRules    = ebtablesRemoveBasicRules,\n};\n\nstatic int\nebiptablesDriverInit(bool privileged)\n{\n    if (!privileged)\n        return 0;\n\n    ebiptablesDriverProbeCtdir();\n    if (ebiptablesDriverProbeStateMatch() < 0)\n        return -1;\n\n    ebiptables_driver.flags = TECHDRV_FLAG_INITIALIZED;\n\n    return 0;\n}"
  },
  {
    "function_name": "ebiptablesDriverProbeStateMatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3755-3781",
    "snippet": "static int\nebiptablesDriverProbeStateMatch(void)\n{\n    unsigned long version;\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, 0);\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_IPV4,\n                           false, ebiptablesDriverProbeStateMatchQuery, &version,\n                           \"--version\", NULL);\n\n    if (virFirewallApply(fw) < 0)\n        goto cleanup;\n\n    /*\n     * since version 1.4.16 '-m state --state ...' will be converted to\n     * '-m conntrack --ctstate ...'\n     */\n    if (version >= 1 * 1000000 + 4 * 1000 + 16)\n        newMatchState = true;\n\n    ret = 0;\n cleanup:\n    virFirewallFree(fw);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool newMatchState;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallFree",
          "args": [
            "fw"
          ],
          "line": 3779
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "286-298",
          "snippet": "void virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallApply",
          "args": [
            "fw"
          ],
          "line": 3767
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "804-868",
          "snippet": "int\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
            "static virMutex ruleLock = VIR_MUTEX_INITIALIZER;",
            "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic virMutex ruleLock = VIR_MUTEX_INITIALIZER;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nint\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallAddRuleFull",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "false",
            "ebiptablesDriverProbeStateMatchQuery",
            "&version",
            "\"--version\"",
            "NULL"
          ],
          "line": 3763
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallStartTransaction",
          "args": [
            "fw",
            "0"
          ],
          "line": 3762
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallStartTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "586-607",
          "snippet": "void virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallNew",
          "args": [],
          "line": 3759
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "231-242",
          "snippet": "virFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic bool newMatchState;\n\nstatic int\nebiptablesDriverProbeStateMatch(void)\n{\n    unsigned long version;\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, 0);\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_IPV4,\n                           false, ebiptablesDriverProbeStateMatchQuery, &version,\n                           \"--version\", NULL);\n\n    if (virFirewallApply(fw) < 0)\n        goto cleanup;\n\n    /*\n     * since version 1.4.16 '-m state --state ...' will be converted to\n     * '-m conntrack --ctstate ...'\n     */\n    if (version >= 1 * 1000000 + 4 * 1000 + 16)\n        newMatchState = true;\n\n    ret = 0;\n cleanup:\n    virFirewallFree(fw);\n    return ret;\n}"
  },
  {
    "function_name": "ebiptablesDriverProbeStateMatchQuery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3724-3752",
    "snippet": "static int\nebiptablesDriverProbeStateMatchQuery(virFirewallPtr fw G_GNUC_UNUSED,\n                                     virFirewallLayer layer G_GNUC_UNUSED,\n                                     const char *const *lines,\n                                     void *opaque)\n{\n    unsigned long *version = opaque;\n    char *tmp;\n\n    if (!lines || !lines[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No output from iptables --version\"));\n        return -1;\n    }\n\n    /*\n     * we expect output in the format\n     * 'iptables v1.4.16'\n     */\n    if (!(tmp = strchr(lines[0], 'v')) ||\n        virParseVersionString(tmp + 1, version, true) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse version string '%s'\"),\n                       lines[0]);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cannot parse version string '%s'\")",
            "lines[0]"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot parse version string '%s'\""
          ],
          "line": 3746
        },
        "resolved": true,
        "details": {
          "function_name": "_virNWFilterTeardownFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_gentech_driver.c",
          "lines": "898-927",
          "snippet": "static int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdev.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_dhcpsnoop.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _virNWFilterTeardownFilter(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsocketaddr.h\"\n#include \"datatypes.h\"\n#include \"virnetdev.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_dhcpsnoop.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"virerror.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int _virNWFilterTeardownFilter(const char *ifname);\n\nstatic int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virParseVersionString",
          "args": [
            "tmp + 1",
            "version",
            "true"
          ],
          "line": 3744
        },
        "resolved": true,
        "details": {
          "function_name": "virParseVersionString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "254-282",
          "snippet": "int\nvirParseVersionString(const char *str, unsigned long *version,\n                      bool allowMissing)\n{\n    unsigned int major, minor = 0, micro = 0;\n    char *tmp;\n\n    if (virStrToLong_ui(str, &tmp, 10, &major) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &minor) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &micro) < 0)\n        return -1;\n\n    if (major > UINT_MAX / 1000000 || minor > 999 || micro > 999)\n        return -1;\n\n    *version = 1000000 * major + 1000 * minor + micro;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirParseVersionString(const char *str, unsigned long *version,\n                      bool allowMissing)\n{\n    unsigned int major, minor = 0, micro = 0;\n    char *tmp;\n\n    if (virStrToLong_ui(str, &tmp, 10, &major) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &minor) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &micro) < 0)\n        return -1;\n\n    if (major > UINT_MAX / 1000000 || minor > 999 || micro > 999)\n        return -1;\n\n    *version = 1000000 * major + 1000 * minor + micro;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "lines[0]",
            "'v'"
          ],
          "line": 3743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"No output from iptables --version\")"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nebiptablesDriverProbeStateMatchQuery(virFirewallPtr fw G_GNUC_UNUSED,\n                                     virFirewallLayer layer G_GNUC_UNUSED,\n                                     const char *const *lines,\n                                     void *opaque)\n{\n    unsigned long *version = opaque;\n    char *tmp;\n\n    if (!lines || !lines[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No output from iptables --version\"));\n        return -1;\n    }\n\n    /*\n     * we expect output in the format\n     * 'iptables v1.4.16'\n     */\n    if (!(tmp = strchr(lines[0], 'v')) ||\n        virParseVersionString(tmp + 1, version, true) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse version string '%s'\"),\n                       lines[0]);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "ebiptablesDriverProbeCtdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3697-3721",
    "snippet": "static void\nebiptablesDriverProbeCtdir(void)\n{\n    struct utsname utsname;\n    unsigned long thisversion;\n\n    iptables_ctdir_corrected = CTDIR_STATUS_UNKNOWN;\n\n    if (uname(&utsname) < 0) {\n        VIR_ERROR(_(\"Call to utsname failed: %d\"), errno);\n        return;\n    }\n\n    /* following Linux lxr, the logic was inverted in 2.6.39 */\n    if (virParseVersionString(utsname.release, &thisversion, true) < 0) {\n        VIR_ERROR(_(\"Could not determine kernel version from string %s\"),\n                  utsname.release);\n        return;\n    }\n\n    if (thisversion >= 2 * 1000000 + 6 * 1000 + 39)\n        iptables_ctdir_corrected = CTDIR_STATUS_CORRECTED;\n    else\n        iptables_ctdir_corrected = CTDIR_STATUS_OLD;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ctdirStatus iptables_ctdir_corrected;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Could not determine kernel version from string %s\")",
            "utsname.release"
          ],
          "line": 3712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not determine kernel version from string %s\""
          ],
          "line": 3712
        },
        "resolved": true,
        "details": {
          "function_name": "_virNWFilterTeardownFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_gentech_driver.c",
          "lines": "898-927",
          "snippet": "static int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdev.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_dhcpsnoop.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _virNWFilterTeardownFilter(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsocketaddr.h\"\n#include \"datatypes.h\"\n#include \"virnetdev.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_dhcpsnoop.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"virerror.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int _virNWFilterTeardownFilter(const char *ifname);\n\nstatic int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virParseVersionString",
          "args": [
            "utsname.release",
            "&thisversion",
            "true"
          ],
          "line": 3711
        },
        "resolved": true,
        "details": {
          "function_name": "virParseVersionString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "254-282",
          "snippet": "int\nvirParseVersionString(const char *str, unsigned long *version,\n                      bool allowMissing)\n{\n    unsigned int major, minor = 0, micro = 0;\n    char *tmp;\n\n    if (virStrToLong_ui(str, &tmp, 10, &major) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &minor) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &micro) < 0)\n        return -1;\n\n    if (major > UINT_MAX / 1000000 || minor > 999 || micro > 999)\n        return -1;\n\n    *version = 1000000 * major + 1000 * minor + micro;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirParseVersionString(const char *str, unsigned long *version,\n                      bool allowMissing)\n{\n    unsigned int major, minor = 0, micro = 0;\n    char *tmp;\n\n    if (virStrToLong_ui(str, &tmp, 10, &major) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &minor) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &micro) < 0)\n        return -1;\n\n    if (major > UINT_MAX / 1000000 || minor > 999 || micro > 999)\n        return -1;\n\n    *version = 1000000 * major + 1000 * minor + micro;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Call to utsname failed: %d\")",
            "errno"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uname",
          "args": [
            "&utsname"
          ],
          "line": 3705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic enum ctdirStatus iptables_ctdir_corrected;\n\nstatic void\nebiptablesDriverProbeCtdir(void)\n{\n    struct utsname utsname;\n    unsigned long thisversion;\n\n    iptables_ctdir_corrected = CTDIR_STATUS_UNKNOWN;\n\n    if (uname(&utsname) < 0) {\n        VIR_ERROR(_(\"Call to utsname failed: %d\"), errno);\n        return;\n    }\n\n    /* following Linux lxr, the logic was inverted in 2.6.39 */\n    if (virParseVersionString(utsname.release, &thisversion, true) < 0) {\n        VIR_ERROR(_(\"Could not determine kernel version from string %s\"),\n                  utsname.release);\n        return;\n    }\n\n    if (thisversion >= 2 * 1000000 + 6 * 1000 + 39)\n        iptables_ctdir_corrected = CTDIR_STATUS_CORRECTED;\n    else\n        iptables_ctdir_corrected = CTDIR_STATUS_OLD;\n}"
  },
  {
    "function_name": "ebiptablesAllTeardown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3646-3675",
    "snippet": "static int\nebiptablesAllTeardown(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebiptablesTearNewRulesFW(fw, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n\n    ebtablesRemoveSubChainsFW(fw, ifname);\n\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallFree",
          "args": [
            "fw"
          ],
          "line": 3673
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "286-298",
          "snippet": "void virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallApply",
          "args": [
            "fw"
          ],
          "line": 3672
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "804-868",
          "snippet": "int\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
            "static virMutex ruleLock = VIR_MUTEX_INITIALIZER;",
            "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic virMutex ruleLock = VIR_MUTEX_INITIALIZER;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nint\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRemoveRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3670
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRemoveRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2559-2564",
          "snippet": "static void\nebtablesRemoveRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, false);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRemoveRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRemoveSubChainsFW",
          "args": [
            "fw",
            "ifname"
          ],
          "line": 3667
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRemoveSubChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2719-2724",
          "snippet": "static void\nebtablesRemoveSubChainsFW(virFirewallPtr fw,\n                          const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);",
            "static char chainprefixes_host[3] = {\n    CHAINPREFIX_HOST_IN,\n    CHAINPREFIX_HOST_OUT,\n    0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\nstatic char chainprefixes_host[3] = {\n    CHAINPREFIX_HOST_IN,\n    CHAINPREFIX_HOST_OUT,\n    0\n};\n\nstatic void\nebtablesRemoveSubChainsFW(virFirewallPtr fw,\n                          const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesUnlinkRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3665
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesUnlinkRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2602-2607",
          "snippet": "static void\nebtablesUnlinkRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, false);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesUnlinkRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveRootChainsFW",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "ifname"
          ],
          "line": 3662
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveRootChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "559-567",
          "snippet": "static void\niptablesRemoveRootChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *ifname)\n{\n    iptablesRemoveRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRemoveRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRemoveRootChainFW(fw, layer, 'H', true, ifname);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesRemoveRootChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *ifname)\n{\n    iptablesRemoveRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRemoveRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRemoveRootChainFW(fw, layer, 'H', true, ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesClearVirtInPostFW",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "ifname"
          ],
          "line": 3661
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesClearVirtInPostFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "629-639",
          "snippet": "static void\niptablesClearVirtInPostFW(virFirewallPtr fw,\n                          virFirewallLayer layer,\n                          const char *ifname)\n{\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", VIRT_IN_POST_CHAIN,\n                           MATCH_PHYSDEV_IN_FW,\n                           ifname, \"-j\", \"ACCEPT\", NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"",
            "#define VIRT_IN_POST_CHAIN \"libvirt-in-post\""
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"\n#define VIRT_IN_POST_CHAIN \"libvirt-in-post\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesClearVirtInPostFW(virFirewallPtr fw,\n                          virFirewallLayer layer,\n                          const char *ifname)\n{\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", VIRT_IN_POST_CHAIN,\n                           MATCH_PHYSDEV_IN_FW,\n                           ifname, \"-j\", \"ACCEPT\", NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesUnlinkRootChainsFW",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "ifname"
          ],
          "line": 3660
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesUnlinkRootChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "717-725",
          "snippet": "static void\niptablesUnlinkRootChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *ifname)\n{\n    iptablesUnlinkRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesUnlinkRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesUnlinkRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define HOST_IN_CHAIN      \"libvirt-host-in\"",
            "#define VIRT_OUT_CHAIN     \"libvirt-out\"",
            "#define VIRT_IN_CHAIN      \"libvirt-in\""
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define HOST_IN_CHAIN      \"libvirt-host-in\"\n#define VIRT_OUT_CHAIN     \"libvirt-out\"\n#define VIRT_IN_CHAIN      \"libvirt-in\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesUnlinkRootChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *ifname)\n{\n    iptablesUnlinkRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesUnlinkRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesUnlinkRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebiptablesTearNewRulesFW",
          "args": [
            "fw",
            "ifname"
          ],
          "line": 3654
        },
        "resolved": true,
        "details": {
          "function_name": "ebiptablesTearNewRulesFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3576-3590",
          "snippet": "static void\nebiptablesTearNewRulesFW(virFirewallPtr fw, const char *ifname)\n{\n    iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebiptablesTearNewRulesFW(virFirewallPtr fw, const char *ifname)\n{\n    iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallStartTransaction",
          "args": [
            "fw",
            "VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS"
          ],
          "line": 3652
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallStartTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "586-607",
          "snippet": "void virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallNew",
          "args": [],
          "line": 3649
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "231-242",
          "snippet": "virFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebiptablesAllTeardown(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebiptablesTearNewRulesFW(fw, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n\n    ebtablesRemoveSubChainsFW(fw, ifname);\n\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}"
  },
  {
    "function_name": "ebiptablesTearOldRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3608-3634",
    "snippet": "static int\nebiptablesTearOldRules(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRenameTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRenameTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n    ebtablesRemoveSubChainsFW(fw, ifname);\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n    ebtablesRenameTmpSubAndRootChainsFW(fw, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallFree",
          "args": [
            "fw"
          ],
          "line": 3632
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "286-298",
          "snippet": "void virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallApply",
          "args": [
            "fw"
          ],
          "line": 3631
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "804-868",
          "snippet": "int\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
            "static virMutex ruleLock = VIR_MUTEX_INITIALIZER;",
            "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic virMutex ruleLock = VIR_MUTEX_INITIALIZER;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nint\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRenameTmpSubAndRootChainsFW",
          "args": [
            "fw",
            "ifname"
          ],
          "line": 3629
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRenameTmpSubAndRootChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2812-2833",
          "snippet": "static void\nebtablesRenameTmpSubAndRootChainsFW(virFirewallPtr fw,\n                                    const char *ifname)\n{\n    char rootchain[MAX_CHAINNAME_LENGTH];\n    size_t i;\n    char chains[3] = {\n        CHAINPREFIX_HOST_IN_TEMP,\n        CHAINPREFIX_HOST_OUT_TEMP,\n        0\n    };\n    for (i = 0; chains[i] != 0; i++) {\n        PRINT_ROOT_CHAIN(rootchain, chains[i], ifname);\n        virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                               false, ebtablesRenameTmpSubAndRootChainsQuery,\n                               NULL,\n                               \"-t\", \"nat\", \"-L\", rootchain, NULL);\n    }\n\n    ebtablesRenameTmpRootChainFW(fw, true, ifname);\n    ebtablesRenameTmpRootChainFW(fw, false, ifname);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRenameTmpSubAndRootChainsFW(virFirewallPtr fw,\n                                    const char *ifname)\n{\n    char rootchain[MAX_CHAINNAME_LENGTH];\n    size_t i;\n    char chains[3] = {\n        CHAINPREFIX_HOST_IN_TEMP,\n        CHAINPREFIX_HOST_OUT_TEMP,\n        0\n    };\n    for (i = 0; chains[i] != 0; i++) {\n        PRINT_ROOT_CHAIN(rootchain, chains[i], ifname);\n        virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                               false, ebtablesRenameTmpSubAndRootChainsQuery,\n                               NULL,\n                               \"-t\", \"nat\", \"-L\", rootchain, NULL);\n    }\n\n    ebtablesRenameTmpRootChainFW(fw, true, ifname);\n    ebtablesRenameTmpRootChainFW(fw, false, ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRemoveRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3628
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRemoveRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2559-2564",
          "snippet": "static void\nebtablesRemoveRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, false);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRemoveRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRemoveSubChainsFW",
          "args": [
            "fw",
            "ifname"
          ],
          "line": 3626
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRemoveSubChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2719-2724",
          "snippet": "static void\nebtablesRemoveSubChainsFW(virFirewallPtr fw,\n                          const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);",
            "static char chainprefixes_host[3] = {\n    CHAINPREFIX_HOST_IN,\n    CHAINPREFIX_HOST_OUT,\n    0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\nstatic char chainprefixes_host[3] = {\n    CHAINPREFIX_HOST_IN,\n    CHAINPREFIX_HOST_OUT,\n    0\n};\n\nstatic void\nebtablesRemoveSubChainsFW(virFirewallPtr fw,\n                          const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesUnlinkRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3625
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesUnlinkRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2602-2607",
          "snippet": "static void\nebtablesUnlinkRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, false);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesUnlinkRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRenameTmpRootChainsFW",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "ifname"
          ],
          "line": 3622
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRenameTmpRootChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "766-774",
          "snippet": "static void\niptablesRenameTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesRenameTmpRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRenameTmpRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRenameTmpRootChainFW(fw, layer, 'H', true, ifname);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesRenameTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesRenameTmpRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRenameTmpRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRenameTmpRootChainFW(fw, layer, 'H', true, ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveRootChainsFW",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "ifname"
          ],
          "line": 3621
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveRootChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "559-567",
          "snippet": "static void\niptablesRemoveRootChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *ifname)\n{\n    iptablesRemoveRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRemoveRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRemoveRootChainFW(fw, layer, 'H', true, ifname);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesRemoveRootChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *ifname)\n{\n    iptablesRemoveRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRemoveRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRemoveRootChainFW(fw, layer, 'H', true, ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesUnlinkRootChainsFW",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "ifname"
          ],
          "line": 3620
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesUnlinkRootChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "717-725",
          "snippet": "static void\niptablesUnlinkRootChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *ifname)\n{\n    iptablesUnlinkRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesUnlinkRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesUnlinkRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define HOST_IN_CHAIN      \"libvirt-host-in\"",
            "#define VIRT_OUT_CHAIN     \"libvirt-out\"",
            "#define VIRT_IN_CHAIN      \"libvirt-in\""
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define HOST_IN_CHAIN      \"libvirt-host-in\"\n#define VIRT_OUT_CHAIN     \"libvirt-out\"\n#define VIRT_IN_CHAIN      \"libvirt-in\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesUnlinkRootChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *ifname)\n{\n    iptablesUnlinkRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesUnlinkRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesUnlinkRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallStartTransaction",
          "args": [
            "fw",
            "VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS"
          ],
          "line": 3614
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallStartTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "586-607",
          "snippet": "void virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallNew",
          "args": [],
          "line": 3611
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "231-242",
          "snippet": "virFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebiptablesTearOldRules(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRenameTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRenameTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n    ebtablesRemoveSubChainsFW(fw, ifname);\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n    ebtablesRenameTmpSubAndRootChainsFW(fw, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}"
  },
  {
    "function_name": "ebiptablesTearNewRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3593-3606",
    "snippet": "static int\nebiptablesTearNewRules(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebiptablesTearNewRulesFW(fw, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallFree",
          "args": [
            "fw"
          ],
          "line": 3604
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "286-298",
          "snippet": "void virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallApply",
          "args": [
            "fw"
          ],
          "line": 3603
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "804-868",
          "snippet": "int\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
            "static virMutex ruleLock = VIR_MUTEX_INITIALIZER;",
            "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic virMutex ruleLock = VIR_MUTEX_INITIALIZER;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nint\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebiptablesTearNewRulesFW",
          "args": [
            "fw",
            "ifname"
          ],
          "line": 3601
        },
        "resolved": true,
        "details": {
          "function_name": "ebiptablesTearNewRulesFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3576-3590",
          "snippet": "static void\nebiptablesTearNewRulesFW(virFirewallPtr fw, const char *ifname)\n{\n    iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebiptablesTearNewRulesFW(virFirewallPtr fw, const char *ifname)\n{\n    iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallStartTransaction",
          "args": [
            "fw",
            "VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS"
          ],
          "line": 3599
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallStartTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "586-607",
          "snippet": "void virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallNew",
          "args": [],
          "line": 3596
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "231-242",
          "snippet": "virFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebiptablesTearNewRules(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebiptablesTearNewRulesFW(fw, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}"
  },
  {
    "function_name": "ebiptablesTearNewRulesFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3576-3590",
    "snippet": "static void\nebiptablesTearNewRulesFW(virFirewallPtr fw, const char *ifname)\n{\n    iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebtablesRemoveTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3589
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRemoveTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2567-2572",
          "snippet": "static void\nebtablesRemoveTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, 1);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRemoveTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRemoveTmpSubChainsFW",
          "args": [
            "fw",
            "ifname"
          ],
          "line": 3587
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRemoveTmpSubChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2727-2732",
          "snippet": "static void\nebtablesRemoveTmpSubChainsFW(virFirewallPtr fw,\n                             const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host_temp);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);",
            "static char chainprefixes_host_temp[3] = {\n    CHAINPREFIX_HOST_IN_TEMP,\n    CHAINPREFIX_HOST_OUT_TEMP,\n    0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\nstatic char chainprefixes_host_temp[3] = {\n    CHAINPREFIX_HOST_IN_TEMP,\n    CHAINPREFIX_HOST_OUT_TEMP,\n    0\n};\n\nstatic void\nebtablesRemoveTmpSubChainsFW(virFirewallPtr fw,\n                             const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host_temp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesUnlinkTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3586
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesUnlinkTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2610-2615",
          "snippet": "static void\nebtablesUnlinkTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, 1);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesUnlinkTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveTmpRootChainsFW",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "ifname"
          ],
          "line": 3583
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveTmpRootChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "548-556",
          "snippet": "static void\niptablesRemoveTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesRemoveTmpRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRemoveTmpRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRemoveTmpRootChainFW(fw, layer, 'H', true, ifname);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesRemoveTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesRemoveTmpRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRemoveTmpRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRemoveTmpRootChainFW(fw, layer, 'H', true, ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesUnlinkTmpRootChainsFW",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "ifname"
          ],
          "line": 3582
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesUnlinkTmpRootChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "728-736",
          "snippet": "static void\niptablesUnlinkTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesUnlinkTmpRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesUnlinkTmpRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesUnlinkTmpRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define HOST_IN_CHAIN      \"libvirt-host-in\"",
            "#define VIRT_OUT_CHAIN     \"libvirt-out\"",
            "#define VIRT_IN_CHAIN      \"libvirt-in\""
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define HOST_IN_CHAIN      \"libvirt-host-in\"\n#define VIRT_OUT_CHAIN     \"libvirt-out\"\n#define VIRT_IN_CHAIN      \"libvirt-in\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesUnlinkTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesUnlinkTmpRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesUnlinkTmpRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesUnlinkTmpRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebiptablesTearNewRulesFW(virFirewallPtr fw, const char *ifname)\n{\n    iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n}"
  },
  {
    "function_name": "ebiptablesApplyNewRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3359-3573",
    "snippet": "static int\nebiptablesApplyNewRules(const char *ifname,\n                        virNWFilterRuleInstPtr *rules,\n                        size_t nrules)\n{\n    size_t i, j;\n    virFirewallPtr fw = virFirewallNew();\n    virHashTablePtr chains_in_set  = virHashCreate(10, NULL);\n    virHashTablePtr chains_out_set = virHashCreate(10, NULL);\n    bool haveEbtables = false;\n    bool haveIptables = false;\n    bool haveIp6tables = false;\n    char *errmsg = NULL;\n    struct ebtablesSubChainInst **subchains = NULL;\n    size_t nsubchains = 0;\n    int ret = -1;\n\n    if (!chains_in_set || !chains_out_set)\n        goto cleanup;\n\n    if (nrules)\n        qsort(rules, nrules, sizeof(rules[0]),\n              virNWFilterRuleInstSortPtr);\n\n    /* cleanup whatever may exist */\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n\n    virFirewallStartTransaction(fw, 0);\n\n    /* walk the list of rules and increase the priority\n     * of rules in case the chain priority is of higher value;\n     * this preserves the order of the rules and ensures that\n     * the chain will be created before the chain's rules\n     * are created; don't adjust rules in the root chain\n     * example: a rule of priority -510 will be adjusted to\n     * priority -500 and the chain with priority -500 will\n     * then be created before it.\n     */\n    for (i = 0; i < nrules; i++) {\n        if (rules[i]->chainPriority > rules[i]->priority &&\n            !strstr(\"root\", rules[i]->chainSuffix)) {\n\n             rules[i]->priority = rules[i]->chainPriority;\n        }\n    }\n\n    for (i = 0; i < nrules; i++) {\n        if (virNWFilterRuleIsProtocolEthernet(rules[i]->def)) {\n            haveEbtables = true;\n        } else {\n            if (virNWFilterRuleIsProtocolIPv4(rules[i]->def))\n                haveIptables = true;\n            else if (virNWFilterRuleIsProtocolIPv6(rules[i]->def))\n                haveIp6tables = true;\n        }\n    }\n    /* process ebtables commands; interleave commands from filters with\n       commands for creating and connecting ebtables chains */\n    if (haveEbtables) {\n\n        /* scan the rules to see which chains need to be created */\n        for (i = 0; i < nrules; i++) {\n            if (virNWFilterRuleIsProtocolEthernet(rules[i]->def)) {\n                const char *name = rules[i]->chainSuffix;\n                if (rules[i]->def->tt == VIR_NWFILTER_RULE_DIRECTION_OUT ||\n                    rules[i]->def->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n                    if (virHashUpdateEntry(chains_in_set, name,\n                                           &rules[i]->chainPriority) < 0)\n                        goto cleanup;\n                }\n                if (rules[i]->def->tt == VIR_NWFILTER_RULE_DIRECTION_IN ||\n                    rules[i]->def->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n                    if (virHashUpdateEntry(chains_out_set, name,\n                                           &rules[i]->chainPriority) < 0)\n                        goto cleanup;\n                }\n            }\n        }\n\n        /* create needed chains */\n        if (virHashSize(chains_in_set) > 0) {\n            ebtablesCreateTmpRootChainFW(fw, true, ifname);\n            if (ebtablesGetSubChainInsts(chains_in_set,\n                                         true,\n                                         &subchains,\n                                         &nsubchains) < 0)\n                goto cleanup;\n        }\n        if (virHashSize(chains_out_set) > 0) {\n            ebtablesCreateTmpRootChainFW(fw, false, ifname);\n            if (ebtablesGetSubChainInsts(chains_out_set,\n                                         false,\n                                         &subchains,\n                                         &nsubchains) < 0)\n                goto cleanup;\n        }\n\n        if (nsubchains > 0)\n            qsort(subchains, nsubchains, sizeof(subchains[0]),\n                  ebtablesSubChainInstSort);\n\n        for (i = 0, j = 0; i < nrules; i++) {\n            if (virNWFilterRuleIsProtocolEthernet(rules[i]->def)) {\n                while (j < nsubchains &&\n                       subchains[j]->priority <= rules[i]->priority) {\n                    ebtablesCreateTmpSubChainFW(fw,\n                                                subchains[j]->incoming,\n                                                ifname,\n                                                subchains[j]->protoidx,\n                                                subchains[j]->filtername);\n                    j++;\n                }\n                if (ebtablesRuleInstCommand(fw,\n                                            ifname,\n                                            rules[i]) < 0)\n                    goto cleanup;\n            }\n        }\n        while (j < nsubchains) {\n            ebtablesCreateTmpSubChainFW(fw,\n                                        subchains[j]->incoming,\n                                        ifname,\n                                        subchains[j]->protoidx,\n                                        subchains[j]->filtername);\n            j++;\n        }\n    }\n\n    if (haveIptables) {\n        iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n        iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n        iptablesCreateBaseChainsFW(fw, VIR_FIREWALL_LAYER_IPV4);\n        iptablesCreateTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n        iptablesLinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n        iptablesSetupVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n        for (i = 0; i < nrules; i++) {\n            if (virNWFilterRuleIsProtocolIPv4(rules[i]->def)) {\n                if (iptablesRuleInstCommand(fw,\n                                            ifname,\n                                            rules[i]) < 0)\n                    goto cleanup;\n            }\n        }\n\n        iptablesCheckBridgeNFCallEnabled(false);\n    }\n\n    if (haveIp6tables) {\n        iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n        iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n        iptablesCreateBaseChainsFW(fw, VIR_FIREWALL_LAYER_IPV6);\n        iptablesCreateTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n        iptablesLinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n        iptablesSetupVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n        for (i = 0; i < nrules; i++) {\n            if (virNWFilterRuleIsProtocolIPv6(rules[i]->def)) {\n                if (iptablesRuleInstCommand(fw,\n                                            ifname,\n                                            rules[i]) < 0)\n                    goto cleanup;\n            }\n        }\n\n        iptablesCheckBridgeNFCallEnabled(true);\n    }\n\n    if (virHashSize(chains_in_set) != 0)\n        ebtablesLinkTmpRootChainFW(fw, true, ifname);\n    if (virHashSize(chains_out_set) != 0)\n        ebtablesLinkTmpRootChainFW(fw, false, ifname);\n\n    virFirewallStartRollback(fw, 0);\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    if (haveIp6tables) {\n        iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n        iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    }\n\n    if (haveIptables) {\n        iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n        iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    }\n\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n\n    if (virFirewallApply(fw) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    for (i = 0; i < nsubchains; i++)\n        VIR_FREE(subchains[i]);\n    VIR_FREE(subchains);\n    virFirewallFree(fw);\n    virHashFree(chains_in_set);\n    virHashFree(chains_out_set);\n\n    VIR_FREE(errmsg);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "errmsg"
          ],
          "line": 3571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "chains_out_set"
          ],
          "line": 3569
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallFree",
          "args": [
            "fw"
          ],
          "line": 3567
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "286-298",
          "snippet": "void virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "subchains"
          ],
          "line": 3566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "subchains[i]"
          ],
          "line": 3565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallApply",
          "args": [
            "fw"
          ],
          "line": 3558
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "804-868",
          "snippet": "int\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
            "static virMutex ruleLock = VIR_MUTEX_INITIALIZER;",
            "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic virMutex ruleLock = VIR_MUTEX_INITIALIZER;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nint\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRemoveTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3556
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRemoveTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2567-2572",
          "snippet": "static void\nebtablesRemoveTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, 1);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRemoveTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRemoveTmpSubChainsFW",
          "args": [
            "fw",
            "ifname"
          ],
          "line": 3554
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRemoveTmpSubChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2727-2732",
          "snippet": "static void\nebtablesRemoveTmpSubChainsFW(virFirewallPtr fw,\n                             const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host_temp);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);",
            "static char chainprefixes_host_temp[3] = {\n    CHAINPREFIX_HOST_IN_TEMP,\n    CHAINPREFIX_HOST_OUT_TEMP,\n    0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\nstatic char chainprefixes_host_temp[3] = {\n    CHAINPREFIX_HOST_IN_TEMP,\n    CHAINPREFIX_HOST_OUT_TEMP,\n    0\n};\n\nstatic void\nebtablesRemoveTmpSubChainsFW(virFirewallPtr fw,\n                             const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host_temp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRemoveTmpRootChainsFW",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "ifname"
          ],
          "line": 3551
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveTmpRootChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "548-556",
          "snippet": "static void\niptablesRemoveTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesRemoveTmpRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRemoveTmpRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRemoveTmpRootChainFW(fw, layer, 'H', true, ifname);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesRemoveTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesRemoveTmpRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRemoveTmpRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRemoveTmpRootChainFW(fw, layer, 'H', true, ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesUnlinkTmpRootChainsFW",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV4",
            "ifname"
          ],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesUnlinkTmpRootChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "728-736",
          "snippet": "static void\niptablesUnlinkTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesUnlinkTmpRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesUnlinkTmpRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesUnlinkTmpRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define HOST_IN_CHAIN      \"libvirt-host-in\"",
            "#define VIRT_OUT_CHAIN     \"libvirt-out\"",
            "#define VIRT_IN_CHAIN      \"libvirt-in\""
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define HOST_IN_CHAIN      \"libvirt-host-in\"\n#define VIRT_OUT_CHAIN     \"libvirt-out\"\n#define VIRT_IN_CHAIN      \"libvirt-in\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesUnlinkTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesUnlinkTmpRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesUnlinkTmpRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesUnlinkTmpRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesUnlinkTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesUnlinkTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2610-2615",
          "snippet": "static void\nebtablesUnlinkTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, 1);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesUnlinkTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallStartRollback",
          "args": [
            "fw",
            "0"
          ],
          "line": 3541
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallStartRollback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "622-637",
          "snippet": "void virFirewallStartRollback(virFirewallPtr firewall,\n                              unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (firewall->ngroups == 0) {\n        firewall->err = EINVAL;\n        return;\n    }\n\n    group = firewall->groups[firewall->ngroups-1];\n    group->rollbackFlags = flags;\n    group->addingRollback = true;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartRollback(virFirewallPtr firewall,\n                              unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (firewall->ngroups == 0) {\n        firewall->err = EINVAL;\n        return;\n    }\n\n    group = firewall->groups[firewall->ngroups-1];\n    group->rollbackFlags = flags;\n    group->addingRollback = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesLinkTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3539
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesLinkTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2516-2531",
          "snippet": "static void\nebtablesLinkTmpRootChainFW(virFirewallPtr fw,\n                           int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\",\n                       incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                       incoming ? \"-i\" : \"-o\",\n                       ifname, \"-j\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
            "#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"",
            "#define EBTABLES_CHAIN_INCOMING \"PREROUTING\""
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"\n#define EBTABLES_CHAIN_INCOMING \"PREROUTING\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesLinkTmpRootChainFW(virFirewallPtr fw,\n                           int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\",\n                       incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                       incoming ? \"-i\" : \"-o\",\n                       ifname, \"-j\", chain, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashSize",
          "args": [
            "chains_out_set"
          ],
          "line": 3538
        },
        "resolved": true,
        "details": {
          "function_name": "virHashSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "547-553",
          "snippet": "ssize_t\nvirHashSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->nbElems;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nssize_t\nvirHashSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->nbElems;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesCheckBridgeNFCallEnabled",
          "args": [
            "true"
          ],
          "line": 3533
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesCheckBridgeNFCallEnabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3165-3201",
          "snippet": "static void\niptablesCheckBridgeNFCallEnabled(bool isIPv6)\n{\n    static time_t lastReport, lastReportIPv6;\n    const char *pathname = NULL;\n    char buffer[1];\n    time_t now = time(NULL);\n\n    if (isIPv6 &&\n        (now - lastReportIPv6) > BRIDGE_NF_CALL_ALERT_INTERVAL) {\n        pathname = PROC_BRIDGE_NF_CALL_IP6TABLES;\n    } else if (now - lastReport > BRIDGE_NF_CALL_ALERT_INTERVAL) {\n        pathname = PROC_BRIDGE_NF_CALL_IPTABLES;\n    }\n\n    if (pathname) {\n        int fd = open(pathname, O_RDONLY);\n        if (fd >= 0) {\n            if (read(fd, buffer, 1) == 1) {\n                if (buffer[0] == '0') {\n                    char msg[256];\n                    g_snprintf(msg, sizeof(msg),\n                               _(\"To enable ip%stables filtering for the VM do \"\n                                \"'echo 1 > %s'\"),\n                               isIPv6 ? \"6\" : \"\",\n                               pathname);\n                    VIR_WARN(\"%s\", msg);\n                    if (isIPv6)\n                        lastReportIPv6 = now;\n                    else\n                        lastReport = now;\n                }\n            }\n            VIR_FORCE_CLOSE(fd);\n        }\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define BRIDGE_NF_CALL_ALERT_INTERVAL  10 /* seconds */",
            "#define PROC_BRIDGE_NF_CALL_IP6TABLES \\\n        \"/proc/sys/net/bridge/bridge-nf-call-ip6tables\"",
            "#define PROC_BRIDGE_NF_CALL_IPTABLES \\\n        \"/proc/sys/net/bridge/bridge-nf-call-iptables\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define BRIDGE_NF_CALL_ALERT_INTERVAL  10 /* seconds */\n#define PROC_BRIDGE_NF_CALL_IP6TABLES \\\n        \"/proc/sys/net/bridge/bridge-nf-call-ip6tables\"\n#define PROC_BRIDGE_NF_CALL_IPTABLES \\\n        \"/proc/sys/net/bridge/bridge-nf-call-iptables\"\n\nstatic void\niptablesCheckBridgeNFCallEnabled(bool isIPv6)\n{\n    static time_t lastReport, lastReportIPv6;\n    const char *pathname = NULL;\n    char buffer[1];\n    time_t now = time(NULL);\n\n    if (isIPv6 &&\n        (now - lastReportIPv6) > BRIDGE_NF_CALL_ALERT_INTERVAL) {\n        pathname = PROC_BRIDGE_NF_CALL_IP6TABLES;\n    } else if (now - lastReport > BRIDGE_NF_CALL_ALERT_INTERVAL) {\n        pathname = PROC_BRIDGE_NF_CALL_IPTABLES;\n    }\n\n    if (pathname) {\n        int fd = open(pathname, O_RDONLY);\n        if (fd >= 0) {\n            if (read(fd, buffer, 1) == 1) {\n                if (buffer[0] == '0') {\n                    char msg[256];\n                    g_snprintf(msg, sizeof(msg),\n                               _(\"To enable ip%stables filtering for the VM do \"\n                                \"'echo 1 > %s'\"),\n                               isIPv6 ? \"6\" : \"\",\n                               pathname);\n                    VIR_WARN(\"%s\", msg);\n                    if (isIPv6)\n                        lastReportIPv6 = now;\n                    else\n                        lastReport = now;\n                }\n            }\n            VIR_FORCE_CLOSE(fd);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesRuleInstCommand",
          "args": [
            "fw",
            "ifname",
            "rules[i]"
          ],
          "line": 3526
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRuleInstCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3221-3253",
          "snippet": "static int\niptablesRuleInstCommand(virFirewallPtr fw,\n                        const char *ifname,\n                        virNWFilterRuleInstPtr rule)\n{\n    virNWFilterVarCombIterPtr vciter, tmp;\n    int ret = -1;\n\n    /* rule->vars holds all the variables names that this rule will access.\n     * iterate over all combinations of the variables' values and instantiate\n     * the filtering rule with each combination.\n     */\n    tmp = vciter = virNWFilterVarCombIterCreate(rule->vars,\n                                                rule->def->varAccess,\n                                                rule->def->nVarAccess);\n    if (!vciter)\n        return -1;\n\n    do {\n        if (ebiptablesCreateRuleInstance(fw,\n                                         rule->chainSuffix,\n                                         rule->def,\n                                         ifname,\n                                         tmp) < 0)\n            goto cleanup;\n        tmp = virNWFilterVarCombIterNext(tmp);\n    } while (tmp != NULL);\n\n    ret = 0;\n cleanup:\n    virNWFilterVarCombIterFree(vciter);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\niptablesRuleInstCommand(virFirewallPtr fw,\n                        const char *ifname,\n                        virNWFilterRuleInstPtr rule)\n{\n    virNWFilterVarCombIterPtr vciter, tmp;\n    int ret = -1;\n\n    /* rule->vars holds all the variables names that this rule will access.\n     * iterate over all combinations of the variables' values and instantiate\n     * the filtering rule with each combination.\n     */\n    tmp = vciter = virNWFilterVarCombIterCreate(rule->vars,\n                                                rule->def->varAccess,\n                                                rule->def->nVarAccess);\n    if (!vciter)\n        return -1;\n\n    do {\n        if (ebiptablesCreateRuleInstance(fw,\n                                         rule->chainSuffix,\n                                         rule->def,\n                                         ifname,\n                                         tmp) < 0)\n            goto cleanup;\n        tmp = virNWFilterVarCombIterNext(tmp);\n    } while (tmp != NULL);\n\n    ret = 0;\n cleanup:\n    virNWFilterVarCombIterFree(vciter);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleIsProtocolIPv6",
          "args": [
            "rules[i]->def"
          ],
          "line": 3525
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleIsProtocolIPv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "3133-3140",
          "snippet": "bool\nvirNWFilterRuleIsProtocolIPv6(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType >= VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6 &&\n        rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6)\n        return true;\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirNWFilterRuleIsProtocolIPv6(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType >= VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6 &&\n        rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6)\n        return true;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesSetupVirtInPostFW",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "ifname"
          ],
          "line": 3522
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesSetupVirtInPostFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "612-626",
          "snippet": "static void\niptablesSetupVirtInPostFW(virFirewallPtr fw G_GNUC_UNUSED,\n                          virFirewallLayer layer G_GNUC_UNUSED,\n                          const char *ifname G_GNUC_UNUSED)\n{\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", VIRT_IN_POST_CHAIN,\n                           MATCH_PHYSDEV_IN_FW,\n                           ifname, \"-j\", \"ACCEPT\", NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-A\", VIRT_IN_POST_CHAIN,\n                       MATCH_PHYSDEV_IN_FW,\n                       ifname, \"-j\", \"ACCEPT\", NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"",
            "#define VIRT_IN_POST_CHAIN \"libvirt-in-post\""
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"\n#define VIRT_IN_POST_CHAIN \"libvirt-in-post\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesSetupVirtInPostFW(virFirewallPtr fw G_GNUC_UNUSED,\n                          virFirewallLayer layer G_GNUC_UNUSED,\n                          const char *ifname G_GNUC_UNUSED)\n{\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", VIRT_IN_POST_CHAIN,\n                           MATCH_PHYSDEV_IN_FW,\n                           ifname, \"-j\", \"ACCEPT\", NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-A\", VIRT_IN_POST_CHAIN,\n                       MATCH_PHYSDEV_IN_FW,\n                       ifname, \"-j\", \"ACCEPT\", NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesLinkTmpRootChainsFW",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "ifname"
          ],
          "line": 3521
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesLinkTmpRootChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "601-609",
          "snippet": "static void\niptablesLinkTmpRootChainsFW(virFirewallPtr fw,\n                            virFirewallLayer layer,\n                            const char *ifname)\n{\n    iptablesLinkTmpRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesLinkTmpRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesLinkTmpRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define HOST_IN_CHAIN      \"libvirt-host-in\"",
            "#define VIRT_OUT_CHAIN     \"libvirt-out\"",
            "#define VIRT_IN_CHAIN      \"libvirt-in\""
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define HOST_IN_CHAIN      \"libvirt-host-in\"\n#define VIRT_OUT_CHAIN     \"libvirt-out\"\n#define VIRT_IN_CHAIN      \"libvirt-in\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesLinkTmpRootChainsFW(virFirewallPtr fw,\n                            virFirewallLayer layer,\n                            const char *ifname)\n{\n    iptablesLinkTmpRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesLinkTmpRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesLinkTmpRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesCreateTmpRootChainsFW",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6",
            "ifname"
          ],
          "line": 3519
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesCreateTmpRootChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "484-492",
          "snippet": "static void\niptablesCreateTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesCreateTmpRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesCreateTmpRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesCreateTmpRootChainFW(fw, layer, 'H', true, ifname);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesCreateTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesCreateTmpRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesCreateTmpRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesCreateTmpRootChainFW(fw, layer, 'H', true, ifname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesCreateBaseChainsFW",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_IPV6"
          ],
          "line": 3518
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesCreateBaseChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "425-461",
          "snippet": "static void\niptablesCreateBaseChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer)\n{\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", VIRT_IN_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", VIRT_OUT_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", VIRT_IN_POST_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", HOST_IN_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"FORWARD\", \"-j\", VIRT_IN_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"FORWARD\", \"-j\", VIRT_OUT_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"FORWARD\", \"-j\", VIRT_IN_POST_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"INPUT\", \"-j\", HOST_IN_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"FORWARD\", \"1\", \"-j\", VIRT_IN_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"FORWARD\", \"2\", \"-j\", VIRT_OUT_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"FORWARD\", \"3\", \"-j\", VIRT_IN_POST_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"INPUT\", \"1\", \"-j\", HOST_IN_CHAIN, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define HOST_IN_CHAIN      \"libvirt-host-in\"",
            "#define VIRT_IN_POST_CHAIN \"libvirt-in-post\"",
            "#define VIRT_OUT_CHAIN     \"libvirt-out\"",
            "#define VIRT_IN_CHAIN      \"libvirt-in\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define HOST_IN_CHAIN      \"libvirt-host-in\"\n#define VIRT_IN_POST_CHAIN \"libvirt-in-post\"\n#define VIRT_OUT_CHAIN     \"libvirt-out\"\n#define VIRT_IN_CHAIN      \"libvirt-in\"\n\nstatic void\niptablesCreateBaseChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer)\n{\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", VIRT_IN_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", VIRT_OUT_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", VIRT_IN_POST_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", HOST_IN_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"FORWARD\", \"-j\", VIRT_IN_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"FORWARD\", \"-j\", VIRT_OUT_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"FORWARD\", \"-j\", VIRT_IN_POST_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"INPUT\", \"-j\", HOST_IN_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"FORWARD\", \"1\", \"-j\", VIRT_IN_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"FORWARD\", \"2\", \"-j\", VIRT_OUT_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"FORWARD\", \"3\", \"-j\", VIRT_IN_POST_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"INPUT\", \"1\", \"-j\", HOST_IN_CHAIN, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleIsProtocolIPv4",
          "args": [
            "rules[i]->def"
          ],
          "line": 3503
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleIsProtocolIPv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "3123-3130",
          "snippet": "bool\nvirNWFilterRuleIsProtocolIPv4(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType >= VIR_NWFILTER_RULE_PROTOCOL_TCP &&\n        rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_ALL)\n        return true;\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirNWFilterRuleIsProtocolIPv4(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType >= VIR_NWFILTER_RULE_PROTOCOL_TCP &&\n        rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_ALL)\n        return true;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesCreateTmpSubChainFW",
          "args": [
            "fw",
            "subchains[j]->incoming",
            "ifname",
            "subchains[j]->protoidx",
            "subchains[j]->filtername"
          ],
          "line": 3483
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesCreateTmpSubChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2617-2662",
          "snippet": "static void\nebtablesCreateTmpSubChainFW(virFirewallPtr fw,\n                            bool incoming,\n                            const char *ifname,\n                            enum l3_proto_idx protoidx,\n                            const char *filtername)\n{\n    char rootchain[MAX_CHAINNAME_LENGTH], chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                : CHAINPREFIX_HOST_OUT_TEMP;\n    virFirewallRulePtr fwrule;\n\n    PRINT_ROOT_CHAIN(rootchain, chainPrefix, ifname);\n    PRINT_CHAIN(chain, chainPrefix, ifname,\n                (filtername) ? filtername : l3_protocols[protoidx].val);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-X\", chain, NULL);\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-N\", chain, NULL);\n\n    fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                \"-t\", \"nat\", \"-A\", rootchain, NULL);\n\n    switch ((int)protoidx) {\n    case L2_PROTO_MAC_IDX:\n        break;\n    case L2_PROTO_STP_IDX:\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-d\", NWFILTER_MAC_BGA, NULL);\n        break;\n    default:\n        virFirewallRuleAddArg(fw, fwrule, \"-p\");\n        virFirewallRuleAddArgFormat(fw, fwrule,\n                                    \"0x%04x\",\n                                    l3_protocols[protoidx].attr);\n        break;\n    }\n\n    virFirewallRuleAddArgList(fw, fwrule,\n                              \"-j\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);",
            "static const struct ushort_map l3_protocols[] = {\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV4_IDX, ETHERTYPE_IP,     \"ipv4\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV6_IDX, ETHERTYPE_IPV6,   \"ipv6\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_ARP_IDX,  ETHERTYPE_ARP,    \"arp\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_RARP_IDX, ETHERTYPE_REVARP, \"rarp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_VLAN_IDX, ETHERTYPE_VLAN,   \"vlan\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_STP_IDX,  0,                \"stp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_MAC_IDX,  0,                \"mac\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_LAST_IDX, 0,                NULL),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\nstatic const struct ushort_map l3_protocols[] = {\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV4_IDX, ETHERTYPE_IP,     \"ipv4\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV6_IDX, ETHERTYPE_IPV6,   \"ipv6\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_ARP_IDX,  ETHERTYPE_ARP,    \"arp\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_RARP_IDX, ETHERTYPE_REVARP, \"rarp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_VLAN_IDX, ETHERTYPE_VLAN,   \"vlan\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_STP_IDX,  0,                \"stp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_MAC_IDX,  0,                \"mac\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_LAST_IDX, 0,                NULL),\n};\n\nstatic void\nebtablesCreateTmpSubChainFW(virFirewallPtr fw,\n                            bool incoming,\n                            const char *ifname,\n                            enum l3_proto_idx protoidx,\n                            const char *filtername)\n{\n    char rootchain[MAX_CHAINNAME_LENGTH], chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                : CHAINPREFIX_HOST_OUT_TEMP;\n    virFirewallRulePtr fwrule;\n\n    PRINT_ROOT_CHAIN(rootchain, chainPrefix, ifname);\n    PRINT_CHAIN(chain, chainPrefix, ifname,\n                (filtername) ? filtername : l3_protocols[protoidx].val);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-X\", chain, NULL);\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-N\", chain, NULL);\n\n    fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                \"-t\", \"nat\", \"-A\", rootchain, NULL);\n\n    switch ((int)protoidx) {\n    case L2_PROTO_MAC_IDX:\n        break;\n    case L2_PROTO_STP_IDX:\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-d\", NWFILTER_MAC_BGA, NULL);\n        break;\n    default:\n        virFirewallRuleAddArg(fw, fwrule, \"-p\");\n        virFirewallRuleAddArgFormat(fw, fwrule,\n                                    \"0x%04x\",\n                                    l3_protocols[protoidx].attr);\n        break;\n    }\n\n    virFirewallRuleAddArgList(fw, fwrule,\n                              \"-j\", chain, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRuleInstCommand",
          "args": [
            "fw",
            "ifname",
            "rules[i]"
          ],
          "line": 3476
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRuleInstCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3256-3288",
          "snippet": "static int\nebtablesRuleInstCommand(virFirewallPtr fw,\n                        const char *ifname,\n                        virNWFilterRuleInstPtr rule)\n{\n    virNWFilterVarCombIterPtr vciter, tmp;\n    int ret = -1;\n\n    /* rule->vars holds all the variables names that this rule will access.\n     * iterate over all combinations of the variables' values and instantiate\n     * the filtering rule with each combination.\n     */\n    tmp = vciter = virNWFilterVarCombIterCreate(rule->vars,\n                                                rule->def->varAccess,\n                                                rule->def->nVarAccess);\n    if (!vciter)\n        return -1;\n\n    do {\n        if (ebiptablesCreateRuleInstance(fw,\n                                         rule->chainSuffix,\n                                         rule->def,\n                                         ifname,\n                                         tmp) < 0)\n            goto cleanup;\n        tmp = virNWFilterVarCombIterNext(tmp);\n    } while (tmp != NULL);\n\n    ret = 0;\n cleanup:\n    virNWFilterVarCombIterFree(vciter);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebtablesRuleInstCommand(virFirewallPtr fw,\n                        const char *ifname,\n                        virNWFilterRuleInstPtr rule)\n{\n    virNWFilterVarCombIterPtr vciter, tmp;\n    int ret = -1;\n\n    /* rule->vars holds all the variables names that this rule will access.\n     * iterate over all combinations of the variables' values and instantiate\n     * the filtering rule with each combination.\n     */\n    tmp = vciter = virNWFilterVarCombIterCreate(rule->vars,\n                                                rule->def->varAccess,\n                                                rule->def->nVarAccess);\n    if (!vciter)\n        return -1;\n\n    do {\n        if (ebiptablesCreateRuleInstance(fw,\n                                         rule->chainSuffix,\n                                         rule->def,\n                                         ifname,\n                                         tmp) < 0)\n            goto cleanup;\n        tmp = virNWFilterVarCombIterNext(tmp);\n    } while (tmp != NULL);\n\n    ret = 0;\n cleanup:\n    virNWFilterVarCombIterFree(vciter);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleIsProtocolEthernet",
          "args": [
            "rules[i]->def"
          ],
          "line": 3466
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleIsProtocolEthernet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "3143-3149",
          "snippet": "bool\nvirNWFilterRuleIsProtocolEthernet(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_IPV6)\n        return true;\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirNWFilterRuleIsProtocolEthernet(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_IPV6)\n        return true;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "subchains",
            "nsubchains",
            "sizeof(subchains[0])",
            "ebtablesSubChainInstSort"
          ],
          "line": 3462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebtablesGetSubChainInsts",
          "args": [
            "chains_out_set",
            "false",
            "&subchains",
            "&nsubchains"
          ],
          "line": 3454
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesGetSubChainInsts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3309-3357",
          "snippet": "static int\nebtablesGetSubChainInsts(virHashTablePtr chains,\n                         bool incoming,\n                         struct ebtablesSubChainInst ***insts,\n                         size_t *ninsts)\n{\n    virHashKeyValuePairPtr filter_names;\n    size_t i;\n    int ret = -1;\n\n    filter_names = virHashGetItems(chains,\n                                   ebiptablesFilterOrderSort);\n    if (filter_names == NULL)\n        return -1;\n\n    for (i = 0; filter_names[i].key; i++) {\n        struct ebtablesSubChainInst *inst;\n        enum l3_proto_idx idx = ebtablesGetProtoIdxByFiltername(\n                                  filter_names[i].key);\n\n        if ((int)idx < 0)\n            continue;\n\n        if (VIR_ALLOC(inst) < 0)\n            goto cleanup;\n        inst->priority = *(const virNWFilterChainPriority *)filter_names[i].value;\n        inst->incoming = incoming;\n        inst->protoidx = idx;\n        inst->filtername = filter_names[i].key;\n\n        if (VIR_APPEND_ELEMENT(*insts, *ninsts, inst) < 0) {\n            VIR_FREE(inst);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(filter_names);\n    if (ret < 0) {\n        for (i = 0; i < *ninsts; i++)\n            VIR_FREE(*insts[i]);\n        VIR_FREE(*insts);\n        *ninsts = 0;\n    }\n    return ret;\n\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nebtablesGetSubChainInsts(virHashTablePtr chains,\n                         bool incoming,\n                         struct ebtablesSubChainInst ***insts,\n                         size_t *ninsts)\n{\n    virHashKeyValuePairPtr filter_names;\n    size_t i;\n    int ret = -1;\n\n    filter_names = virHashGetItems(chains,\n                                   ebiptablesFilterOrderSort);\n    if (filter_names == NULL)\n        return -1;\n\n    for (i = 0; filter_names[i].key; i++) {\n        struct ebtablesSubChainInst *inst;\n        enum l3_proto_idx idx = ebtablesGetProtoIdxByFiltername(\n                                  filter_names[i].key);\n\n        if ((int)idx < 0)\n            continue;\n\n        if (VIR_ALLOC(inst) < 0)\n            goto cleanup;\n        inst->priority = *(const virNWFilterChainPriority *)filter_names[i].value;\n        inst->incoming = incoming;\n        inst->protoidx = idx;\n        inst->filtername = filter_names[i].key;\n\n        if (VIR_APPEND_ELEMENT(*insts, *ninsts, inst) < 0) {\n            VIR_FREE(inst);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(filter_names);\n    if (ret < 0) {\n        for (i = 0; i < *ninsts; i++)\n            VIR_FREE(*insts[i]);\n        VIR_FREE(*insts);\n        *ninsts = 0;\n    }\n    return ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesCreateTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3453
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesCreateTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2501-2513",
          "snippet": "static void\nebtablesCreateTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = (incoming) ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-N\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesCreateTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = (incoming) ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-N\", chain, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashUpdateEntry",
          "args": [
            "chains_out_set",
            "name",
            "&rules[i]->chainPriority"
          ],
          "line": 3436
        },
        "resolved": true,
        "details": {
          "function_name": "virHashUpdateEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "422-427",
          "snippet": "int\nvirHashUpdateEntry(virHashTablePtr table, const void *name,\n                   void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, true);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashUpdateEntry(virHashTablePtr table, const void *name,\n                   void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "\"root\"",
            "rules[i]->chainSuffix"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallStartTransaction",
          "args": [
            "fw",
            "0"
          ],
          "line": 3391
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallStartTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "586-607",
          "snippet": "void virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "rules",
            "nrules",
            "sizeof(rules[0])",
            "virNWFilterRuleInstSortPtr"
          ],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "10",
            "NULL"
          ],
          "line": 3367
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallNew",
          "args": [],
          "line": 3365
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "231-242",
          "snippet": "virFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebiptablesApplyNewRules(const char *ifname,\n                        virNWFilterRuleInstPtr *rules,\n                        size_t nrules)\n{\n    size_t i, j;\n    virFirewallPtr fw = virFirewallNew();\n    virHashTablePtr chains_in_set  = virHashCreate(10, NULL);\n    virHashTablePtr chains_out_set = virHashCreate(10, NULL);\n    bool haveEbtables = false;\n    bool haveIptables = false;\n    bool haveIp6tables = false;\n    char *errmsg = NULL;\n    struct ebtablesSubChainInst **subchains = NULL;\n    size_t nsubchains = 0;\n    int ret = -1;\n\n    if (!chains_in_set || !chains_out_set)\n        goto cleanup;\n\n    if (nrules)\n        qsort(rules, nrules, sizeof(rules[0]),\n              virNWFilterRuleInstSortPtr);\n\n    /* cleanup whatever may exist */\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n\n    virFirewallStartTransaction(fw, 0);\n\n    /* walk the list of rules and increase the priority\n     * of rules in case the chain priority is of higher value;\n     * this preserves the order of the rules and ensures that\n     * the chain will be created before the chain's rules\n     * are created; don't adjust rules in the root chain\n     * example: a rule of priority -510 will be adjusted to\n     * priority -500 and the chain with priority -500 will\n     * then be created before it.\n     */\n    for (i = 0; i < nrules; i++) {\n        if (rules[i]->chainPriority > rules[i]->priority &&\n            !strstr(\"root\", rules[i]->chainSuffix)) {\n\n             rules[i]->priority = rules[i]->chainPriority;\n        }\n    }\n\n    for (i = 0; i < nrules; i++) {\n        if (virNWFilterRuleIsProtocolEthernet(rules[i]->def)) {\n            haveEbtables = true;\n        } else {\n            if (virNWFilterRuleIsProtocolIPv4(rules[i]->def))\n                haveIptables = true;\n            else if (virNWFilterRuleIsProtocolIPv6(rules[i]->def))\n                haveIp6tables = true;\n        }\n    }\n    /* process ebtables commands; interleave commands from filters with\n       commands for creating and connecting ebtables chains */\n    if (haveEbtables) {\n\n        /* scan the rules to see which chains need to be created */\n        for (i = 0; i < nrules; i++) {\n            if (virNWFilterRuleIsProtocolEthernet(rules[i]->def)) {\n                const char *name = rules[i]->chainSuffix;\n                if (rules[i]->def->tt == VIR_NWFILTER_RULE_DIRECTION_OUT ||\n                    rules[i]->def->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n                    if (virHashUpdateEntry(chains_in_set, name,\n                                           &rules[i]->chainPriority) < 0)\n                        goto cleanup;\n                }\n                if (rules[i]->def->tt == VIR_NWFILTER_RULE_DIRECTION_IN ||\n                    rules[i]->def->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n                    if (virHashUpdateEntry(chains_out_set, name,\n                                           &rules[i]->chainPriority) < 0)\n                        goto cleanup;\n                }\n            }\n        }\n\n        /* create needed chains */\n        if (virHashSize(chains_in_set) > 0) {\n            ebtablesCreateTmpRootChainFW(fw, true, ifname);\n            if (ebtablesGetSubChainInsts(chains_in_set,\n                                         true,\n                                         &subchains,\n                                         &nsubchains) < 0)\n                goto cleanup;\n        }\n        if (virHashSize(chains_out_set) > 0) {\n            ebtablesCreateTmpRootChainFW(fw, false, ifname);\n            if (ebtablesGetSubChainInsts(chains_out_set,\n                                         false,\n                                         &subchains,\n                                         &nsubchains) < 0)\n                goto cleanup;\n        }\n\n        if (nsubchains > 0)\n            qsort(subchains, nsubchains, sizeof(subchains[0]),\n                  ebtablesSubChainInstSort);\n\n        for (i = 0, j = 0; i < nrules; i++) {\n            if (virNWFilterRuleIsProtocolEthernet(rules[i]->def)) {\n                while (j < nsubchains &&\n                       subchains[j]->priority <= rules[i]->priority) {\n                    ebtablesCreateTmpSubChainFW(fw,\n                                                subchains[j]->incoming,\n                                                ifname,\n                                                subchains[j]->protoidx,\n                                                subchains[j]->filtername);\n                    j++;\n                }\n                if (ebtablesRuleInstCommand(fw,\n                                            ifname,\n                                            rules[i]) < 0)\n                    goto cleanup;\n            }\n        }\n        while (j < nsubchains) {\n            ebtablesCreateTmpSubChainFW(fw,\n                                        subchains[j]->incoming,\n                                        ifname,\n                                        subchains[j]->protoidx,\n                                        subchains[j]->filtername);\n            j++;\n        }\n    }\n\n    if (haveIptables) {\n        iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n        iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n        iptablesCreateBaseChainsFW(fw, VIR_FIREWALL_LAYER_IPV4);\n        iptablesCreateTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n        iptablesLinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n        iptablesSetupVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n        for (i = 0; i < nrules; i++) {\n            if (virNWFilterRuleIsProtocolIPv4(rules[i]->def)) {\n                if (iptablesRuleInstCommand(fw,\n                                            ifname,\n                                            rules[i]) < 0)\n                    goto cleanup;\n            }\n        }\n\n        iptablesCheckBridgeNFCallEnabled(false);\n    }\n\n    if (haveIp6tables) {\n        iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n        iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n        iptablesCreateBaseChainsFW(fw, VIR_FIREWALL_LAYER_IPV6);\n        iptablesCreateTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n        iptablesLinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n        iptablesSetupVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n        for (i = 0; i < nrules; i++) {\n            if (virNWFilterRuleIsProtocolIPv6(rules[i]->def)) {\n                if (iptablesRuleInstCommand(fw,\n                                            ifname,\n                                            rules[i]) < 0)\n                    goto cleanup;\n            }\n        }\n\n        iptablesCheckBridgeNFCallEnabled(true);\n    }\n\n    if (virHashSize(chains_in_set) != 0)\n        ebtablesLinkTmpRootChainFW(fw, true, ifname);\n    if (virHashSize(chains_out_set) != 0)\n        ebtablesLinkTmpRootChainFW(fw, false, ifname);\n\n    virFirewallStartRollback(fw, 0);\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    if (haveIp6tables) {\n        iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n        iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    }\n\n    if (haveIptables) {\n        iptablesUnlinkTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n        iptablesRemoveTmpRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    }\n\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n\n    if (virFirewallApply(fw) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    for (i = 0; i < nsubchains; i++)\n        VIR_FREE(subchains[i]);\n    VIR_FREE(subchains);\n    virFirewallFree(fw);\n    virHashFree(chains_in_set);\n    virHashFree(chains_out_set);\n\n    VIR_FREE(errmsg);\n    return ret;\n}"
  },
  {
    "function_name": "ebtablesGetSubChainInsts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3309-3357",
    "snippet": "static int\nebtablesGetSubChainInsts(virHashTablePtr chains,\n                         bool incoming,\n                         struct ebtablesSubChainInst ***insts,\n                         size_t *ninsts)\n{\n    virHashKeyValuePairPtr filter_names;\n    size_t i;\n    int ret = -1;\n\n    filter_names = virHashGetItems(chains,\n                                   ebiptablesFilterOrderSort);\n    if (filter_names == NULL)\n        return -1;\n\n    for (i = 0; filter_names[i].key; i++) {\n        struct ebtablesSubChainInst *inst;\n        enum l3_proto_idx idx = ebtablesGetProtoIdxByFiltername(\n                                  filter_names[i].key);\n\n        if ((int)idx < 0)\n            continue;\n\n        if (VIR_ALLOC(inst) < 0)\n            goto cleanup;\n        inst->priority = *(const virNWFilterChainPriority *)filter_names[i].value;\n        inst->incoming = incoming;\n        inst->protoidx = idx;\n        inst->filtername = filter_names[i].key;\n\n        if (VIR_APPEND_ELEMENT(*insts, *ninsts, inst) < 0) {\n            VIR_FREE(inst);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(filter_names);\n    if (ret < 0) {\n        for (i = 0; i < *ninsts; i++)\n            VIR_FREE(*insts[i]);\n        VIR_FREE(*insts);\n        *ninsts = 0;\n    }\n    return ret;\n\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*insts"
          ],
          "line": 3352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*insts[i]"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "filter_names"
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "inst"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "*insts",
            "*ninsts",
            "inst"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "inst"
          ],
          "line": 3332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebtablesGetProtoIdxByFiltername",
          "args": [
            "filter_names[i].key"
          ],
          "line": 3326
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesGetProtoIdxByFiltername",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3207-3218",
          "snippet": "static enum l3_proto_idx\nebtablesGetProtoIdxByFiltername(const char *filtername)\n{\n    enum l3_proto_idx idx;\n\n    for (idx = 0; idx < L3_PROTO_LAST_IDX; idx++) {\n        if (STRPREFIX(filtername, l3_protocols[idx].val))\n            return idx;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct ushort_map l3_protocols[] = {\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV4_IDX, ETHERTYPE_IP,     \"ipv4\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV6_IDX, ETHERTYPE_IPV6,   \"ipv6\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_ARP_IDX,  ETHERTYPE_ARP,    \"arp\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_RARP_IDX, ETHERTYPE_REVARP, \"rarp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_VLAN_IDX, ETHERTYPE_VLAN,   \"vlan\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_STP_IDX,  0,                \"stp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_MAC_IDX,  0,                \"mac\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_LAST_IDX, 0,                NULL),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic const struct ushort_map l3_protocols[] = {\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV4_IDX, ETHERTYPE_IP,     \"ipv4\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV6_IDX, ETHERTYPE_IPV6,   \"ipv6\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_ARP_IDX,  ETHERTYPE_ARP,    \"arp\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_RARP_IDX, ETHERTYPE_REVARP, \"rarp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_VLAN_IDX, ETHERTYPE_VLAN,   \"vlan\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_STP_IDX,  0,                \"stp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_MAC_IDX,  0,                \"mac\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_LAST_IDX, 0,                NULL),\n};\n\nstatic enum l3_proto_idx\nebtablesGetProtoIdxByFiltername(const char *filtername)\n{\n    enum l3_proto_idx idx;\n\n    for (idx = 0; idx < L3_PROTO_LAST_IDX; idx++) {\n        if (STRPREFIX(filtername, l3_protocols[idx].val))\n            return idx;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashGetItems",
          "args": [
            "chains",
            "ebiptablesFilterOrderSort"
          ],
          "line": 3319
        },
        "resolved": true,
        "details": {
          "function_name": "virHashGetItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "783-805",
          "snippet": "virHashKeyValuePairPtr virHashGetItems(virHashTablePtr table,\n                                       virHashKeyComparator compar)\n{\n    ssize_t numElems = virHashSize(table);\n    struct getKeysIter iter = {\n        .arrayIdx = 0,\n        .sortArray = NULL,\n    };\n\n    if (numElems < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(iter.sortArray, numElems + 1))\n        return NULL;\n\n    virHashForEach(table, virHashGetKeysIterator, &iter);\n\n    if (compar)\n        qsort(&iter.sortArray[0], numElems, sizeof(iter.sortArray[0]),\n              (qsort_comp)compar);\n\n    return iter.sortArray;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashKeyValuePairPtr virHashGetItems(virHashTablePtr table,\n                                       virHashKeyComparator compar)\n{\n    ssize_t numElems = virHashSize(table);\n    struct getKeysIter iter = {\n        .arrayIdx = 0,\n        .sortArray = NULL,\n    };\n\n    if (numElems < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(iter.sortArray, numElems + 1))\n        return NULL;\n\n    virHashForEach(table, virHashGetKeysIterator, &iter);\n\n    if (compar)\n        qsort(&iter.sortArray[0], numElems, sizeof(iter.sortArray[0]),\n              (qsort_comp)compar);\n\n    return iter.sortArray;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nebtablesGetSubChainInsts(virHashTablePtr chains,\n                         bool incoming,\n                         struct ebtablesSubChainInst ***insts,\n                         size_t *ninsts)\n{\n    virHashKeyValuePairPtr filter_names;\n    size_t i;\n    int ret = -1;\n\n    filter_names = virHashGetItems(chains,\n                                   ebiptablesFilterOrderSort);\n    if (filter_names == NULL)\n        return -1;\n\n    for (i = 0; filter_names[i].key; i++) {\n        struct ebtablesSubChainInst *inst;\n        enum l3_proto_idx idx = ebtablesGetProtoIdxByFiltername(\n                                  filter_names[i].key);\n\n        if ((int)idx < 0)\n            continue;\n\n        if (VIR_ALLOC(inst) < 0)\n            goto cleanup;\n        inst->priority = *(const virNWFilterChainPriority *)filter_names[i].value;\n        inst->incoming = incoming;\n        inst->protoidx = idx;\n        inst->filtername = filter_names[i].key;\n\n        if (VIR_APPEND_ELEMENT(*insts, *ninsts, inst) < 0) {\n            VIR_FREE(inst);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(filter_names);\n    if (ret < 0) {\n        for (i = 0; i < *ninsts; i++)\n            VIR_FREE(*insts[i]);\n        VIR_FREE(*insts);\n        *ninsts = 0;\n    }\n    return ret;\n\n}"
  },
  {
    "function_name": "ebtablesSubChainInstSort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3298-3306",
    "snippet": "static int\nebtablesSubChainInstSort(const void *a, const void *b)\n{\n    const struct ebtablesSubChainInst **insta = (const struct ebtablesSubChainInst **)a;\n    const struct ebtablesSubChainInst **instb = (const struct ebtablesSubChainInst **)b;\n\n    /* priorities are limited to range [-1000, 1000] */\n    return (*insta)->priority - (*instb)->priority;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nebtablesSubChainInstSort(const void *a, const void *b)\n{\n    const struct ebtablesSubChainInst **insta = (const struct ebtablesSubChainInst **)a;\n    const struct ebtablesSubChainInst **instb = (const struct ebtablesSubChainInst **)b;\n\n    /* priorities are limited to range [-1000, 1000] */\n    return (*insta)->priority - (*instb)->priority;\n}"
  },
  {
    "function_name": "ebtablesRuleInstCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3256-3288",
    "snippet": "static int\nebtablesRuleInstCommand(virFirewallPtr fw,\n                        const char *ifname,\n                        virNWFilterRuleInstPtr rule)\n{\n    virNWFilterVarCombIterPtr vciter, tmp;\n    int ret = -1;\n\n    /* rule->vars holds all the variables names that this rule will access.\n     * iterate over all combinations of the variables' values and instantiate\n     * the filtering rule with each combination.\n     */\n    tmp = vciter = virNWFilterVarCombIterCreate(rule->vars,\n                                                rule->def->varAccess,\n                                                rule->def->nVarAccess);\n    if (!vciter)\n        return -1;\n\n    do {\n        if (ebiptablesCreateRuleInstance(fw,\n                                         rule->chainSuffix,\n                                         rule->def,\n                                         ifname,\n                                         tmp) < 0)\n            goto cleanup;\n        tmp = virNWFilterVarCombIterNext(tmp);\n    } while (tmp != NULL);\n\n    ret = 0;\n cleanup:\n    virNWFilterVarCombIterFree(vciter);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterVarCombIterFree",
          "args": [
            "vciter"
          ],
          "line": 3286
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarCombIterFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "308-320",
          "snippet": "void\nvirNWFilterVarCombIterFree(virNWFilterVarCombIterPtr ci)\n{\n    size_t i;\n\n    if (!ci)\n        return;\n\n    for (i = 0; i < ci->nIter; i++)\n        VIR_FREE(ci->iter[i].varNames);\n\n    VIR_FREE(ci);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirNWFilterVarCombIterFree(virNWFilterVarCombIterPtr ci)\n{\n    size_t i;\n\n    if (!ci)\n        return;\n\n    for (i = 0; i < ci->nIter; i++)\n        VIR_FREE(ci->iter[i].varNames);\n\n    VIR_FREE(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterVarCombIterNext",
          "args": [
            "tmp"
          ],
          "line": 3281
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarCombIterNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "526-548",
          "snippet": "virNWFilterVarCombIterPtr\nvirNWFilterVarCombIterNext(virNWFilterVarCombIterPtr ci)\n{\n    size_t i;\n\n    for (i = 0; i < ci->nIter; i++) {\n next:\n        ci->iter[i].curValue++;\n        if (ci->iter[i].curValue <= ci->iter[i].maxValue) {\n            if (!virNWFilterVarCombIterEntryAreUniqueEntries(\n                                              &ci->iter[i], ci->hashTable))\n                goto next;\n            break;\n        } else {\n            ci->iter[i].curValue = ci->iter[i].minValue;\n        }\n    }\n\n    if (ci->nIter == i)\n        return NULL;\n\n    return ci;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirNWFilterVarCombIterPtr\nvirNWFilterVarCombIterNext(virNWFilterVarCombIterPtr ci)\n{\n    size_t i;\n\n    for (i = 0; i < ci->nIter; i++) {\n next:\n        ci->iter[i].curValue++;\n        if (ci->iter[i].curValue <= ci->iter[i].maxValue) {\n            if (!virNWFilterVarCombIterEntryAreUniqueEntries(\n                                              &ci->iter[i], ci->hashTable))\n                goto next;\n            break;\n        } else {\n            ci->iter[i].curValue = ci->iter[i].minValue;\n        }\n    }\n\n    if (ci->nIter == i)\n        return NULL;\n\n    return ci;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebiptablesCreateRuleInstance",
          "args": [
            "fw",
            "rule->chainSuffix",
            "rule->def",
            "ifname",
            "tmp"
          ],
          "line": 3275
        },
        "resolved": true,
        "details": {
          "function_name": "ebiptablesCreateRuleInstance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2446-2498",
          "snippet": "static int\nebiptablesCreateRuleInstance(virFirewallPtr fw,\n                             const char *chainSuffix,\n                             virNWFilterRuleDefPtr rule,\n                             const char *ifname,\n                             virNWFilterVarCombIterPtr vars)\n{\n    if (virNWFilterRuleIsProtocolEthernet(rule)) {\n        if (rule->tt == VIR_NWFILTER_RULE_DIRECTION_OUT ||\n            rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n            if (ebtablesCreateRuleInstance(fw,\n                                           CHAINPREFIX_HOST_IN_TEMP,\n                                           chainSuffix,\n                                           rule,\n                                           ifname,\n                                           vars,\n                                           rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) < 0)\n                return -1;\n        }\n\n        if (rule->tt == VIR_NWFILTER_RULE_DIRECTION_IN ||\n            rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n            if (ebtablesCreateRuleInstance(fw,\n                                           CHAINPREFIX_HOST_OUT_TEMP,\n                                           chainSuffix,\n                                           rule,\n                                           ifname,\n                                           vars,\n                                           false) < 0)\n                return -1;\n        }\n    } else {\n        virFirewallLayer layer;\n        if (virNWFilterRuleIsProtocolIPv6(rule)) {\n            layer = VIR_FIREWALL_LAYER_IPV6;\n        } else if (virNWFilterRuleIsProtocolIPv4(rule)) {\n            layer = VIR_FIREWALL_LAYER_IPV4;\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           \"%s\", _(\"unexpected protocol type\"));\n            return -1;\n        }\n\n        if (iptablesCreateRuleInstance(fw,\n                                       layer,\n                                       rule,\n                                       ifname,\n                                       vars) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebiptablesCreateRuleInstance(virFirewallPtr fw,\n                             const char *chainSuffix,\n                             virNWFilterRuleDefPtr rule,\n                             const char *ifname,\n                             virNWFilterVarCombIterPtr vars)\n{\n    if (virNWFilterRuleIsProtocolEthernet(rule)) {\n        if (rule->tt == VIR_NWFILTER_RULE_DIRECTION_OUT ||\n            rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n            if (ebtablesCreateRuleInstance(fw,\n                                           CHAINPREFIX_HOST_IN_TEMP,\n                                           chainSuffix,\n                                           rule,\n                                           ifname,\n                                           vars,\n                                           rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) < 0)\n                return -1;\n        }\n\n        if (rule->tt == VIR_NWFILTER_RULE_DIRECTION_IN ||\n            rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n            if (ebtablesCreateRuleInstance(fw,\n                                           CHAINPREFIX_HOST_OUT_TEMP,\n                                           chainSuffix,\n                                           rule,\n                                           ifname,\n                                           vars,\n                                           false) < 0)\n                return -1;\n        }\n    } else {\n        virFirewallLayer layer;\n        if (virNWFilterRuleIsProtocolIPv6(rule)) {\n            layer = VIR_FIREWALL_LAYER_IPV6;\n        } else if (virNWFilterRuleIsProtocolIPv4(rule)) {\n            layer = VIR_FIREWALL_LAYER_IPV4;\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           \"%s\", _(\"unexpected protocol type\"));\n            return -1;\n        }\n\n        if (iptablesCreateRuleInstance(fw,\n                                       layer,\n                                       rule,\n                                       ifname,\n                                       vars) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterVarCombIterCreate",
          "args": [
            "rule->vars",
            "rule->def->varAccess",
            "rule->def->nVarAccess"
          ],
          "line": 3268
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarCombIterCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "469-524",
          "snippet": "virNWFilterVarCombIterPtr\nvirNWFilterVarCombIterCreate(virHashTablePtr hash,\n                             virNWFilterVarAccessPtr *varAccess,\n                             size_t nVarAccess)\n{\n    virNWFilterVarCombIterPtr res;\n    size_t i;\n    unsigned int iterId;\n    int iterIndex = -1;\n    unsigned int nextIntIterId = VIR_NWFILTER_MAX_ITERID + 1;\n\n    if (VIR_ALLOC_VAR(res, virNWFilterVarCombIterEntry, 1 + nVarAccess) < 0)\n        return NULL;\n\n    res->hashTable = hash;\n\n    /* create the default iterator to support @0 */\n    iterId = 0;\n\n    res->nIter = 1;\n    virNWFilterVarCombIterEntryInit(&res->iter[0], iterId);\n\n    for (i = 0; i < nVarAccess; i++) {\n        switch (virNWFilterVarAccessGetType(varAccess[i])) {\n        case VIR_NWFILTER_VAR_ACCESS_ITERATOR:\n            iterId = virNWFilterVarAccessGetIterId(varAccess[i]);\n            iterIndex = virNWFilterVarCombIterGetIndexByIterId(res, iterId);\n            if (iterIndex < 0) {\n                iterIndex = res->nIter;\n                virNWFilterVarCombIterEntryInit(&res->iter[iterIndex], iterId);\n                res->nIter++;\n            }\n            break;\n        case VIR_NWFILTER_VAR_ACCESS_ELEMENT:\n            iterIndex = res->nIter;\n            virNWFilterVarAccessSetIntIterId(varAccess[i], nextIntIterId);\n            virNWFilterVarCombIterEntryInit(&res->iter[iterIndex],\n                                            nextIntIterId);\n            nextIntIterId++;\n            res->nIter++;\n            break;\n        case VIR_NWFILTER_VAR_ACCESS_LAST:\n            goto err_exit;\n        }\n\n        if (virNWFilterVarCombIterAddVariable(&res->iter[iterIndex],\n                                              hash, varAccess[i]) < 0)\n            goto err_exit;\n    }\n\n    return res;\n\n err_exit:\n    virNWFilterVarCombIterFree(res);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNWFilterVarAccessSetIntIterId(virNWFilterVarAccessPtr,\n                                             unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNWFilterVarAccessSetIntIterId(virNWFilterVarAccessPtr,\n                                             unsigned int);\n\nvirNWFilterVarCombIterPtr\nvirNWFilterVarCombIterCreate(virHashTablePtr hash,\n                             virNWFilterVarAccessPtr *varAccess,\n                             size_t nVarAccess)\n{\n    virNWFilterVarCombIterPtr res;\n    size_t i;\n    unsigned int iterId;\n    int iterIndex = -1;\n    unsigned int nextIntIterId = VIR_NWFILTER_MAX_ITERID + 1;\n\n    if (VIR_ALLOC_VAR(res, virNWFilterVarCombIterEntry, 1 + nVarAccess) < 0)\n        return NULL;\n\n    res->hashTable = hash;\n\n    /* create the default iterator to support @0 */\n    iterId = 0;\n\n    res->nIter = 1;\n    virNWFilterVarCombIterEntryInit(&res->iter[0], iterId);\n\n    for (i = 0; i < nVarAccess; i++) {\n        switch (virNWFilterVarAccessGetType(varAccess[i])) {\n        case VIR_NWFILTER_VAR_ACCESS_ITERATOR:\n            iterId = virNWFilterVarAccessGetIterId(varAccess[i]);\n            iterIndex = virNWFilterVarCombIterGetIndexByIterId(res, iterId);\n            if (iterIndex < 0) {\n                iterIndex = res->nIter;\n                virNWFilterVarCombIterEntryInit(&res->iter[iterIndex], iterId);\n                res->nIter++;\n            }\n            break;\n        case VIR_NWFILTER_VAR_ACCESS_ELEMENT:\n            iterIndex = res->nIter;\n            virNWFilterVarAccessSetIntIterId(varAccess[i], nextIntIterId);\n            virNWFilterVarCombIterEntryInit(&res->iter[iterIndex],\n                                            nextIntIterId);\n            nextIntIterId++;\n            res->nIter++;\n            break;\n        case VIR_NWFILTER_VAR_ACCESS_LAST:\n            goto err_exit;\n        }\n\n        if (virNWFilterVarCombIterAddVariable(&res->iter[iterIndex],\n                                              hash, varAccess[i]) < 0)\n            goto err_exit;\n    }\n\n    return res;\n\n err_exit:\n    virNWFilterVarCombIterFree(res);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebtablesRuleInstCommand(virFirewallPtr fw,\n                        const char *ifname,\n                        virNWFilterRuleInstPtr rule)\n{\n    virNWFilterVarCombIterPtr vciter, tmp;\n    int ret = -1;\n\n    /* rule->vars holds all the variables names that this rule will access.\n     * iterate over all combinations of the variables' values and instantiate\n     * the filtering rule with each combination.\n     */\n    tmp = vciter = virNWFilterVarCombIterCreate(rule->vars,\n                                                rule->def->varAccess,\n                                                rule->def->nVarAccess);\n    if (!vciter)\n        return -1;\n\n    do {\n        if (ebiptablesCreateRuleInstance(fw,\n                                         rule->chainSuffix,\n                                         rule->def,\n                                         ifname,\n                                         tmp) < 0)\n            goto cleanup;\n        tmp = virNWFilterVarCombIterNext(tmp);\n    } while (tmp != NULL);\n\n    ret = 0;\n cleanup:\n    virNWFilterVarCombIterFree(vciter);\n    return ret;\n}"
  },
  {
    "function_name": "iptablesRuleInstCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3221-3253",
    "snippet": "static int\niptablesRuleInstCommand(virFirewallPtr fw,\n                        const char *ifname,\n                        virNWFilterRuleInstPtr rule)\n{\n    virNWFilterVarCombIterPtr vciter, tmp;\n    int ret = -1;\n\n    /* rule->vars holds all the variables names that this rule will access.\n     * iterate over all combinations of the variables' values and instantiate\n     * the filtering rule with each combination.\n     */\n    tmp = vciter = virNWFilterVarCombIterCreate(rule->vars,\n                                                rule->def->varAccess,\n                                                rule->def->nVarAccess);\n    if (!vciter)\n        return -1;\n\n    do {\n        if (ebiptablesCreateRuleInstance(fw,\n                                         rule->chainSuffix,\n                                         rule->def,\n                                         ifname,\n                                         tmp) < 0)\n            goto cleanup;\n        tmp = virNWFilterVarCombIterNext(tmp);\n    } while (tmp != NULL);\n\n    ret = 0;\n cleanup:\n    virNWFilterVarCombIterFree(vciter);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterVarCombIterFree",
          "args": [
            "vciter"
          ],
          "line": 3251
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarCombIterFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "308-320",
          "snippet": "void\nvirNWFilterVarCombIterFree(virNWFilterVarCombIterPtr ci)\n{\n    size_t i;\n\n    if (!ci)\n        return;\n\n    for (i = 0; i < ci->nIter; i++)\n        VIR_FREE(ci->iter[i].varNames);\n\n    VIR_FREE(ci);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirNWFilterVarCombIterFree(virNWFilterVarCombIterPtr ci)\n{\n    size_t i;\n\n    if (!ci)\n        return;\n\n    for (i = 0; i < ci->nIter; i++)\n        VIR_FREE(ci->iter[i].varNames);\n\n    VIR_FREE(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterVarCombIterNext",
          "args": [
            "tmp"
          ],
          "line": 3246
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarCombIterNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "526-548",
          "snippet": "virNWFilterVarCombIterPtr\nvirNWFilterVarCombIterNext(virNWFilterVarCombIterPtr ci)\n{\n    size_t i;\n\n    for (i = 0; i < ci->nIter; i++) {\n next:\n        ci->iter[i].curValue++;\n        if (ci->iter[i].curValue <= ci->iter[i].maxValue) {\n            if (!virNWFilterVarCombIterEntryAreUniqueEntries(\n                                              &ci->iter[i], ci->hashTable))\n                goto next;\n            break;\n        } else {\n            ci->iter[i].curValue = ci->iter[i].minValue;\n        }\n    }\n\n    if (ci->nIter == i)\n        return NULL;\n\n    return ci;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirNWFilterVarCombIterPtr\nvirNWFilterVarCombIterNext(virNWFilterVarCombIterPtr ci)\n{\n    size_t i;\n\n    for (i = 0; i < ci->nIter; i++) {\n next:\n        ci->iter[i].curValue++;\n        if (ci->iter[i].curValue <= ci->iter[i].maxValue) {\n            if (!virNWFilterVarCombIterEntryAreUniqueEntries(\n                                              &ci->iter[i], ci->hashTable))\n                goto next;\n            break;\n        } else {\n            ci->iter[i].curValue = ci->iter[i].minValue;\n        }\n    }\n\n    if (ci->nIter == i)\n        return NULL;\n\n    return ci;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebiptablesCreateRuleInstance",
          "args": [
            "fw",
            "rule->chainSuffix",
            "rule->def",
            "ifname",
            "tmp"
          ],
          "line": 3240
        },
        "resolved": true,
        "details": {
          "function_name": "ebiptablesCreateRuleInstance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2446-2498",
          "snippet": "static int\nebiptablesCreateRuleInstance(virFirewallPtr fw,\n                             const char *chainSuffix,\n                             virNWFilterRuleDefPtr rule,\n                             const char *ifname,\n                             virNWFilterVarCombIterPtr vars)\n{\n    if (virNWFilterRuleIsProtocolEthernet(rule)) {\n        if (rule->tt == VIR_NWFILTER_RULE_DIRECTION_OUT ||\n            rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n            if (ebtablesCreateRuleInstance(fw,\n                                           CHAINPREFIX_HOST_IN_TEMP,\n                                           chainSuffix,\n                                           rule,\n                                           ifname,\n                                           vars,\n                                           rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) < 0)\n                return -1;\n        }\n\n        if (rule->tt == VIR_NWFILTER_RULE_DIRECTION_IN ||\n            rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n            if (ebtablesCreateRuleInstance(fw,\n                                           CHAINPREFIX_HOST_OUT_TEMP,\n                                           chainSuffix,\n                                           rule,\n                                           ifname,\n                                           vars,\n                                           false) < 0)\n                return -1;\n        }\n    } else {\n        virFirewallLayer layer;\n        if (virNWFilterRuleIsProtocolIPv6(rule)) {\n            layer = VIR_FIREWALL_LAYER_IPV6;\n        } else if (virNWFilterRuleIsProtocolIPv4(rule)) {\n            layer = VIR_FIREWALL_LAYER_IPV4;\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           \"%s\", _(\"unexpected protocol type\"));\n            return -1;\n        }\n\n        if (iptablesCreateRuleInstance(fw,\n                                       layer,\n                                       rule,\n                                       ifname,\n                                       vars) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebiptablesCreateRuleInstance(virFirewallPtr fw,\n                             const char *chainSuffix,\n                             virNWFilterRuleDefPtr rule,\n                             const char *ifname,\n                             virNWFilterVarCombIterPtr vars)\n{\n    if (virNWFilterRuleIsProtocolEthernet(rule)) {\n        if (rule->tt == VIR_NWFILTER_RULE_DIRECTION_OUT ||\n            rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n            if (ebtablesCreateRuleInstance(fw,\n                                           CHAINPREFIX_HOST_IN_TEMP,\n                                           chainSuffix,\n                                           rule,\n                                           ifname,\n                                           vars,\n                                           rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) < 0)\n                return -1;\n        }\n\n        if (rule->tt == VIR_NWFILTER_RULE_DIRECTION_IN ||\n            rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n            if (ebtablesCreateRuleInstance(fw,\n                                           CHAINPREFIX_HOST_OUT_TEMP,\n                                           chainSuffix,\n                                           rule,\n                                           ifname,\n                                           vars,\n                                           false) < 0)\n                return -1;\n        }\n    } else {\n        virFirewallLayer layer;\n        if (virNWFilterRuleIsProtocolIPv6(rule)) {\n            layer = VIR_FIREWALL_LAYER_IPV6;\n        } else if (virNWFilterRuleIsProtocolIPv4(rule)) {\n            layer = VIR_FIREWALL_LAYER_IPV4;\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           \"%s\", _(\"unexpected protocol type\"));\n            return -1;\n        }\n\n        if (iptablesCreateRuleInstance(fw,\n                                       layer,\n                                       rule,\n                                       ifname,\n                                       vars) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterVarCombIterCreate",
          "args": [
            "rule->vars",
            "rule->def->varAccess",
            "rule->def->nVarAccess"
          ],
          "line": 3233
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarCombIterCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "469-524",
          "snippet": "virNWFilterVarCombIterPtr\nvirNWFilterVarCombIterCreate(virHashTablePtr hash,\n                             virNWFilterVarAccessPtr *varAccess,\n                             size_t nVarAccess)\n{\n    virNWFilterVarCombIterPtr res;\n    size_t i;\n    unsigned int iterId;\n    int iterIndex = -1;\n    unsigned int nextIntIterId = VIR_NWFILTER_MAX_ITERID + 1;\n\n    if (VIR_ALLOC_VAR(res, virNWFilterVarCombIterEntry, 1 + nVarAccess) < 0)\n        return NULL;\n\n    res->hashTable = hash;\n\n    /* create the default iterator to support @0 */\n    iterId = 0;\n\n    res->nIter = 1;\n    virNWFilterVarCombIterEntryInit(&res->iter[0], iterId);\n\n    for (i = 0; i < nVarAccess; i++) {\n        switch (virNWFilterVarAccessGetType(varAccess[i])) {\n        case VIR_NWFILTER_VAR_ACCESS_ITERATOR:\n            iterId = virNWFilterVarAccessGetIterId(varAccess[i]);\n            iterIndex = virNWFilterVarCombIterGetIndexByIterId(res, iterId);\n            if (iterIndex < 0) {\n                iterIndex = res->nIter;\n                virNWFilterVarCombIterEntryInit(&res->iter[iterIndex], iterId);\n                res->nIter++;\n            }\n            break;\n        case VIR_NWFILTER_VAR_ACCESS_ELEMENT:\n            iterIndex = res->nIter;\n            virNWFilterVarAccessSetIntIterId(varAccess[i], nextIntIterId);\n            virNWFilterVarCombIterEntryInit(&res->iter[iterIndex],\n                                            nextIntIterId);\n            nextIntIterId++;\n            res->nIter++;\n            break;\n        case VIR_NWFILTER_VAR_ACCESS_LAST:\n            goto err_exit;\n        }\n\n        if (virNWFilterVarCombIterAddVariable(&res->iter[iterIndex],\n                                              hash, varAccess[i]) < 0)\n            goto err_exit;\n    }\n\n    return res;\n\n err_exit:\n    virNWFilterVarCombIterFree(res);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNWFilterVarAccessSetIntIterId(virNWFilterVarAccessPtr,\n                                             unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNWFilterVarAccessSetIntIterId(virNWFilterVarAccessPtr,\n                                             unsigned int);\n\nvirNWFilterVarCombIterPtr\nvirNWFilterVarCombIterCreate(virHashTablePtr hash,\n                             virNWFilterVarAccessPtr *varAccess,\n                             size_t nVarAccess)\n{\n    virNWFilterVarCombIterPtr res;\n    size_t i;\n    unsigned int iterId;\n    int iterIndex = -1;\n    unsigned int nextIntIterId = VIR_NWFILTER_MAX_ITERID + 1;\n\n    if (VIR_ALLOC_VAR(res, virNWFilterVarCombIterEntry, 1 + nVarAccess) < 0)\n        return NULL;\n\n    res->hashTable = hash;\n\n    /* create the default iterator to support @0 */\n    iterId = 0;\n\n    res->nIter = 1;\n    virNWFilterVarCombIterEntryInit(&res->iter[0], iterId);\n\n    for (i = 0; i < nVarAccess; i++) {\n        switch (virNWFilterVarAccessGetType(varAccess[i])) {\n        case VIR_NWFILTER_VAR_ACCESS_ITERATOR:\n            iterId = virNWFilterVarAccessGetIterId(varAccess[i]);\n            iterIndex = virNWFilterVarCombIterGetIndexByIterId(res, iterId);\n            if (iterIndex < 0) {\n                iterIndex = res->nIter;\n                virNWFilterVarCombIterEntryInit(&res->iter[iterIndex], iterId);\n                res->nIter++;\n            }\n            break;\n        case VIR_NWFILTER_VAR_ACCESS_ELEMENT:\n            iterIndex = res->nIter;\n            virNWFilterVarAccessSetIntIterId(varAccess[i], nextIntIterId);\n            virNWFilterVarCombIterEntryInit(&res->iter[iterIndex],\n                                            nextIntIterId);\n            nextIntIterId++;\n            res->nIter++;\n            break;\n        case VIR_NWFILTER_VAR_ACCESS_LAST:\n            goto err_exit;\n        }\n\n        if (virNWFilterVarCombIterAddVariable(&res->iter[iterIndex],\n                                              hash, varAccess[i]) < 0)\n            goto err_exit;\n    }\n\n    return res;\n\n err_exit:\n    virNWFilterVarCombIterFree(res);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\niptablesRuleInstCommand(virFirewallPtr fw,\n                        const char *ifname,\n                        virNWFilterRuleInstPtr rule)\n{\n    virNWFilterVarCombIterPtr vciter, tmp;\n    int ret = -1;\n\n    /* rule->vars holds all the variables names that this rule will access.\n     * iterate over all combinations of the variables' values and instantiate\n     * the filtering rule with each combination.\n     */\n    tmp = vciter = virNWFilterVarCombIterCreate(rule->vars,\n                                                rule->def->varAccess,\n                                                rule->def->nVarAccess);\n    if (!vciter)\n        return -1;\n\n    do {\n        if (ebiptablesCreateRuleInstance(fw,\n                                         rule->chainSuffix,\n                                         rule->def,\n                                         ifname,\n                                         tmp) < 0)\n            goto cleanup;\n        tmp = virNWFilterVarCombIterNext(tmp);\n    } while (tmp != NULL);\n\n    ret = 0;\n cleanup:\n    virNWFilterVarCombIterFree(vciter);\n    return ret;\n}"
  },
  {
    "function_name": "ebtablesGetProtoIdxByFiltername",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3207-3218",
    "snippet": "static enum l3_proto_idx\nebtablesGetProtoIdxByFiltername(const char *filtername)\n{\n    enum l3_proto_idx idx;\n\n    for (idx = 0; idx < L3_PROTO_LAST_IDX; idx++) {\n        if (STRPREFIX(filtername, l3_protocols[idx].val))\n            return idx;\n    }\n\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct ushort_map l3_protocols[] = {\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV4_IDX, ETHERTYPE_IP,     \"ipv4\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV6_IDX, ETHERTYPE_IPV6,   \"ipv6\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_ARP_IDX,  ETHERTYPE_ARP,    \"arp\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_RARP_IDX, ETHERTYPE_REVARP, \"rarp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_VLAN_IDX, ETHERTYPE_VLAN,   \"vlan\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_STP_IDX,  0,                \"stp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_MAC_IDX,  0,                \"mac\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_LAST_IDX, 0,                NULL),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "filtername",
            "l3_protocols[idx].val"
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic const struct ushort_map l3_protocols[] = {\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV4_IDX, ETHERTYPE_IP,     \"ipv4\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV6_IDX, ETHERTYPE_IPV6,   \"ipv6\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_ARP_IDX,  ETHERTYPE_ARP,    \"arp\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_RARP_IDX, ETHERTYPE_REVARP, \"rarp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_VLAN_IDX, ETHERTYPE_VLAN,   \"vlan\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_STP_IDX,  0,                \"stp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_MAC_IDX,  0,                \"mac\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_LAST_IDX, 0,                NULL),\n};\n\nstatic enum l3_proto_idx\nebtablesGetProtoIdxByFiltername(const char *filtername)\n{\n    enum l3_proto_idx idx;\n\n    for (idx = 0; idx < L3_PROTO_LAST_IDX; idx++) {\n        if (STRPREFIX(filtername, l3_protocols[idx].val))\n            return idx;\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "iptablesCheckBridgeNFCallEnabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3165-3201",
    "snippet": "static void\niptablesCheckBridgeNFCallEnabled(bool isIPv6)\n{\n    static time_t lastReport, lastReportIPv6;\n    const char *pathname = NULL;\n    char buffer[1];\n    time_t now = time(NULL);\n\n    if (isIPv6 &&\n        (now - lastReportIPv6) > BRIDGE_NF_CALL_ALERT_INTERVAL) {\n        pathname = PROC_BRIDGE_NF_CALL_IP6TABLES;\n    } else if (now - lastReport > BRIDGE_NF_CALL_ALERT_INTERVAL) {\n        pathname = PROC_BRIDGE_NF_CALL_IPTABLES;\n    }\n\n    if (pathname) {\n        int fd = open(pathname, O_RDONLY);\n        if (fd >= 0) {\n            if (read(fd, buffer, 1) == 1) {\n                if (buffer[0] == '0') {\n                    char msg[256];\n                    g_snprintf(msg, sizeof(msg),\n                               _(\"To enable ip%stables filtering for the VM do \"\n                                \"'echo 1 > %s'\"),\n                               isIPv6 ? \"6\" : \"\",\n                               pathname);\n                    VIR_WARN(\"%s\", msg);\n                    if (isIPv6)\n                        lastReportIPv6 = now;\n                    else\n                        lastReport = now;\n                }\n            }\n            VIR_FORCE_CLOSE(fd);\n        }\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define BRIDGE_NF_CALL_ALERT_INTERVAL  10 /* seconds */",
      "#define PROC_BRIDGE_NF_CALL_IP6TABLES \\\n        \"/proc/sys/net/bridge/bridge-nf-call-ip6tables\"",
      "#define PROC_BRIDGE_NF_CALL_IPTABLES \\\n        \"/proc/sys/net/bridge/bridge-nf-call-iptables\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"%s\"",
            "msg"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "msg",
            "sizeof(msg)",
            "_(\"To enable ip%stables filtering for the VM do \"\n                                \"'echo 1 > %s'\")",
            "isIPv6 ? \"6\" : \"\"",
            "pathname"
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"To enable ip%stables filtering for the VM do \"\n                                \"'echo 1 > %s'\""
          ],
          "line": 3187
        },
        "resolved": true,
        "details": {
          "function_name": "_virNWFilterTeardownFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_gentech_driver.c",
          "lines": "898-927",
          "snippet": "static int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdev.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_dhcpsnoop.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _virNWFilterTeardownFilter(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsocketaddr.h\"\n#include \"datatypes.h\"\n#include \"virnetdev.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_dhcpsnoop.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"virerror.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int _virNWFilterTeardownFilter(const char *ifname);\n\nstatic int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buffer",
            "1"
          ],
          "line": 3183
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDelIOThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-domain.c",
          "lines": "7811-7841",
          "snippet": "int\nvirDomainDelIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=0x%x\", iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonZeroArgGoto(iothread_id, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainDelIOThread) {\n        int ret;\n        ret = conn->driver->domainDelIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirDomainDelIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=0x%x\", iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonZeroArgGoto(iothread_id, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainDelIOThread) {\n        int ret;\n        ret = conn->driver->domainDelIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "pathname",
            "O_RDONLY"
          ],
          "line": 3181
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 3171
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobCleanStorageSourceRuntime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "636-647",
          "snippet": "static void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define BRIDGE_NF_CALL_ALERT_INTERVAL  10 /* seconds */\n#define PROC_BRIDGE_NF_CALL_IP6TABLES \\\n        \"/proc/sys/net/bridge/bridge-nf-call-ip6tables\"\n#define PROC_BRIDGE_NF_CALL_IPTABLES \\\n        \"/proc/sys/net/bridge/bridge-nf-call-iptables\"\n\nstatic void\niptablesCheckBridgeNFCallEnabled(bool isIPv6)\n{\n    static time_t lastReport, lastReportIPv6;\n    const char *pathname = NULL;\n    char buffer[1];\n    time_t now = time(NULL);\n\n    if (isIPv6 &&\n        (now - lastReportIPv6) > BRIDGE_NF_CALL_ALERT_INTERVAL) {\n        pathname = PROC_BRIDGE_NF_CALL_IP6TABLES;\n    } else if (now - lastReport > BRIDGE_NF_CALL_ALERT_INTERVAL) {\n        pathname = PROC_BRIDGE_NF_CALL_IPTABLES;\n    }\n\n    if (pathname) {\n        int fd = open(pathname, O_RDONLY);\n        if (fd >= 0) {\n            if (read(fd, buffer, 1) == 1) {\n                if (buffer[0] == '0') {\n                    char msg[256];\n                    g_snprintf(msg, sizeof(msg),\n                               _(\"To enable ip%stables filtering for the VM do \"\n                                \"'echo 1 > %s'\"),\n                               isIPv6 ? \"6\" : \"\",\n                               pathname);\n                    VIR_WARN(\"%s\", msg);\n                    if (isIPv6)\n                        lastReportIPv6 = now;\n                    else\n                        lastReport = now;\n                }\n            }\n            VIR_FORCE_CLOSE(fd);\n        }\n    }\n}"
  },
  {
    "function_name": "ebiptablesFilterOrderSort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3155-3162",
    "snippet": "static int\nebiptablesFilterOrderSort(const virHashKeyValuePair *a,\n                          const virHashKeyValuePair *b)\n{\n    /* elements' values has been limited to range [-1000, 1000] */\n    return *(virNWFilterChainPriority *)a->value -\n           *(virNWFilterChainPriority *)b->value;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nebiptablesFilterOrderSort(const virHashKeyValuePair *a,\n                          const virHashKeyValuePair *b)\n{\n    /* elements' values has been limited to range [-1000, 1000] */\n    return *(virNWFilterChainPriority *)a->value -\n           *(virNWFilterChainPriority *)b->value;\n}"
  },
  {
    "function_name": "virNWFilterRuleInstSortPtr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3146-3152",
    "snippet": "static int\nvirNWFilterRuleInstSortPtr(const void *a, const void *b)\n{\n    virNWFilterRuleInst * const *insta = a;\n    virNWFilterRuleInst * const *instb = b;\n    return virNWFilterRuleInstSort(*insta, *instb);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNWFilterRuleInstSort",
          "args": [
            "*insta",
            "*instb"
          ],
          "line": 3151
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleInstSortPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3146-3152",
          "snippet": "static int\nvirNWFilterRuleInstSortPtr(const void *a, const void *b)\n{\n    virNWFilterRuleInst * const *insta = a;\n    virNWFilterRuleInst * const *instb = b;\n    return virNWFilterRuleInstSort(*insta, *instb);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirNWFilterRuleInstSortPtr(const void *a, const void *b)\n{\n    virNWFilterRuleInst * const *insta = a;\n    virNWFilterRuleInst * const *instb = b;\n    return virNWFilterRuleInstSort(*insta, *instb);\n}"
  },
  {
    "function_name": "virNWFilterRuleInstSort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3121-3143",
    "snippet": "static int\nvirNWFilterRuleInstSort(const void *a, const void *b)\n{\n    const virNWFilterRuleInst *insta = a;\n    const virNWFilterRuleInst *instb = b;\n    const char *root = virNWFilterChainSuffixTypeToString(\n                                     VIR_NWFILTER_CHAINSUFFIX_ROOT);\n    bool root_a = STREQ(insta->chainSuffix, root);\n    bool root_b = STREQ(instb->chainSuffix, root);\n\n    /* ensure root chain commands appear before all others since\n       we will need them to create the child chains */\n    if (root_a) {\n        if (root_b)\n            goto normal;\n        return -1; /* a before b */\n    }\n    if (root_b)\n        return 1; /* b before a */\n normal:\n    /* priorities are limited to range [-1000, 1000] */\n    return insta->priority - instb->priority;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "instb->chainSuffix",
            "root"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "insta->chainSuffix",
            "root"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterChainSuffixTypeToString",
          "args": [
            "VIR_NWFILTER_CHAINSUFFIX_ROOT"
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nvirNWFilterRuleInstSort(const void *a, const void *b)\n{\n    const virNWFilterRuleInst *insta = a;\n    const virNWFilterRuleInst *instb = b;\n    const char *root = virNWFilterChainSuffixTypeToString(\n                                     VIR_NWFILTER_CHAINSUFFIX_ROOT);\n    bool root_a = STREQ(insta->chainSuffix, root);\n    bool root_b = STREQ(instb->chainSuffix, root);\n\n    /* ensure root chain commands appear before all others since\n       we will need them to create the child chains */\n    if (root_a) {\n        if (root_b)\n            goto normal;\n        return -1; /* a before b */\n    }\n    if (root_b)\n        return 1; /* b before a */\n normal:\n    /* priorities are limited to range [-1000, 1000] */\n    return insta->priority - instb->priority;\n}"
  },
  {
    "function_name": "ebtablesCleanAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3095-3118",
    "snippet": "static int\nebtablesCleanAll(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n    ebtablesRemoveSubChainsFW(fw, ifname);\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallFree",
          "args": [
            "fw"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "286-298",
          "snippet": "void virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallApply",
          "args": [
            "fw"
          ],
          "line": 3115
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "804-868",
          "snippet": "int\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
            "static virMutex ruleLock = VIR_MUTEX_INITIALIZER;",
            "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic virMutex ruleLock = VIR_MUTEX_INITIALIZER;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nint\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRemoveTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3113
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRemoveTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2567-2572",
          "snippet": "static void\nebtablesRemoveTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, 1);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRemoveTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRemoveTmpSubChainsFW",
          "args": [
            "fw",
            "ifname"
          ],
          "line": 3111
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRemoveTmpSubChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2727-2732",
          "snippet": "static void\nebtablesRemoveTmpSubChainsFW(virFirewallPtr fw,\n                             const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host_temp);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);",
            "static char chainprefixes_host_temp[3] = {\n    CHAINPREFIX_HOST_IN_TEMP,\n    CHAINPREFIX_HOST_OUT_TEMP,\n    0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\nstatic char chainprefixes_host_temp[3] = {\n    CHAINPREFIX_HOST_IN_TEMP,\n    CHAINPREFIX_HOST_OUT_TEMP,\n    0\n};\n\nstatic void\nebtablesRemoveTmpSubChainsFW(virFirewallPtr fw,\n                             const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host_temp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesUnlinkTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3110
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesUnlinkTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2610-2615",
          "snippet": "static void\nebtablesUnlinkTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, 1);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesUnlinkTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRemoveRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3107
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRemoveRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2559-2564",
          "snippet": "static void\nebtablesRemoveRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, false);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRemoveRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRemoveSubChainsFW",
          "args": [
            "fw",
            "ifname"
          ],
          "line": 3105
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRemoveSubChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2719-2724",
          "snippet": "static void\nebtablesRemoveSubChainsFW(virFirewallPtr fw,\n                          const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);",
            "static char chainprefixes_host[3] = {\n    CHAINPREFIX_HOST_IN,\n    CHAINPREFIX_HOST_OUT,\n    0\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\nstatic char chainprefixes_host[3] = {\n    CHAINPREFIX_HOST_IN,\n    CHAINPREFIX_HOST_OUT,\n    0\n};\n\nstatic void\nebtablesRemoveSubChainsFW(virFirewallPtr fw,\n                          const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesUnlinkRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3104
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesUnlinkRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2602-2607",
          "snippet": "static void\nebtablesUnlinkRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, false);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesUnlinkRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallStartTransaction",
          "args": [
            "fw",
            "VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS"
          ],
          "line": 3101
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallStartTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "586-607",
          "snippet": "void virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallNew",
          "args": [],
          "line": 3098
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "231-242",
          "snippet": "virFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebtablesCleanAll(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n    ebtablesRemoveSubChainsFW(fw, ifname);\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}"
  },
  {
    "function_name": "ebtablesRemoveBasicRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3088-3092",
    "snippet": "static int\nebtablesRemoveBasicRules(const char *ifname)\n{\n    return ebtablesCleanAll(ifname);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebtablesCleanAll",
          "args": [
            "ifname"
          ],
          "line": 3091
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesCleanAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3095-3118",
          "snippet": "static int\nebtablesCleanAll(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n    ebtablesRemoveSubChainsFW(fw, ifname);\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebtablesCleanAll(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n    ebtablesRemoveSubChainsFW(fw, ifname);\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebtablesRemoveBasicRules(const char *ifname)\n{\n    return ebtablesCleanAll(ifname);\n}"
  },
  {
    "function_name": "ebtablesApplyDropAllRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "3043-3085",
    "snippet": "static int\nebtablesApplyDropAllRules(const char *ifname)\n{\n    char chain_in [MAX_CHAINNAME_LENGTH],\n         chain_out[MAX_CHAINNAME_LENGTH];\n    virFirewallPtr fw = virFirewallNew();\n\n    if (ebiptablesAllTeardown(ifname) < 0)\n        goto error;\n\n    virFirewallStartTransaction(fw, 0);\n\n    ebtablesCreateTmpRootChainFW(fw, true, ifname);\n    ebtablesCreateTmpRootChainFW(fw, false, ifname);\n\n    PRINT_ROOT_CHAIN(chain_in, CHAINPREFIX_HOST_IN_TEMP, ifname);\n    PRINT_ROOT_CHAIN(chain_out, CHAINPREFIX_HOST_OUT_TEMP, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain_in,\n                       \"-j\", \"DROP\", NULL);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain_out,\n                       \"-j\", \"DROP\", NULL);\n\n    ebtablesLinkTmpRootChainFW(fw, true, ifname);\n    ebtablesLinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRenameTmpRootChainFW(fw, true, ifname);\n    ebtablesRenameTmpRootChainFW(fw, false, ifname);\n\n    if (virFirewallApply(fw) < 0)\n        goto tear_down_tmpebchains;\n\n    virFirewallFree(fw);\n    return 0;\n\n tear_down_tmpebchains:\n    ebtablesCleanAll(ifname);\n error:\n    virFirewallFree(fw);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallFree",
          "args": [
            "fw"
          ],
          "line": 3083
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "286-298",
          "snippet": "void virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesCleanAll",
          "args": [
            "ifname"
          ],
          "line": 3081
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesCleanAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3095-3118",
          "snippet": "static int\nebtablesCleanAll(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n    ebtablesRemoveSubChainsFW(fw, ifname);\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebtablesCleanAll(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n    ebtablesRemoveSubChainsFW(fw, ifname);\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallApply",
          "args": [
            "fw"
          ],
          "line": 3074
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "804-868",
          "snippet": "int\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
            "static virMutex ruleLock = VIR_MUTEX_INITIALIZER;",
            "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic virMutex ruleLock = VIR_MUTEX_INITIALIZER;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nint\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRenameTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3072
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRenameTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2758-2764",
          "snippet": "static void\nebtablesRenameTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming,\n                             const char *ifname)\n{\n    ebtablesRenameTmpSubChainFW(fw, incoming, ifname, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRenameTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming,\n                             const char *ifname)\n{\n    ebtablesRenameTmpSubChainFW(fw, incoming, ifname, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesLinkTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3070
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesLinkTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2516-2531",
          "snippet": "static void\nebtablesLinkTmpRootChainFW(virFirewallPtr fw,\n                           int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\",\n                       incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                       incoming ? \"-i\" : \"-o\",\n                       ifname, \"-j\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
            "#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"",
            "#define EBTABLES_CHAIN_INCOMING \"PREROUTING\""
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"\n#define EBTABLES_CHAIN_INCOMING \"PREROUTING\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesLinkTmpRootChainFW(virFirewallPtr fw,\n                           int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\",\n                       incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                       incoming ? \"-i\" : \"-o\",\n                       ifname, \"-j\", chain, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_ETHERNET",
            "\"-t\"",
            "\"nat\"",
            "\"-A\"",
            "chain_out",
            "\"-j\"",
            "\"DROP\"",
            "NULL"
          ],
          "line": 3065
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "chain_out",
            "CHAINPREFIX_HOST_OUT_TEMP",
            "ifname"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "chain_in",
            "CHAINPREFIX_HOST_IN_TEMP",
            "ifname"
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebtablesCreateTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3056
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesCreateTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2501-2513",
          "snippet": "static void\nebtablesCreateTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = (incoming) ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-N\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesCreateTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = (incoming) ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-N\", chain, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallStartTransaction",
          "args": [
            "fw",
            "0"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallStartTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "586-607",
          "snippet": "void virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebiptablesAllTeardown",
          "args": [
            "ifname"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "ebiptablesAllTeardown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3646-3675",
          "snippet": "static int\nebiptablesAllTeardown(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebiptablesTearNewRulesFW(fw, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n\n    ebtablesRemoveSubChainsFW(fw, ifname);\n\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebiptablesAllTeardown(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebiptablesTearNewRulesFW(fw, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n\n    ebtablesRemoveSubChainsFW(fw, ifname);\n\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallNew",
          "args": [],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "231-242",
          "snippet": "virFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebtablesApplyDropAllRules(const char *ifname)\n{\n    char chain_in [MAX_CHAINNAME_LENGTH],\n         chain_out[MAX_CHAINNAME_LENGTH];\n    virFirewallPtr fw = virFirewallNew();\n\n    if (ebiptablesAllTeardown(ifname) < 0)\n        goto error;\n\n    virFirewallStartTransaction(fw, 0);\n\n    ebtablesCreateTmpRootChainFW(fw, true, ifname);\n    ebtablesCreateTmpRootChainFW(fw, false, ifname);\n\n    PRINT_ROOT_CHAIN(chain_in, CHAINPREFIX_HOST_IN_TEMP, ifname);\n    PRINT_ROOT_CHAIN(chain_out, CHAINPREFIX_HOST_OUT_TEMP, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain_in,\n                       \"-j\", \"DROP\", NULL);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain_out,\n                       \"-j\", \"DROP\", NULL);\n\n    ebtablesLinkTmpRootChainFW(fw, true, ifname);\n    ebtablesLinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRenameTmpRootChainFW(fw, true, ifname);\n    ebtablesRenameTmpRootChainFW(fw, false, ifname);\n\n    if (virFirewallApply(fw) < 0)\n        goto tear_down_tmpebchains;\n\n    virFirewallFree(fw);\n    return 0;\n\n tear_down_tmpebchains:\n    ebtablesCleanAll(ifname);\n error:\n    virFirewallFree(fw);\n    return -1;\n}"
  },
  {
    "function_name": "ebtablesApplyDHCPOnlyRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2931-3031",
    "snippet": "static int\nebtablesApplyDHCPOnlyRules(const char *ifname,\n                           const virMacAddr *macaddr,\n                           virNWFilterVarValuePtr dhcpsrvrs,\n                           bool leaveTemporary)\n{\n    char chain_in [MAX_CHAINNAME_LENGTH],\n         chain_out[MAX_CHAINNAME_LENGTH];\n    char macaddr_str[VIR_MAC_STRING_BUFLEN];\n    unsigned int idx = 0;\n    unsigned int num_dhcpsrvrs;\n    virFirewallPtr fw = virFirewallNew();\n\n    virMacAddrFormat(macaddr, macaddr_str);\n\n    if (ebiptablesAllTeardown(ifname) < 0)\n        goto error;\n\n    virFirewallStartTransaction(fw, 0);\n\n    ebtablesCreateTmpRootChainFW(fw, true, ifname);\n    ebtablesCreateTmpRootChainFW(fw, false, ifname);\n\n    PRINT_ROOT_CHAIN(chain_in, CHAINPREFIX_HOST_IN_TEMP, ifname);\n    PRINT_ROOT_CHAIN(chain_out, CHAINPREFIX_HOST_OUT_TEMP, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain_in,\n                       \"-s\", macaddr_str,\n                       \"-p\", \"ipv4\", \"--ip-protocol\", \"udp\",\n                       \"--ip-sport\", \"68\", \"--ip-dport\", \"67\",\n                       \"-j\", \"ACCEPT\", NULL);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain_in,\n                       \"-j\", \"DROP\", NULL);\n\n    num_dhcpsrvrs = (dhcpsrvrs != NULL)\n                    ? virNWFilterVarValueGetCardinality(dhcpsrvrs)\n                    : 0;\n\n    while (true) {\n        const char *dhcpserver = NULL;\n        int ctr;\n\n        if (idx < num_dhcpsrvrs)\n            dhcpserver = virNWFilterVarValueGetNthValue(dhcpsrvrs, idx);\n\n        /*\n         * create two rules allowing response to MAC address of VM\n         * or to broadcast MAC address\n         */\n        for (ctr = 0; ctr < 2; ctr++) {\n            if (dhcpserver)\n                virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                   \"-t\", \"nat\", \"-A\", chain_out,\n                                   \"-d\", (ctr == 0) ? macaddr_str : \"ff:ff:ff:ff:ff:ff\",\n                                   \"-p\", \"ipv4\", \"--ip-protocol\", \"udp\",\n                                   \"--ip-src\", dhcpserver,\n                                   \"--ip-sport\", \"67\", \"--ip-dport\", \"68\",\n                                   \"-j\", \"ACCEPT\", NULL);\n            else\n                virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                   \"-t\", \"nat\", \"-A\", chain_out,\n                                   \"-d\", (ctr == 0) ? macaddr_str : \"ff:ff:ff:ff:ff:ff\",\n                                   \"-p\", \"ipv4\", \"--ip-protocol\", \"udp\",\n                                   \"--ip-sport\", \"67\", \"--ip-dport\", \"68\",\n                                   \"-j\", \"ACCEPT\", NULL);\n        }\n\n        idx++;\n\n        if (idx >= num_dhcpsrvrs)\n            break;\n    }\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain_out,\n                       \"-j\", \"DROP\", NULL);\n\n    ebtablesLinkTmpRootChainFW(fw, true, ifname);\n    ebtablesLinkTmpRootChainFW(fw, false, ifname);\n\n    if (!leaveTemporary) {\n        ebtablesRenameTmpRootChainFW(fw, true, ifname);\n        ebtablesRenameTmpRootChainFW(fw, false, ifname);\n    }\n\n    if (virFirewallApply(fw) < 0)\n        goto tear_down_tmpebchains;\n\n    virFirewallFree(fw);\n\n    return 0;\n\n tear_down_tmpebchains:\n    ebtablesCleanAll(ifname);\n error:\n    virFirewallFree(fw);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallFree",
          "args": [
            "fw"
          ],
          "line": 3029
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "286-298",
          "snippet": "void virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesCleanAll",
          "args": [
            "ifname"
          ],
          "line": 3027
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesCleanAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3095-3118",
          "snippet": "static int\nebtablesCleanAll(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n    ebtablesRemoveSubChainsFW(fw, ifname);\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebtablesCleanAll(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n    ebtablesRemoveSubChainsFW(fw, ifname);\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallApply",
          "args": [
            "fw"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "804-868",
          "snippet": "int\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
            "static virMutex ruleLock = VIR_MUTEX_INITIALIZER;",
            "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic virMutex ruleLock = VIR_MUTEX_INITIALIZER;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nint\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRenameTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3016
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRenameTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2758-2764",
          "snippet": "static void\nebtablesRenameTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming,\n                             const char *ifname)\n{\n    ebtablesRenameTmpSubChainFW(fw, incoming, ifname, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRenameTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming,\n                             const char *ifname)\n{\n    ebtablesRenameTmpSubChainFW(fw, incoming, ifname, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesLinkTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesLinkTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2516-2531",
          "snippet": "static void\nebtablesLinkTmpRootChainFW(virFirewallPtr fw,\n                           int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\",\n                       incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                       incoming ? \"-i\" : \"-o\",\n                       ifname, \"-j\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
            "#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"",
            "#define EBTABLES_CHAIN_INCOMING \"PREROUTING\""
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"\n#define EBTABLES_CHAIN_INCOMING \"PREROUTING\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesLinkTmpRootChainFW(virFirewallPtr fw,\n                           int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\",\n                       incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                       incoming ? \"-i\" : \"-o\",\n                       ifname, \"-j\", chain, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_ETHERNET",
            "\"-t\"",
            "\"nat\"",
            "\"-A\"",
            "chain_out",
            "\"-j\"",
            "\"DROP\"",
            "NULL"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterVarValueGetNthValue",
          "args": [
            "dhcpsrvrs",
            "idx"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarValueGetNthValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "142-164",
          "snippet": "const char *\nvirNWFilterVarValueGetNthValue(const virNWFilterVarValue* val, unsigned int idx)\n{\n    const char *res = NULL;\n\n    if (!val)\n        return NULL;\n\n    switch (val->valType) {\n    case NWFILTER_VALUE_TYPE_SIMPLE:\n        if (idx == 0)\n            res = val->u.simple.value;\n        break;\n    case NWFILTER_VALUE_TYPE_ARRAY:\n        if (idx < val->u.array.nValues)\n            res = val->u.array.values[idx];\n        break;\n    case NWFILTER_VALUE_TYPE_LAST:\n        break;\n    }\n\n    return res;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool isValidVarValue(const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic bool isValidVarValue(const char *value);\n\nconst char *\nvirNWFilterVarValueGetNthValue(const virNWFilterVarValue* val, unsigned int idx)\n{\n    const char *res = NULL;\n\n    if (!val)\n        return NULL;\n\n    switch (val->valType) {\n    case NWFILTER_VALUE_TYPE_SIMPLE:\n        if (idx == 0)\n            res = val->u.simple.value;\n        break;\n    case NWFILTER_VALUE_TYPE_ARRAY:\n        if (idx < val->u.array.nValues)\n            res = val->u.array.values[idx];\n        break;\n    case NWFILTER_VALUE_TYPE_LAST:\n        break;\n    }\n\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterVarValueGetCardinality",
          "args": [
            "dhcpsrvrs"
          ],
          "line": 2969
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarValueGetCardinality",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "166-180",
          "snippet": "unsigned int\nvirNWFilterVarValueGetCardinality(const virNWFilterVarValue *val)\n{\n    switch (val->valType) {\n    case NWFILTER_VALUE_TYPE_SIMPLE:\n        return 1;\n        break;\n    case NWFILTER_VALUE_TYPE_ARRAY:\n        return val->u.array.nValues;\n        break;\n    case NWFILTER_VALUE_TYPE_LAST:\n        return 0;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nunsigned int\nvirNWFilterVarValueGetCardinality(const virNWFilterVarValue *val)\n{\n    switch (val->valType) {\n    case NWFILTER_VALUE_TYPE_SIMPLE:\n        return 1;\n        break;\n    case NWFILTER_VALUE_TYPE_ARRAY:\n        return val->u.array.nValues;\n        break;\n    case NWFILTER_VALUE_TYPE_LAST:\n        return 0;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "chain_out",
            "CHAINPREFIX_HOST_OUT_TEMP",
            "ifname"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "chain_in",
            "CHAINPREFIX_HOST_IN_TEMP",
            "ifname"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebtablesCreateTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 2952
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesCreateTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2501-2513",
          "snippet": "static void\nebtablesCreateTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = (incoming) ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-N\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesCreateTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = (incoming) ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-N\", chain, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallStartTransaction",
          "args": [
            "fw",
            "0"
          ],
          "line": 2949
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallStartTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "586-607",
          "snippet": "void virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebiptablesAllTeardown",
          "args": [
            "ifname"
          ],
          "line": 2946
        },
        "resolved": true,
        "details": {
          "function_name": "ebiptablesAllTeardown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3646-3675",
          "snippet": "static int\nebiptablesAllTeardown(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebiptablesTearNewRulesFW(fw, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n\n    ebtablesRemoveSubChainsFW(fw, ifname);\n\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebiptablesAllTeardown(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebiptablesTearNewRulesFW(fw, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n\n    ebtablesRemoveSubChainsFW(fw, ifname);\n\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "macaddr",
            "macaddr_str"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallNew",
          "args": [],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "231-242",
          "snippet": "virFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebtablesApplyDHCPOnlyRules(const char *ifname,\n                           const virMacAddr *macaddr,\n                           virNWFilterVarValuePtr dhcpsrvrs,\n                           bool leaveTemporary)\n{\n    char chain_in [MAX_CHAINNAME_LENGTH],\n         chain_out[MAX_CHAINNAME_LENGTH];\n    char macaddr_str[VIR_MAC_STRING_BUFLEN];\n    unsigned int idx = 0;\n    unsigned int num_dhcpsrvrs;\n    virFirewallPtr fw = virFirewallNew();\n\n    virMacAddrFormat(macaddr, macaddr_str);\n\n    if (ebiptablesAllTeardown(ifname) < 0)\n        goto error;\n\n    virFirewallStartTransaction(fw, 0);\n\n    ebtablesCreateTmpRootChainFW(fw, true, ifname);\n    ebtablesCreateTmpRootChainFW(fw, false, ifname);\n\n    PRINT_ROOT_CHAIN(chain_in, CHAINPREFIX_HOST_IN_TEMP, ifname);\n    PRINT_ROOT_CHAIN(chain_out, CHAINPREFIX_HOST_OUT_TEMP, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain_in,\n                       \"-s\", macaddr_str,\n                       \"-p\", \"ipv4\", \"--ip-protocol\", \"udp\",\n                       \"--ip-sport\", \"68\", \"--ip-dport\", \"67\",\n                       \"-j\", \"ACCEPT\", NULL);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain_in,\n                       \"-j\", \"DROP\", NULL);\n\n    num_dhcpsrvrs = (dhcpsrvrs != NULL)\n                    ? virNWFilterVarValueGetCardinality(dhcpsrvrs)\n                    : 0;\n\n    while (true) {\n        const char *dhcpserver = NULL;\n        int ctr;\n\n        if (idx < num_dhcpsrvrs)\n            dhcpserver = virNWFilterVarValueGetNthValue(dhcpsrvrs, idx);\n\n        /*\n         * create two rules allowing response to MAC address of VM\n         * or to broadcast MAC address\n         */\n        for (ctr = 0; ctr < 2; ctr++) {\n            if (dhcpserver)\n                virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                   \"-t\", \"nat\", \"-A\", chain_out,\n                                   \"-d\", (ctr == 0) ? macaddr_str : \"ff:ff:ff:ff:ff:ff\",\n                                   \"-p\", \"ipv4\", \"--ip-protocol\", \"udp\",\n                                   \"--ip-src\", dhcpserver,\n                                   \"--ip-sport\", \"67\", \"--ip-dport\", \"68\",\n                                   \"-j\", \"ACCEPT\", NULL);\n            else\n                virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                   \"-t\", \"nat\", \"-A\", chain_out,\n                                   \"-d\", (ctr == 0) ? macaddr_str : \"ff:ff:ff:ff:ff:ff\",\n                                   \"-p\", \"ipv4\", \"--ip-protocol\", \"udp\",\n                                   \"--ip-sport\", \"67\", \"--ip-dport\", \"68\",\n                                   \"-j\", \"ACCEPT\", NULL);\n        }\n\n        idx++;\n\n        if (idx >= num_dhcpsrvrs)\n            break;\n    }\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain_out,\n                       \"-j\", \"DROP\", NULL);\n\n    ebtablesLinkTmpRootChainFW(fw, true, ifname);\n    ebtablesLinkTmpRootChainFW(fw, false, ifname);\n\n    if (!leaveTemporary) {\n        ebtablesRenameTmpRootChainFW(fw, true, ifname);\n        ebtablesRenameTmpRootChainFW(fw, false, ifname);\n    }\n\n    if (virFirewallApply(fw) < 0)\n        goto tear_down_tmpebchains;\n\n    virFirewallFree(fw);\n\n    return 0;\n\n tear_down_tmpebchains:\n    ebtablesCleanAll(ifname);\n error:\n    virFirewallFree(fw);\n    return -1;\n}"
  },
  {
    "function_name": "ebtablesApplyBasicRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2862-2911",
    "snippet": "static int\nebtablesApplyBasicRules(const char *ifname,\n                        const virMacAddr *macaddr)\n{\n    virFirewallPtr fw = virFirewallNew();\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = CHAINPREFIX_HOST_IN_TEMP;\n    char macaddr_str[VIR_MAC_STRING_BUFLEN];\n\n    virMacAddrFormat(macaddr, macaddr_str);\n\n    if (ebiptablesAllTeardown(ifname) < 0)\n        goto error;\n\n    virFirewallStartTransaction(fw, 0);\n\n    ebtablesCreateTmpRootChainFW(fw, true, ifname);\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain,\n                       \"-s\", \"!\", macaddr_str,\n                       \"-j\", \"DROP\", NULL);\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain,\n                       \"-p\", \"IPv4\",\n                       \"-j\", \"ACCEPT\", NULL);\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain,\n                       \"-p\", \"ARP\",\n                       \"-j\", \"ACCEPT\", NULL);\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain,\n                       \"-j\", \"DROP\", NULL);\n\n    ebtablesLinkTmpRootChainFW(fw, true, ifname);\n    ebtablesRenameTmpRootChainFW(fw, true, ifname);\n\n    if (virFirewallApply(fw) < 0)\n        goto tear_down_tmpebchains;\n\n    virFirewallFree(fw);\n    return 0;\n\n tear_down_tmpebchains:\n    ebtablesCleanAll(ifname);\n error:\n    virFirewallFree(fw);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallFree",
          "args": [
            "fw"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "286-298",
          "snippet": "void virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesCleanAll",
          "args": [
            "ifname"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesCleanAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3095-3118",
          "snippet": "static int\nebtablesCleanAll(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n    ebtablesRemoveSubChainsFW(fw, ifname);\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebtablesCleanAll(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n    ebtablesRemoveSubChainsFW(fw, ifname);\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ebtablesUnlinkTmpRootChainFW(fw, true, ifname);\n    ebtablesUnlinkTmpRootChainFW(fw, false, ifname);\n    ebtablesRemoveTmpSubChainsFW(fw, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, true, ifname);\n    ebtablesRemoveTmpRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallApply",
          "args": [
            "fw"
          ],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "804-868",
          "snippet": "int\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
            "static virMutex ruleLock = VIR_MUTEX_INITIALIZER;",
            "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic virMutex ruleLock = VIR_MUTEX_INITIALIZER;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nint\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesRenameTmpRootChainFW",
          "args": [
            "fw",
            "true",
            "ifname"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRenameTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2758-2764",
          "snippet": "static void\nebtablesRenameTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming,\n                             const char *ifname)\n{\n    ebtablesRenameTmpSubChainFW(fw, incoming, ifname, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRenameTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming,\n                             const char *ifname)\n{\n    ebtablesRenameTmpSubChainFW(fw, incoming, ifname, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesLinkTmpRootChainFW",
          "args": [
            "fw",
            "true",
            "ifname"
          ],
          "line": 2897
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesLinkTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2516-2531",
          "snippet": "static void\nebtablesLinkTmpRootChainFW(virFirewallPtr fw,\n                           int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\",\n                       incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                       incoming ? \"-i\" : \"-o\",\n                       ifname, \"-j\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
            "#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"",
            "#define EBTABLES_CHAIN_INCOMING \"PREROUTING\""
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"\n#define EBTABLES_CHAIN_INCOMING \"PREROUTING\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesLinkTmpRootChainFW(virFirewallPtr fw,\n                           int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\",\n                       incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                       incoming ? \"-i\" : \"-o\",\n                       ifname, \"-j\", chain, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_ETHERNET",
            "\"-t\"",
            "\"nat\"",
            "\"-A\"",
            "chain",
            "\"-j\"",
            "\"DROP\"",
            "NULL"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebtablesCreateTmpRootChainFW",
          "args": [
            "fw",
            "true",
            "ifname"
          ],
          "line": 2878
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesCreateTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2501-2513",
          "snippet": "static void\nebtablesCreateTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = (incoming) ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-N\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesCreateTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = (incoming) ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-N\", chain, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallStartTransaction",
          "args": [
            "fw",
            "0"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallStartTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "586-607",
          "snippet": "void virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebiptablesAllTeardown",
          "args": [
            "ifname"
          ],
          "line": 2873
        },
        "resolved": true,
        "details": {
          "function_name": "ebiptablesAllTeardown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "3646-3675",
          "snippet": "static int\nebiptablesAllTeardown(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebiptablesTearNewRulesFW(fw, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n\n    ebtablesRemoveSubChainsFW(fw, ifname);\n\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebiptablesAllTeardown(const char *ifname)\n{\n    virFirewallPtr fw = virFirewallNew();\n    int ret = -1;\n\n    virFirewallStartTransaction(fw, VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n\n    ebiptablesTearNewRulesFW(fw, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV4, ifname);\n\n    iptablesUnlinkRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesClearVirtInPostFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n    iptablesRemoveRootChainsFW(fw, VIR_FIREWALL_LAYER_IPV6, ifname);\n\n    ebtablesUnlinkRootChainFW(fw, true, ifname);\n    ebtablesUnlinkRootChainFW(fw, false, ifname);\n\n    ebtablesRemoveSubChainsFW(fw, ifname);\n\n    ebtablesRemoveRootChainFW(fw, true, ifname);\n    ebtablesRemoveRootChainFW(fw, false, ifname);\n\n    ret = virFirewallApply(fw);\n    virFirewallFree(fw);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "macaddr",
            "macaddr_str"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallNew",
          "args": [],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "231-242",
          "snippet": "virFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebtablesApplyBasicRules(const char *ifname,\n                        const virMacAddr *macaddr)\n{\n    virFirewallPtr fw = virFirewallNew();\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = CHAINPREFIX_HOST_IN_TEMP;\n    char macaddr_str[VIR_MAC_STRING_BUFLEN];\n\n    virMacAddrFormat(macaddr, macaddr_str);\n\n    if (ebiptablesAllTeardown(ifname) < 0)\n        goto error;\n\n    virFirewallStartTransaction(fw, 0);\n\n    ebtablesCreateTmpRootChainFW(fw, true, ifname);\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain,\n                       \"-s\", \"!\", macaddr_str,\n                       \"-j\", \"DROP\", NULL);\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain,\n                       \"-p\", \"IPv4\",\n                       \"-j\", \"ACCEPT\", NULL);\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain,\n                       \"-p\", \"ARP\",\n                       \"-j\", \"ACCEPT\", NULL);\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\", chain,\n                       \"-j\", \"DROP\", NULL);\n\n    ebtablesLinkTmpRootChainFW(fw, true, ifname);\n    ebtablesRenameTmpRootChainFW(fw, true, ifname);\n\n    if (virFirewallApply(fw) < 0)\n        goto tear_down_tmpebchains;\n\n    virFirewallFree(fw);\n    return 0;\n\n tear_down_tmpebchains:\n    ebtablesCleanAll(ifname);\n error:\n    virFirewallFree(fw);\n    return -1;\n}"
  },
  {
    "function_name": "ebiptablesCanApplyBasicRules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2843-2847",
    "snippet": "static int\nebiptablesCanApplyBasicRules(void)\n{\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nebiptablesCanApplyBasicRules(void)\n{\n    return true;\n}"
  },
  {
    "function_name": "ebtablesRenameTmpSubAndRootChainsFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2812-2833",
    "snippet": "static void\nebtablesRenameTmpSubAndRootChainsFW(virFirewallPtr fw,\n                                    const char *ifname)\n{\n    char rootchain[MAX_CHAINNAME_LENGTH];\n    size_t i;\n    char chains[3] = {\n        CHAINPREFIX_HOST_IN_TEMP,\n        CHAINPREFIX_HOST_OUT_TEMP,\n        0\n    };\n    for (i = 0; chains[i] != 0; i++) {\n        PRINT_ROOT_CHAIN(rootchain, chains[i], ifname);\n        virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                               false, ebtablesRenameTmpSubAndRootChainsQuery,\n                               NULL,\n                               \"-t\", \"nat\", \"-L\", rootchain, NULL);\n    }\n\n    ebtablesRenameTmpRootChainFW(fw, true, ifname);\n    ebtablesRenameTmpRootChainFW(fw, false, ifname);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebtablesRenameTmpRootChainFW",
          "args": [
            "fw",
            "false",
            "ifname"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRenameTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2758-2764",
          "snippet": "static void\nebtablesRenameTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming,\n                             const char *ifname)\n{\n    ebtablesRenameTmpSubChainFW(fw, incoming, ifname, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRenameTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming,\n                             const char *ifname)\n{\n    ebtablesRenameTmpSubChainFW(fw, incoming, ifname, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallAddRuleFull",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_ETHERNET",
            "false",
            "ebtablesRenameTmpSubAndRootChainsQuery",
            "NULL",
            "\"-t\"",
            "\"nat\"",
            "\"-L\"",
            "rootchain",
            "NULL"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "rootchain",
            "chains[i]",
            "ifname"
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRenameTmpSubAndRootChainsFW(virFirewallPtr fw,\n                                    const char *ifname)\n{\n    char rootchain[MAX_CHAINNAME_LENGTH];\n    size_t i;\n    char chains[3] = {\n        CHAINPREFIX_HOST_IN_TEMP,\n        CHAINPREFIX_HOST_OUT_TEMP,\n        0\n    };\n    for (i = 0; chains[i] != 0; i++) {\n        PRINT_ROOT_CHAIN(rootchain, chains[i], ifname);\n        virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                               false, ebtablesRenameTmpSubAndRootChainsQuery,\n                               NULL,\n                               \"-t\", \"nat\", \"-L\", rootchain, NULL);\n    }\n\n    ebtablesRenameTmpRootChainFW(fw, true, ifname);\n    ebtablesRenameTmpRootChainFW(fw, false, ifname);\n}"
  },
  {
    "function_name": "ebtablesRenameTmpSubAndRootChainsQuery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2767-2809",
    "snippet": "static int\nebtablesRenameTmpSubAndRootChainsQuery(virFirewallPtr fw,\n                                       virFirewallLayer layer,\n                                       const char *const *lines,\n                                       void *opaque G_GNUC_UNUSED)\n{\n    size_t i;\n    char newchain[MAX_CHAINNAME_LENGTH];\n\n    for (i = 0; lines[i] != NULL; i++) {\n        VIR_DEBUG(\"Considering '%s'\", lines[i]);\n        char *tmp = strstr(lines[i], \"-j \");\n        if (!tmp)\n            continue;\n        tmp = tmp + 3;\n        if (tmp[0] != CHAINPREFIX_HOST_IN_TEMP &&\n            tmp[0] != CHAINPREFIX_HOST_OUT_TEMP)\n            continue;\n        if (tmp[1] != '-')\n            continue;\n\n        ignore_value(virStrcpyStatic(newchain, tmp));\n        if (newchain[0] == CHAINPREFIX_HOST_IN_TEMP)\n            newchain[0] = CHAINPREFIX_HOST_IN;\n        else\n            newchain[0] = CHAINPREFIX_HOST_OUT;\n        VIR_DEBUG(\"Renaming chain '%s' to '%s'\", tmp, newchain);\n        virFirewallAddRuleFull(fw, layer,\n                               false, ebtablesRenameTmpSubAndRootChainsQuery,\n                               NULL,\n                               \"-t\", \"nat\", \"-L\", tmp, NULL);\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-t\", \"nat\", \"-F\", newchain, NULL);\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-t\", \"nat\", \"-X\", newchain, NULL);\n        virFirewallAddRule(fw, layer,\n                           \"-t\", \"nat\", \"-E\", tmp, newchain, NULL);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
      "#define CHAINPREFIX_HOST_OUT      'O'",
      "#define CHAINPREFIX_HOST_IN       'I'"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "layer",
            "\"-t\"",
            "\"nat\"",
            "\"-E\"",
            "tmp",
            "newchain",
            "NULL"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Renaming chain '%s' to '%s'\"",
            "tmp",
            "newchain"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrcpyStatic(newchain, tmp)"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "newchain",
            "tmp"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "lines[i]",
            "\"-j \""
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Considering '%s'\"",
            "lines[i]"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n\nstatic int\nebtablesRenameTmpSubAndRootChainsQuery(virFirewallPtr fw,\n                                       virFirewallLayer layer,\n                                       const char *const *lines,\n                                       void *opaque G_GNUC_UNUSED)\n{\n    size_t i;\n    char newchain[MAX_CHAINNAME_LENGTH];\n\n    for (i = 0; lines[i] != NULL; i++) {\n        VIR_DEBUG(\"Considering '%s'\", lines[i]);\n        char *tmp = strstr(lines[i], \"-j \");\n        if (!tmp)\n            continue;\n        tmp = tmp + 3;\n        if (tmp[0] != CHAINPREFIX_HOST_IN_TEMP &&\n            tmp[0] != CHAINPREFIX_HOST_OUT_TEMP)\n            continue;\n        if (tmp[1] != '-')\n            continue;\n\n        ignore_value(virStrcpyStatic(newchain, tmp));\n        if (newchain[0] == CHAINPREFIX_HOST_IN_TEMP)\n            newchain[0] = CHAINPREFIX_HOST_IN;\n        else\n            newchain[0] = CHAINPREFIX_HOST_OUT;\n        VIR_DEBUG(\"Renaming chain '%s' to '%s'\", tmp, newchain);\n        virFirewallAddRuleFull(fw, layer,\n                               false, ebtablesRenameTmpSubAndRootChainsQuery,\n                               NULL,\n                               \"-t\", \"nat\", \"-L\", tmp, NULL);\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-t\", \"nat\", \"-F\", newchain, NULL);\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-t\", \"nat\", \"-X\", newchain, NULL);\n        virFirewallAddRule(fw, layer,\n                           \"-t\", \"nat\", \"-E\", tmp, newchain, NULL);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "ebtablesRenameTmpRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2758-2764",
    "snippet": "static void\nebtablesRenameTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming,\n                             const char *ifname)\n{\n    ebtablesRenameTmpSubChainFW(fw, incoming, ifname, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebtablesRenameTmpSubChainFW",
          "args": [
            "fw",
            "incoming",
            "ifname",
            "NULL"
          ],
          "line": 2763
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesRenameTmpSubChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2734-2756",
          "snippet": "static void\nebtablesRenameTmpSubChainFW(virFirewallPtr fw,\n                            int incoming,\n                            const char *ifname,\n                            const char *protocol)\n{\n    char tmpchain[MAX_CHAINNAME_LENGTH], chain[MAX_CHAINNAME_LENGTH];\n    char tmpChainPrefix = (incoming) ? CHAINPREFIX_HOST_IN_TEMP\n                                     : CHAINPREFIX_HOST_OUT_TEMP;\n    char chainPrefix = (incoming) ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    if (protocol) {\n        PRINT_CHAIN(tmpchain, tmpChainPrefix, ifname, protocol);\n        PRINT_CHAIN(chain, chainPrefix, ifname, protocol);\n    } else {\n        PRINT_ROOT_CHAIN(tmpchain, tmpChainPrefix, ifname);\n        PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n    }\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-E\", tmpchain, chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
            "#define CHAINPREFIX_HOST_OUT      'O'",
            "#define CHAINPREFIX_HOST_IN       'I'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRenameTmpSubChainFW(virFirewallPtr fw,\n                            int incoming,\n                            const char *ifname,\n                            const char *protocol)\n{\n    char tmpchain[MAX_CHAINNAME_LENGTH], chain[MAX_CHAINNAME_LENGTH];\n    char tmpChainPrefix = (incoming) ? CHAINPREFIX_HOST_IN_TEMP\n                                     : CHAINPREFIX_HOST_OUT_TEMP;\n    char chainPrefix = (incoming) ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    if (protocol) {\n        PRINT_CHAIN(tmpchain, tmpChainPrefix, ifname, protocol);\n        PRINT_CHAIN(chain, chainPrefix, ifname, protocol);\n    } else {\n        PRINT_ROOT_CHAIN(tmpchain, tmpChainPrefix, ifname);\n        PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n    }\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-E\", tmpchain, chain, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRenameTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming,\n                             const char *ifname)\n{\n    ebtablesRenameTmpSubChainFW(fw, incoming, ifname, NULL);\n}"
  },
  {
    "function_name": "ebtablesRenameTmpSubChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2734-2756",
    "snippet": "static void\nebtablesRenameTmpSubChainFW(virFirewallPtr fw,\n                            int incoming,\n                            const char *ifname,\n                            const char *protocol)\n{\n    char tmpchain[MAX_CHAINNAME_LENGTH], chain[MAX_CHAINNAME_LENGTH];\n    char tmpChainPrefix = (incoming) ? CHAINPREFIX_HOST_IN_TEMP\n                                     : CHAINPREFIX_HOST_OUT_TEMP;\n    char chainPrefix = (incoming) ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    if (protocol) {\n        PRINT_CHAIN(tmpchain, tmpChainPrefix, ifname, protocol);\n        PRINT_CHAIN(chain, chainPrefix, ifname, protocol);\n    } else {\n        PRINT_ROOT_CHAIN(tmpchain, tmpChainPrefix, ifname);\n        PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n    }\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-E\", tmpchain, chain, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
      "#define CHAINPREFIX_HOST_OUT      'O'",
      "#define CHAINPREFIX_HOST_IN       'I'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_ETHERNET",
            "\"-t\"",
            "\"nat\"",
            "\"-E\"",
            "tmpchain",
            "chain",
            "NULL"
          ],
          "line": 2754
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "tmpchain",
            "tmpChainPrefix",
            "ifname"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname",
            "protocol"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_CHAIN",
          "args": [
            "tmpchain",
            "tmpChainPrefix",
            "ifname",
            "protocol"
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRenameTmpSubChainFW(virFirewallPtr fw,\n                            int incoming,\n                            const char *ifname,\n                            const char *protocol)\n{\n    char tmpchain[MAX_CHAINNAME_LENGTH], chain[MAX_CHAINNAME_LENGTH];\n    char tmpChainPrefix = (incoming) ? CHAINPREFIX_HOST_IN_TEMP\n                                     : CHAINPREFIX_HOST_OUT_TEMP;\n    char chainPrefix = (incoming) ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    if (protocol) {\n        PRINT_CHAIN(tmpchain, tmpChainPrefix, ifname, protocol);\n        PRINT_CHAIN(chain, chainPrefix, ifname, protocol);\n    } else {\n        PRINT_ROOT_CHAIN(tmpchain, tmpChainPrefix, ifname);\n        PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n    }\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-E\", tmpchain, chain, NULL);\n}"
  },
  {
    "function_name": "ebtablesRemoveTmpSubChainsFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2727-2732",
    "snippet": "static void\nebtablesRemoveTmpSubChainsFW(virFirewallPtr fw,\n                             const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host_temp);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);",
      "static char chainprefixes_host_temp[3] = {\n    CHAINPREFIX_HOST_IN_TEMP,\n    CHAINPREFIX_HOST_OUT_TEMP,\n    0\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ebtablesRemoveSubChainsFW",
          "args": [
            "fw",
            "ifname",
            "chainprefixes_host_temp"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "_ebtablesRemoveSubChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2702-2717",
          "snippet": "static void\n_ebtablesRemoveSubChainsFW(virFirewallPtr fw,\n                           const char *ifname,\n                           const char *chainprefixes)\n{\n    char rootchain[MAX_CHAINNAME_LENGTH];\n    size_t i;\n\n    for (i = 0; chainprefixes[i] != 0; i++) {\n        PRINT_ROOT_CHAIN(rootchain, chainprefixes[i], ifname);\n        virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                               false, ebtablesRemoveSubChainsQuery,\n                               (void *)chainprefixes,\n                               \"-t\", \"nat\", \"-L\", rootchain, NULL);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_ebtablesRemoveSubChainsFW(virFirewallPtr fw,\n                           const char *ifname,\n                           const char *chainprefixes)\n{\n    char rootchain[MAX_CHAINNAME_LENGTH];\n    size_t i;\n\n    for (i = 0; chainprefixes[i] != 0; i++) {\n        PRINT_ROOT_CHAIN(rootchain, chainprefixes[i], ifname);\n        virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                               false, ebtablesRemoveSubChainsQuery,\n                               (void *)chainprefixes,\n                               \"-t\", \"nat\", \"-L\", rootchain, NULL);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\nstatic char chainprefixes_host_temp[3] = {\n    CHAINPREFIX_HOST_IN_TEMP,\n    CHAINPREFIX_HOST_OUT_TEMP,\n    0\n};\n\nstatic void\nebtablesRemoveTmpSubChainsFW(virFirewallPtr fw,\n                             const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host_temp);\n}"
  },
  {
    "function_name": "ebtablesRemoveSubChainsFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2719-2724",
    "snippet": "static void\nebtablesRemoveSubChainsFW(virFirewallPtr fw,\n                          const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);",
      "static char chainprefixes_host[3] = {\n    CHAINPREFIX_HOST_IN,\n    CHAINPREFIX_HOST_OUT,\n    0\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ebtablesRemoveSubChainsFW",
          "args": [
            "fw",
            "ifname",
            "chainprefixes_host"
          ],
          "line": 2723
        },
        "resolved": true,
        "details": {
          "function_name": "_ebtablesRemoveSubChainsFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2702-2717",
          "snippet": "static void\n_ebtablesRemoveSubChainsFW(virFirewallPtr fw,\n                           const char *ifname,\n                           const char *chainprefixes)\n{\n    char rootchain[MAX_CHAINNAME_LENGTH];\n    size_t i;\n\n    for (i = 0; chainprefixes[i] != 0; i++) {\n        PRINT_ROOT_CHAIN(rootchain, chainprefixes[i], ifname);\n        virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                               false, ebtablesRemoveSubChainsQuery,\n                               (void *)chainprefixes,\n                               \"-t\", \"nat\", \"-L\", rootchain, NULL);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_ebtablesRemoveSubChainsFW(virFirewallPtr fw,\n                           const char *ifname,\n                           const char *chainprefixes)\n{\n    char rootchain[MAX_CHAINNAME_LENGTH];\n    size_t i;\n\n    for (i = 0; chainprefixes[i] != 0; i++) {\n        PRINT_ROOT_CHAIN(rootchain, chainprefixes[i], ifname);\n        virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                               false, ebtablesRemoveSubChainsQuery,\n                               (void *)chainprefixes,\n                               \"-t\", \"nat\", \"-L\", rootchain, NULL);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\nstatic char chainprefixes_host[3] = {\n    CHAINPREFIX_HOST_IN,\n    CHAINPREFIX_HOST_OUT,\n    0\n};\n\nstatic void\nebtablesRemoveSubChainsFW(virFirewallPtr fw,\n                          const char *ifname)\n{\n    _ebtablesRemoveSubChainsFW(fw, ifname, chainprefixes_host);\n}"
  },
  {
    "function_name": "_ebtablesRemoveSubChainsFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2702-2717",
    "snippet": "static void\n_ebtablesRemoveSubChainsFW(virFirewallPtr fw,\n                           const char *ifname,\n                           const char *chainprefixes)\n{\n    char rootchain[MAX_CHAINNAME_LENGTH];\n    size_t i;\n\n    for (i = 0; chainprefixes[i] != 0; i++) {\n        PRINT_ROOT_CHAIN(rootchain, chainprefixes[i], ifname);\n        virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                               false, ebtablesRemoveSubChainsQuery,\n                               (void *)chainprefixes,\n                               \"-t\", \"nat\", \"-L\", rootchain, NULL);\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRuleFull",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_ETHERNET",
            "false",
            "ebtablesRemoveSubChainsQuery",
            "(void *)chainprefixes",
            "\"-t\"",
            "\"nat\"",
            "\"-L\"",
            "rootchain",
            "NULL"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "rootchain",
            "chainprefixes[i]",
            "ifname"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_ebtablesRemoveSubChainsFW(virFirewallPtr fw,\n                           const char *ifname,\n                           const char *chainprefixes)\n{\n    char rootchain[MAX_CHAINNAME_LENGTH];\n    size_t i;\n\n    for (i = 0; chainprefixes[i] != 0; i++) {\n        PRINT_ROOT_CHAIN(rootchain, chainprefixes[i], ifname);\n        virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                               false, ebtablesRemoveSubChainsQuery,\n                               (void *)chainprefixes,\n                               \"-t\", \"nat\", \"-L\", rootchain, NULL);\n    }\n}"
  },
  {
    "function_name": "ebtablesRemoveSubChainsQuery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2665-2699",
    "snippet": "static int\nebtablesRemoveSubChainsQuery(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             const char *const *lines,\n                             void *opaque)\n{\n    size_t i, j;\n    const char *chainprefixes = opaque;\n\n    for (i = 0; lines[i] != NULL; i++) {\n        VIR_DEBUG(\"Considering '%s'\", lines[i]);\n        char *tmp = strstr(lines[i], \"-j \");\n        if (!tmp)\n            continue;\n        tmp = tmp + 3;\n        for (j = 0; chainprefixes[j]; j++) {\n            if (tmp[0] == chainprefixes[j] &&\n                tmp[1] == '-') {\n                VIR_DEBUG(\"Processing chain '%s'\", tmp);\n                virFirewallAddRuleFull(fw, layer,\n                                       false, ebtablesRemoveSubChainsQuery,\n                                       (void *)chainprefixes,\n                                        \"-t\", \"nat\", \"-L\", tmp, NULL);\n                virFirewallAddRuleFull(fw, layer,\n                                       true, NULL, NULL,\n                                       \"-t\", \"nat\", \"-F\", tmp, NULL);\n                virFirewallAddRuleFull(fw, layer,\n                                       true, NULL, NULL,\n                                       \"-t\", \"nat\", \"-X\", tmp, NULL);\n            }\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRuleFull",
          "args": [
            "fw",
            "layer",
            "true",
            "NULL",
            "NULL",
            "\"-t\"",
            "\"nat\"",
            "\"-X\"",
            "tmp",
            "NULL"
          ],
          "line": 2691
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Processing chain '%s'\"",
            "tmp"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "lines[i]",
            "\"-j \""
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Considering '%s'\"",
            "lines[i]"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nebtablesRemoveSubChainsQuery(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             const char *const *lines,\n                             void *opaque)\n{\n    size_t i, j;\n    const char *chainprefixes = opaque;\n\n    for (i = 0; lines[i] != NULL; i++) {\n        VIR_DEBUG(\"Considering '%s'\", lines[i]);\n        char *tmp = strstr(lines[i], \"-j \");\n        if (!tmp)\n            continue;\n        tmp = tmp + 3;\n        for (j = 0; chainprefixes[j]; j++) {\n            if (tmp[0] == chainprefixes[j] &&\n                tmp[1] == '-') {\n                VIR_DEBUG(\"Processing chain '%s'\", tmp);\n                virFirewallAddRuleFull(fw, layer,\n                                       false, ebtablesRemoveSubChainsQuery,\n                                       (void *)chainprefixes,\n                                        \"-t\", \"nat\", \"-L\", tmp, NULL);\n                virFirewallAddRuleFull(fw, layer,\n                                       true, NULL, NULL,\n                                       \"-t\", \"nat\", \"-F\", tmp, NULL);\n                virFirewallAddRuleFull(fw, layer,\n                                       true, NULL, NULL,\n                                       \"-t\", \"nat\", \"-X\", tmp, NULL);\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "ebtablesCreateTmpSubChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2617-2662",
    "snippet": "static void\nebtablesCreateTmpSubChainFW(virFirewallPtr fw,\n                            bool incoming,\n                            const char *ifname,\n                            enum l3_proto_idx protoidx,\n                            const char *filtername)\n{\n    char rootchain[MAX_CHAINNAME_LENGTH], chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                : CHAINPREFIX_HOST_OUT_TEMP;\n    virFirewallRulePtr fwrule;\n\n    PRINT_ROOT_CHAIN(rootchain, chainPrefix, ifname);\n    PRINT_CHAIN(chain, chainPrefix, ifname,\n                (filtername) ? filtername : l3_protocols[protoidx].val);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-X\", chain, NULL);\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-N\", chain, NULL);\n\n    fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                \"-t\", \"nat\", \"-A\", rootchain, NULL);\n\n    switch ((int)protoidx) {\n    case L2_PROTO_MAC_IDX:\n        break;\n    case L2_PROTO_STP_IDX:\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-d\", NWFILTER_MAC_BGA, NULL);\n        break;\n    default:\n        virFirewallRuleAddArg(fw, fwrule, \"-p\");\n        virFirewallRuleAddArgFormat(fw, fwrule,\n                                    \"0x%04x\",\n                                    l3_protocols[protoidx].attr);\n        break;\n    }\n\n    virFirewallRuleAddArgList(fw, fwrule,\n                              \"-j\", chain, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);",
      "static const struct ushort_map l3_protocols[] = {\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV4_IDX, ETHERTYPE_IP,     \"ipv4\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV6_IDX, ETHERTYPE_IPV6,   \"ipv6\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_ARP_IDX,  ETHERTYPE_ARP,    \"arp\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_RARP_IDX, ETHERTYPE_REVARP, \"rarp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_VLAN_IDX, ETHERTYPE_VLAN,   \"vlan\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_STP_IDX,  0,                \"stp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_MAC_IDX,  0,                \"mac\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_LAST_IDX, 0,                NULL),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallRuleAddArgList",
          "args": [
            "fw",
            "fwrule",
            "\"-j\"",
            "chain",
            "NULL"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "541-562",
          "snippet": "void virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallRuleAddArgFormat",
          "args": [
            "fw",
            "fwrule",
            "\"0x%04x\"",
            "l3_protocols[protoidx].attr"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "501-520",
          "snippet": "void virFirewallRuleAddArgFormat(virFirewallPtr firewall,\n                                 virFirewallRulePtr rule,\n                                 const char *fmt, ...)\n{\n    g_autofree char *arg = NULL;\n    va_list list;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, fmt);\n    arg = g_strdup_vprintf(fmt, list);\n    va_end(list);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgFormat(virFirewallPtr firewall,\n                                 virFirewallRulePtr rule,\n                                 const char *fmt, ...)\n{\n    g_autofree char *arg = NULL;\n    va_list list;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, fmt);\n    arg = g_strdup_vprintf(fmt, list);\n    va_end(list);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_ETHERNET",
            "\"-t\"",
            "\"nat\"",
            "\"-A\"",
            "rootchain",
            "NULL"
          ],
          "line": 2642
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname",
            "(filtername) ? filtername : l3_protocols[protoidx].val"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "rootchain",
            "chainPrefix",
            "ifname"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\nstatic const struct ushort_map l3_protocols[] = {\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV4_IDX, ETHERTYPE_IP,     \"ipv4\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV6_IDX, ETHERTYPE_IPV6,   \"ipv6\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_ARP_IDX,  ETHERTYPE_ARP,    \"arp\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_RARP_IDX, ETHERTYPE_REVARP, \"rarp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_VLAN_IDX, ETHERTYPE_VLAN,   \"vlan\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_STP_IDX,  0,                \"stp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_MAC_IDX,  0,                \"mac\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_LAST_IDX, 0,                NULL),\n};\n\nstatic void\nebtablesCreateTmpSubChainFW(virFirewallPtr fw,\n                            bool incoming,\n                            const char *ifname,\n                            enum l3_proto_idx protoidx,\n                            const char *filtername)\n{\n    char rootchain[MAX_CHAINNAME_LENGTH], chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                : CHAINPREFIX_HOST_OUT_TEMP;\n    virFirewallRulePtr fwrule;\n\n    PRINT_ROOT_CHAIN(rootchain, chainPrefix, ifname);\n    PRINT_CHAIN(chain, chainPrefix, ifname,\n                (filtername) ? filtername : l3_protocols[protoidx].val);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-X\", chain, NULL);\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-N\", chain, NULL);\n\n    fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                \"-t\", \"nat\", \"-A\", rootchain, NULL);\n\n    switch ((int)protoidx) {\n    case L2_PROTO_MAC_IDX:\n        break;\n    case L2_PROTO_STP_IDX:\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-d\", NWFILTER_MAC_BGA, NULL);\n        break;\n    default:\n        virFirewallRuleAddArg(fw, fwrule, \"-p\");\n        virFirewallRuleAddArgFormat(fw, fwrule,\n                                    \"0x%04x\",\n                                    l3_protocols[protoidx].attr);\n        break;\n    }\n\n    virFirewallRuleAddArgList(fw, fwrule,\n                              \"-j\", chain, NULL);\n}"
  },
  {
    "function_name": "ebtablesUnlinkTmpRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2610-2615",
    "snippet": "static void\nebtablesUnlinkTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, 1);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ebtablesUnlinkRootChainFW",
          "args": [
            "fw",
            "incoming",
            "ifname",
            "1"
          ],
          "line": 2614
        },
        "resolved": true,
        "details": {
          "function_name": "_ebtablesUnlinkRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2575-2599",
          "snippet": "static void\n_ebtablesUnlinkRootChainFW(virFirewallPtr fw,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix;\n\n    if (isTempChain) {\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                               : CHAINPREFIX_HOST_OUT_TEMP;\n    } else {\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN\n                               : CHAINPREFIX_HOST_OUT;\n    }\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-D\",\n                           incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                           incoming ? \"-i\" : \"-o\",\n                           ifname, \"-j\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
            "#define CHAINPREFIX_HOST_OUT      'O'",
            "#define CHAINPREFIX_HOST_IN       'I'",
            "#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"",
            "#define EBTABLES_CHAIN_INCOMING \"PREROUTING\""
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"\n#define EBTABLES_CHAIN_INCOMING \"PREROUTING\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_ebtablesUnlinkRootChainFW(virFirewallPtr fw,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix;\n\n    if (isTempChain) {\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                               : CHAINPREFIX_HOST_OUT_TEMP;\n    } else {\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN\n                               : CHAINPREFIX_HOST_OUT;\n    }\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-D\",\n                           incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                           incoming ? \"-i\" : \"-o\",\n                           ifname, \"-j\", chain, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesUnlinkTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, 1);\n}"
  },
  {
    "function_name": "ebtablesUnlinkRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2602-2607",
    "snippet": "static void\nebtablesUnlinkRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, false);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ebtablesUnlinkRootChainFW",
          "args": [
            "fw",
            "incoming",
            "ifname",
            "false"
          ],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "_ebtablesUnlinkRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2575-2599",
          "snippet": "static void\n_ebtablesUnlinkRootChainFW(virFirewallPtr fw,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix;\n\n    if (isTempChain) {\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                               : CHAINPREFIX_HOST_OUT_TEMP;\n    } else {\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN\n                               : CHAINPREFIX_HOST_OUT;\n    }\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-D\",\n                           incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                           incoming ? \"-i\" : \"-o\",\n                           ifname, \"-j\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
            "#define CHAINPREFIX_HOST_OUT      'O'",
            "#define CHAINPREFIX_HOST_IN       'I'",
            "#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"",
            "#define EBTABLES_CHAIN_INCOMING \"PREROUTING\""
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"\n#define EBTABLES_CHAIN_INCOMING \"PREROUTING\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_ebtablesUnlinkRootChainFW(virFirewallPtr fw,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix;\n\n    if (isTempChain) {\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                               : CHAINPREFIX_HOST_OUT_TEMP;\n    } else {\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN\n                               : CHAINPREFIX_HOST_OUT;\n    }\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-D\",\n                           incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                           incoming ? \"-i\" : \"-o\",\n                           ifname, \"-j\", chain, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesUnlinkRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesUnlinkRootChainFW(fw, incoming, ifname, false);\n}"
  },
  {
    "function_name": "_ebtablesUnlinkRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2575-2599",
    "snippet": "static void\n_ebtablesUnlinkRootChainFW(virFirewallPtr fw,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix;\n\n    if (isTempChain) {\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                               : CHAINPREFIX_HOST_OUT_TEMP;\n    } else {\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN\n                               : CHAINPREFIX_HOST_OUT;\n    }\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-D\",\n                           incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                           incoming ? \"-i\" : \"-o\",\n                           ifname, \"-j\", chain, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
      "#define CHAINPREFIX_HOST_OUT      'O'",
      "#define CHAINPREFIX_HOST_IN       'I'",
      "#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"",
      "#define EBTABLES_CHAIN_INCOMING \"PREROUTING\""
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRuleFull",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_ETHERNET",
            "true",
            "NULL",
            "NULL",
            "\"-t\"",
            "\"nat\"",
            "\"-D\"",
            "incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING",
            "incoming ? \"-i\" : \"-o\"",
            "ifname",
            "\"-j\"",
            "chain",
            "NULL"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"\n#define EBTABLES_CHAIN_INCOMING \"PREROUTING\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_ebtablesUnlinkRootChainFW(virFirewallPtr fw,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix;\n\n    if (isTempChain) {\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                               : CHAINPREFIX_HOST_OUT_TEMP;\n    } else {\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN\n                               : CHAINPREFIX_HOST_OUT;\n    }\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-D\",\n                           incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                           incoming ? \"-i\" : \"-o\",\n                           ifname, \"-j\", chain, NULL);\n}"
  },
  {
    "function_name": "ebtablesRemoveTmpRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2567-2572",
    "snippet": "static void\nebtablesRemoveTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, 1);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ebtablesRemoveRootChainFW",
          "args": [
            "fw",
            "incoming",
            "ifname",
            "1"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "_ebtablesRemoveRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2534-2556",
          "snippet": "static void\n_ebtablesRemoveRootChainFW(virFirewallPtr fw,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix;\n    if (isTempChain)\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                               : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN\n                               : CHAINPREFIX_HOST_OUT;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-X\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
            "#define CHAINPREFIX_HOST_OUT      'O'",
            "#define CHAINPREFIX_HOST_IN       'I'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_ebtablesRemoveRootChainFW(virFirewallPtr fw,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix;\n    if (isTempChain)\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                               : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN\n                               : CHAINPREFIX_HOST_OUT;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-X\", chain, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRemoveTmpRootChainFW(virFirewallPtr fw,\n                             bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, 1);\n}"
  },
  {
    "function_name": "ebtablesRemoveRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2559-2564",
    "snippet": "static void\nebtablesRemoveRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, false);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ebtablesRemoveRootChainFW",
          "args": [
            "fw",
            "incoming",
            "ifname",
            "false"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "_ebtablesRemoveRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2534-2556",
          "snippet": "static void\n_ebtablesRemoveRootChainFW(virFirewallPtr fw,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix;\n    if (isTempChain)\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                               : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN\n                               : CHAINPREFIX_HOST_OUT;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-X\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
            "#define CHAINPREFIX_HOST_OUT      'O'",
            "#define CHAINPREFIX_HOST_IN       'I'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_ebtablesRemoveRootChainFW(virFirewallPtr fw,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix;\n    if (isTempChain)\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                               : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN\n                               : CHAINPREFIX_HOST_OUT;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-X\", chain, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesRemoveRootChainFW(virFirewallPtr fw,\n                          bool incoming, const char *ifname)\n{\n    _ebtablesRemoveRootChainFW(fw, incoming, ifname, false);\n}"
  },
  {
    "function_name": "_ebtablesRemoveRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2534-2556",
    "snippet": "static void\n_ebtablesRemoveRootChainFW(virFirewallPtr fw,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix;\n    if (isTempChain)\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                               : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN\n                               : CHAINPREFIX_HOST_OUT;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-X\", chain, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
      "#define CHAINPREFIX_HOST_OUT      'O'",
      "#define CHAINPREFIX_HOST_IN       'I'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRuleFull",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_ETHERNET",
            "true",
            "NULL",
            "NULL",
            "\"-t\"",
            "\"nat\"",
            "\"-X\"",
            "chain",
            "NULL"
          ],
          "line": 2553
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_ebtablesRemoveRootChainFW(virFirewallPtr fw,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix;\n    if (isTempChain)\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                               : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix = incoming ? CHAINPREFIX_HOST_IN\n                               : CHAINPREFIX_HOST_OUT;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                           true, NULL, NULL,\n                           \"-t\", \"nat\", \"-X\", chain, NULL);\n}"
  },
  {
    "function_name": "ebtablesLinkTmpRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2516-2531",
    "snippet": "static void\nebtablesLinkTmpRootChainFW(virFirewallPtr fw,\n                           int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\",\n                       incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                       incoming ? \"-i\" : \"-o\",\n                       ifname, \"-j\", chain, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
      "#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"",
      "#define EBTABLES_CHAIN_INCOMING \"PREROUTING\""
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_ETHERNET",
            "\"-t\"",
            "\"nat\"",
            "\"-A\"",
            "incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING",
            "incoming ? \"-i\" : \"-o\"",
            "ifname",
            "\"-j\"",
            "chain",
            "NULL"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define EBTABLES_CHAIN_OUTGOING \"POSTROUTING\"\n#define EBTABLES_CHAIN_INCOMING \"PREROUTING\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesLinkTmpRootChainFW(virFirewallPtr fw,\n                           int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-A\",\n                       incoming ? EBTABLES_CHAIN_INCOMING : EBTABLES_CHAIN_OUTGOING,\n                       incoming ? \"-i\" : \"-o\",\n                       ifname, \"-j\", chain, NULL);\n}"
  },
  {
    "function_name": "ebtablesCreateTmpRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2501-2513",
    "snippet": "static void\nebtablesCreateTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = (incoming) ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-N\", chain, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_ETHERNET",
            "\"-t\"",
            "\"nat\"",
            "\"-N\"",
            "chain",
            "NULL"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\nebtablesCreateTmpRootChainFW(virFirewallPtr fw,\n                             int incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix = (incoming) ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n\n    PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                       \"-t\", \"nat\", \"-N\", chain, NULL);\n}"
  },
  {
    "function_name": "ebiptablesCreateRuleInstance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "2446-2498",
    "snippet": "static int\nebiptablesCreateRuleInstance(virFirewallPtr fw,\n                             const char *chainSuffix,\n                             virNWFilterRuleDefPtr rule,\n                             const char *ifname,\n                             virNWFilterVarCombIterPtr vars)\n{\n    if (virNWFilterRuleIsProtocolEthernet(rule)) {\n        if (rule->tt == VIR_NWFILTER_RULE_DIRECTION_OUT ||\n            rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n            if (ebtablesCreateRuleInstance(fw,\n                                           CHAINPREFIX_HOST_IN_TEMP,\n                                           chainSuffix,\n                                           rule,\n                                           ifname,\n                                           vars,\n                                           rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) < 0)\n                return -1;\n        }\n\n        if (rule->tt == VIR_NWFILTER_RULE_DIRECTION_IN ||\n            rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n            if (ebtablesCreateRuleInstance(fw,\n                                           CHAINPREFIX_HOST_OUT_TEMP,\n                                           chainSuffix,\n                                           rule,\n                                           ifname,\n                                           vars,\n                                           false) < 0)\n                return -1;\n        }\n    } else {\n        virFirewallLayer layer;\n        if (virNWFilterRuleIsProtocolIPv6(rule)) {\n            layer = VIR_FIREWALL_LAYER_IPV6;\n        } else if (virNWFilterRuleIsProtocolIPv4(rule)) {\n            layer = VIR_FIREWALL_LAYER_IPV4;\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           \"%s\", _(\"unexpected protocol type\"));\n            return -1;\n        }\n\n        if (iptablesCreateRuleInstance(fw,\n                                       layer,\n                                       rule,\n                                       ifname,\n                                       vars) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesCreateRuleInstance",
          "args": [
            "fw",
            "layer",
            "rule",
            "ifname",
            "vars"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "ebiptablesCreateRuleInstance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "2446-2498",
          "snippet": "static int\nebiptablesCreateRuleInstance(virFirewallPtr fw,\n                             const char *chainSuffix,\n                             virNWFilterRuleDefPtr rule,\n                             const char *ifname,\n                             virNWFilterVarCombIterPtr vars)\n{\n    if (virNWFilterRuleIsProtocolEthernet(rule)) {\n        if (rule->tt == VIR_NWFILTER_RULE_DIRECTION_OUT ||\n            rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n            if (ebtablesCreateRuleInstance(fw,\n                                           CHAINPREFIX_HOST_IN_TEMP,\n                                           chainSuffix,\n                                           rule,\n                                           ifname,\n                                           vars,\n                                           rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) < 0)\n                return -1;\n        }\n\n        if (rule->tt == VIR_NWFILTER_RULE_DIRECTION_IN ||\n            rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n            if (ebtablesCreateRuleInstance(fw,\n                                           CHAINPREFIX_HOST_OUT_TEMP,\n                                           chainSuffix,\n                                           rule,\n                                           ifname,\n                                           vars,\n                                           false) < 0)\n                return -1;\n        }\n    } else {\n        virFirewallLayer layer;\n        if (virNWFilterRuleIsProtocolIPv6(rule)) {\n            layer = VIR_FIREWALL_LAYER_IPV6;\n        } else if (virNWFilterRuleIsProtocolIPv4(rule)) {\n            layer = VIR_FIREWALL_LAYER_IPV4;\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           \"%s\", _(\"unexpected protocol type\"));\n            return -1;\n        }\n\n        if (iptablesCreateRuleInstance(fw,\n                                       layer,\n                                       rule,\n                                       ifname,\n                                       vars) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"unexpected protocol type\")"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected protocol type\""
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "_virNWFilterTeardownFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_gentech_driver.c",
          "lines": "898-927",
          "snippet": "static int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdev.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_dhcpsnoop.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _virNWFilterTeardownFilter(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsocketaddr.h\"\n#include \"datatypes.h\"\n#include \"virnetdev.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_dhcpsnoop.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"virerror.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int _virNWFilterTeardownFilter(const char *ifname);\n\nstatic int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleIsProtocolIPv4",
          "args": [
            "rule"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleIsProtocolIPv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "3123-3130",
          "snippet": "bool\nvirNWFilterRuleIsProtocolIPv4(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType >= VIR_NWFILTER_RULE_PROTOCOL_TCP &&\n        rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_ALL)\n        return true;\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirNWFilterRuleIsProtocolIPv4(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType >= VIR_NWFILTER_RULE_PROTOCOL_TCP &&\n        rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_ALL)\n        return true;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleIsProtocolIPv6",
          "args": [
            "rule"
          ],
          "line": 2479
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleIsProtocolIPv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "3133-3140",
          "snippet": "bool\nvirNWFilterRuleIsProtocolIPv6(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType >= VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6 &&\n        rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6)\n        return true;\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirNWFilterRuleIsProtocolIPv6(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType >= VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6 &&\n        rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6)\n        return true;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebtablesCreateRuleInstance",
          "args": [
            "fw",
            "CHAINPREFIX_HOST_OUT_TEMP",
            "chainSuffix",
            "rule",
            "ifname",
            "vars",
            "false"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesCreateRuleInstance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "1779-2429",
          "snippet": "static int\nebtablesCreateRuleInstance(virFirewallPtr fw,\n                           char chainPrefix,\n                           const char *chainSuffix,\n                           virNWFilterRuleDefPtr rule,\n                           const char *ifname,\n                           virNWFilterVarCombIterPtr vars,\n                           bool reverse)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n    char ipaddr[INET_ADDRSTRLEN];\n    char ipmask[INET_ADDRSTRLEN];\n    char ipv6addr[INET6_ADDRSTRLEN];\n    char number[VIR_INT64_STR_BUFLEN];\n    char numberalt[VIR_INT64_STR_BUFLEN];\n    char field[VIR_INT64_STR_BUFLEN];\n    char fieldalt[VIR_INT64_STR_BUFLEN];\n    char chain[MAX_CHAINNAME_LENGTH];\n    const char *target;\n    bool hasMask = false;\n    virFirewallRulePtr fwrule;\n    int ret = -1;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (STREQ(chainSuffix,\n              virNWFilterChainSuffixTypeToString(\n                  VIR_NWFILTER_CHAINSUFFIX_ROOT)))\n        PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n    else\n        PRINT_CHAIN(chain, chainPrefix, ifname,\n                    chainSuffix);\n\n#define INST_ITEM(STRUCT, ITEM, CLI) \\\n        if (HAS_ENTRY_ITEM(&rule->p.STRUCT.ITEM)) { \\\n            if (printDataType(vars, \\\n                              field, sizeof(field), \\\n                              &rule->p.STRUCT.ITEM) < 0) \\\n                goto cleanup; \\\n            virFirewallRuleAddArg(fw, fwrule, CLI); \\\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.STRUCT.ITEM)) \\\n                virFirewallRuleAddArg(fw, fwrule, \"!\"); \\\n            virFirewallRuleAddArg(fw, fwrule, field); \\\n        }\n\n#define INST_ITEM_2PARMS(STRUCT, ITEM, ITEM_HI, CLI, SEP) \\\n        if (HAS_ENTRY_ITEM(&rule->p.STRUCT.ITEM)) { \\\n            if (printDataType(vars, \\\n                              field, sizeof(field), \\\n                              &rule->p.STRUCT.ITEM) < 0) \\\n                goto cleanup; \\\n            virFirewallRuleAddArg(fw, fwrule, CLI); \\\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.STRUCT.ITEM)) \\\n                virFirewallRuleAddArg(fw, fwrule, \"!\"); \\\n            if (HAS_ENTRY_ITEM(&rule->p.STRUCT.ITEM_HI)) { \\\n                if (printDataType(vars, \\\n                                  fieldalt, sizeof(fieldalt), \\\n                                  &rule->p.STRUCT.ITEM_HI) < 0) \\\n                    goto cleanup; \\\n                virFirewallRuleAddArgFormat(fw, fwrule, \\\n                                            \"%s%s%s\", field, SEP, fieldalt); \\\n            } else  { \\\n                virFirewallRuleAddArg(fw, fwrule, field); \\\n            } \\\n        }\n#define INST_ITEM_RANGE(S, I, I_HI, C) \\\n    INST_ITEM_2PARMS(S, I, I_HI, C, \":\")\n#define INST_ITEM_MASK(S, I, MASK, C) \\\n    INST_ITEM_2PARMS(S, I, MASK, C, \"/\")\n\n    switch ((int)rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_MAC:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\",\n                                    \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.ethHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        if (HAS_ENTRY_ITEM(&rule->p.ethHdrFilter.dataProtocolID)) {\n            if (printDataTypeAsHex(vars,\n                                   number, sizeof(number),\n                                   &rule->p.ethHdrFilter.dataProtocolID) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"-p\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ethHdrFilter.dataProtocolID))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_VLAN:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.vlanHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-p\", \"0x8100\", NULL);\n\n        INST_ITEM(vlanHdrFilter, dataVlanID, \"--vlan-id\")\n        INST_ITEM(vlanHdrFilter, dataVlanEncap, \"--vlan-encap\")\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_STP:\n        /* cannot handle inout direction with srcmask set in reverse dir.\n           since this clashes with -d below... */\n        if (reverse &&\n            HAS_ENTRY_ITEM(&rule->p.stpHdrFilter.ethHdr.dataSrcMACAddr)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"STP filtering in %s direction with \"\n                             \"source MAC address set is not supported\"),\n                           virNWFilterRuleDirectionTypeToString(\n                               VIR_NWFILTER_RULE_DIRECTION_INOUT));\n            return -1;\n        }\n\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.stpHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-d\",  NWFILTER_MAC_BGA, NULL);\n\n        INST_ITEM(stpHdrFilter, dataType, \"--stp-type\")\n        INST_ITEM(stpHdrFilter, dataFlags, \"--stp-flags\")\n        INST_ITEM_RANGE(stpHdrFilter, dataRootPri, dataRootPriHi,\n                        \"--stp-root-pri\");\n        INST_ITEM_MASK(stpHdrFilter, dataRootAddr, dataRootAddrMask,\n                       \"--stp-root-addr\");\n        INST_ITEM_RANGE(stpHdrFilter, dataRootCost, dataRootCostHi,\n                        \"--stp-root-cost\");\n        INST_ITEM_RANGE(stpHdrFilter, dataSndrPrio, dataSndrPrioHi,\n                        \"--stp-sender-prio\");\n        INST_ITEM_MASK(stpHdrFilter, dataSndrAddr, dataSndrAddrMask,\n                       \"--stp-sender-addr\");\n        INST_ITEM_RANGE(stpHdrFilter, dataPort, dataPortHi, \"--stp-port\");\n        INST_ITEM_RANGE(stpHdrFilter, dataAge, dataAgeHi, \"--stp-msg-age\");\n        INST_ITEM_RANGE(stpHdrFilter, dataMaxAge, dataMaxAgeHi,\n                        \"--stp-max-age\");\n        INST_ITEM_RANGE(stpHdrFilter, dataHelloTime, dataHelloTimeHi,\n                        \"--stp-hello-time\");\n        INST_ITEM_RANGE(stpHdrFilter, dataFwdDelay, dataFwdDelayHi,\n                        \"--stp-forward-delay\");\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_RARP:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.arpHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArg(fw, fwrule, \"-p\");\n        virFirewallRuleAddArgFormat(fw, fwrule, \"0x%x\",\n                                    (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ARP)\n                                    ? l3_protocols[L3_PROTO_ARP_IDX].attr\n                                    : l3_protocols[L3_PROTO_RARP_IDX].attr);\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataHWType)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.arpHdrFilter.dataHWType) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-htype\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataHWType))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataOpcode)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.arpHdrFilter.dataOpcode) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-opcode\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataOpcode))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataProtocolType)) {\n            if (printDataTypeAsHex(vars,\n                                   number, sizeof(number),\n                                   &rule->p.arpHdrFilter.dataProtocolType) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-ptype\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataProtocolType))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPSrcIPAddr)) {\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.arpHdrFilter.dataARPSrcIPAddr) < 0)\n                goto cleanup;\n\n            if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPSrcIPMask)) {\n                if (printDataType(vars,\n                                  ipmask, sizeof(ipmask),\n                                  &rule->p.arpHdrFilter.dataARPSrcIPMask) < 0)\n                    goto cleanup;\n                hasMask = true;\n            }\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-ip-dst\" : \"--arp-ip-src\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPSrcIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, hasMask ? ipmask : \"32\");\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPDstIPAddr)) {\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.arpHdrFilter.dataARPDstIPAddr) < 0)\n                goto cleanup;\n\n            if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPDstIPMask)) {\n                if (printDataType(vars,\n                                  ipmask, sizeof(ipmask),\n                                  &rule->p.arpHdrFilter.dataARPDstIPMask) < 0)\n                    goto cleanup;\n                hasMask = true;\n            }\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-ip-src\" : \"--arp-ip-dst\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPDstIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, hasMask ? ipmask : \"32\");\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPSrcMACAddr)) {\n            if (printDataType(vars,\n                              macaddr, sizeof(macaddr),\n                              &rule->p.arpHdrFilter.dataARPSrcMACAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-mac-dst\" : \"--arp-mac-src\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPSrcMACAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPDstMACAddr)) {\n            if (printDataType(vars,\n                              macaddr, sizeof(macaddr),\n                              &rule->p.arpHdrFilter.dataARPDstMACAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-mac-src\" : \"--arp-mac-dst\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPDstMACAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataGratuitousARP) &&\n            rule->p.arpHdrFilter.dataGratuitousARP.u.boolean) {\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataGratuitousARP))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-gratuitous\");\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IP:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.ipHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-p\", \"ipv4\", NULL);\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr)) {\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-destination\" : \"--ip-source\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataSrcIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipHdrFilter.ipHdr.dataSrcIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipaddr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipaddr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataDstIPAddr)) {\n\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.ipHdrFilter.ipHdr.dataDstIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-source\" : \"--ip-destination\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataDstIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataDstIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipHdrFilter.ipHdr.dataDstIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipaddr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipaddr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataProtocolID)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipHdrFilter.ipHdr.dataProtocolID) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule, \"--ip-protocol\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataProtocolID))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataSrcPortStart)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipHdrFilter.portData.dataSrcPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-destination-port\" : \"--ip-source-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.portData.dataSrcPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataSrcPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipHdrFilter.portData.dataSrcPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataDstPortStart)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipHdrFilter.portData.dataDstPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-source-port\" : \"--ip-destination-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.portData.dataDstPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataDstPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipHdrFilter.portData.dataDstPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataDSCP)) {\n            if (printDataTypeAsHex(vars,\n                                   number, sizeof(number),\n                                   &rule->p.ipHdrFilter.ipHdr.dataDSCP) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule, \"--ip-tos\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataDSCP))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IPV6:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.ipv6HdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-p\", \"ipv6\", NULL);\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr)) {\n            if (printDataType(vars,\n                              ipv6addr, sizeof(ipv6addr),\n                              &rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-destination\" : \"--ip6-source\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.ipHdr.dataSrcIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipv6addr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipv6addr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr)) {\n\n            if (printDataType(vars,\n                              ipv6addr, sizeof(ipv6addr),\n                              &rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-source\" : \"--ip6-destination\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataDstIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.ipHdr.dataDstIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipv6addr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipv6addr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataProtocolID)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipv6HdrFilter.ipHdr.dataProtocolID) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule, \"--ip6-protocol\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.ipHdr.dataProtocolID))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataSrcPortStart)) {\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipv6HdrFilter.portData.dataSrcPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-destination-port\" : \"--ip6-source-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.portData.dataSrcPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataSrcPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.portData.dataSrcPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataDstPortStart)) {\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipv6HdrFilter.portData.dataDstPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-source-port\" : \"--ip6-destination-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.portData.dataDstPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataDstPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.portData.dataDstPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeStart)  ||\n            HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeEnd) ||\n            HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeStart) ||\n            HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeEnd)) {\n            bool lo = false;\n            char *r;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  \"--ip6-icmp-type\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeStart)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.dataICMPTypeStart) < 0)\n                    goto cleanup;\n                lo = true;\n            } else {\n                ignore_value(virStrcpyStatic(number, \"0\"));\n            }\n\n            virBufferStrcat(&buf, number, \":\", NULL);\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.dataICMPTypeEnd) < 0)\n                    goto cleanup;\n            } else {\n                if (lo)\n                    ignore_value(virStrcpyStatic(numberalt, number));\n                else\n                    ignore_value(virStrcpyStatic(numberalt, \"255\"));\n            }\n\n            virBufferStrcat(&buf, numberalt, \"/\", NULL);\n\n            lo = false;\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeStart)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.dataICMPCodeStart) < 0)\n                    goto cleanup;\n                lo = true;\n            } else {\n                ignore_value(virStrcpyStatic(number, \"0\"));\n            }\n\n            virBufferStrcat(&buf, number, \":\", NULL);\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.dataICMPCodeEnd) < 0)\n                    goto cleanup;\n            } else {\n                if (lo)\n                    ignore_value(virStrcpyStatic(numberalt, number));\n                else\n                    ignore_value(virStrcpyStatic(numberalt, \"255\"));\n            }\n\n            virBufferStrcat(&buf, numberalt, NULL);\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.dataICMPTypeStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            r = virBufferContentAndReset(&buf);\n\n            virFirewallRuleAddArg(fw, fwrule, r);\n\n            VIR_FREE(r);\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_NONE:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected rule protocol %d\"),\n                       rule->prtclType);\n        return -1;\n    }\n\n    switch (rule->action) {\n    case VIR_NWFILTER_RULE_ACTION_REJECT:\n        /* REJECT not supported */\n        target = virNWFilterJumpTargetTypeToString(\n                                     VIR_NWFILTER_RULE_ACTION_DROP);\n        break;\n    default:\n        target = virNWFilterJumpTargetTypeToString(rule->action);\n    }\n\n    virFirewallRuleAddArgList(fw, fwrule,\n                              \"-j\", target, NULL);\n\n#undef INST_ITEM_RANGE\n#undef INST_ITEM_MASK\n#undef INST_ITEM_2PARMS\n#undef INST_ITEM\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);",
            "static const struct ushort_map l3_protocols[] = {\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV4_IDX, ETHERTYPE_IP,     \"ipv4\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV6_IDX, ETHERTYPE_IPV6,   \"ipv6\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_ARP_IDX,  ETHERTYPE_ARP,    \"arp\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_RARP_IDX, ETHERTYPE_REVARP, \"rarp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_VLAN_IDX, ETHERTYPE_VLAN,   \"vlan\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_STP_IDX,  0,                \"stp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_MAC_IDX,  0,                \"mac\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_LAST_IDX, 0,                NULL),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\nstatic const struct ushort_map l3_protocols[] = {\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV4_IDX, ETHERTYPE_IP,     \"ipv4\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV6_IDX, ETHERTYPE_IPV6,   \"ipv6\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_ARP_IDX,  ETHERTYPE_ARP,    \"arp\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_RARP_IDX, ETHERTYPE_REVARP, \"rarp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_VLAN_IDX, ETHERTYPE_VLAN,   \"vlan\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_STP_IDX,  0,                \"stp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_MAC_IDX,  0,                \"mac\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_LAST_IDX, 0,                NULL),\n};\n\nstatic int\nebtablesCreateRuleInstance(virFirewallPtr fw,\n                           char chainPrefix,\n                           const char *chainSuffix,\n                           virNWFilterRuleDefPtr rule,\n                           const char *ifname,\n                           virNWFilterVarCombIterPtr vars,\n                           bool reverse)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n    char ipaddr[INET_ADDRSTRLEN];\n    char ipmask[INET_ADDRSTRLEN];\n    char ipv6addr[INET6_ADDRSTRLEN];\n    char number[VIR_INT64_STR_BUFLEN];\n    char numberalt[VIR_INT64_STR_BUFLEN];\n    char field[VIR_INT64_STR_BUFLEN];\n    char fieldalt[VIR_INT64_STR_BUFLEN];\n    char chain[MAX_CHAINNAME_LENGTH];\n    const char *target;\n    bool hasMask = false;\n    virFirewallRulePtr fwrule;\n    int ret = -1;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (STREQ(chainSuffix,\n              virNWFilterChainSuffixTypeToString(\n                  VIR_NWFILTER_CHAINSUFFIX_ROOT)))\n        PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n    else\n        PRINT_CHAIN(chain, chainPrefix, ifname,\n                    chainSuffix);\n\n#define INST_ITEM(STRUCT, ITEM, CLI) \\\n        if (HAS_ENTRY_ITEM(&rule->p.STRUCT.ITEM)) { \\\n            if (printDataType(vars, \\\n                              field, sizeof(field), \\\n                              &rule->p.STRUCT.ITEM) < 0) \\\n                goto cleanup; \\\n            virFirewallRuleAddArg(fw, fwrule, CLI); \\\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.STRUCT.ITEM)) \\\n                virFirewallRuleAddArg(fw, fwrule, \"!\"); \\\n            virFirewallRuleAddArg(fw, fwrule, field); \\\n        }\n\n#define INST_ITEM_2PARMS(STRUCT, ITEM, ITEM_HI, CLI, SEP) \\\n        if (HAS_ENTRY_ITEM(&rule->p.STRUCT.ITEM)) { \\\n            if (printDataType(vars, \\\n                              field, sizeof(field), \\\n                              &rule->p.STRUCT.ITEM) < 0) \\\n                goto cleanup; \\\n            virFirewallRuleAddArg(fw, fwrule, CLI); \\\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.STRUCT.ITEM)) \\\n                virFirewallRuleAddArg(fw, fwrule, \"!\"); \\\n            if (HAS_ENTRY_ITEM(&rule->p.STRUCT.ITEM_HI)) { \\\n                if (printDataType(vars, \\\n                                  fieldalt, sizeof(fieldalt), \\\n                                  &rule->p.STRUCT.ITEM_HI) < 0) \\\n                    goto cleanup; \\\n                virFirewallRuleAddArgFormat(fw, fwrule, \\\n                                            \"%s%s%s\", field, SEP, fieldalt); \\\n            } else  { \\\n                virFirewallRuleAddArg(fw, fwrule, field); \\\n            } \\\n        }\n#define INST_ITEM_RANGE(S, I, I_HI, C) \\\n    INST_ITEM_2PARMS(S, I, I_HI, C, \":\")\n#define INST_ITEM_MASK(S, I, MASK, C) \\\n    INST_ITEM_2PARMS(S, I, MASK, C, \"/\")\n\n    switch ((int)rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_MAC:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\",\n                                    \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.ethHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        if (HAS_ENTRY_ITEM(&rule->p.ethHdrFilter.dataProtocolID)) {\n            if (printDataTypeAsHex(vars,\n                                   number, sizeof(number),\n                                   &rule->p.ethHdrFilter.dataProtocolID) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"-p\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ethHdrFilter.dataProtocolID))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_VLAN:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.vlanHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-p\", \"0x8100\", NULL);\n\n        INST_ITEM(vlanHdrFilter, dataVlanID, \"--vlan-id\")\n        INST_ITEM(vlanHdrFilter, dataVlanEncap, \"--vlan-encap\")\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_STP:\n        /* cannot handle inout direction with srcmask set in reverse dir.\n           since this clashes with -d below... */\n        if (reverse &&\n            HAS_ENTRY_ITEM(&rule->p.stpHdrFilter.ethHdr.dataSrcMACAddr)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"STP filtering in %s direction with \"\n                             \"source MAC address set is not supported\"),\n                           virNWFilterRuleDirectionTypeToString(\n                               VIR_NWFILTER_RULE_DIRECTION_INOUT));\n            return -1;\n        }\n\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.stpHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-d\",  NWFILTER_MAC_BGA, NULL);\n\n        INST_ITEM(stpHdrFilter, dataType, \"--stp-type\")\n        INST_ITEM(stpHdrFilter, dataFlags, \"--stp-flags\")\n        INST_ITEM_RANGE(stpHdrFilter, dataRootPri, dataRootPriHi,\n                        \"--stp-root-pri\");\n        INST_ITEM_MASK(stpHdrFilter, dataRootAddr, dataRootAddrMask,\n                       \"--stp-root-addr\");\n        INST_ITEM_RANGE(stpHdrFilter, dataRootCost, dataRootCostHi,\n                        \"--stp-root-cost\");\n        INST_ITEM_RANGE(stpHdrFilter, dataSndrPrio, dataSndrPrioHi,\n                        \"--stp-sender-prio\");\n        INST_ITEM_MASK(stpHdrFilter, dataSndrAddr, dataSndrAddrMask,\n                       \"--stp-sender-addr\");\n        INST_ITEM_RANGE(stpHdrFilter, dataPort, dataPortHi, \"--stp-port\");\n        INST_ITEM_RANGE(stpHdrFilter, dataAge, dataAgeHi, \"--stp-msg-age\");\n        INST_ITEM_RANGE(stpHdrFilter, dataMaxAge, dataMaxAgeHi,\n                        \"--stp-max-age\");\n        INST_ITEM_RANGE(stpHdrFilter, dataHelloTime, dataHelloTimeHi,\n                        \"--stp-hello-time\");\n        INST_ITEM_RANGE(stpHdrFilter, dataFwdDelay, dataFwdDelayHi,\n                        \"--stp-forward-delay\");\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_RARP:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.arpHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArg(fw, fwrule, \"-p\");\n        virFirewallRuleAddArgFormat(fw, fwrule, \"0x%x\",\n                                    (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ARP)\n                                    ? l3_protocols[L3_PROTO_ARP_IDX].attr\n                                    : l3_protocols[L3_PROTO_RARP_IDX].attr);\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataHWType)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.arpHdrFilter.dataHWType) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-htype\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataHWType))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataOpcode)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.arpHdrFilter.dataOpcode) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-opcode\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataOpcode))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataProtocolType)) {\n            if (printDataTypeAsHex(vars,\n                                   number, sizeof(number),\n                                   &rule->p.arpHdrFilter.dataProtocolType) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-ptype\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataProtocolType))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPSrcIPAddr)) {\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.arpHdrFilter.dataARPSrcIPAddr) < 0)\n                goto cleanup;\n\n            if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPSrcIPMask)) {\n                if (printDataType(vars,\n                                  ipmask, sizeof(ipmask),\n                                  &rule->p.arpHdrFilter.dataARPSrcIPMask) < 0)\n                    goto cleanup;\n                hasMask = true;\n            }\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-ip-dst\" : \"--arp-ip-src\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPSrcIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, hasMask ? ipmask : \"32\");\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPDstIPAddr)) {\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.arpHdrFilter.dataARPDstIPAddr) < 0)\n                goto cleanup;\n\n            if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPDstIPMask)) {\n                if (printDataType(vars,\n                                  ipmask, sizeof(ipmask),\n                                  &rule->p.arpHdrFilter.dataARPDstIPMask) < 0)\n                    goto cleanup;\n                hasMask = true;\n            }\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-ip-src\" : \"--arp-ip-dst\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPDstIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, hasMask ? ipmask : \"32\");\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPSrcMACAddr)) {\n            if (printDataType(vars,\n                              macaddr, sizeof(macaddr),\n                              &rule->p.arpHdrFilter.dataARPSrcMACAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-mac-dst\" : \"--arp-mac-src\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPSrcMACAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPDstMACAddr)) {\n            if (printDataType(vars,\n                              macaddr, sizeof(macaddr),\n                              &rule->p.arpHdrFilter.dataARPDstMACAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-mac-src\" : \"--arp-mac-dst\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPDstMACAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataGratuitousARP) &&\n            rule->p.arpHdrFilter.dataGratuitousARP.u.boolean) {\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataGratuitousARP))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-gratuitous\");\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IP:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.ipHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-p\", \"ipv4\", NULL);\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr)) {\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-destination\" : \"--ip-source\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataSrcIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipHdrFilter.ipHdr.dataSrcIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipaddr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipaddr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataDstIPAddr)) {\n\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.ipHdrFilter.ipHdr.dataDstIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-source\" : \"--ip-destination\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataDstIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataDstIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipHdrFilter.ipHdr.dataDstIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipaddr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipaddr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataProtocolID)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipHdrFilter.ipHdr.dataProtocolID) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule, \"--ip-protocol\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataProtocolID))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataSrcPortStart)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipHdrFilter.portData.dataSrcPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-destination-port\" : \"--ip-source-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.portData.dataSrcPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataSrcPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipHdrFilter.portData.dataSrcPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataDstPortStart)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipHdrFilter.portData.dataDstPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-source-port\" : \"--ip-destination-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.portData.dataDstPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataDstPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipHdrFilter.portData.dataDstPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataDSCP)) {\n            if (printDataTypeAsHex(vars,\n                                   number, sizeof(number),\n                                   &rule->p.ipHdrFilter.ipHdr.dataDSCP) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule, \"--ip-tos\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataDSCP))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IPV6:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.ipv6HdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-p\", \"ipv6\", NULL);\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr)) {\n            if (printDataType(vars,\n                              ipv6addr, sizeof(ipv6addr),\n                              &rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-destination\" : \"--ip6-source\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.ipHdr.dataSrcIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipv6addr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipv6addr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr)) {\n\n            if (printDataType(vars,\n                              ipv6addr, sizeof(ipv6addr),\n                              &rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-source\" : \"--ip6-destination\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataDstIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.ipHdr.dataDstIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipv6addr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipv6addr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataProtocolID)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipv6HdrFilter.ipHdr.dataProtocolID) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule, \"--ip6-protocol\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.ipHdr.dataProtocolID))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataSrcPortStart)) {\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipv6HdrFilter.portData.dataSrcPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-destination-port\" : \"--ip6-source-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.portData.dataSrcPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataSrcPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.portData.dataSrcPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataDstPortStart)) {\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipv6HdrFilter.portData.dataDstPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-source-port\" : \"--ip6-destination-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.portData.dataDstPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataDstPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.portData.dataDstPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeStart)  ||\n            HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeEnd) ||\n            HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeStart) ||\n            HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeEnd)) {\n            bool lo = false;\n            char *r;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  \"--ip6-icmp-type\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeStart)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.dataICMPTypeStart) < 0)\n                    goto cleanup;\n                lo = true;\n            } else {\n                ignore_value(virStrcpyStatic(number, \"0\"));\n            }\n\n            virBufferStrcat(&buf, number, \":\", NULL);\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.dataICMPTypeEnd) < 0)\n                    goto cleanup;\n            } else {\n                if (lo)\n                    ignore_value(virStrcpyStatic(numberalt, number));\n                else\n                    ignore_value(virStrcpyStatic(numberalt, \"255\"));\n            }\n\n            virBufferStrcat(&buf, numberalt, \"/\", NULL);\n\n            lo = false;\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeStart)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.dataICMPCodeStart) < 0)\n                    goto cleanup;\n                lo = true;\n            } else {\n                ignore_value(virStrcpyStatic(number, \"0\"));\n            }\n\n            virBufferStrcat(&buf, number, \":\", NULL);\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.dataICMPCodeEnd) < 0)\n                    goto cleanup;\n            } else {\n                if (lo)\n                    ignore_value(virStrcpyStatic(numberalt, number));\n                else\n                    ignore_value(virStrcpyStatic(numberalt, \"255\"));\n            }\n\n            virBufferStrcat(&buf, numberalt, NULL);\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.dataICMPTypeStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            r = virBufferContentAndReset(&buf);\n\n            virFirewallRuleAddArg(fw, fwrule, r);\n\n            VIR_FREE(r);\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_NONE:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected rule protocol %d\"),\n                       rule->prtclType);\n        return -1;\n    }\n\n    switch (rule->action) {\n    case VIR_NWFILTER_RULE_ACTION_REJECT:\n        /* REJECT not supported */\n        target = virNWFilterJumpTargetTypeToString(\n                                     VIR_NWFILTER_RULE_ACTION_DROP);\n        break;\n    default:\n        target = virNWFilterJumpTargetTypeToString(rule->action);\n    }\n\n    virFirewallRuleAddArgList(fw, fwrule,\n                              \"-j\", target, NULL);\n\n#undef INST_ITEM_RANGE\n#undef INST_ITEM_MASK\n#undef INST_ITEM_2PARMS\n#undef INST_ITEM\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleIsProtocolEthernet",
          "args": [
            "rule"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterRuleIsProtocolEthernet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "3143-3149",
          "snippet": "bool\nvirNWFilterRuleIsProtocolEthernet(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_IPV6)\n        return true;\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirNWFilterRuleIsProtocolEthernet(virNWFilterRuleDefPtr rule)\n{\n    if (rule->prtclType <= VIR_NWFILTER_RULE_PROTOCOL_IPV6)\n        return true;\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\nebiptablesCreateRuleInstance(virFirewallPtr fw,\n                             const char *chainSuffix,\n                             virNWFilterRuleDefPtr rule,\n                             const char *ifname,\n                             virNWFilterVarCombIterPtr vars)\n{\n    if (virNWFilterRuleIsProtocolEthernet(rule)) {\n        if (rule->tt == VIR_NWFILTER_RULE_DIRECTION_OUT ||\n            rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n            if (ebtablesCreateRuleInstance(fw,\n                                           CHAINPREFIX_HOST_IN_TEMP,\n                                           chainSuffix,\n                                           rule,\n                                           ifname,\n                                           vars,\n                                           rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) < 0)\n                return -1;\n        }\n\n        if (rule->tt == VIR_NWFILTER_RULE_DIRECTION_IN ||\n            rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT) {\n            if (ebtablesCreateRuleInstance(fw,\n                                           CHAINPREFIX_HOST_OUT_TEMP,\n                                           chainSuffix,\n                                           rule,\n                                           ifname,\n                                           vars,\n                                           false) < 0)\n                return -1;\n        }\n    } else {\n        virFirewallLayer layer;\n        if (virNWFilterRuleIsProtocolIPv6(rule)) {\n            layer = VIR_FIREWALL_LAYER_IPV6;\n        } else if (virNWFilterRuleIsProtocolIPv4(rule)) {\n            layer = VIR_FIREWALL_LAYER_IPV4;\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           \"%s\", _(\"unexpected protocol type\"));\n            return -1;\n        }\n\n        if (iptablesCreateRuleInstance(fw,\n                                       layer,\n                                       rule,\n                                       ifname,\n                                       vars) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "ebtablesCreateRuleInstance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "1779-2429",
    "snippet": "static int\nebtablesCreateRuleInstance(virFirewallPtr fw,\n                           char chainPrefix,\n                           const char *chainSuffix,\n                           virNWFilterRuleDefPtr rule,\n                           const char *ifname,\n                           virNWFilterVarCombIterPtr vars,\n                           bool reverse)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n    char ipaddr[INET_ADDRSTRLEN];\n    char ipmask[INET_ADDRSTRLEN];\n    char ipv6addr[INET6_ADDRSTRLEN];\n    char number[VIR_INT64_STR_BUFLEN];\n    char numberalt[VIR_INT64_STR_BUFLEN];\n    char field[VIR_INT64_STR_BUFLEN];\n    char fieldalt[VIR_INT64_STR_BUFLEN];\n    char chain[MAX_CHAINNAME_LENGTH];\n    const char *target;\n    bool hasMask = false;\n    virFirewallRulePtr fwrule;\n    int ret = -1;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (STREQ(chainSuffix,\n              virNWFilterChainSuffixTypeToString(\n                  VIR_NWFILTER_CHAINSUFFIX_ROOT)))\n        PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n    else\n        PRINT_CHAIN(chain, chainPrefix, ifname,\n                    chainSuffix);\n\n#define INST_ITEM(STRUCT, ITEM, CLI) \\\n        if (HAS_ENTRY_ITEM(&rule->p.STRUCT.ITEM)) { \\\n            if (printDataType(vars, \\\n                              field, sizeof(field), \\\n                              &rule->p.STRUCT.ITEM) < 0) \\\n                goto cleanup; \\\n            virFirewallRuleAddArg(fw, fwrule, CLI); \\\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.STRUCT.ITEM)) \\\n                virFirewallRuleAddArg(fw, fwrule, \"!\"); \\\n            virFirewallRuleAddArg(fw, fwrule, field); \\\n        }\n\n#define INST_ITEM_2PARMS(STRUCT, ITEM, ITEM_HI, CLI, SEP) \\\n        if (HAS_ENTRY_ITEM(&rule->p.STRUCT.ITEM)) { \\\n            if (printDataType(vars, \\\n                              field, sizeof(field), \\\n                              &rule->p.STRUCT.ITEM) < 0) \\\n                goto cleanup; \\\n            virFirewallRuleAddArg(fw, fwrule, CLI); \\\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.STRUCT.ITEM)) \\\n                virFirewallRuleAddArg(fw, fwrule, \"!\"); \\\n            if (HAS_ENTRY_ITEM(&rule->p.STRUCT.ITEM_HI)) { \\\n                if (printDataType(vars, \\\n                                  fieldalt, sizeof(fieldalt), \\\n                                  &rule->p.STRUCT.ITEM_HI) < 0) \\\n                    goto cleanup; \\\n                virFirewallRuleAddArgFormat(fw, fwrule, \\\n                                            \"%s%s%s\", field, SEP, fieldalt); \\\n            } else  { \\\n                virFirewallRuleAddArg(fw, fwrule, field); \\\n            } \\\n        }\n#define INST_ITEM_RANGE(S, I, I_HI, C) \\\n    INST_ITEM_2PARMS(S, I, I_HI, C, \":\")\n#define INST_ITEM_MASK(S, I, MASK, C) \\\n    INST_ITEM_2PARMS(S, I, MASK, C, \"/\")\n\n    switch ((int)rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_MAC:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\",\n                                    \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.ethHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        if (HAS_ENTRY_ITEM(&rule->p.ethHdrFilter.dataProtocolID)) {\n            if (printDataTypeAsHex(vars,\n                                   number, sizeof(number),\n                                   &rule->p.ethHdrFilter.dataProtocolID) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"-p\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ethHdrFilter.dataProtocolID))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_VLAN:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.vlanHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-p\", \"0x8100\", NULL);\n\n        INST_ITEM(vlanHdrFilter, dataVlanID, \"--vlan-id\")\n        INST_ITEM(vlanHdrFilter, dataVlanEncap, \"--vlan-encap\")\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_STP:\n        /* cannot handle inout direction with srcmask set in reverse dir.\n           since this clashes with -d below... */\n        if (reverse &&\n            HAS_ENTRY_ITEM(&rule->p.stpHdrFilter.ethHdr.dataSrcMACAddr)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"STP filtering in %s direction with \"\n                             \"source MAC address set is not supported\"),\n                           virNWFilterRuleDirectionTypeToString(\n                               VIR_NWFILTER_RULE_DIRECTION_INOUT));\n            return -1;\n        }\n\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.stpHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-d\",  NWFILTER_MAC_BGA, NULL);\n\n        INST_ITEM(stpHdrFilter, dataType, \"--stp-type\")\n        INST_ITEM(stpHdrFilter, dataFlags, \"--stp-flags\")\n        INST_ITEM_RANGE(stpHdrFilter, dataRootPri, dataRootPriHi,\n                        \"--stp-root-pri\");\n        INST_ITEM_MASK(stpHdrFilter, dataRootAddr, dataRootAddrMask,\n                       \"--stp-root-addr\");\n        INST_ITEM_RANGE(stpHdrFilter, dataRootCost, dataRootCostHi,\n                        \"--stp-root-cost\");\n        INST_ITEM_RANGE(stpHdrFilter, dataSndrPrio, dataSndrPrioHi,\n                        \"--stp-sender-prio\");\n        INST_ITEM_MASK(stpHdrFilter, dataSndrAddr, dataSndrAddrMask,\n                       \"--stp-sender-addr\");\n        INST_ITEM_RANGE(stpHdrFilter, dataPort, dataPortHi, \"--stp-port\");\n        INST_ITEM_RANGE(stpHdrFilter, dataAge, dataAgeHi, \"--stp-msg-age\");\n        INST_ITEM_RANGE(stpHdrFilter, dataMaxAge, dataMaxAgeHi,\n                        \"--stp-max-age\");\n        INST_ITEM_RANGE(stpHdrFilter, dataHelloTime, dataHelloTimeHi,\n                        \"--stp-hello-time\");\n        INST_ITEM_RANGE(stpHdrFilter, dataFwdDelay, dataFwdDelayHi,\n                        \"--stp-forward-delay\");\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_RARP:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.arpHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArg(fw, fwrule, \"-p\");\n        virFirewallRuleAddArgFormat(fw, fwrule, \"0x%x\",\n                                    (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ARP)\n                                    ? l3_protocols[L3_PROTO_ARP_IDX].attr\n                                    : l3_protocols[L3_PROTO_RARP_IDX].attr);\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataHWType)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.arpHdrFilter.dataHWType) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-htype\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataHWType))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataOpcode)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.arpHdrFilter.dataOpcode) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-opcode\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataOpcode))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataProtocolType)) {\n            if (printDataTypeAsHex(vars,\n                                   number, sizeof(number),\n                                   &rule->p.arpHdrFilter.dataProtocolType) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-ptype\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataProtocolType))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPSrcIPAddr)) {\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.arpHdrFilter.dataARPSrcIPAddr) < 0)\n                goto cleanup;\n\n            if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPSrcIPMask)) {\n                if (printDataType(vars,\n                                  ipmask, sizeof(ipmask),\n                                  &rule->p.arpHdrFilter.dataARPSrcIPMask) < 0)\n                    goto cleanup;\n                hasMask = true;\n            }\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-ip-dst\" : \"--arp-ip-src\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPSrcIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, hasMask ? ipmask : \"32\");\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPDstIPAddr)) {\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.arpHdrFilter.dataARPDstIPAddr) < 0)\n                goto cleanup;\n\n            if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPDstIPMask)) {\n                if (printDataType(vars,\n                                  ipmask, sizeof(ipmask),\n                                  &rule->p.arpHdrFilter.dataARPDstIPMask) < 0)\n                    goto cleanup;\n                hasMask = true;\n            }\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-ip-src\" : \"--arp-ip-dst\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPDstIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, hasMask ? ipmask : \"32\");\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPSrcMACAddr)) {\n            if (printDataType(vars,\n                              macaddr, sizeof(macaddr),\n                              &rule->p.arpHdrFilter.dataARPSrcMACAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-mac-dst\" : \"--arp-mac-src\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPSrcMACAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPDstMACAddr)) {\n            if (printDataType(vars,\n                              macaddr, sizeof(macaddr),\n                              &rule->p.arpHdrFilter.dataARPDstMACAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-mac-src\" : \"--arp-mac-dst\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPDstMACAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataGratuitousARP) &&\n            rule->p.arpHdrFilter.dataGratuitousARP.u.boolean) {\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataGratuitousARP))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-gratuitous\");\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IP:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.ipHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-p\", \"ipv4\", NULL);\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr)) {\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-destination\" : \"--ip-source\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataSrcIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipHdrFilter.ipHdr.dataSrcIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipaddr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipaddr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataDstIPAddr)) {\n\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.ipHdrFilter.ipHdr.dataDstIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-source\" : \"--ip-destination\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataDstIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataDstIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipHdrFilter.ipHdr.dataDstIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipaddr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipaddr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataProtocolID)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipHdrFilter.ipHdr.dataProtocolID) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule, \"--ip-protocol\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataProtocolID))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataSrcPortStart)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipHdrFilter.portData.dataSrcPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-destination-port\" : \"--ip-source-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.portData.dataSrcPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataSrcPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipHdrFilter.portData.dataSrcPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataDstPortStart)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipHdrFilter.portData.dataDstPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-source-port\" : \"--ip-destination-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.portData.dataDstPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataDstPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipHdrFilter.portData.dataDstPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataDSCP)) {\n            if (printDataTypeAsHex(vars,\n                                   number, sizeof(number),\n                                   &rule->p.ipHdrFilter.ipHdr.dataDSCP) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule, \"--ip-tos\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataDSCP))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IPV6:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.ipv6HdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-p\", \"ipv6\", NULL);\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr)) {\n            if (printDataType(vars,\n                              ipv6addr, sizeof(ipv6addr),\n                              &rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-destination\" : \"--ip6-source\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.ipHdr.dataSrcIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipv6addr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipv6addr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr)) {\n\n            if (printDataType(vars,\n                              ipv6addr, sizeof(ipv6addr),\n                              &rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-source\" : \"--ip6-destination\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataDstIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.ipHdr.dataDstIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipv6addr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipv6addr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataProtocolID)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipv6HdrFilter.ipHdr.dataProtocolID) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule, \"--ip6-protocol\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.ipHdr.dataProtocolID))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataSrcPortStart)) {\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipv6HdrFilter.portData.dataSrcPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-destination-port\" : \"--ip6-source-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.portData.dataSrcPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataSrcPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.portData.dataSrcPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataDstPortStart)) {\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipv6HdrFilter.portData.dataDstPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-source-port\" : \"--ip6-destination-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.portData.dataDstPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataDstPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.portData.dataDstPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeStart)  ||\n            HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeEnd) ||\n            HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeStart) ||\n            HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeEnd)) {\n            bool lo = false;\n            char *r;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  \"--ip6-icmp-type\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeStart)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.dataICMPTypeStart) < 0)\n                    goto cleanup;\n                lo = true;\n            } else {\n                ignore_value(virStrcpyStatic(number, \"0\"));\n            }\n\n            virBufferStrcat(&buf, number, \":\", NULL);\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.dataICMPTypeEnd) < 0)\n                    goto cleanup;\n            } else {\n                if (lo)\n                    ignore_value(virStrcpyStatic(numberalt, number));\n                else\n                    ignore_value(virStrcpyStatic(numberalt, \"255\"));\n            }\n\n            virBufferStrcat(&buf, numberalt, \"/\", NULL);\n\n            lo = false;\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeStart)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.dataICMPCodeStart) < 0)\n                    goto cleanup;\n                lo = true;\n            } else {\n                ignore_value(virStrcpyStatic(number, \"0\"));\n            }\n\n            virBufferStrcat(&buf, number, \":\", NULL);\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.dataICMPCodeEnd) < 0)\n                    goto cleanup;\n            } else {\n                if (lo)\n                    ignore_value(virStrcpyStatic(numberalt, number));\n                else\n                    ignore_value(virStrcpyStatic(numberalt, \"255\"));\n            }\n\n            virBufferStrcat(&buf, numberalt, NULL);\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.dataICMPTypeStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            r = virBufferContentAndReset(&buf);\n\n            virFirewallRuleAddArg(fw, fwrule, r);\n\n            VIR_FREE(r);\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_NONE:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected rule protocol %d\"),\n                       rule->prtclType);\n        return -1;\n    }\n\n    switch (rule->action) {\n    case VIR_NWFILTER_RULE_ACTION_REJECT:\n        /* REJECT not supported */\n        target = virNWFilterJumpTargetTypeToString(\n                                     VIR_NWFILTER_RULE_ACTION_DROP);\n        break;\n    default:\n        target = virNWFilterJumpTargetTypeToString(rule->action);\n    }\n\n    virFirewallRuleAddArgList(fw, fwrule,\n                              \"-j\", target, NULL);\n\n#undef INST_ITEM_RANGE\n#undef INST_ITEM_MASK\n#undef INST_ITEM_2PARMS\n#undef INST_ITEM\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);",
      "static const struct ushort_map l3_protocols[] = {\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV4_IDX, ETHERTYPE_IP,     \"ipv4\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV6_IDX, ETHERTYPE_IPV6,   \"ipv6\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_ARP_IDX,  ETHERTYPE_ARP,    \"arp\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_RARP_IDX, ETHERTYPE_REVARP, \"rarp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_VLAN_IDX, ETHERTYPE_VLAN,   \"vlan\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_STP_IDX,  0,                \"stp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_MAC_IDX,  0,                \"mac\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_LAST_IDX, 0,                NULL),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallRuleAddArgList",
          "args": [
            "fw",
            "fwrule",
            "\"-j\"",
            "target",
            "NULL"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "541-562",
          "snippet": "void virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterJumpTargetTypeToString",
          "args": [
            "rule->action"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterJumpTargetTypeToString",
          "args": [
            "VIR_NWFILTER_RULE_ACTION_DROP"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected rule protocol %d\")",
            "rule->prtclType"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected rule protocol %d\""
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "_virNWFilterTeardownFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_gentech_driver.c",
          "lines": "898-927",
          "snippet": "static int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdev.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_dhcpsnoop.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _virNWFilterTeardownFilter(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsocketaddr.h\"\n#include \"datatypes.h\"\n#include \"virnetdev.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_dhcpsnoop.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"virerror.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int _virNWFilterTeardownFilter(const char *ifname);\n\nstatic int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "VIR_FIREWALL_LAYER_ETHERNET",
            "\"-t\"",
            "\"nat\"",
            "\"-A\"",
            "chain",
            "NULL"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "r"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.ipv6HdrFilter.dataICMPTypeStart"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferStrcat",
          "args": [
            "&buf",
            "numberalt",
            "NULL"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferStrcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "624-635",
          "snippet": "void\nvirBufferStrcat(virBufferPtr buf, ...)\n{\n    va_list ap;\n\n    if (!buf)\n        return;\n\n    va_start(ap, buf);\n    virBufferStrcatVArgs(buf, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferStrcat(virBufferPtr buf, ...)\n{\n    va_list ap;\n\n    if (!buf)\n        return;\n\n    va_start(ap, buf);\n    virBufferStrcatVArgs(buf, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrcpyStatic(numberalt, \"255\")"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "numberalt",
            "\"255\""
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrcpyStatic(numberalt, number)"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "numberalt",
            "number"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printDataType",
          "args": [
            "vars",
            "numberalt",
            "sizeof(numberalt)",
            "&rule->p.ipv6HdrFilter.dataICMPCodeEnd"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "printDataTypeAsHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "349-355",
          "snippet": "static int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.dataICMPCodeEnd"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrcpyStatic(number, \"0\")"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "number",
            "\"0\""
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.dataICMPCodeStart"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrcpyStatic(numberalt, \"255\")"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "numberalt",
            "\"255\""
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrcpyStatic(numberalt, number)"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "numberalt",
            "number"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.dataICMPTypeEnd"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrcpyStatic(number, \"0\")"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "number",
            "\"0\""
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.dataICMPTypeStart"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.dataICMPCodeEnd"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.dataICMPCodeStart"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.dataICMPTypeEnd"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.dataICMPTypeStart"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallRuleAddArgFormat",
          "args": [
            "fw",
            "fwrule",
            "\"%s:%s\"",
            "number",
            "numberalt"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "501-520",
          "snippet": "void virFirewallRuleAddArgFormat(virFirewallPtr firewall,\n                                 virFirewallRulePtr rule,\n                                 const char *fmt, ...)\n{\n    g_autofree char *arg = NULL;\n    va_list list;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, fmt);\n    arg = g_strdup_vprintf(fmt, list);\n    va_end(list);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgFormat(virFirewallPtr firewall,\n                                 virFirewallRulePtr rule,\n                                 const char *fmt, ...)\n{\n    g_autofree char *arg = NULL;\n    va_list list;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, fmt);\n    arg = g_strdup_vprintf(fmt, list);\n    va_end(list);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.portData.dataDstPortEnd"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.ipv6HdrFilter.portData.dataDstPortStart"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.portData.dataDstPortStart"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.portData.dataSrcPortEnd"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.ipv6HdrFilter.portData.dataSrcPortStart"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.portData.dataSrcPortStart"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.ipv6HdrFilter.ipHdr.dataProtocolID"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.ipHdr.dataProtocolID"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.ipHdr.dataDstIPMask"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPMask"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebtablesHandleEthHdr",
          "args": [
            "fw",
            "fwrule",
            "vars",
            "&rule->p.ipv6HdrFilter.ethHdr",
            "reverse"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "ebtablesHandleEthHdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "358-419",
          "snippet": "static int\nebtablesHandleEthHdr(virFirewallPtr fw,\n                     virFirewallRulePtr fwrule,\n                     virNWFilterVarCombIterPtr vars,\n                     ethHdrDataDefPtr ethHdr,\n                     bool reverse)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n    char macmask[VIR_MAC_STRING_BUFLEN];\n\n    if (HAS_ENTRY_ITEM(&ethHdr->dataSrcMACAddr)) {\n        if (printDataType(vars,\n                          macaddr, sizeof(macaddr),\n                          &ethHdr->dataSrcMACAddr) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  reverse ? \"-d\" : \"-s\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ethHdr->dataSrcMACAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n        if (HAS_ENTRY_ITEM(&ethHdr->dataSrcMACMask)) {\n            if (printDataType(vars,\n                              macmask, sizeof(macmask),\n                              &ethHdr->dataSrcMACMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", macaddr, macmask);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ethHdr->dataDstMACAddr)) {\n        if (printDataType(vars,\n                          macaddr, sizeof(macaddr),\n                          &ethHdr->dataDstMACAddr) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  reverse ? \"-s\" : \"-d\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ethHdr->dataDstMACAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n        if (HAS_ENTRY_ITEM(&ethHdr->dataDstMACMask)) {\n            if (printDataType(vars,\n                              macmask, sizeof(macmask),\n                              &ethHdr->dataDstMACMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", macaddr, macmask);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nebtablesHandleEthHdr(virFirewallPtr fw,\n                     virFirewallRulePtr fwrule,\n                     virNWFilterVarCombIterPtr vars,\n                     ethHdrDataDefPtr ethHdr,\n                     bool reverse)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n    char macmask[VIR_MAC_STRING_BUFLEN];\n\n    if (HAS_ENTRY_ITEM(&ethHdr->dataSrcMACAddr)) {\n        if (printDataType(vars,\n                          macaddr, sizeof(macaddr),\n                          &ethHdr->dataSrcMACAddr) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  reverse ? \"-d\" : \"-s\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ethHdr->dataSrcMACAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n        if (HAS_ENTRY_ITEM(&ethHdr->dataSrcMACMask)) {\n            if (printDataType(vars,\n                              macmask, sizeof(macmask),\n                              &ethHdr->dataSrcMACMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", macaddr, macmask);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ethHdr->dataDstMACAddr)) {\n        if (printDataType(vars,\n                          macaddr, sizeof(macaddr),\n                          &ethHdr->dataDstMACAddr) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  reverse ? \"-s\" : \"-d\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ethHdr->dataDstMACAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n        if (HAS_ENTRY_ITEM(&ethHdr->dataDstMACMask)) {\n            if (printDataType(vars,\n                              macmask, sizeof(macmask),\n                              &ethHdr->dataDstMACMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", macaddr, macmask);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.ipHdrFilter.ipHdr.dataDSCP"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipHdrFilter.ipHdr.dataDSCP"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipHdrFilter.portData.dataDstPortEnd"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.ipHdrFilter.portData.dataDstPortStart"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipHdrFilter.portData.dataDstPortStart"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipHdrFilter.portData.dataSrcPortEnd"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.ipHdrFilter.portData.dataSrcPortStart"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipHdrFilter.portData.dataSrcPortStart"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.ipHdrFilter.ipHdr.dataProtocolID"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipHdrFilter.ipHdr.dataProtocolID"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipHdrFilter.ipHdr.dataDstIPMask"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.ipHdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipHdrFilter.ipHdr.dataDstIPAddr"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipHdrFilter.ipHdr.dataSrcIPMask"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.arpHdrFilter.dataGratuitousARP"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.arpHdrFilter.dataGratuitousARP"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.arpHdrFilter.dataARPDstMACAddr"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.arpHdrFilter.dataARPDstMACAddr"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.arpHdrFilter.dataARPSrcMACAddr"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.arpHdrFilter.dataARPSrcMACAddr"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.arpHdrFilter.dataARPDstIPAddr"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.arpHdrFilter.dataARPDstIPMask"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.arpHdrFilter.dataARPDstIPAddr"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.arpHdrFilter.dataARPSrcIPAddr"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.arpHdrFilter.dataARPSrcIPMask"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.arpHdrFilter.dataARPSrcIPAddr"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.arpHdrFilter.dataProtocolType"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.arpHdrFilter.dataProtocolType"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.arpHdrFilter.dataOpcode"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.arpHdrFilter.dataOpcode"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.arpHdrFilter.dataHWType"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.arpHdrFilter.dataHWType"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INST_ITEM_RANGE",
          "args": [
            "stpHdrFilter",
            "dataFwdDelay",
            "dataFwdDelayHi",
            "\"--stp-forward-delay\""
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INST_ITEM_RANGE",
          "args": [
            "stpHdrFilter",
            "dataHelloTime",
            "dataHelloTimeHi",
            "\"--stp-hello-time\""
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INST_ITEM_RANGE",
          "args": [
            "stpHdrFilter",
            "dataMaxAge",
            "dataMaxAgeHi",
            "\"--stp-max-age\""
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INST_ITEM_RANGE",
          "args": [
            "stpHdrFilter",
            "dataAge",
            "dataAgeHi",
            "\"--stp-msg-age\""
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INST_ITEM_RANGE",
          "args": [
            "stpHdrFilter",
            "dataPort",
            "dataPortHi",
            "\"--stp-port\""
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INST_ITEM_MASK",
          "args": [
            "stpHdrFilter",
            "dataSndrAddr",
            "dataSndrAddrMask",
            "\"--stp-sender-addr\""
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INST_ITEM_RANGE",
          "args": [
            "stpHdrFilter",
            "dataSndrPrio",
            "dataSndrPrioHi",
            "\"--stp-sender-prio\""
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INST_ITEM_RANGE",
          "args": [
            "stpHdrFilter",
            "dataRootCost",
            "dataRootCostHi",
            "\"--stp-root-cost\""
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INST_ITEM_MASK",
          "args": [
            "stpHdrFilter",
            "dataRootAddr",
            "dataRootAddrMask",
            "\"--stp-root-addr\""
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INST_ITEM_RANGE",
          "args": [
            "stpHdrFilter",
            "dataRootPri",
            "dataRootPriHi",
            "\"--stp-root-pri\""
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INST_ITEM",
          "args": [
            "stpHdrFilter",
            "dataFlags",
            "\"--stp-flags\""
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INST_ITEM",
          "args": [
            "stpHdrFilter",
            "dataType",
            "\"--stp-type\""
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"STP filtering in %s direction with \"\n                             \"source MAC address set is not supported\")",
            "virNWFilterRuleDirectionTypeToString(\n                               VIR_NWFILTER_RULE_DIRECTION_INOUT)"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterRuleDirectionTypeToString",
          "args": [
            "VIR_NWFILTER_RULE_DIRECTION_INOUT"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.stpHdrFilter.ethHdr.dataSrcMACAddr"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INST_ITEM",
          "args": [
            "vlanHdrFilter",
            "dataVlanEncap",
            "\"--vlan-encap\""
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INST_ITEM",
          "args": [
            "vlanHdrFilter",
            "dataVlanID",
            "\"--vlan-id\""
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.ethHdrFilter.dataProtocolID"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.ethHdrFilter.dataProtocolID"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname",
            "chainSuffix"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_ROOT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "chainSuffix",
            "virNWFilterChainSuffixTypeToString(\n                  VIR_NWFILTER_CHAINSUFFIX_ROOT)"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterChainSuffixTypeToString",
          "args": [
            "VIR_NWFILTER_CHAINSUFFIX_ROOT"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\nstatic const struct ushort_map l3_protocols[] = {\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV4_IDX, ETHERTYPE_IP,     \"ipv4\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_IPV6_IDX, ETHERTYPE_IPV6,   \"ipv6\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_ARP_IDX,  ETHERTYPE_ARP,    \"arp\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_RARP_IDX, ETHERTYPE_REVARP, \"rarp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_VLAN_IDX, ETHERTYPE_VLAN,   \"vlan\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_STP_IDX,  0,                \"stp\"),\n    USHORTMAP_ENTRY_IDX(L2_PROTO_MAC_IDX,  0,                \"mac\"),\n    USHORTMAP_ENTRY_IDX(L3_PROTO_LAST_IDX, 0,                NULL),\n};\n\nstatic int\nebtablesCreateRuleInstance(virFirewallPtr fw,\n                           char chainPrefix,\n                           const char *chainSuffix,\n                           virNWFilterRuleDefPtr rule,\n                           const char *ifname,\n                           virNWFilterVarCombIterPtr vars,\n                           bool reverse)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n    char ipaddr[INET_ADDRSTRLEN];\n    char ipmask[INET_ADDRSTRLEN];\n    char ipv6addr[INET6_ADDRSTRLEN];\n    char number[VIR_INT64_STR_BUFLEN];\n    char numberalt[VIR_INT64_STR_BUFLEN];\n    char field[VIR_INT64_STR_BUFLEN];\n    char fieldalt[VIR_INT64_STR_BUFLEN];\n    char chain[MAX_CHAINNAME_LENGTH];\n    const char *target;\n    bool hasMask = false;\n    virFirewallRulePtr fwrule;\n    int ret = -1;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (STREQ(chainSuffix,\n              virNWFilterChainSuffixTypeToString(\n                  VIR_NWFILTER_CHAINSUFFIX_ROOT)))\n        PRINT_ROOT_CHAIN(chain, chainPrefix, ifname);\n    else\n        PRINT_CHAIN(chain, chainPrefix, ifname,\n                    chainSuffix);\n\n#define INST_ITEM(STRUCT, ITEM, CLI) \\\n        if (HAS_ENTRY_ITEM(&rule->p.STRUCT.ITEM)) { \\\n            if (printDataType(vars, \\\n                              field, sizeof(field), \\\n                              &rule->p.STRUCT.ITEM) < 0) \\\n                goto cleanup; \\\n            virFirewallRuleAddArg(fw, fwrule, CLI); \\\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.STRUCT.ITEM)) \\\n                virFirewallRuleAddArg(fw, fwrule, \"!\"); \\\n            virFirewallRuleAddArg(fw, fwrule, field); \\\n        }\n\n#define INST_ITEM_2PARMS(STRUCT, ITEM, ITEM_HI, CLI, SEP) \\\n        if (HAS_ENTRY_ITEM(&rule->p.STRUCT.ITEM)) { \\\n            if (printDataType(vars, \\\n                              field, sizeof(field), \\\n                              &rule->p.STRUCT.ITEM) < 0) \\\n                goto cleanup; \\\n            virFirewallRuleAddArg(fw, fwrule, CLI); \\\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.STRUCT.ITEM)) \\\n                virFirewallRuleAddArg(fw, fwrule, \"!\"); \\\n            if (HAS_ENTRY_ITEM(&rule->p.STRUCT.ITEM_HI)) { \\\n                if (printDataType(vars, \\\n                                  fieldalt, sizeof(fieldalt), \\\n                                  &rule->p.STRUCT.ITEM_HI) < 0) \\\n                    goto cleanup; \\\n                virFirewallRuleAddArgFormat(fw, fwrule, \\\n                                            \"%s%s%s\", field, SEP, fieldalt); \\\n            } else  { \\\n                virFirewallRuleAddArg(fw, fwrule, field); \\\n            } \\\n        }\n#define INST_ITEM_RANGE(S, I, I_HI, C) \\\n    INST_ITEM_2PARMS(S, I, I_HI, C, \":\")\n#define INST_ITEM_MASK(S, I, MASK, C) \\\n    INST_ITEM_2PARMS(S, I, MASK, C, \"/\")\n\n    switch ((int)rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_MAC:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\",\n                                    \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.ethHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        if (HAS_ENTRY_ITEM(&rule->p.ethHdrFilter.dataProtocolID)) {\n            if (printDataTypeAsHex(vars,\n                                   number, sizeof(number),\n                                   &rule->p.ethHdrFilter.dataProtocolID) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"-p\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ethHdrFilter.dataProtocolID))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_VLAN:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.vlanHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-p\", \"0x8100\", NULL);\n\n        INST_ITEM(vlanHdrFilter, dataVlanID, \"--vlan-id\")\n        INST_ITEM(vlanHdrFilter, dataVlanEncap, \"--vlan-encap\")\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_STP:\n        /* cannot handle inout direction with srcmask set in reverse dir.\n           since this clashes with -d below... */\n        if (reverse &&\n            HAS_ENTRY_ITEM(&rule->p.stpHdrFilter.ethHdr.dataSrcMACAddr)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"STP filtering in %s direction with \"\n                             \"source MAC address set is not supported\"),\n                           virNWFilterRuleDirectionTypeToString(\n                               VIR_NWFILTER_RULE_DIRECTION_INOUT));\n            return -1;\n        }\n\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.stpHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-d\",  NWFILTER_MAC_BGA, NULL);\n\n        INST_ITEM(stpHdrFilter, dataType, \"--stp-type\")\n        INST_ITEM(stpHdrFilter, dataFlags, \"--stp-flags\")\n        INST_ITEM_RANGE(stpHdrFilter, dataRootPri, dataRootPriHi,\n                        \"--stp-root-pri\");\n        INST_ITEM_MASK(stpHdrFilter, dataRootAddr, dataRootAddrMask,\n                       \"--stp-root-addr\");\n        INST_ITEM_RANGE(stpHdrFilter, dataRootCost, dataRootCostHi,\n                        \"--stp-root-cost\");\n        INST_ITEM_RANGE(stpHdrFilter, dataSndrPrio, dataSndrPrioHi,\n                        \"--stp-sender-prio\");\n        INST_ITEM_MASK(stpHdrFilter, dataSndrAddr, dataSndrAddrMask,\n                       \"--stp-sender-addr\");\n        INST_ITEM_RANGE(stpHdrFilter, dataPort, dataPortHi, \"--stp-port\");\n        INST_ITEM_RANGE(stpHdrFilter, dataAge, dataAgeHi, \"--stp-msg-age\");\n        INST_ITEM_RANGE(stpHdrFilter, dataMaxAge, dataMaxAgeHi,\n                        \"--stp-max-age\");\n        INST_ITEM_RANGE(stpHdrFilter, dataHelloTime, dataHelloTimeHi,\n                        \"--stp-hello-time\");\n        INST_ITEM_RANGE(stpHdrFilter, dataFwdDelay, dataFwdDelayHi,\n                        \"--stp-forward-delay\");\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ARP:\n    case VIR_NWFILTER_RULE_PROTOCOL_RARP:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.arpHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArg(fw, fwrule, \"-p\");\n        virFirewallRuleAddArgFormat(fw, fwrule, \"0x%x\",\n                                    (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ARP)\n                                    ? l3_protocols[L3_PROTO_ARP_IDX].attr\n                                    : l3_protocols[L3_PROTO_RARP_IDX].attr);\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataHWType)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.arpHdrFilter.dataHWType) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-htype\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataHWType))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataOpcode)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.arpHdrFilter.dataOpcode) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-opcode\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataOpcode))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataProtocolType)) {\n            if (printDataTypeAsHex(vars,\n                                   number, sizeof(number),\n                                   &rule->p.arpHdrFilter.dataProtocolType) < 0)\n                goto cleanup;\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-ptype\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataProtocolType))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPSrcIPAddr)) {\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.arpHdrFilter.dataARPSrcIPAddr) < 0)\n                goto cleanup;\n\n            if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPSrcIPMask)) {\n                if (printDataType(vars,\n                                  ipmask, sizeof(ipmask),\n                                  &rule->p.arpHdrFilter.dataARPSrcIPMask) < 0)\n                    goto cleanup;\n                hasMask = true;\n            }\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-ip-dst\" : \"--arp-ip-src\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPSrcIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, hasMask ? ipmask : \"32\");\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPDstIPAddr)) {\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.arpHdrFilter.dataARPDstIPAddr) < 0)\n                goto cleanup;\n\n            if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPDstIPMask)) {\n                if (printDataType(vars,\n                                  ipmask, sizeof(ipmask),\n                                  &rule->p.arpHdrFilter.dataARPDstIPMask) < 0)\n                    goto cleanup;\n                hasMask = true;\n            }\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-ip-src\" : \"--arp-ip-dst\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPDstIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, hasMask ? ipmask : \"32\");\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPSrcMACAddr)) {\n            if (printDataType(vars,\n                              macaddr, sizeof(macaddr),\n                              &rule->p.arpHdrFilter.dataARPSrcMACAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-mac-dst\" : \"--arp-mac-src\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPSrcMACAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataARPDstMACAddr)) {\n            if (printDataType(vars,\n                              macaddr, sizeof(macaddr),\n                              &rule->p.arpHdrFilter.dataARPDstMACAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--arp-mac-src\" : \"--arp-mac-dst\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataARPDstMACAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.arpHdrFilter.dataGratuitousARP) &&\n            rule->p.arpHdrFilter.dataGratuitousARP.u.boolean) {\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.arpHdrFilter.dataGratuitousARP))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, \"--arp-gratuitous\");\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IP:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.ipHdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-p\", \"ipv4\", NULL);\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr)) {\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-destination\" : \"--ip-source\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataSrcIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataSrcIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipHdrFilter.ipHdr.dataSrcIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipaddr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipaddr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataDstIPAddr)) {\n\n            if (printDataType(vars,\n                              ipaddr, sizeof(ipaddr),\n                              &rule->p.ipHdrFilter.ipHdr.dataDstIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-source\" : \"--ip-destination\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataDstIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataDstIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipHdrFilter.ipHdr.dataDstIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipaddr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipaddr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataProtocolID)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipHdrFilter.ipHdr.dataProtocolID) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule, \"--ip-protocol\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataProtocolID))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataSrcPortStart)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipHdrFilter.portData.dataSrcPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-destination-port\" : \"--ip-source-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.portData.dataSrcPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataSrcPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipHdrFilter.portData.dataSrcPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataDstPortStart)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipHdrFilter.portData.dataDstPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip-source-port\" : \"--ip-destination-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.portData.dataDstPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.portData.dataDstPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipHdrFilter.portData.dataDstPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipHdrFilter.ipHdr.dataDSCP)) {\n            if (printDataTypeAsHex(vars,\n                                   number, sizeof(number),\n                                   &rule->p.ipHdrFilter.ipHdr.dataDSCP) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule, \"--ip-tos\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipHdrFilter.ipHdr.dataDSCP))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IPV6:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n\n        if (ebtablesHandleEthHdr(fw, fwrule,\n                                 vars,\n                                 &rule->p.ipv6HdrFilter.ethHdr,\n                                 reverse) < 0)\n            goto cleanup;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-p\", \"ipv6\", NULL);\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr)) {\n            if (printDataType(vars,\n                              ipv6addr, sizeof(ipv6addr),\n                              &rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-destination\" : \"--ip6-source\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataSrcIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.ipHdr.dataSrcIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipv6addr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipv6addr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr)) {\n\n            if (printDataType(vars,\n                              ipv6addr, sizeof(ipv6addr),\n                              &rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-source\" : \"--ip6-destination\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.ipHdr.dataDstIPAddr))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataDstIPMask)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.ipHdr.dataDstIPMask) < 0)\n                    goto cleanup;\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", ipv6addr, number);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, ipv6addr);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.ipHdr.dataProtocolID)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipv6HdrFilter.ipHdr.dataProtocolID) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule, \"--ip6-protocol\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.ipHdr.dataProtocolID))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, number);\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataSrcPortStart)) {\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipv6HdrFilter.portData.dataSrcPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-destination-port\" : \"--ip6-source-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.portData.dataSrcPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataSrcPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.portData.dataSrcPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataDstPortStart)) {\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.ipv6HdrFilter.portData.dataDstPortStart) < 0)\n                goto cleanup;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  reverse ? \"--ip6-source-port\" : \"--ip6-destination-port\");\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.portData.dataDstPortStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.portData.dataDstPortEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.portData.dataDstPortEnd) < 0)\n                    goto cleanup;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s:%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n\n        if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeStart)  ||\n            HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeEnd) ||\n            HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeStart) ||\n            HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeEnd)) {\n            bool lo = false;\n            char *r;\n\n            virFirewallRuleAddArg(fw, fwrule,\n                                  \"--ip6-icmp-type\");\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeStart)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.dataICMPTypeStart) < 0)\n                    goto cleanup;\n                lo = true;\n            } else {\n                ignore_value(virStrcpyStatic(number, \"0\"));\n            }\n\n            virBufferStrcat(&buf, number, \":\", NULL);\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPTypeEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.dataICMPTypeEnd) < 0)\n                    goto cleanup;\n            } else {\n                if (lo)\n                    ignore_value(virStrcpyStatic(numberalt, number));\n                else\n                    ignore_value(virStrcpyStatic(numberalt, \"255\"));\n            }\n\n            virBufferStrcat(&buf, numberalt, \"/\", NULL);\n\n            lo = false;\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeStart)) {\n                if (printDataType(vars,\n                                  number, sizeof(number),\n                                  &rule->p.ipv6HdrFilter.dataICMPCodeStart) < 0)\n                    goto cleanup;\n                lo = true;\n            } else {\n                ignore_value(virStrcpyStatic(number, \"0\"));\n            }\n\n            virBufferStrcat(&buf, number, \":\", NULL);\n\n            if (HAS_ENTRY_ITEM(&rule->p.ipv6HdrFilter.dataICMPCodeEnd)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.ipv6HdrFilter.dataICMPCodeEnd) < 0)\n                    goto cleanup;\n            } else {\n                if (lo)\n                    ignore_value(virStrcpyStatic(numberalt, number));\n                else\n                    ignore_value(virStrcpyStatic(numberalt, \"255\"));\n            }\n\n            virBufferStrcat(&buf, numberalt, NULL);\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.ipv6HdrFilter.dataICMPTypeStart))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n            r = virBufferContentAndReset(&buf);\n\n            virFirewallRuleAddArg(fw, fwrule, r);\n\n            VIR_FREE(r);\n        }\n        break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_NONE:\n        fwrule = virFirewallAddRule(fw, VIR_FIREWALL_LAYER_ETHERNET,\n                                    \"-t\", \"nat\", \"-A\", chain, NULL);\n        break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected rule protocol %d\"),\n                       rule->prtclType);\n        return -1;\n    }\n\n    switch (rule->action) {\n    case VIR_NWFILTER_RULE_ACTION_REJECT:\n        /* REJECT not supported */\n        target = virNWFilterJumpTargetTypeToString(\n                                     VIR_NWFILTER_RULE_ACTION_DROP);\n        break;\n    default:\n        target = virNWFilterJumpTargetTypeToString(rule->action);\n    }\n\n    virFirewallRuleAddArgList(fw, fwrule,\n                              \"-j\", target, NULL);\n\n#undef INST_ITEM_RANGE\n#undef INST_ITEM_MASK\n#undef INST_ITEM_2PARMS\n#undef INST_ITEM\n\n    ret = 0;\n cleanup:\n    virBufferFreeAndReset(&buf);\n\n    return ret;\n}"
  },
  {
    "function_name": "iptablesCreateRuleInstance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "1661-1759",
    "snippet": "static int\niptablesCreateRuleInstance(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           virNWFilterRuleDefPtr rule,\n                           const char *ifname,\n                           virNWFilterVarCombIterPtr vars)\n{\n    int rc;\n    bool directionIn = false;\n    char chainPrefix[2];\n    bool needState = true;\n    bool maySkipICMP, inout = false;\n    const char *matchState;\n\n    if (!(rule->flags & RULE_FLAG_NO_STATEMATCH) &&\n         (rule->flags & IPTABLES_STATE_FLAGS)) {\n        return iptablesCreateRuleInstanceStateCtrl(fw,\n                                                   layer,\n                                                   rule,\n                                                   ifname,\n                                                   vars);\n    }\n\n    if ((rule->tt == VIR_NWFILTER_RULE_DIRECTION_IN) ||\n        (rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT)) {\n        directionIn = true;\n        inout = (rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT);\n        if (inout)\n            needState = false;\n    }\n\n    if ((rule->flags & RULE_FLAG_NO_STATEMATCH))\n        needState = false;\n\n    chainPrefix[0] = 'F';\n\n    maySkipICMP = directionIn || inout;\n\n    if (needState)\n        matchState = directionIn ? \"ESTABLISHED\" : \"NEW,ESTABLISHED\";\n    else\n        matchState = NULL;\n\n    chainPrefix[1] = CHAINPREFIX_HOST_IN_TEMP;\n    rc = _iptablesCreateRuleInstance(fw,\n                                     layer,\n                                     directionIn,\n                                     chainPrefix,\n                                     rule,\n                                     ifname,\n                                     vars,\n                                     matchState, true,\n                                     \"RETURN\",\n                                     maySkipICMP);\n    if (rc < 0)\n        return rc;\n\n\n    maySkipICMP = !directionIn || inout;\n    if (needState)\n        matchState = directionIn ?  \"NEW,ESTABLISHED\" : \"ESTABLISHED\";\n    else\n        matchState = NULL;\n\n    chainPrefix[1] = CHAINPREFIX_HOST_OUT_TEMP;\n    rc = _iptablesCreateRuleInstance(fw,\n                                     layer,\n                                     !directionIn,\n                                     chainPrefix,\n                                     rule,\n                                     ifname,\n                                     vars,\n                                     matchState, true,\n                                     \"ACCEPT\",\n                                     maySkipICMP);\n    if (rc < 0)\n        return rc;\n\n    maySkipICMP = directionIn;\n    if (needState)\n        matchState = directionIn ? \"ESTABLISHED\" : \"NEW,ESTABLISHED\";\n    else\n        matchState = NULL;\n\n    chainPrefix[0] = 'H';\n    chainPrefix[1] = CHAINPREFIX_HOST_IN_TEMP;\n    rc = _iptablesCreateRuleInstance(fw,\n                                     layer,\n                                     directionIn,\n                                     chainPrefix,\n                                     rule,\n                                     ifname,\n                                     vars,\n                                     matchState, true,\n                                     \"RETURN\",\n                                     maySkipICMP);\n\n    return rc;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_iptablesCreateRuleInstance",
          "args": [
            "fw",
            "layer",
            "directionIn",
            "chainPrefix",
            "rule",
            "ifname",
            "vars",
            "matchState",
            "true",
            "\"RETURN\"",
            "maySkipICMP"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "_iptablesCreateRuleInstance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "1140-1525",
          "snippet": "static int\n_iptablesCreateRuleInstance(virFirewallPtr fw,\n                            virFirewallLayer layer,\n                            bool directionIn,\n                            const char *chainPrefix,\n                            virNWFilterRuleDefPtr rule,\n                            const char *ifname,\n                            virNWFilterVarCombIterPtr vars,\n                            const char *match, bool defMatch,\n                            const char *accept_target,\n                            bool maySkipICMP)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char number[VIR_INT64_STR_BUFLEN];\n    char numberalt[VIR_INT64_STR_BUFLEN];\n    const char *target;\n    bool srcMacSkipped = false;\n    bool skipRule = false;\n    bool skipMatch = false;\n    bool hasICMPType = false;\n    virFirewallRulePtr fwrule;\n    size_t fwruleargs;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    switch ((int)rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_TCP:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"tcp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.tcpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.tcpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.tcpHdrFilter.dataTCPFlags)) {\n            char *flags;\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.tcpHdrFilter.dataTCPFlags))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, \"--tcp-flags\");\n\n            if (!(flags = virNWFilterPrintTCPFlags(rule->p.tcpHdrFilter.dataTCPFlags.u.tcpFlags.mask)))\n                return -1;\n            virFirewallRuleAddArg(fw, fwrule, flags);\n            VIR_FREE(flags);\n            if (!(flags = virNWFilterPrintTCPFlags(rule->p.tcpHdrFilter.dataTCPFlags.u.tcpFlags.flags)))\n                return -1;\n            virFirewallRuleAddArg(fw, fwrule, flags);\n            VIR_FREE(flags);\n        }\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.tcpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.tcpHdrFilter.dataTCPOption)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.tcpHdrFilter.dataTCPOption) < 0)\n                return -1;\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.tcpHdrFilter.dataTCPOption))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"--tcp-option\", number, NULL);\n        }\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"udp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.udpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.udpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.udpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITE:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"udplite\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.udpliteHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.udpliteHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ESP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"esp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.espHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.espHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_AH:\n    case VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"ah\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.ahHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.ahHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTP:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"sctp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.sctpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.sctpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.sctpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    NULL);\n\n        if (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ICMP)\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-p\", \"icmp\", NULL);\n        else\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-p\", \"icmpv6\", NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.icmpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.icmpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.icmpHdrFilter.dataICMPType)) {\n            const char *parm;\n\n            hasICMPType = true;\n\n            if (maySkipICMP) {\n                virFirewallRemoveRule(fw, fwrule);\n                return 0;\n            }\n\n            if (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ICMP)\n                parm = \"--icmp-type\";\n            else\n                parm = \"--icmpv6-type\";\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.icmpHdrFilter.dataICMPType) < 0)\n                return -1;\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.icmpHdrFilter.dataICMPType))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, parm);\n\n            if (HAS_ENTRY_ITEM(&rule->p.icmpHdrFilter.dataICMPCode)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.icmpHdrFilter.dataICMPCode) < 0)\n                    return -1;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IGMP:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"igmp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.igmpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.igmpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ALL:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"all\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.allHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.allHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected protocol %d\"),\n                       rule->prtclType);\n        return -1;\n    }\n\n    if ((srcMacSkipped &&\n         fwruleargs == virFirewallRuleGetArgCount(fwrule)) ||\n        skipRule) {\n        virFirewallRemoveRule(fw, fwrule);\n        return 0;\n    }\n\n    if (rule->action == VIR_NWFILTER_RULE_ACTION_ACCEPT) {\n        target = accept_target;\n    } else {\n        target = virNWFilterJumpTargetTypeToString(rule->action);\n        skipMatch = defMatch;\n    }\n\n    if (match && !skipMatch) {\n        if (newMatchState)\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"conntrack\",\n                                      \"--ctstate\", match,\n                                      NULL);\n        else\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"state\",\n                                      \"--state\", match,\n                                      NULL);\n    }\n\n    if (defMatch && match != NULL && !skipMatch && !hasICMPType)\n        iptablesEnforceDirection(fw, fwrule,\n                                 directionIn,\n                                 rule);\n\n    if (iptablesHandleIPHdrAfterStateMatch(fw, fwrule,\n                                           vars,\n                                           &rule->p.allHdrFilter.ipHdr,\n                                           directionIn) < 0)\n        return -1;\n\n    virFirewallRuleAddArgList(fw, fwrule,\n                              \"-j\", target, NULL);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool newMatchState;",
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic bool newMatchState;\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\n_iptablesCreateRuleInstance(virFirewallPtr fw,\n                            virFirewallLayer layer,\n                            bool directionIn,\n                            const char *chainPrefix,\n                            virNWFilterRuleDefPtr rule,\n                            const char *ifname,\n                            virNWFilterVarCombIterPtr vars,\n                            const char *match, bool defMatch,\n                            const char *accept_target,\n                            bool maySkipICMP)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char number[VIR_INT64_STR_BUFLEN];\n    char numberalt[VIR_INT64_STR_BUFLEN];\n    const char *target;\n    bool srcMacSkipped = false;\n    bool skipRule = false;\n    bool skipMatch = false;\n    bool hasICMPType = false;\n    virFirewallRulePtr fwrule;\n    size_t fwruleargs;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    switch ((int)rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_TCP:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"tcp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.tcpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.tcpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.tcpHdrFilter.dataTCPFlags)) {\n            char *flags;\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.tcpHdrFilter.dataTCPFlags))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, \"--tcp-flags\");\n\n            if (!(flags = virNWFilterPrintTCPFlags(rule->p.tcpHdrFilter.dataTCPFlags.u.tcpFlags.mask)))\n                return -1;\n            virFirewallRuleAddArg(fw, fwrule, flags);\n            VIR_FREE(flags);\n            if (!(flags = virNWFilterPrintTCPFlags(rule->p.tcpHdrFilter.dataTCPFlags.u.tcpFlags.flags)))\n                return -1;\n            virFirewallRuleAddArg(fw, fwrule, flags);\n            VIR_FREE(flags);\n        }\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.tcpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.tcpHdrFilter.dataTCPOption)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.tcpHdrFilter.dataTCPOption) < 0)\n                return -1;\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.tcpHdrFilter.dataTCPOption))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"--tcp-option\", number, NULL);\n        }\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"udp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.udpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.udpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.udpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITE:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"udplite\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.udpliteHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.udpliteHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ESP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"esp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.espHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.espHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_AH:\n    case VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"ah\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.ahHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.ahHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTP:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"sctp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.sctpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.sctpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.sctpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    NULL);\n\n        if (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ICMP)\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-p\", \"icmp\", NULL);\n        else\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-p\", \"icmpv6\", NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.icmpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.icmpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.icmpHdrFilter.dataICMPType)) {\n            const char *parm;\n\n            hasICMPType = true;\n\n            if (maySkipICMP) {\n                virFirewallRemoveRule(fw, fwrule);\n                return 0;\n            }\n\n            if (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ICMP)\n                parm = \"--icmp-type\";\n            else\n                parm = \"--icmpv6-type\";\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.icmpHdrFilter.dataICMPType) < 0)\n                return -1;\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.icmpHdrFilter.dataICMPType))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, parm);\n\n            if (HAS_ENTRY_ITEM(&rule->p.icmpHdrFilter.dataICMPCode)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.icmpHdrFilter.dataICMPCode) < 0)\n                    return -1;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IGMP:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"igmp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.igmpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.igmpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ALL:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"all\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.allHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.allHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected protocol %d\"),\n                       rule->prtclType);\n        return -1;\n    }\n\n    if ((srcMacSkipped &&\n         fwruleargs == virFirewallRuleGetArgCount(fwrule)) ||\n        skipRule) {\n        virFirewallRemoveRule(fw, fwrule);\n        return 0;\n    }\n\n    if (rule->action == VIR_NWFILTER_RULE_ACTION_ACCEPT) {\n        target = accept_target;\n    } else {\n        target = virNWFilterJumpTargetTypeToString(rule->action);\n        skipMatch = defMatch;\n    }\n\n    if (match && !skipMatch) {\n        if (newMatchState)\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"conntrack\",\n                                      \"--ctstate\", match,\n                                      NULL);\n        else\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"state\",\n                                      \"--state\", match,\n                                      NULL);\n    }\n\n    if (defMatch && match != NULL && !skipMatch && !hasICMPType)\n        iptablesEnforceDirection(fw, fwrule,\n                                 directionIn,\n                                 rule);\n\n    if (iptablesHandleIPHdrAfterStateMatch(fw, fwrule,\n                                           vars,\n                                           &rule->p.allHdrFilter.ipHdr,\n                                           directionIn) < 0)\n        return -1;\n\n    virFirewallRuleAddArgList(fw, fwrule,\n                              \"-j\", target, NULL);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesCreateRuleInstanceStateCtrl",
          "args": [
            "fw",
            "layer",
            "rule",
            "ifname",
            "vars"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesCreateRuleInstanceStateCtrl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "1540-1658",
          "snippet": "static int\niptablesCreateRuleInstanceStateCtrl(virFirewallPtr fw,\n                                    virFirewallLayer layer,\n                                    virNWFilterRuleDefPtr rule,\n                                    const char *ifname,\n                                    virNWFilterVarCombIterPtr vars)\n{\n    int rc = 0;\n    bool directionIn = false;\n    char chainPrefix[2];\n    bool maySkipICMP, inout = false;\n    char *matchState = NULL;\n    bool create;\n\n    if ((rule->tt == VIR_NWFILTER_RULE_DIRECTION_IN) ||\n        (rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT)) {\n        directionIn = true;\n        inout = (rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT);\n    }\n\n    chainPrefix[0] = 'F';\n\n    maySkipICMP = directionIn || inout;\n\n    create = true;\n    matchState = NULL;\n\n    if (directionIn && !inout) {\n        if ((rule->flags & IPTABLES_STATE_FLAGS))\n            create = false;\n    }\n\n    if (create && (rule->flags & IPTABLES_STATE_FLAGS)) {\n        if (printStateMatchFlags(rule->flags, &matchState) < 0)\n            return -1;\n    }\n\n    chainPrefix[1] = CHAINPREFIX_HOST_IN_TEMP;\n    if (create) {\n        rc = _iptablesCreateRuleInstance(fw,\n                                         layer,\n                                         directionIn,\n                                         chainPrefix,\n                                         rule,\n                                         ifname,\n                                         vars,\n                                         matchState, false,\n                                         \"RETURN\",\n                                         maySkipICMP);\n\n        VIR_FREE(matchState);\n        if (rc < 0)\n            return rc;\n    }\n\n    maySkipICMP = !directionIn || inout;\n    create = true;\n\n    if (!directionIn) {\n        if ((rule->flags & IPTABLES_STATE_FLAGS))\n            create = false;\n    }\n\n    if (create && (rule->flags & IPTABLES_STATE_FLAGS)) {\n        if (printStateMatchFlags(rule->flags, &matchState) < 0)\n            return -1;\n    }\n\n    chainPrefix[1] = CHAINPREFIX_HOST_OUT_TEMP;\n    if (create) {\n        rc = _iptablesCreateRuleInstance(fw,\n                                         layer,\n                                         !directionIn,\n                                         chainPrefix,\n                                         rule,\n                                         ifname,\n                                         vars,\n                                         matchState, false,\n                                         \"ACCEPT\",\n                                         maySkipICMP);\n\n        VIR_FREE(matchState);\n\n        if (rc < 0)\n            return rc;\n    }\n\n    maySkipICMP = directionIn;\n\n    create = true;\n\n    if (directionIn && !inout) {\n        if ((rule->flags & IPTABLES_STATE_FLAGS))\n            create = false;\n    } else {\n        if ((rule->flags & IPTABLES_STATE_FLAGS)) {\n            if (printStateMatchFlags(rule->flags, &matchState) < 0)\n                return -1;\n        }\n    }\n\n    if (create) {\n        chainPrefix[0] = 'H';\n        chainPrefix[1] = CHAINPREFIX_HOST_IN_TEMP;\n        rc = _iptablesCreateRuleInstance(fw,\n                                         layer,\n                                         directionIn,\n                                         chainPrefix,\n                                         rule,\n                                         ifname,\n                                         vars,\n                                         matchState, false,\n                                         \"RETURN\",\n                                         maySkipICMP);\n        VIR_FREE(matchState);\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\niptablesCreateRuleInstanceStateCtrl(virFirewallPtr fw,\n                                    virFirewallLayer layer,\n                                    virNWFilterRuleDefPtr rule,\n                                    const char *ifname,\n                                    virNWFilterVarCombIterPtr vars)\n{\n    int rc = 0;\n    bool directionIn = false;\n    char chainPrefix[2];\n    bool maySkipICMP, inout = false;\n    char *matchState = NULL;\n    bool create;\n\n    if ((rule->tt == VIR_NWFILTER_RULE_DIRECTION_IN) ||\n        (rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT)) {\n        directionIn = true;\n        inout = (rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT);\n    }\n\n    chainPrefix[0] = 'F';\n\n    maySkipICMP = directionIn || inout;\n\n    create = true;\n    matchState = NULL;\n\n    if (directionIn && !inout) {\n        if ((rule->flags & IPTABLES_STATE_FLAGS))\n            create = false;\n    }\n\n    if (create && (rule->flags & IPTABLES_STATE_FLAGS)) {\n        if (printStateMatchFlags(rule->flags, &matchState) < 0)\n            return -1;\n    }\n\n    chainPrefix[1] = CHAINPREFIX_HOST_IN_TEMP;\n    if (create) {\n        rc = _iptablesCreateRuleInstance(fw,\n                                         layer,\n                                         directionIn,\n                                         chainPrefix,\n                                         rule,\n                                         ifname,\n                                         vars,\n                                         matchState, false,\n                                         \"RETURN\",\n                                         maySkipICMP);\n\n        VIR_FREE(matchState);\n        if (rc < 0)\n            return rc;\n    }\n\n    maySkipICMP = !directionIn || inout;\n    create = true;\n\n    if (!directionIn) {\n        if ((rule->flags & IPTABLES_STATE_FLAGS))\n            create = false;\n    }\n\n    if (create && (rule->flags & IPTABLES_STATE_FLAGS)) {\n        if (printStateMatchFlags(rule->flags, &matchState) < 0)\n            return -1;\n    }\n\n    chainPrefix[1] = CHAINPREFIX_HOST_OUT_TEMP;\n    if (create) {\n        rc = _iptablesCreateRuleInstance(fw,\n                                         layer,\n                                         !directionIn,\n                                         chainPrefix,\n                                         rule,\n                                         ifname,\n                                         vars,\n                                         matchState, false,\n                                         \"ACCEPT\",\n                                         maySkipICMP);\n\n        VIR_FREE(matchState);\n\n        if (rc < 0)\n            return rc;\n    }\n\n    maySkipICMP = directionIn;\n\n    create = true;\n\n    if (directionIn && !inout) {\n        if ((rule->flags & IPTABLES_STATE_FLAGS))\n            create = false;\n    } else {\n        if ((rule->flags & IPTABLES_STATE_FLAGS)) {\n            if (printStateMatchFlags(rule->flags, &matchState) < 0)\n                return -1;\n        }\n    }\n\n    if (create) {\n        chainPrefix[0] = 'H';\n        chainPrefix[1] = CHAINPREFIX_HOST_IN_TEMP;\n        rc = _iptablesCreateRuleInstance(fw,\n                                         layer,\n                                         directionIn,\n                                         chainPrefix,\n                                         rule,\n                                         ifname,\n                                         vars,\n                                         matchState, false,\n                                         \"RETURN\",\n                                         maySkipICMP);\n        VIR_FREE(matchState);\n    }\n\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\niptablesCreateRuleInstance(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           virNWFilterRuleDefPtr rule,\n                           const char *ifname,\n                           virNWFilterVarCombIterPtr vars)\n{\n    int rc;\n    bool directionIn = false;\n    char chainPrefix[2];\n    bool needState = true;\n    bool maySkipICMP, inout = false;\n    const char *matchState;\n\n    if (!(rule->flags & RULE_FLAG_NO_STATEMATCH) &&\n         (rule->flags & IPTABLES_STATE_FLAGS)) {\n        return iptablesCreateRuleInstanceStateCtrl(fw,\n                                                   layer,\n                                                   rule,\n                                                   ifname,\n                                                   vars);\n    }\n\n    if ((rule->tt == VIR_NWFILTER_RULE_DIRECTION_IN) ||\n        (rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT)) {\n        directionIn = true;\n        inout = (rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT);\n        if (inout)\n            needState = false;\n    }\n\n    if ((rule->flags & RULE_FLAG_NO_STATEMATCH))\n        needState = false;\n\n    chainPrefix[0] = 'F';\n\n    maySkipICMP = directionIn || inout;\n\n    if (needState)\n        matchState = directionIn ? \"ESTABLISHED\" : \"NEW,ESTABLISHED\";\n    else\n        matchState = NULL;\n\n    chainPrefix[1] = CHAINPREFIX_HOST_IN_TEMP;\n    rc = _iptablesCreateRuleInstance(fw,\n                                     layer,\n                                     directionIn,\n                                     chainPrefix,\n                                     rule,\n                                     ifname,\n                                     vars,\n                                     matchState, true,\n                                     \"RETURN\",\n                                     maySkipICMP);\n    if (rc < 0)\n        return rc;\n\n\n    maySkipICMP = !directionIn || inout;\n    if (needState)\n        matchState = directionIn ?  \"NEW,ESTABLISHED\" : \"ESTABLISHED\";\n    else\n        matchState = NULL;\n\n    chainPrefix[1] = CHAINPREFIX_HOST_OUT_TEMP;\n    rc = _iptablesCreateRuleInstance(fw,\n                                     layer,\n                                     !directionIn,\n                                     chainPrefix,\n                                     rule,\n                                     ifname,\n                                     vars,\n                                     matchState, true,\n                                     \"ACCEPT\",\n                                     maySkipICMP);\n    if (rc < 0)\n        return rc;\n\n    maySkipICMP = directionIn;\n    if (needState)\n        matchState = directionIn ? \"ESTABLISHED\" : \"NEW,ESTABLISHED\";\n    else\n        matchState = NULL;\n\n    chainPrefix[0] = 'H';\n    chainPrefix[1] = CHAINPREFIX_HOST_IN_TEMP;\n    rc = _iptablesCreateRuleInstance(fw,\n                                     layer,\n                                     directionIn,\n                                     chainPrefix,\n                                     rule,\n                                     ifname,\n                                     vars,\n                                     matchState, true,\n                                     \"RETURN\",\n                                     maySkipICMP);\n\n    return rc;\n}"
  },
  {
    "function_name": "iptablesCreateRuleInstanceStateCtrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "1540-1658",
    "snippet": "static int\niptablesCreateRuleInstanceStateCtrl(virFirewallPtr fw,\n                                    virFirewallLayer layer,\n                                    virNWFilterRuleDefPtr rule,\n                                    const char *ifname,\n                                    virNWFilterVarCombIterPtr vars)\n{\n    int rc = 0;\n    bool directionIn = false;\n    char chainPrefix[2];\n    bool maySkipICMP, inout = false;\n    char *matchState = NULL;\n    bool create;\n\n    if ((rule->tt == VIR_NWFILTER_RULE_DIRECTION_IN) ||\n        (rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT)) {\n        directionIn = true;\n        inout = (rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT);\n    }\n\n    chainPrefix[0] = 'F';\n\n    maySkipICMP = directionIn || inout;\n\n    create = true;\n    matchState = NULL;\n\n    if (directionIn && !inout) {\n        if ((rule->flags & IPTABLES_STATE_FLAGS))\n            create = false;\n    }\n\n    if (create && (rule->flags & IPTABLES_STATE_FLAGS)) {\n        if (printStateMatchFlags(rule->flags, &matchState) < 0)\n            return -1;\n    }\n\n    chainPrefix[1] = CHAINPREFIX_HOST_IN_TEMP;\n    if (create) {\n        rc = _iptablesCreateRuleInstance(fw,\n                                         layer,\n                                         directionIn,\n                                         chainPrefix,\n                                         rule,\n                                         ifname,\n                                         vars,\n                                         matchState, false,\n                                         \"RETURN\",\n                                         maySkipICMP);\n\n        VIR_FREE(matchState);\n        if (rc < 0)\n            return rc;\n    }\n\n    maySkipICMP = !directionIn || inout;\n    create = true;\n\n    if (!directionIn) {\n        if ((rule->flags & IPTABLES_STATE_FLAGS))\n            create = false;\n    }\n\n    if (create && (rule->flags & IPTABLES_STATE_FLAGS)) {\n        if (printStateMatchFlags(rule->flags, &matchState) < 0)\n            return -1;\n    }\n\n    chainPrefix[1] = CHAINPREFIX_HOST_OUT_TEMP;\n    if (create) {\n        rc = _iptablesCreateRuleInstance(fw,\n                                         layer,\n                                         !directionIn,\n                                         chainPrefix,\n                                         rule,\n                                         ifname,\n                                         vars,\n                                         matchState, false,\n                                         \"ACCEPT\",\n                                         maySkipICMP);\n\n        VIR_FREE(matchState);\n\n        if (rc < 0)\n            return rc;\n    }\n\n    maySkipICMP = directionIn;\n\n    create = true;\n\n    if (directionIn && !inout) {\n        if ((rule->flags & IPTABLES_STATE_FLAGS))\n            create = false;\n    } else {\n        if ((rule->flags & IPTABLES_STATE_FLAGS)) {\n            if (printStateMatchFlags(rule->flags, &matchState) < 0)\n                return -1;\n        }\n    }\n\n    if (create) {\n        chainPrefix[0] = 'H';\n        chainPrefix[1] = CHAINPREFIX_HOST_IN_TEMP;\n        rc = _iptablesCreateRuleInstance(fw,\n                                         layer,\n                                         directionIn,\n                                         chainPrefix,\n                                         rule,\n                                         ifname,\n                                         vars,\n                                         matchState, false,\n                                         \"RETURN\",\n                                         maySkipICMP);\n        VIR_FREE(matchState);\n    }\n\n    return rc;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "matchState"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_iptablesCreateRuleInstance",
          "args": [
            "fw",
            "layer",
            "directionIn",
            "chainPrefix",
            "rule",
            "ifname",
            "vars",
            "matchState",
            "false",
            "\"RETURN\"",
            "maySkipICMP"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "_iptablesCreateRuleInstance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "1140-1525",
          "snippet": "static int\n_iptablesCreateRuleInstance(virFirewallPtr fw,\n                            virFirewallLayer layer,\n                            bool directionIn,\n                            const char *chainPrefix,\n                            virNWFilterRuleDefPtr rule,\n                            const char *ifname,\n                            virNWFilterVarCombIterPtr vars,\n                            const char *match, bool defMatch,\n                            const char *accept_target,\n                            bool maySkipICMP)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char number[VIR_INT64_STR_BUFLEN];\n    char numberalt[VIR_INT64_STR_BUFLEN];\n    const char *target;\n    bool srcMacSkipped = false;\n    bool skipRule = false;\n    bool skipMatch = false;\n    bool hasICMPType = false;\n    virFirewallRulePtr fwrule;\n    size_t fwruleargs;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    switch ((int)rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_TCP:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"tcp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.tcpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.tcpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.tcpHdrFilter.dataTCPFlags)) {\n            char *flags;\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.tcpHdrFilter.dataTCPFlags))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, \"--tcp-flags\");\n\n            if (!(flags = virNWFilterPrintTCPFlags(rule->p.tcpHdrFilter.dataTCPFlags.u.tcpFlags.mask)))\n                return -1;\n            virFirewallRuleAddArg(fw, fwrule, flags);\n            VIR_FREE(flags);\n            if (!(flags = virNWFilterPrintTCPFlags(rule->p.tcpHdrFilter.dataTCPFlags.u.tcpFlags.flags)))\n                return -1;\n            virFirewallRuleAddArg(fw, fwrule, flags);\n            VIR_FREE(flags);\n        }\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.tcpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.tcpHdrFilter.dataTCPOption)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.tcpHdrFilter.dataTCPOption) < 0)\n                return -1;\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.tcpHdrFilter.dataTCPOption))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"--tcp-option\", number, NULL);\n        }\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"udp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.udpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.udpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.udpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITE:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"udplite\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.udpliteHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.udpliteHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ESP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"esp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.espHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.espHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_AH:\n    case VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"ah\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.ahHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.ahHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTP:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"sctp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.sctpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.sctpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.sctpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    NULL);\n\n        if (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ICMP)\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-p\", \"icmp\", NULL);\n        else\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-p\", \"icmpv6\", NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.icmpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.icmpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.icmpHdrFilter.dataICMPType)) {\n            const char *parm;\n\n            hasICMPType = true;\n\n            if (maySkipICMP) {\n                virFirewallRemoveRule(fw, fwrule);\n                return 0;\n            }\n\n            if (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ICMP)\n                parm = \"--icmp-type\";\n            else\n                parm = \"--icmpv6-type\";\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.icmpHdrFilter.dataICMPType) < 0)\n                return -1;\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.icmpHdrFilter.dataICMPType))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, parm);\n\n            if (HAS_ENTRY_ITEM(&rule->p.icmpHdrFilter.dataICMPCode)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.icmpHdrFilter.dataICMPCode) < 0)\n                    return -1;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IGMP:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"igmp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.igmpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.igmpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ALL:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"all\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.allHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.allHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected protocol %d\"),\n                       rule->prtclType);\n        return -1;\n    }\n\n    if ((srcMacSkipped &&\n         fwruleargs == virFirewallRuleGetArgCount(fwrule)) ||\n        skipRule) {\n        virFirewallRemoveRule(fw, fwrule);\n        return 0;\n    }\n\n    if (rule->action == VIR_NWFILTER_RULE_ACTION_ACCEPT) {\n        target = accept_target;\n    } else {\n        target = virNWFilterJumpTargetTypeToString(rule->action);\n        skipMatch = defMatch;\n    }\n\n    if (match && !skipMatch) {\n        if (newMatchState)\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"conntrack\",\n                                      \"--ctstate\", match,\n                                      NULL);\n        else\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"state\",\n                                      \"--state\", match,\n                                      NULL);\n    }\n\n    if (defMatch && match != NULL && !skipMatch && !hasICMPType)\n        iptablesEnforceDirection(fw, fwrule,\n                                 directionIn,\n                                 rule);\n\n    if (iptablesHandleIPHdrAfterStateMatch(fw, fwrule,\n                                           vars,\n                                           &rule->p.allHdrFilter.ipHdr,\n                                           directionIn) < 0)\n        return -1;\n\n    virFirewallRuleAddArgList(fw, fwrule,\n                              \"-j\", target, NULL);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool newMatchState;",
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic bool newMatchState;\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\n_iptablesCreateRuleInstance(virFirewallPtr fw,\n                            virFirewallLayer layer,\n                            bool directionIn,\n                            const char *chainPrefix,\n                            virNWFilterRuleDefPtr rule,\n                            const char *ifname,\n                            virNWFilterVarCombIterPtr vars,\n                            const char *match, bool defMatch,\n                            const char *accept_target,\n                            bool maySkipICMP)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char number[VIR_INT64_STR_BUFLEN];\n    char numberalt[VIR_INT64_STR_BUFLEN];\n    const char *target;\n    bool srcMacSkipped = false;\n    bool skipRule = false;\n    bool skipMatch = false;\n    bool hasICMPType = false;\n    virFirewallRulePtr fwrule;\n    size_t fwruleargs;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    switch ((int)rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_TCP:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"tcp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.tcpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.tcpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.tcpHdrFilter.dataTCPFlags)) {\n            char *flags;\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.tcpHdrFilter.dataTCPFlags))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, \"--tcp-flags\");\n\n            if (!(flags = virNWFilterPrintTCPFlags(rule->p.tcpHdrFilter.dataTCPFlags.u.tcpFlags.mask)))\n                return -1;\n            virFirewallRuleAddArg(fw, fwrule, flags);\n            VIR_FREE(flags);\n            if (!(flags = virNWFilterPrintTCPFlags(rule->p.tcpHdrFilter.dataTCPFlags.u.tcpFlags.flags)))\n                return -1;\n            virFirewallRuleAddArg(fw, fwrule, flags);\n            VIR_FREE(flags);\n        }\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.tcpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.tcpHdrFilter.dataTCPOption)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.tcpHdrFilter.dataTCPOption) < 0)\n                return -1;\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.tcpHdrFilter.dataTCPOption))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"--tcp-option\", number, NULL);\n        }\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"udp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.udpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.udpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.udpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITE:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"udplite\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.udpliteHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.udpliteHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ESP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"esp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.espHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.espHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_AH:\n    case VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"ah\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.ahHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.ahHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTP:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"sctp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.sctpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.sctpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.sctpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    NULL);\n\n        if (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ICMP)\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-p\", \"icmp\", NULL);\n        else\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-p\", \"icmpv6\", NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.icmpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.icmpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.icmpHdrFilter.dataICMPType)) {\n            const char *parm;\n\n            hasICMPType = true;\n\n            if (maySkipICMP) {\n                virFirewallRemoveRule(fw, fwrule);\n                return 0;\n            }\n\n            if (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ICMP)\n                parm = \"--icmp-type\";\n            else\n                parm = \"--icmpv6-type\";\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.icmpHdrFilter.dataICMPType) < 0)\n                return -1;\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.icmpHdrFilter.dataICMPType))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, parm);\n\n            if (HAS_ENTRY_ITEM(&rule->p.icmpHdrFilter.dataICMPCode)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.icmpHdrFilter.dataICMPCode) < 0)\n                    return -1;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IGMP:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"igmp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.igmpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.igmpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ALL:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"all\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.allHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.allHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected protocol %d\"),\n                       rule->prtclType);\n        return -1;\n    }\n\n    if ((srcMacSkipped &&\n         fwruleargs == virFirewallRuleGetArgCount(fwrule)) ||\n        skipRule) {\n        virFirewallRemoveRule(fw, fwrule);\n        return 0;\n    }\n\n    if (rule->action == VIR_NWFILTER_RULE_ACTION_ACCEPT) {\n        target = accept_target;\n    } else {\n        target = virNWFilterJumpTargetTypeToString(rule->action);\n        skipMatch = defMatch;\n    }\n\n    if (match && !skipMatch) {\n        if (newMatchState)\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"conntrack\",\n                                      \"--ctstate\", match,\n                                      NULL);\n        else\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"state\",\n                                      \"--state\", match,\n                                      NULL);\n    }\n\n    if (defMatch && match != NULL && !skipMatch && !hasICMPType)\n        iptablesEnforceDirection(fw, fwrule,\n                                 directionIn,\n                                 rule);\n\n    if (iptablesHandleIPHdrAfterStateMatch(fw, fwrule,\n                                           vars,\n                                           &rule->p.allHdrFilter.ipHdr,\n                                           directionIn) < 0)\n        return -1;\n\n    virFirewallRuleAddArgList(fw, fwrule,\n                              \"-j\", target, NULL);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printStateMatchFlags",
          "args": [
            "rule->flags",
            "&matchState"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "printStateMatchFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "1528-1538",
          "snippet": "static int\nprintStateMatchFlags(int32_t flags, char **bufptr)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virNWFilterPrintStateMatchFlags(&buf,\n                                    \"\",\n                                    flags,\n                                    false);\n    *bufptr = virBufferContentAndReset(&buf);\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintStateMatchFlags(int32_t flags, char **bufptr)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virNWFilterPrintStateMatchFlags(&buf,\n                                    \"\",\n                                    flags,\n                                    false);\n    *bufptr = virBufferContentAndReset(&buf);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "matchState"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "matchState"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\niptablesCreateRuleInstanceStateCtrl(virFirewallPtr fw,\n                                    virFirewallLayer layer,\n                                    virNWFilterRuleDefPtr rule,\n                                    const char *ifname,\n                                    virNWFilterVarCombIterPtr vars)\n{\n    int rc = 0;\n    bool directionIn = false;\n    char chainPrefix[2];\n    bool maySkipICMP, inout = false;\n    char *matchState = NULL;\n    bool create;\n\n    if ((rule->tt == VIR_NWFILTER_RULE_DIRECTION_IN) ||\n        (rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT)) {\n        directionIn = true;\n        inout = (rule->tt == VIR_NWFILTER_RULE_DIRECTION_INOUT);\n    }\n\n    chainPrefix[0] = 'F';\n\n    maySkipICMP = directionIn || inout;\n\n    create = true;\n    matchState = NULL;\n\n    if (directionIn && !inout) {\n        if ((rule->flags & IPTABLES_STATE_FLAGS))\n            create = false;\n    }\n\n    if (create && (rule->flags & IPTABLES_STATE_FLAGS)) {\n        if (printStateMatchFlags(rule->flags, &matchState) < 0)\n            return -1;\n    }\n\n    chainPrefix[1] = CHAINPREFIX_HOST_IN_TEMP;\n    if (create) {\n        rc = _iptablesCreateRuleInstance(fw,\n                                         layer,\n                                         directionIn,\n                                         chainPrefix,\n                                         rule,\n                                         ifname,\n                                         vars,\n                                         matchState, false,\n                                         \"RETURN\",\n                                         maySkipICMP);\n\n        VIR_FREE(matchState);\n        if (rc < 0)\n            return rc;\n    }\n\n    maySkipICMP = !directionIn || inout;\n    create = true;\n\n    if (!directionIn) {\n        if ((rule->flags & IPTABLES_STATE_FLAGS))\n            create = false;\n    }\n\n    if (create && (rule->flags & IPTABLES_STATE_FLAGS)) {\n        if (printStateMatchFlags(rule->flags, &matchState) < 0)\n            return -1;\n    }\n\n    chainPrefix[1] = CHAINPREFIX_HOST_OUT_TEMP;\n    if (create) {\n        rc = _iptablesCreateRuleInstance(fw,\n                                         layer,\n                                         !directionIn,\n                                         chainPrefix,\n                                         rule,\n                                         ifname,\n                                         vars,\n                                         matchState, false,\n                                         \"ACCEPT\",\n                                         maySkipICMP);\n\n        VIR_FREE(matchState);\n\n        if (rc < 0)\n            return rc;\n    }\n\n    maySkipICMP = directionIn;\n\n    create = true;\n\n    if (directionIn && !inout) {\n        if ((rule->flags & IPTABLES_STATE_FLAGS))\n            create = false;\n    } else {\n        if ((rule->flags & IPTABLES_STATE_FLAGS)) {\n            if (printStateMatchFlags(rule->flags, &matchState) < 0)\n                return -1;\n        }\n    }\n\n    if (create) {\n        chainPrefix[0] = 'H';\n        chainPrefix[1] = CHAINPREFIX_HOST_IN_TEMP;\n        rc = _iptablesCreateRuleInstance(fw,\n                                         layer,\n                                         directionIn,\n                                         chainPrefix,\n                                         rule,\n                                         ifname,\n                                         vars,\n                                         matchState, false,\n                                         \"RETURN\",\n                                         maySkipICMP);\n        VIR_FREE(matchState);\n    }\n\n    return rc;\n}"
  },
  {
    "function_name": "printStateMatchFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "1528-1538",
    "snippet": "static int\nprintStateMatchFlags(int32_t flags, char **bufptr)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virNWFilterPrintStateMatchFlags(&buf,\n                                    \"\",\n                                    flags,\n                                    false);\n    *bufptr = virBufferContentAndReset(&buf);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterPrintStateMatchFlags",
          "args": [
            "&buf",
            "\"\"",
            "flags",
            "false"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterPrintStateMatchFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "843-855",
          "snippet": "void\nvirNWFilterPrintStateMatchFlags(virBufferPtr buf,\n                                const char *prefix,\n                                int32_t flags,\n                                bool disp_none)\n{\n    if (!disp_none && (flags & RULE_FLAG_STATE_NONE))\n        return;\n\n    virBufferAdd(buf, prefix, -1);\n\n    printStringItems(buf, stateMatchMap, flags, \",\");\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct int_map stateMatchMap[] = {\n    INTMAP_ENTRY(RULE_FLAG_STATE_NEW,           \"NEW\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_ESTABLISHED,   \"ESTABLISHED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_RELATED,       \"RELATED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_INVALID,       \"INVALID\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_NONE,          \"NONE\"),\n    INTMAP_ENTRY_LAST,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic const struct int_map stateMatchMap[] = {\n    INTMAP_ENTRY(RULE_FLAG_STATE_NEW,           \"NEW\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_ESTABLISHED,   \"ESTABLISHED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_RELATED,       \"RELATED\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_INVALID,       \"INVALID\"),\n    INTMAP_ENTRY(RULE_FLAG_STATE_NONE,          \"NONE\"),\n    INTMAP_ENTRY_LAST,\n};\n\nvoid\nvirNWFilterPrintStateMatchFlags(virBufferPtr buf,\n                                const char *prefix,\n                                int32_t flags,\n                                bool disp_none)\n{\n    if (!disp_none && (flags & RULE_FLAG_STATE_NONE))\n        return;\n\n    virBufferAdd(buf, prefix, -1);\n\n    printStringItems(buf, stateMatchMap, flags, \",\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintStateMatchFlags(int32_t flags, char **bufptr)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virNWFilterPrintStateMatchFlags(&buf,\n                                    \"\",\n                                    flags,\n                                    false);\n    *bufptr = virBufferContentAndReset(&buf);\n    return 0;\n}"
  },
  {
    "function_name": "_iptablesCreateRuleInstance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "1140-1525",
    "snippet": "static int\n_iptablesCreateRuleInstance(virFirewallPtr fw,\n                            virFirewallLayer layer,\n                            bool directionIn,\n                            const char *chainPrefix,\n                            virNWFilterRuleDefPtr rule,\n                            const char *ifname,\n                            virNWFilterVarCombIterPtr vars,\n                            const char *match, bool defMatch,\n                            const char *accept_target,\n                            bool maySkipICMP)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char number[VIR_INT64_STR_BUFLEN];\n    char numberalt[VIR_INT64_STR_BUFLEN];\n    const char *target;\n    bool srcMacSkipped = false;\n    bool skipRule = false;\n    bool skipMatch = false;\n    bool hasICMPType = false;\n    virFirewallRulePtr fwrule;\n    size_t fwruleargs;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    switch ((int)rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_TCP:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"tcp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.tcpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.tcpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.tcpHdrFilter.dataTCPFlags)) {\n            char *flags;\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.tcpHdrFilter.dataTCPFlags))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, \"--tcp-flags\");\n\n            if (!(flags = virNWFilterPrintTCPFlags(rule->p.tcpHdrFilter.dataTCPFlags.u.tcpFlags.mask)))\n                return -1;\n            virFirewallRuleAddArg(fw, fwrule, flags);\n            VIR_FREE(flags);\n            if (!(flags = virNWFilterPrintTCPFlags(rule->p.tcpHdrFilter.dataTCPFlags.u.tcpFlags.flags)))\n                return -1;\n            virFirewallRuleAddArg(fw, fwrule, flags);\n            VIR_FREE(flags);\n        }\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.tcpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.tcpHdrFilter.dataTCPOption)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.tcpHdrFilter.dataTCPOption) < 0)\n                return -1;\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.tcpHdrFilter.dataTCPOption))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"--tcp-option\", number, NULL);\n        }\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"udp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.udpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.udpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.udpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITE:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"udplite\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.udpliteHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.udpliteHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ESP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"esp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.espHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.espHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_AH:\n    case VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"ah\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.ahHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.ahHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTP:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"sctp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.sctpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.sctpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.sctpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    NULL);\n\n        if (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ICMP)\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-p\", \"icmp\", NULL);\n        else\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-p\", \"icmpv6\", NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.icmpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.icmpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.icmpHdrFilter.dataICMPType)) {\n            const char *parm;\n\n            hasICMPType = true;\n\n            if (maySkipICMP) {\n                virFirewallRemoveRule(fw, fwrule);\n                return 0;\n            }\n\n            if (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ICMP)\n                parm = \"--icmp-type\";\n            else\n                parm = \"--icmpv6-type\";\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.icmpHdrFilter.dataICMPType) < 0)\n                return -1;\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.icmpHdrFilter.dataICMPType))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, parm);\n\n            if (HAS_ENTRY_ITEM(&rule->p.icmpHdrFilter.dataICMPCode)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.icmpHdrFilter.dataICMPCode) < 0)\n                    return -1;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IGMP:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"igmp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.igmpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.igmpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ALL:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"all\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.allHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.allHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected protocol %d\"),\n                       rule->prtclType);\n        return -1;\n    }\n\n    if ((srcMacSkipped &&\n         fwruleargs == virFirewallRuleGetArgCount(fwrule)) ||\n        skipRule) {\n        virFirewallRemoveRule(fw, fwrule);\n        return 0;\n    }\n\n    if (rule->action == VIR_NWFILTER_RULE_ACTION_ACCEPT) {\n        target = accept_target;\n    } else {\n        target = virNWFilterJumpTargetTypeToString(rule->action);\n        skipMatch = defMatch;\n    }\n\n    if (match && !skipMatch) {\n        if (newMatchState)\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"conntrack\",\n                                      \"--ctstate\", match,\n                                      NULL);\n        else\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"state\",\n                                      \"--state\", match,\n                                      NULL);\n    }\n\n    if (defMatch && match != NULL && !skipMatch && !hasICMPType)\n        iptablesEnforceDirection(fw, fwrule,\n                                 directionIn,\n                                 rule);\n\n    if (iptablesHandleIPHdrAfterStateMatch(fw, fwrule,\n                                           vars,\n                                           &rule->p.allHdrFilter.ipHdr,\n                                           directionIn) < 0)\n        return -1;\n\n    virFirewallRuleAddArgList(fw, fwrule,\n                              \"-j\", target, NULL);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool newMatchState;",
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallRuleAddArgList",
          "args": [
            "fw",
            "fwrule",
            "\"-j\"",
            "target",
            "NULL"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "541-562",
          "snippet": "void virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesHandleIPHdrAfterStateMatch",
          "args": [
            "fw",
            "fwrule",
            "vars",
            "&rule->p.allHdrFilter.ipHdr",
            "directionIn"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesHandleIPHdrAfterStateMatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "963-1024",
          "snippet": "static int\niptablesHandleIPHdrAfterStateMatch(virFirewallPtr fw,\n                                   virFirewallRulePtr fwrule,\n                                   virNWFilterVarCombIterPtr vars,\n                                   ipHdrDataDefPtr ipHdr,\n                                   bool directionIn)\n{\n    char number[VIR_INT64_STR_BUFLEN];\n    char str[MAX_IPSET_NAME_LENGTH];\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataIPSet) &&\n        HAS_ENTRY_ITEM(&ipHdr->dataIPSetFlags)) {\n\n        if (printDataType(vars,\n                          str, sizeof(str),\n                          &ipHdr->dataIPSet) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"set\",\n                                  \"--match-set\", str,\n                                  NULL);\n\n        if (printDataTypeDirection(vars,\n                                   str, sizeof(str),\n                                   &ipHdr->dataIPSetFlags, directionIn) < 0)\n            return -1;\n\n        virFirewallRuleAddArg(fw, fwrule, str);\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataConnlimitAbove)) {\n        if (!directionIn) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &ipHdr->dataConnlimitAbove) < 0)\n               return -1;\n\n            /* place connlimit after potential -m state --state ...\n               since this is the most useful order */\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"connlimit\",\n                                      NULL);\n            if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataConnlimitAbove))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"--connlimit-above\", number,\n                                      NULL);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataComment)) {\n        /* keep comments behind everything else -- they are packet eval.\n           no-ops */\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"comment\",\n                                  \"--comment\", ipHdr->dataComment.u.string,\n                                  NULL);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\niptablesHandleIPHdrAfterStateMatch(virFirewallPtr fw,\n                                   virFirewallRulePtr fwrule,\n                                   virNWFilterVarCombIterPtr vars,\n                                   ipHdrDataDefPtr ipHdr,\n                                   bool directionIn)\n{\n    char number[VIR_INT64_STR_BUFLEN];\n    char str[MAX_IPSET_NAME_LENGTH];\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataIPSet) &&\n        HAS_ENTRY_ITEM(&ipHdr->dataIPSetFlags)) {\n\n        if (printDataType(vars,\n                          str, sizeof(str),\n                          &ipHdr->dataIPSet) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"set\",\n                                  \"--match-set\", str,\n                                  NULL);\n\n        if (printDataTypeDirection(vars,\n                                   str, sizeof(str),\n                                   &ipHdr->dataIPSetFlags, directionIn) < 0)\n            return -1;\n\n        virFirewallRuleAddArg(fw, fwrule, str);\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataConnlimitAbove)) {\n        if (!directionIn) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &ipHdr->dataConnlimitAbove) < 0)\n               return -1;\n\n            /* place connlimit after potential -m state --state ...\n               since this is the most useful order */\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"connlimit\",\n                                      NULL);\n            if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataConnlimitAbove))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"--connlimit-above\", number,\n                                      NULL);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataComment)) {\n        /* keep comments behind everything else -- they are packet eval.\n           no-ops */\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"comment\",\n                                  \"--comment\", ipHdr->dataComment.u.string,\n                                  NULL);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesEnforceDirection",
          "args": [
            "fw",
            "fwrule",
            "directionIn",
            "rule"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesEnforceDirection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "1093-1118",
          "snippet": "static void\niptablesEnforceDirection(virFirewallPtr fw,\n                         virFirewallRulePtr fwrule,\n                         bool directionIn,\n                         virNWFilterRuleDefPtr rule)\n{\n    switch (iptables_ctdir_corrected) {\n    case CTDIR_STATUS_UNKNOWN:\n        /* could not be determined or s.th. is seriously wrong */\n        return;\n    case CTDIR_STATUS_CORRECTED:\n        directionIn = !directionIn;\n        break;\n    case CTDIR_STATUS_OLD:\n        break;\n    }\n\n    if (rule->tt != VIR_NWFILTER_RULE_DIRECTION_INOUT)\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"conntrack\",\n                                  \"--ctdir\",\n                                  (directionIn ?\n                                   \"Original\" :\n                                   \"Reply\"),\n                                  NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum ctdirStatus iptables_ctdir_corrected;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic enum ctdirStatus iptables_ctdir_corrected;\n\nstatic void\niptablesEnforceDirection(virFirewallPtr fw,\n                         virFirewallRulePtr fwrule,\n                         bool directionIn,\n                         virNWFilterRuleDefPtr rule)\n{\n    switch (iptables_ctdir_corrected) {\n    case CTDIR_STATUS_UNKNOWN:\n        /* could not be determined or s.th. is seriously wrong */\n        return;\n    case CTDIR_STATUS_CORRECTED:\n        directionIn = !directionIn;\n        break;\n    case CTDIR_STATUS_OLD:\n        break;\n    }\n\n    if (rule->tt != VIR_NWFILTER_RULE_DIRECTION_INOUT)\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"conntrack\",\n                                  \"--ctdir\",\n                                  (directionIn ?\n                                   \"Original\" :\n                                   \"Reply\"),\n                                  NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterJumpTargetTypeToString",
          "args": [
            "rule->action"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallRemoveRule",
          "args": [
            "fw",
            "fwrule"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRemoveRule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "444-483",
          "snippet": "void virFirewallRemoveRule(virFirewallPtr firewall,\n                           virFirewallRulePtr rule)\n{\n    size_t i;\n    virFirewallGroupPtr group;\n\n    /* Explicitly not checking firewall->err too,\n     * because if rule was partially created\n     * before hitting error we must still remove\n     * it to avoid leaking 'rule'\n     */\n    if (!firewall)\n        return;\n\n    if (firewall->ngroups == 0)\n        return;\n    group = firewall->groups[firewall->currentGroup];\n\n    if (group->addingRollback) {\n        for (i = 0; i < group->nrollback; i++) {\n            if (group->rollback[i] == rule) {\n                VIR_DELETE_ELEMENT(group->rollback,\n                                   i,\n                                   group->nrollback);\n                virFirewallRuleFree(rule);\n                break;\n            }\n        }\n    } else {\n        for (i = 0; i < group->naction; i++) {\n            if (group->action[i] == rule) {\n                VIR_DELETE_ELEMENT(group->action,\n                                   i,\n                                   group->naction);\n                virFirewallRuleFree(rule);\n                return;\n            }\n        }\n    }\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRemoveRule(virFirewallPtr firewall,\n                           virFirewallRulePtr rule)\n{\n    size_t i;\n    virFirewallGroupPtr group;\n\n    /* Explicitly not checking firewall->err too,\n     * because if rule was partially created\n     * before hitting error we must still remove\n     * it to avoid leaking 'rule'\n     */\n    if (!firewall)\n        return;\n\n    if (firewall->ngroups == 0)\n        return;\n    group = firewall->groups[firewall->currentGroup];\n\n    if (group->addingRollback) {\n        for (i = 0; i < group->nrollback; i++) {\n            if (group->rollback[i] == rule) {\n                VIR_DELETE_ELEMENT(group->rollback,\n                                   i,\n                                   group->nrollback);\n                virFirewallRuleFree(rule);\n                break;\n            }\n        }\n    } else {\n        for (i = 0; i < group->naction; i++) {\n            if (group->action[i] == rule) {\n                VIR_DELETE_ELEMENT(group->action,\n                                   i,\n                                   group->naction);\n                virFirewallRuleFree(rule);\n                return;\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallRuleGetArgCount",
          "args": [
            "fwrule"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleGetArgCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "565-570",
          "snippet": "size_t virFirewallRuleGetArgCount(virFirewallRulePtr rule)\n{\n    if (!rule)\n        return 0;\n    return rule->argsLen;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nsize_t virFirewallRuleGetArgCount(virFirewallRulePtr rule)\n{\n    if (!rule)\n        return 0;\n    return rule->argsLen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected protocol %d\")",
            "rule->prtclType"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected protocol %d\""
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "_virNWFilterTeardownFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_gentech_driver.c",
          "lines": "898-927",
          "snippet": "static int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdev.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_dhcpsnoop.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _virNWFilterTeardownFilter(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsocketaddr.h\"\n#include \"datatypes.h\"\n#include \"virnetdev.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_dhcpsnoop.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"virerror.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int _virNWFilterTeardownFilter(const char *ifname);\n\nstatic int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesHandleIPHdr",
          "args": [
            "fw",
            "fwrule",
            "vars",
            "&rule->p.allHdrFilter.ipHdr",
            "directionIn",
            "&skipRule",
            "&skipMatch"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesHandleIPHdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "815-960",
          "snippet": "static int\niptablesHandleIPHdr(virFirewallPtr fw,\n                    virFirewallRulePtr fwrule,\n                    virNWFilterVarCombIterPtr vars,\n                    ipHdrDataDefPtr ipHdr,\n                    bool directionIn,\n                    bool *skipRule, bool *skipMatch)\n{\n    char ipaddr[INET6_ADDRSTRLEN];\n    char ipaddralt[INET6_ADDRSTRLEN];\n    char number[VIR_INT64_STR_BUFLEN];\n    const char *src = \"--source\";\n    const char *dst = \"--destination\";\n    const char *srcrange = \"--src-range\";\n    const char *dstrange = \"--dst-range\";\n\n    if (directionIn) {\n        src = \"--destination\";\n        dst = \"--source\";\n        srcrange = \"--dst-range\";\n        dstrange = \"--src-range\";\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPAddr)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataSrcIPAddr) < 0)\n            return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataSrcIPAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, src);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPMask)) {\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &ipHdr->dataSrcIPMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, number);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    } else if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPFrom)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataSrcIPFrom) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"iprange\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataSrcIPFrom))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, srcrange);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPTo)) {\n\n            if (printDataType(vars,\n                              ipaddralt, sizeof(ipaddralt),\n                              &ipHdr->dataSrcIPTo) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s-%s\", ipaddr, ipaddralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPAddr)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataDstIPAddr) < 0)\n           return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataDstIPAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, dst);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPMask)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &ipHdr->dataDstIPMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, number);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    } else if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPFrom)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataDstIPFrom) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"iprange\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataDstIPFrom))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, dstrange);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPTo)) {\n            if (printDataType(vars,\n                              ipaddralt, sizeof(ipaddralt),\n                              &ipHdr->dataDstIPTo) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s-%s\", ipaddr, ipaddralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataDSCP)) {\n        if (printDataType(vars,\n                          number, sizeof(number),\n                          &ipHdr->dataDSCP) < 0)\n           return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"dscp\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataDSCP))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"--dscp\", number,\n                                  NULL);\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataConnlimitAbove)) {\n        if (directionIn) {\n            /* only support for limit in outgoing dir. */\n            *skipRule = true;\n        } else {\n            *skipMatch = true;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\niptablesHandleIPHdr(virFirewallPtr fw,\n                    virFirewallRulePtr fwrule,\n                    virNWFilterVarCombIterPtr vars,\n                    ipHdrDataDefPtr ipHdr,\n                    bool directionIn,\n                    bool *skipRule, bool *skipMatch)\n{\n    char ipaddr[INET6_ADDRSTRLEN];\n    char ipaddralt[INET6_ADDRSTRLEN];\n    char number[VIR_INT64_STR_BUFLEN];\n    const char *src = \"--source\";\n    const char *dst = \"--destination\";\n    const char *srcrange = \"--src-range\";\n    const char *dstrange = \"--dst-range\";\n\n    if (directionIn) {\n        src = \"--destination\";\n        dst = \"--source\";\n        srcrange = \"--dst-range\";\n        dstrange = \"--src-range\";\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPAddr)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataSrcIPAddr) < 0)\n            return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataSrcIPAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, src);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPMask)) {\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &ipHdr->dataSrcIPMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, number);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    } else if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPFrom)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataSrcIPFrom) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"iprange\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataSrcIPFrom))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, srcrange);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPTo)) {\n\n            if (printDataType(vars,\n                              ipaddralt, sizeof(ipaddralt),\n                              &ipHdr->dataSrcIPTo) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s-%s\", ipaddr, ipaddralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPAddr)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataDstIPAddr) < 0)\n           return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataDstIPAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, dst);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPMask)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &ipHdr->dataDstIPMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, number);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    } else if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPFrom)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataDstIPFrom) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"iprange\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataDstIPFrom))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, dstrange);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPTo)) {\n            if (printDataType(vars,\n                              ipaddralt, sizeof(ipaddralt),\n                              &ipHdr->dataDstIPTo) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s-%s\", ipaddr, ipaddralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataDSCP)) {\n        if (printDataType(vars,\n                          number, sizeof(number),\n                          &ipHdr->dataDSCP) < 0)\n           return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"dscp\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataDSCP))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"--dscp\", number,\n                                  NULL);\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataConnlimitAbove)) {\n        if (directionIn) {\n            /* only support for limit in outgoing dir. */\n            *skipRule = true;\n        } else {\n            *skipMatch = true;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iptablesHandleSrcMacAddr",
          "args": [
            "fw",
            "fwrule",
            "vars",
            "&rule->p.allHdrFilter.dataSrcMACAddr",
            "directionIn",
            "&srcMacSkipped"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesHandleSrcMacAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "777-812",
          "snippet": "static int\niptablesHandleSrcMacAddr(virFirewallPtr fw,\n                         virFirewallRulePtr fwrule,\n                         virNWFilterVarCombIterPtr vars,\n                         nwItemDescPtr srcMacAddr,\n                         bool directionIn,\n                         bool *srcmacskipped)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n\n    *srcmacskipped = false;\n\n    if (HAS_ENTRY_ITEM(srcMacAddr)) {\n        if (directionIn) {\n            *srcmacskipped = true;\n            return 0;\n        }\n\n        if (printDataType(vars,\n                          macaddr, sizeof(macaddr),\n                          srcMacAddr) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"mac\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(srcMacAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"--mac-source\",\n                                  macaddr,\n                                  NULL);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\niptablesHandleSrcMacAddr(virFirewallPtr fw,\n                         virFirewallRulePtr fwrule,\n                         virNWFilterVarCombIterPtr vars,\n                         nwItemDescPtr srcMacAddr,\n                         bool directionIn,\n                         bool *srcmacskipped)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n\n    *srcmacskipped = false;\n\n    if (HAS_ENTRY_ITEM(srcMacAddr)) {\n        if (directionIn) {\n            *srcmacskipped = true;\n            return 0;\n        }\n\n        if (printDataType(vars,\n                          macaddr, sizeof(macaddr),\n                          srcMacAddr) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"mac\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(srcMacAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"--mac-source\",\n                                  macaddr,\n                                  NULL);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "layer",
            "\"-A\"",
            "chain",
            "\"-p\"",
            "\"all\"",
            "NULL"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallRuleAddArgFormat",
          "args": [
            "fw",
            "fwrule",
            "\"%s/%s\"",
            "number",
            "numberalt"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "501-520",
          "snippet": "void virFirewallRuleAddArgFormat(virFirewallPtr firewall,\n                                 virFirewallRulePtr rule,\n                                 const char *fmt, ...)\n{\n    g_autofree char *arg = NULL;\n    va_list list;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, fmt);\n    arg = g_strdup_vprintf(fmt, list);\n    va_end(list);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgFormat(virFirewallPtr firewall,\n                                 virFirewallRulePtr rule,\n                                 const char *fmt, ...)\n{\n    g_autofree char *arg = NULL;\n    va_list list;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, fmt);\n    arg = g_strdup_vprintf(fmt, list);\n    va_end(list);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printDataType",
          "args": [
            "vars",
            "numberalt",
            "sizeof(numberalt)",
            "&rule->p.icmpHdrFilter.dataICMPCode"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "printDataTypeAsHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "349-355",
          "snippet": "static int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.icmpHdrFilter.dataICMPCode"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.icmpHdrFilter.dataICMPType"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.icmpHdrFilter.dataICMPType"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iptablesHandlePortData",
          "args": [
            "fw",
            "fwrule",
            "vars",
            "&rule->p.sctpHdrFilter.portData",
            "directionIn"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesHandlePortData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "1027-1090",
          "snippet": "static int\niptablesHandlePortData(virFirewallPtr fw,\n                       virFirewallRulePtr fwrule,\n                       virNWFilterVarCombIterPtr vars,\n                       portDataDefPtr portData,\n                       bool directionIn)\n{\n    char portstr[20];\n    char portstralt[20];\n    const char *sport = \"--sport\";\n    const char *dport = \"--dport\";\n    if (directionIn) {\n        sport = \"--dport\";\n        dport = \"--sport\";\n    }\n\n    if (HAS_ENTRY_ITEM(&portData->dataSrcPortStart)) {\n        if (printDataType(vars,\n                          portstr, sizeof(portstr),\n                          &portData->dataSrcPortStart) < 0)\n            return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&portData->dataSrcPortStart))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, sport);\n\n        if (HAS_ENTRY_ITEM(&portData->dataSrcPortEnd)) {\n            if (printDataType(vars,\n                              portstralt, sizeof(portstralt),\n                              &portData->dataSrcPortEnd) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s:%s\", portstr, portstralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, portstr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&portData->dataDstPortStart)) {\n        if (printDataType(vars,\n                          portstr, sizeof(portstr),\n                          &portData->dataDstPortStart) < 0)\n            return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&portData->dataDstPortStart))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, dport);\n\n        if (HAS_ENTRY_ITEM(&portData->dataDstPortEnd)) {\n            if (printDataType(vars,\n                              portstralt, sizeof(portstralt),\n                              &portData->dataDstPortEnd) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s:%s\", portstr, portstralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, portstr);\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\niptablesHandlePortData(virFirewallPtr fw,\n                       virFirewallRulePtr fwrule,\n                       virNWFilterVarCombIterPtr vars,\n                       portDataDefPtr portData,\n                       bool directionIn)\n{\n    char portstr[20];\n    char portstralt[20];\n    const char *sport = \"--sport\";\n    const char *dport = \"--dport\";\n    if (directionIn) {\n        sport = \"--dport\";\n        dport = \"--sport\";\n    }\n\n    if (HAS_ENTRY_ITEM(&portData->dataSrcPortStart)) {\n        if (printDataType(vars,\n                          portstr, sizeof(portstr),\n                          &portData->dataSrcPortStart) < 0)\n            return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&portData->dataSrcPortStart))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, sport);\n\n        if (HAS_ENTRY_ITEM(&portData->dataSrcPortEnd)) {\n            if (printDataType(vars,\n                              portstralt, sizeof(portstralt),\n                              &portData->dataSrcPortEnd) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s:%s\", portstr, portstralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, portstr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&portData->dataDstPortStart)) {\n        if (printDataType(vars,\n                          portstr, sizeof(portstr),\n                          &portData->dataDstPortStart) < 0)\n            return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&portData->dataDstPortStart))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, dport);\n\n        if (HAS_ENTRY_ITEM(&portData->dataDstPortEnd)) {\n            if (printDataType(vars,\n                              portstralt, sizeof(portstralt),\n                              &portData->dataDstPortEnd) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s:%s\", portstr, portstralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, portstr);\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.tcpHdrFilter.dataTCPOption"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.tcpHdrFilter.dataTCPOption"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "flags"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterPrintTCPFlags",
          "args": [
            "rule->p.tcpHdrFilter.dataTCPFlags.u.tcpFlags.flags"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterPrintTCPFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "948-954",
          "snippet": "char *\nvirNWFilterPrintTCPFlags(uint8_t flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    printTCPFlags(&buf, flags);\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirNWFilterPrintTCPFlags(uint8_t flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    printTCPFlags(&buf, flags);\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "flags"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&rule->p.tcpHdrFilter.dataTCPFlags"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&rule->p.tcpHdrFilter.dataTCPFlags"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IPT_ROOT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic bool newMatchState;\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic int\n_iptablesCreateRuleInstance(virFirewallPtr fw,\n                            virFirewallLayer layer,\n                            bool directionIn,\n                            const char *chainPrefix,\n                            virNWFilterRuleDefPtr rule,\n                            const char *ifname,\n                            virNWFilterVarCombIterPtr vars,\n                            const char *match, bool defMatch,\n                            const char *accept_target,\n                            bool maySkipICMP)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char number[VIR_INT64_STR_BUFLEN];\n    char numberalt[VIR_INT64_STR_BUFLEN];\n    const char *target;\n    bool srcMacSkipped = false;\n    bool skipRule = false;\n    bool skipMatch = false;\n    bool hasICMPType = false;\n    virFirewallRulePtr fwrule;\n    size_t fwruleargs;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    switch ((int)rule->prtclType) {\n    case VIR_NWFILTER_RULE_PROTOCOL_TCP:\n    case VIR_NWFILTER_RULE_PROTOCOL_TCPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"tcp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.tcpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.tcpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.tcpHdrFilter.dataTCPFlags)) {\n            char *flags;\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.tcpHdrFilter.dataTCPFlags))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, \"--tcp-flags\");\n\n            if (!(flags = virNWFilterPrintTCPFlags(rule->p.tcpHdrFilter.dataTCPFlags.u.tcpFlags.mask)))\n                return -1;\n            virFirewallRuleAddArg(fw, fwrule, flags);\n            VIR_FREE(flags);\n            if (!(flags = virNWFilterPrintTCPFlags(rule->p.tcpHdrFilter.dataTCPFlags.u.tcpFlags.flags)))\n                return -1;\n            virFirewallRuleAddArg(fw, fwrule, flags);\n            VIR_FREE(flags);\n        }\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.tcpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.tcpHdrFilter.dataTCPOption)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.tcpHdrFilter.dataTCPOption) < 0)\n                return -1;\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.tcpHdrFilter.dataTCPOption))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"--tcp-option\", number, NULL);\n        }\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDP:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"udp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.udpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.udpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.udpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITE:\n    case VIR_NWFILTER_RULE_PROTOCOL_UDPLITEoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"udplite\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.udpliteHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.udpliteHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ESP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ESPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"esp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.espHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.espHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_AH:\n    case VIR_NWFILTER_RULE_PROTOCOL_AHoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"ah\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.ahHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.ahHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTP:\n    case VIR_NWFILTER_RULE_PROTOCOL_SCTPoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"sctp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.sctpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.sctpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (iptablesHandlePortData(fw, fwrule,\n                                   vars,\n                                   &rule->p.sctpHdrFilter.portData,\n                                   directionIn) < 0)\n            return -1;\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMP:\n    case VIR_NWFILTER_RULE_PROTOCOL_ICMPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    NULL);\n\n        if (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ICMP)\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-p\", \"icmp\", NULL);\n        else\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-p\", \"icmpv6\", NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.icmpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.icmpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n        if (HAS_ENTRY_ITEM(&rule->p.icmpHdrFilter.dataICMPType)) {\n            const char *parm;\n\n            hasICMPType = true;\n\n            if (maySkipICMP) {\n                virFirewallRemoveRule(fw, fwrule);\n                return 0;\n            }\n\n            if (rule->prtclType == VIR_NWFILTER_RULE_PROTOCOL_ICMP)\n                parm = \"--icmp-type\";\n            else\n                parm = \"--icmpv6-type\";\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &rule->p.icmpHdrFilter.dataICMPType) < 0)\n                return -1;\n\n            if (ENTRY_WANT_NEG_SIGN(&rule->p.icmpHdrFilter.dataICMPType))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArg(fw, fwrule, parm);\n\n            if (HAS_ENTRY_ITEM(&rule->p.icmpHdrFilter.dataICMPCode)) {\n                if (printDataType(vars,\n                                  numberalt, sizeof(numberalt),\n                                  &rule->p.icmpHdrFilter.dataICMPCode) < 0)\n                    return -1;\n\n                virFirewallRuleAddArgFormat(fw, fwrule,\n                                            \"%s/%s\", number, numberalt);\n            } else {\n                virFirewallRuleAddArg(fw, fwrule, number);\n            }\n        }\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_IGMP:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"igmp\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.igmpHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.igmpHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    case VIR_NWFILTER_RULE_PROTOCOL_ALL:\n    case VIR_NWFILTER_RULE_PROTOCOL_ALLoIPV6:\n        fwrule = virFirewallAddRule(fw, layer,\n                                    \"-A\", chain,\n                                    \"-p\", \"all\",\n                                    NULL);\n\n        fwruleargs = virFirewallRuleGetArgCount(fwrule);\n\n        if (iptablesHandleSrcMacAddr(fw, fwrule,\n                                     vars,\n                                     &rule->p.allHdrFilter.dataSrcMACAddr,\n                                     directionIn,\n                                     &srcMacSkipped) < 0)\n            return -1;\n\n        if (iptablesHandleIPHdr(fw, fwrule,\n                                vars,\n                                &rule->p.allHdrFilter.ipHdr,\n                                directionIn,\n                                &skipRule, &skipMatch) < 0)\n            return -1;\n\n    break;\n\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected protocol %d\"),\n                       rule->prtclType);\n        return -1;\n    }\n\n    if ((srcMacSkipped &&\n         fwruleargs == virFirewallRuleGetArgCount(fwrule)) ||\n        skipRule) {\n        virFirewallRemoveRule(fw, fwrule);\n        return 0;\n    }\n\n    if (rule->action == VIR_NWFILTER_RULE_ACTION_ACCEPT) {\n        target = accept_target;\n    } else {\n        target = virNWFilterJumpTargetTypeToString(rule->action);\n        skipMatch = defMatch;\n    }\n\n    if (match && !skipMatch) {\n        if (newMatchState)\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"conntrack\",\n                                      \"--ctstate\", match,\n                                      NULL);\n        else\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"state\",\n                                      \"--state\", match,\n                                      NULL);\n    }\n\n    if (defMatch && match != NULL && !skipMatch && !hasICMPType)\n        iptablesEnforceDirection(fw, fwrule,\n                                 directionIn,\n                                 rule);\n\n    if (iptablesHandleIPHdrAfterStateMatch(fw, fwrule,\n                                           vars,\n                                           &rule->p.allHdrFilter.ipHdr,\n                                           directionIn) < 0)\n        return -1;\n\n    virFirewallRuleAddArgList(fw, fwrule,\n                              \"-j\", target, NULL);\n\n    return 0;\n}"
  },
  {
    "function_name": "iptablesEnforceDirection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "1093-1118",
    "snippet": "static void\niptablesEnforceDirection(virFirewallPtr fw,\n                         virFirewallRulePtr fwrule,\n                         bool directionIn,\n                         virNWFilterRuleDefPtr rule)\n{\n    switch (iptables_ctdir_corrected) {\n    case CTDIR_STATUS_UNKNOWN:\n        /* could not be determined or s.th. is seriously wrong */\n        return;\n    case CTDIR_STATUS_CORRECTED:\n        directionIn = !directionIn;\n        break;\n    case CTDIR_STATUS_OLD:\n        break;\n    }\n\n    if (rule->tt != VIR_NWFILTER_RULE_DIRECTION_INOUT)\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"conntrack\",\n                                  \"--ctdir\",\n                                  (directionIn ?\n                                   \"Original\" :\n                                   \"Reply\"),\n                                  NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum ctdirStatus iptables_ctdir_corrected;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallRuleAddArgList",
          "args": [
            "fw",
            "fwrule",
            "\"-m\"",
            "\"conntrack\"",
            "\"--ctdir\"",
            "(directionIn ?\n                                   \"Original\" :\n                                   \"Reply\")",
            "NULL"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "541-562",
          "snippet": "void virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic enum ctdirStatus iptables_ctdir_corrected;\n\nstatic void\niptablesEnforceDirection(virFirewallPtr fw,\n                         virFirewallRulePtr fwrule,\n                         bool directionIn,\n                         virNWFilterRuleDefPtr rule)\n{\n    switch (iptables_ctdir_corrected) {\n    case CTDIR_STATUS_UNKNOWN:\n        /* could not be determined or s.th. is seriously wrong */\n        return;\n    case CTDIR_STATUS_CORRECTED:\n        directionIn = !directionIn;\n        break;\n    case CTDIR_STATUS_OLD:\n        break;\n    }\n\n    if (rule->tt != VIR_NWFILTER_RULE_DIRECTION_INOUT)\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"conntrack\",\n                                  \"--ctdir\",\n                                  (directionIn ?\n                                   \"Original\" :\n                                   \"Reply\"),\n                                  NULL);\n}"
  },
  {
    "function_name": "iptablesHandlePortData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "1027-1090",
    "snippet": "static int\niptablesHandlePortData(virFirewallPtr fw,\n                       virFirewallRulePtr fwrule,\n                       virNWFilterVarCombIterPtr vars,\n                       portDataDefPtr portData,\n                       bool directionIn)\n{\n    char portstr[20];\n    char portstralt[20];\n    const char *sport = \"--sport\";\n    const char *dport = \"--dport\";\n    if (directionIn) {\n        sport = \"--dport\";\n        dport = \"--sport\";\n    }\n\n    if (HAS_ENTRY_ITEM(&portData->dataSrcPortStart)) {\n        if (printDataType(vars,\n                          portstr, sizeof(portstr),\n                          &portData->dataSrcPortStart) < 0)\n            return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&portData->dataSrcPortStart))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, sport);\n\n        if (HAS_ENTRY_ITEM(&portData->dataSrcPortEnd)) {\n            if (printDataType(vars,\n                              portstralt, sizeof(portstralt),\n                              &portData->dataSrcPortEnd) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s:%s\", portstr, portstralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, portstr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&portData->dataDstPortStart)) {\n        if (printDataType(vars,\n                          portstr, sizeof(portstr),\n                          &portData->dataDstPortStart) < 0)\n            return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&portData->dataDstPortStart))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, dport);\n\n        if (HAS_ENTRY_ITEM(&portData->dataDstPortEnd)) {\n            if (printDataType(vars,\n                              portstralt, sizeof(portstralt),\n                              &portData->dataDstPortEnd) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s:%s\", portstr, portstralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, portstr);\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallRuleAddArg",
          "args": [
            "fw",
            "fwrule",
            "portstr"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "541-562",
          "snippet": "void virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallRuleAddArgFormat",
          "args": [
            "fw",
            "fwrule",
            "\"%s:%s\"",
            "portstr",
            "portstralt"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "501-520",
          "snippet": "void virFirewallRuleAddArgFormat(virFirewallPtr firewall,\n                                 virFirewallRulePtr rule,\n                                 const char *fmt, ...)\n{\n    g_autofree char *arg = NULL;\n    va_list list;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, fmt);\n    arg = g_strdup_vprintf(fmt, list);\n    va_end(list);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgFormat(virFirewallPtr firewall,\n                                 virFirewallRulePtr rule,\n                                 const char *fmt, ...)\n{\n    g_autofree char *arg = NULL;\n    va_list list;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, fmt);\n    arg = g_strdup_vprintf(fmt, list);\n    va_end(list);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printDataType",
          "args": [
            "vars",
            "portstralt",
            "sizeof(portstralt)",
            "&portData->dataDstPortEnd"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "printDataTypeAsHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "349-355",
          "snippet": "static int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&portData->dataDstPortEnd"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&portData->dataDstPortStart"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&portData->dataDstPortStart"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&portData->dataSrcPortEnd"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&portData->dataSrcPortStart"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&portData->dataSrcPortStart"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\niptablesHandlePortData(virFirewallPtr fw,\n                       virFirewallRulePtr fwrule,\n                       virNWFilterVarCombIterPtr vars,\n                       portDataDefPtr portData,\n                       bool directionIn)\n{\n    char portstr[20];\n    char portstralt[20];\n    const char *sport = \"--sport\";\n    const char *dport = \"--dport\";\n    if (directionIn) {\n        sport = \"--dport\";\n        dport = \"--sport\";\n    }\n\n    if (HAS_ENTRY_ITEM(&portData->dataSrcPortStart)) {\n        if (printDataType(vars,\n                          portstr, sizeof(portstr),\n                          &portData->dataSrcPortStart) < 0)\n            return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&portData->dataSrcPortStart))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, sport);\n\n        if (HAS_ENTRY_ITEM(&portData->dataSrcPortEnd)) {\n            if (printDataType(vars,\n                              portstralt, sizeof(portstralt),\n                              &portData->dataSrcPortEnd) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s:%s\", portstr, portstralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, portstr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&portData->dataDstPortStart)) {\n        if (printDataType(vars,\n                          portstr, sizeof(portstr),\n                          &portData->dataDstPortStart) < 0)\n            return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&portData->dataDstPortStart))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, dport);\n\n        if (HAS_ENTRY_ITEM(&portData->dataDstPortEnd)) {\n            if (printDataType(vars,\n                              portstralt, sizeof(portstralt),\n                              &portData->dataDstPortEnd) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s:%s\", portstr, portstralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, portstr);\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "iptablesHandleIPHdrAfterStateMatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "963-1024",
    "snippet": "static int\niptablesHandleIPHdrAfterStateMatch(virFirewallPtr fw,\n                                   virFirewallRulePtr fwrule,\n                                   virNWFilterVarCombIterPtr vars,\n                                   ipHdrDataDefPtr ipHdr,\n                                   bool directionIn)\n{\n    char number[VIR_INT64_STR_BUFLEN];\n    char str[MAX_IPSET_NAME_LENGTH];\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataIPSet) &&\n        HAS_ENTRY_ITEM(&ipHdr->dataIPSetFlags)) {\n\n        if (printDataType(vars,\n                          str, sizeof(str),\n                          &ipHdr->dataIPSet) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"set\",\n                                  \"--match-set\", str,\n                                  NULL);\n\n        if (printDataTypeDirection(vars,\n                                   str, sizeof(str),\n                                   &ipHdr->dataIPSetFlags, directionIn) < 0)\n            return -1;\n\n        virFirewallRuleAddArg(fw, fwrule, str);\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataConnlimitAbove)) {\n        if (!directionIn) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &ipHdr->dataConnlimitAbove) < 0)\n               return -1;\n\n            /* place connlimit after potential -m state --state ...\n               since this is the most useful order */\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"connlimit\",\n                                      NULL);\n            if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataConnlimitAbove))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"--connlimit-above\", number,\n                                      NULL);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataComment)) {\n        /* keep comments behind everything else -- they are packet eval.\n           no-ops */\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"comment\",\n                                  \"--comment\", ipHdr->dataComment.u.string,\n                                  NULL);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallRuleAddArgList",
          "args": [
            "fw",
            "fwrule",
            "\"-m\"",
            "\"comment\"",
            "\"--comment\"",
            "ipHdr->dataComment.u.string",
            "NULL"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "541-562",
          "snippet": "void virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataComment"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&ipHdr->dataConnlimitAbove"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printDataType",
          "args": [
            "vars",
            "number",
            "sizeof(number)",
            "&ipHdr->dataConnlimitAbove"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "printDataTypeAsHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "349-355",
          "snippet": "static int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataConnlimitAbove"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printDataTypeDirection",
          "args": [
            "vars",
            "str",
            "sizeof(str)",
            "&ipHdr->dataIPSetFlags",
            "directionIn"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "printDataTypeDirection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "341-347",
          "snippet": "static int\nprintDataTypeDirection(virNWFilterVarCombIterPtr vars,\n                       char *buf, int bufsize,\n                       nwItemDescPtr item, bool directionIn)\n{\n    return _printDataType(vars, buf, bufsize, item, 0, directionIn);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintDataTypeDirection(virNWFilterVarCombIterPtr vars,\n                       char *buf, int bufsize,\n                       nwItemDescPtr item, bool directionIn)\n{\n    return _printDataType(vars, buf, bufsize, item, 0, directionIn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataIPSetFlags"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataIPSet"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\niptablesHandleIPHdrAfterStateMatch(virFirewallPtr fw,\n                                   virFirewallRulePtr fwrule,\n                                   virNWFilterVarCombIterPtr vars,\n                                   ipHdrDataDefPtr ipHdr,\n                                   bool directionIn)\n{\n    char number[VIR_INT64_STR_BUFLEN];\n    char str[MAX_IPSET_NAME_LENGTH];\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataIPSet) &&\n        HAS_ENTRY_ITEM(&ipHdr->dataIPSetFlags)) {\n\n        if (printDataType(vars,\n                          str, sizeof(str),\n                          &ipHdr->dataIPSet) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"set\",\n                                  \"--match-set\", str,\n                                  NULL);\n\n        if (printDataTypeDirection(vars,\n                                   str, sizeof(str),\n                                   &ipHdr->dataIPSetFlags, directionIn) < 0)\n            return -1;\n\n        virFirewallRuleAddArg(fw, fwrule, str);\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataConnlimitAbove)) {\n        if (!directionIn) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &ipHdr->dataConnlimitAbove) < 0)\n               return -1;\n\n            /* place connlimit after potential -m state --state ...\n               since this is the most useful order */\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"-m\", \"connlimit\",\n                                      NULL);\n            if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataConnlimitAbove))\n                virFirewallRuleAddArg(fw, fwrule, \"!\");\n            virFirewallRuleAddArgList(fw, fwrule,\n                                      \"--connlimit-above\", number,\n                                      NULL);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataComment)) {\n        /* keep comments behind everything else -- they are packet eval.\n           no-ops */\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"comment\",\n                                  \"--comment\", ipHdr->dataComment.u.string,\n                                  NULL);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "iptablesHandleIPHdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "815-960",
    "snippet": "static int\niptablesHandleIPHdr(virFirewallPtr fw,\n                    virFirewallRulePtr fwrule,\n                    virNWFilterVarCombIterPtr vars,\n                    ipHdrDataDefPtr ipHdr,\n                    bool directionIn,\n                    bool *skipRule, bool *skipMatch)\n{\n    char ipaddr[INET6_ADDRSTRLEN];\n    char ipaddralt[INET6_ADDRSTRLEN];\n    char number[VIR_INT64_STR_BUFLEN];\n    const char *src = \"--source\";\n    const char *dst = \"--destination\";\n    const char *srcrange = \"--src-range\";\n    const char *dstrange = \"--dst-range\";\n\n    if (directionIn) {\n        src = \"--destination\";\n        dst = \"--source\";\n        srcrange = \"--dst-range\";\n        dstrange = \"--src-range\";\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPAddr)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataSrcIPAddr) < 0)\n            return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataSrcIPAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, src);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPMask)) {\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &ipHdr->dataSrcIPMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, number);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    } else if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPFrom)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataSrcIPFrom) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"iprange\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataSrcIPFrom))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, srcrange);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPTo)) {\n\n            if (printDataType(vars,\n                              ipaddralt, sizeof(ipaddralt),\n                              &ipHdr->dataSrcIPTo) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s-%s\", ipaddr, ipaddralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPAddr)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataDstIPAddr) < 0)\n           return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataDstIPAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, dst);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPMask)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &ipHdr->dataDstIPMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, number);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    } else if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPFrom)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataDstIPFrom) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"iprange\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataDstIPFrom))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, dstrange);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPTo)) {\n            if (printDataType(vars,\n                              ipaddralt, sizeof(ipaddralt),\n                              &ipHdr->dataDstIPTo) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s-%s\", ipaddr, ipaddralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataDSCP)) {\n        if (printDataType(vars,\n                          number, sizeof(number),\n                          &ipHdr->dataDSCP) < 0)\n           return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"dscp\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataDSCP))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"--dscp\", number,\n                                  NULL);\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataConnlimitAbove)) {\n        if (directionIn) {\n            /* only support for limit in outgoing dir. */\n            *skipRule = true;\n        } else {\n            *skipMatch = true;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataConnlimitAbove"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallRuleAddArgList",
          "args": [
            "fw",
            "fwrule",
            "\"--dscp\"",
            "number",
            "NULL"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "541-562",
          "snippet": "void virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&ipHdr->dataDSCP"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printDataType",
          "args": [
            "vars",
            "number",
            "sizeof(number)",
            "&ipHdr->dataDSCP"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "printDataTypeAsHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "349-355",
          "snippet": "static int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataDSCP"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallRuleAddArgFormat",
          "args": [
            "fw",
            "fwrule",
            "\"%s-%s\"",
            "ipaddr",
            "ipaddralt"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "501-520",
          "snippet": "void virFirewallRuleAddArgFormat(virFirewallPtr firewall,\n                                 virFirewallRulePtr rule,\n                                 const char *fmt, ...)\n{\n    g_autofree char *arg = NULL;\n    va_list list;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, fmt);\n    arg = g_strdup_vprintf(fmt, list);\n    va_end(list);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgFormat(virFirewallPtr firewall,\n                                 virFirewallRulePtr rule,\n                                 const char *fmt, ...)\n{\n    g_autofree char *arg = NULL;\n    va_list list;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, fmt);\n    arg = g_strdup_vprintf(fmt, list);\n    va_end(list);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataDstIPTo"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&ipHdr->dataDstIPFrom"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataDstIPFrom"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataDstIPMask"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&ipHdr->dataDstIPAddr"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataDstIPAddr"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataSrcIPTo"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&ipHdr->dataSrcIPFrom"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataSrcIPFrom"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataSrcIPMask"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&ipHdr->dataSrcIPAddr"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ipHdr->dataSrcIPAddr"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\niptablesHandleIPHdr(virFirewallPtr fw,\n                    virFirewallRulePtr fwrule,\n                    virNWFilterVarCombIterPtr vars,\n                    ipHdrDataDefPtr ipHdr,\n                    bool directionIn,\n                    bool *skipRule, bool *skipMatch)\n{\n    char ipaddr[INET6_ADDRSTRLEN];\n    char ipaddralt[INET6_ADDRSTRLEN];\n    char number[VIR_INT64_STR_BUFLEN];\n    const char *src = \"--source\";\n    const char *dst = \"--destination\";\n    const char *srcrange = \"--src-range\";\n    const char *dstrange = \"--dst-range\";\n\n    if (directionIn) {\n        src = \"--destination\";\n        dst = \"--source\";\n        srcrange = \"--dst-range\";\n        dstrange = \"--src-range\";\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPAddr)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataSrcIPAddr) < 0)\n            return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataSrcIPAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, src);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPMask)) {\n\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &ipHdr->dataSrcIPMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, number);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    } else if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPFrom)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataSrcIPFrom) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"iprange\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataSrcIPFrom))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, srcrange);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataSrcIPTo)) {\n\n            if (printDataType(vars,\n                              ipaddralt, sizeof(ipaddralt),\n                              &ipHdr->dataSrcIPTo) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s-%s\", ipaddr, ipaddralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPAddr)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataDstIPAddr) < 0)\n           return -1;\n\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataDstIPAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, dst);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPMask)) {\n            if (printDataType(vars,\n                              number, sizeof(number),\n                              &ipHdr->dataDstIPMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", ipaddr, number);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    } else if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPFrom)) {\n        if (printDataType(vars,\n                          ipaddr, sizeof(ipaddr),\n                          &ipHdr->dataDstIPFrom) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"iprange\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataDstIPFrom))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArg(fw, fwrule, dstrange);\n\n        if (HAS_ENTRY_ITEM(&ipHdr->dataDstIPTo)) {\n            if (printDataType(vars,\n                              ipaddralt, sizeof(ipaddralt),\n                              &ipHdr->dataDstIPTo) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s-%s\", ipaddr, ipaddralt);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, ipaddr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataDSCP)) {\n        if (printDataType(vars,\n                          number, sizeof(number),\n                          &ipHdr->dataDSCP) < 0)\n           return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"dscp\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ipHdr->dataDSCP))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"--dscp\", number,\n                                  NULL);\n    }\n\n    if (HAS_ENTRY_ITEM(&ipHdr->dataConnlimitAbove)) {\n        if (directionIn) {\n            /* only support for limit in outgoing dir. */\n            *skipRule = true;\n        } else {\n            *skipMatch = true;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "iptablesHandleSrcMacAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "777-812",
    "snippet": "static int\niptablesHandleSrcMacAddr(virFirewallPtr fw,\n                         virFirewallRulePtr fwrule,\n                         virNWFilterVarCombIterPtr vars,\n                         nwItemDescPtr srcMacAddr,\n                         bool directionIn,\n                         bool *srcmacskipped)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n\n    *srcmacskipped = false;\n\n    if (HAS_ENTRY_ITEM(srcMacAddr)) {\n        if (directionIn) {\n            *srcmacskipped = true;\n            return 0;\n        }\n\n        if (printDataType(vars,\n                          macaddr, sizeof(macaddr),\n                          srcMacAddr) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"mac\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(srcMacAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"--mac-source\",\n                                  macaddr,\n                                  NULL);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallRuleAddArgList",
          "args": [
            "fw",
            "fwrule",
            "\"--mac-source\"",
            "macaddr",
            "NULL"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "541-562",
          "snippet": "void virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "srcMacAddr"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printDataType",
          "args": [
            "vars",
            "macaddr",
            "sizeof(macaddr)",
            "srcMacAddr"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "printDataTypeAsHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "349-355",
          "snippet": "static int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "srcMacAddr"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\niptablesHandleSrcMacAddr(virFirewallPtr fw,\n                         virFirewallRulePtr fwrule,\n                         virNWFilterVarCombIterPtr vars,\n                         nwItemDescPtr srcMacAddr,\n                         bool directionIn,\n                         bool *srcmacskipped)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n\n    *srcmacskipped = false;\n\n    if (HAS_ENTRY_ITEM(srcMacAddr)) {\n        if (directionIn) {\n            *srcmacskipped = true;\n            return 0;\n        }\n\n        if (printDataType(vars,\n                          macaddr, sizeof(macaddr),\n                          srcMacAddr) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"-m\", \"mac\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(srcMacAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  \"--mac-source\",\n                                  macaddr,\n                                  NULL);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "iptablesRenameTmpRootChainsFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "766-774",
    "snippet": "static void\niptablesRenameTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesRenameTmpRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRenameTmpRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRenameTmpRootChainFW(fw, layer, 'H', true, ifname);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesRenameTmpRootChainFW",
          "args": [
            "fw",
            "layer",
            "'H'",
            "true",
            "ifname"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRenameTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "739-763",
          "snippet": "static void\niptablesRenameTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             char prefix,\n                             bool incoming,\n                             const char *ifname)\n{\n    char tmpchain[MAX_CHAINNAME_LENGTH], chain[MAX_CHAINNAME_LENGTH];\n    char tmpChainPrefix[2] = {\n        prefix,\n        incoming ? CHAINPREFIX_HOST_IN_TEMP\n                 : CHAINPREFIX_HOST_OUT_TEMP\n    };\n    char chainPrefix[2] = {\n        prefix,\n        incoming ? CHAINPREFIX_HOST_IN\n                 : CHAINPREFIX_HOST_OUT\n    };\n\n    PRINT_IPT_ROOT_CHAIN(tmpchain, tmpChainPrefix, ifname);\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, layer,\n                       \"-E\", tmpchain, chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
            "#define CHAINPREFIX_HOST_OUT      'O'",
            "#define CHAINPREFIX_HOST_IN       'I'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesRenameTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             char prefix,\n                             bool incoming,\n                             const char *ifname)\n{\n    char tmpchain[MAX_CHAINNAME_LENGTH], chain[MAX_CHAINNAME_LENGTH];\n    char tmpChainPrefix[2] = {\n        prefix,\n        incoming ? CHAINPREFIX_HOST_IN_TEMP\n                 : CHAINPREFIX_HOST_OUT_TEMP\n    };\n    char chainPrefix[2] = {\n        prefix,\n        incoming ? CHAINPREFIX_HOST_IN\n                 : CHAINPREFIX_HOST_OUT\n    };\n\n    PRINT_IPT_ROOT_CHAIN(tmpchain, tmpChainPrefix, ifname);\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, layer,\n                       \"-E\", tmpchain, chain, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesRenameTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesRenameTmpRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRenameTmpRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRenameTmpRootChainFW(fw, layer, 'H', true, ifname);\n}"
  },
  {
    "function_name": "iptablesRenameTmpRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "739-763",
    "snippet": "static void\niptablesRenameTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             char prefix,\n                             bool incoming,\n                             const char *ifname)\n{\n    char tmpchain[MAX_CHAINNAME_LENGTH], chain[MAX_CHAINNAME_LENGTH];\n    char tmpChainPrefix[2] = {\n        prefix,\n        incoming ? CHAINPREFIX_HOST_IN_TEMP\n                 : CHAINPREFIX_HOST_OUT_TEMP\n    };\n    char chainPrefix[2] = {\n        prefix,\n        incoming ? CHAINPREFIX_HOST_IN\n                 : CHAINPREFIX_HOST_OUT\n    };\n\n    PRINT_IPT_ROOT_CHAIN(tmpchain, tmpChainPrefix, ifname);\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, layer,\n                       \"-E\", tmpchain, chain, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
      "#define CHAINPREFIX_HOST_OUT      'O'",
      "#define CHAINPREFIX_HOST_IN       'I'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "layer",
            "\"-E\"",
            "tmpchain",
            "chain",
            "NULL"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_IPT_ROOT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINT_IPT_ROOT_CHAIN",
          "args": [
            "tmpchain",
            "tmpChainPrefix",
            "ifname"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesRenameTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             char prefix,\n                             bool incoming,\n                             const char *ifname)\n{\n    char tmpchain[MAX_CHAINNAME_LENGTH], chain[MAX_CHAINNAME_LENGTH];\n    char tmpChainPrefix[2] = {\n        prefix,\n        incoming ? CHAINPREFIX_HOST_IN_TEMP\n                 : CHAINPREFIX_HOST_OUT_TEMP\n    };\n    char chainPrefix[2] = {\n        prefix,\n        incoming ? CHAINPREFIX_HOST_IN\n                 : CHAINPREFIX_HOST_OUT\n    };\n\n    PRINT_IPT_ROOT_CHAIN(tmpchain, tmpChainPrefix, ifname);\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, layer,\n                       \"-E\", tmpchain, chain, NULL);\n}"
  },
  {
    "function_name": "iptablesUnlinkTmpRootChainsFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "728-736",
    "snippet": "static void\niptablesUnlinkTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesUnlinkTmpRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesUnlinkTmpRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesUnlinkTmpRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define HOST_IN_CHAIN      \"libvirt-host-in\"",
      "#define VIRT_OUT_CHAIN     \"libvirt-out\"",
      "#define VIRT_IN_CHAIN      \"libvirt-in\""
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesUnlinkTmpRootChainFW",
          "args": [
            "fw",
            "layer",
            "HOST_IN_CHAIN",
            "'H'",
            "true",
            "ifname"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesUnlinkTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "705-714",
          "snippet": "static void\niptablesUnlinkTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             const char *basechain,\n                             char prefix,\n                             bool incoming, const char *ifname)\n{\n    _iptablesUnlinkRootChainFW(fw, layer,\n                               basechain, prefix, incoming, ifname, 1);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesUnlinkTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             const char *basechain,\n                             char prefix,\n                             bool incoming, const char *ifname)\n{\n    _iptablesUnlinkRootChainFW(fw, layer,\n                               basechain, prefix, incoming, ifname, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define HOST_IN_CHAIN      \"libvirt-host-in\"\n#define VIRT_OUT_CHAIN     \"libvirt-out\"\n#define VIRT_IN_CHAIN      \"libvirt-in\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesUnlinkTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesUnlinkTmpRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesUnlinkTmpRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesUnlinkTmpRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}"
  },
  {
    "function_name": "iptablesUnlinkRootChainsFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "717-725",
    "snippet": "static void\niptablesUnlinkRootChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *ifname)\n{\n    iptablesUnlinkRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesUnlinkRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesUnlinkRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define HOST_IN_CHAIN      \"libvirt-host-in\"",
      "#define VIRT_OUT_CHAIN     \"libvirt-out\"",
      "#define VIRT_IN_CHAIN      \"libvirt-in\""
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesUnlinkRootChainFW",
          "args": [
            "fw",
            "layer",
            "HOST_IN_CHAIN",
            "'H'",
            "true",
            "ifname"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesUnlinkRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "693-702",
          "snippet": "static void\niptablesUnlinkRootChainFW(virFirewallPtr fw,\n                          virFirewallLayer layer,\n                          const char *basechain,\n                          char prefix,\n                          bool incoming, const char *ifname)\n{\n    _iptablesUnlinkRootChainFW(fw, layer,\n                               basechain, prefix, incoming, ifname, false);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesUnlinkRootChainFW(virFirewallPtr fw,\n                          virFirewallLayer layer,\n                          const char *basechain,\n                          char prefix,\n                          bool incoming, const char *ifname)\n{\n    _iptablesUnlinkRootChainFW(fw, layer,\n                               basechain, prefix, incoming, ifname, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define HOST_IN_CHAIN      \"libvirt-host-in\"\n#define VIRT_OUT_CHAIN     \"libvirt-out\"\n#define VIRT_IN_CHAIN      \"libvirt-in\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesUnlinkRootChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *ifname)\n{\n    iptablesUnlinkRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesUnlinkRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesUnlinkRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}"
  },
  {
    "function_name": "iptablesUnlinkTmpRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "705-714",
    "snippet": "static void\niptablesUnlinkTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             const char *basechain,\n                             char prefix,\n                             bool incoming, const char *ifname)\n{\n    _iptablesUnlinkRootChainFW(fw, layer,\n                               basechain, prefix, incoming, ifname, 1);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_iptablesUnlinkRootChainFW",
          "args": [
            "fw",
            "layer",
            "basechain",
            "prefix",
            "incoming",
            "ifname",
            "1"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "_iptablesUnlinkRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "642-690",
          "snippet": "static void\n_iptablesUnlinkRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *basechain,\n                           char prefix,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n    };\n    if (isTempChain)\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    if (incoming)\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_IN_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n    else\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_OUT_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n\n    /*\n     * Previous versions of libvirt may have created a rule\n     * with the --physdev-is-bridged missing. Remove this one\n     * as well.\n     */\n    if (!incoming)\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_OUT_OLD_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MATCH_PHYSDEV_OUT_OLD_FW  \"-m\", \"physdev\", \"--physdev-out\"",
            "#define MATCH_PHYSDEV_OUT_FW  \"-m\", \"physdev\", \"--physdev-is-bridged\", \"--physdev-out\"",
            "#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"",
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
            "#define CHAINPREFIX_HOST_OUT      'O'",
            "#define CHAINPREFIX_HOST_IN       'I'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define MATCH_PHYSDEV_OUT_OLD_FW  \"-m\", \"physdev\", \"--physdev-out\"\n#define MATCH_PHYSDEV_OUT_FW  \"-m\", \"physdev\", \"--physdev-is-bridged\", \"--physdev-out\"\n#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_iptablesUnlinkRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *basechain,\n                           char prefix,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n    };\n    if (isTempChain)\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    if (incoming)\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_IN_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n    else\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_OUT_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n\n    /*\n     * Previous versions of libvirt may have created a rule\n     * with the --physdev-is-bridged missing. Remove this one\n     * as well.\n     */\n    if (!incoming)\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_OUT_OLD_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesUnlinkTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             const char *basechain,\n                             char prefix,\n                             bool incoming, const char *ifname)\n{\n    _iptablesUnlinkRootChainFW(fw, layer,\n                               basechain, prefix, incoming, ifname, 1);\n}"
  },
  {
    "function_name": "iptablesUnlinkRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "693-702",
    "snippet": "static void\niptablesUnlinkRootChainFW(virFirewallPtr fw,\n                          virFirewallLayer layer,\n                          const char *basechain,\n                          char prefix,\n                          bool incoming, const char *ifname)\n{\n    _iptablesUnlinkRootChainFW(fw, layer,\n                               basechain, prefix, incoming, ifname, false);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_iptablesUnlinkRootChainFW",
          "args": [
            "fw",
            "layer",
            "basechain",
            "prefix",
            "incoming",
            "ifname",
            "false"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "_iptablesUnlinkRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "642-690",
          "snippet": "static void\n_iptablesUnlinkRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *basechain,\n                           char prefix,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n    };\n    if (isTempChain)\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    if (incoming)\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_IN_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n    else\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_OUT_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n\n    /*\n     * Previous versions of libvirt may have created a rule\n     * with the --physdev-is-bridged missing. Remove this one\n     * as well.\n     */\n    if (!incoming)\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_OUT_OLD_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MATCH_PHYSDEV_OUT_OLD_FW  \"-m\", \"physdev\", \"--physdev-out\"",
            "#define MATCH_PHYSDEV_OUT_FW  \"-m\", \"physdev\", \"--physdev-is-bridged\", \"--physdev-out\"",
            "#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"",
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
            "#define CHAINPREFIX_HOST_OUT      'O'",
            "#define CHAINPREFIX_HOST_IN       'I'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define MATCH_PHYSDEV_OUT_OLD_FW  \"-m\", \"physdev\", \"--physdev-out\"\n#define MATCH_PHYSDEV_OUT_FW  \"-m\", \"physdev\", \"--physdev-is-bridged\", \"--physdev-out\"\n#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_iptablesUnlinkRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *basechain,\n                           char prefix,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n    };\n    if (isTempChain)\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    if (incoming)\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_IN_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n    else\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_OUT_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n\n    /*\n     * Previous versions of libvirt may have created a rule\n     * with the --physdev-is-bridged missing. Remove this one\n     * as well.\n     */\n    if (!incoming)\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_OUT_OLD_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesUnlinkRootChainFW(virFirewallPtr fw,\n                          virFirewallLayer layer,\n                          const char *basechain,\n                          char prefix,\n                          bool incoming, const char *ifname)\n{\n    _iptablesUnlinkRootChainFW(fw, layer,\n                               basechain, prefix, incoming, ifname, false);\n}"
  },
  {
    "function_name": "_iptablesUnlinkRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "642-690",
    "snippet": "static void\n_iptablesUnlinkRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *basechain,\n                           char prefix,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n    };\n    if (isTempChain)\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    if (incoming)\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_IN_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n    else\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_OUT_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n\n    /*\n     * Previous versions of libvirt may have created a rule\n     * with the --physdev-is-bridged missing. Remove this one\n     * as well.\n     */\n    if (!incoming)\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_OUT_OLD_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define MATCH_PHYSDEV_OUT_OLD_FW  \"-m\", \"physdev\", \"--physdev-out\"",
      "#define MATCH_PHYSDEV_OUT_FW  \"-m\", \"physdev\", \"--physdev-is-bridged\", \"--physdev-out\"",
      "#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"",
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
      "#define CHAINPREFIX_HOST_OUT      'O'",
      "#define CHAINPREFIX_HOST_IN       'I'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRuleFull",
          "args": [
            "fw",
            "layer",
            "true",
            "NULL",
            "NULL",
            "\"-D\"",
            "basechain",
            "MATCH_PHYSDEV_OUT_OLD_FW",
            "ifname",
            "\"-g\"",
            "chain",
            "NULL"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_IPT_ROOT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define MATCH_PHYSDEV_OUT_OLD_FW  \"-m\", \"physdev\", \"--physdev-out\"\n#define MATCH_PHYSDEV_OUT_FW  \"-m\", \"physdev\", \"--physdev-is-bridged\", \"--physdev-out\"\n#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_iptablesUnlinkRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *basechain,\n                           char prefix,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n    };\n    if (isTempChain)\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    if (incoming)\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_IN_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n    else\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_OUT_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n\n    /*\n     * Previous versions of libvirt may have created a rule\n     * with the --physdev-is-bridged missing. Remove this one\n     * as well.\n     */\n    if (!incoming)\n        virFirewallAddRuleFull(fw, layer,\n                               true, NULL, NULL,\n                               \"-D\", basechain,\n                               MATCH_PHYSDEV_OUT_OLD_FW, ifname,\n                               \"-g\", chain,\n                               NULL);\n}"
  },
  {
    "function_name": "iptablesClearVirtInPostFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "629-639",
    "snippet": "static void\niptablesClearVirtInPostFW(virFirewallPtr fw,\n                          virFirewallLayer layer,\n                          const char *ifname)\n{\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", VIRT_IN_POST_CHAIN,\n                           MATCH_PHYSDEV_IN_FW,\n                           ifname, \"-j\", \"ACCEPT\", NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"",
      "#define VIRT_IN_POST_CHAIN \"libvirt-in-post\""
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRuleFull",
          "args": [
            "fw",
            "layer",
            "true",
            "NULL",
            "NULL",
            "\"-D\"",
            "VIRT_IN_POST_CHAIN",
            "MATCH_PHYSDEV_IN_FW",
            "ifname",
            "\"-j\"",
            "\"ACCEPT\"",
            "NULL"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"\n#define VIRT_IN_POST_CHAIN \"libvirt-in-post\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesClearVirtInPostFW(virFirewallPtr fw,\n                          virFirewallLayer layer,\n                          const char *ifname)\n{\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", VIRT_IN_POST_CHAIN,\n                           MATCH_PHYSDEV_IN_FW,\n                           ifname, \"-j\", \"ACCEPT\", NULL);\n}"
  },
  {
    "function_name": "iptablesSetupVirtInPostFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "612-626",
    "snippet": "static void\niptablesSetupVirtInPostFW(virFirewallPtr fw G_GNUC_UNUSED,\n                          virFirewallLayer layer G_GNUC_UNUSED,\n                          const char *ifname G_GNUC_UNUSED)\n{\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", VIRT_IN_POST_CHAIN,\n                           MATCH_PHYSDEV_IN_FW,\n                           ifname, \"-j\", \"ACCEPT\", NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-A\", VIRT_IN_POST_CHAIN,\n                       MATCH_PHYSDEV_IN_FW,\n                       ifname, \"-j\", \"ACCEPT\", NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"",
      "#define VIRT_IN_POST_CHAIN \"libvirt-in-post\""
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "layer",
            "\"-A\"",
            "VIRT_IN_POST_CHAIN",
            "MATCH_PHYSDEV_IN_FW",
            "ifname",
            "\"-j\"",
            "\"ACCEPT\"",
            "NULL"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"\n#define VIRT_IN_POST_CHAIN \"libvirt-in-post\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesSetupVirtInPostFW(virFirewallPtr fw G_GNUC_UNUSED,\n                          virFirewallLayer layer G_GNUC_UNUSED,\n                          const char *ifname G_GNUC_UNUSED)\n{\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", VIRT_IN_POST_CHAIN,\n                           MATCH_PHYSDEV_IN_FW,\n                           ifname, \"-j\", \"ACCEPT\", NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-A\", VIRT_IN_POST_CHAIN,\n                       MATCH_PHYSDEV_IN_FW,\n                       ifname, \"-j\", \"ACCEPT\", NULL);\n}"
  },
  {
    "function_name": "iptablesLinkTmpRootChainsFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "601-609",
    "snippet": "static void\niptablesLinkTmpRootChainsFW(virFirewallPtr fw,\n                            virFirewallLayer layer,\n                            const char *ifname)\n{\n    iptablesLinkTmpRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesLinkTmpRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesLinkTmpRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define HOST_IN_CHAIN      \"libvirt-host-in\"",
      "#define VIRT_OUT_CHAIN     \"libvirt-out\"",
      "#define VIRT_IN_CHAIN      \"libvirt-in\""
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesLinkTmpRootChainFW",
          "args": [
            "fw",
            "layer",
            "HOST_IN_CHAIN",
            "'H'",
            "true",
            "ifname"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesLinkTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "570-598",
          "snippet": "static void\niptablesLinkTmpRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *basechain,\n                           char prefix,\n                           bool incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n        incoming ? CHAINPREFIX_HOST_IN_TEMP\n                 : CHAINPREFIX_HOST_OUT_TEMP\n    };\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    if (incoming)\n        virFirewallAddRule(fw, layer,\n                           \"-A\", basechain,\n                           MATCH_PHYSDEV_IN_FW,\n                           ifname,\n                           \"-g\", chain, NULL);\n    else\n        virFirewallAddRule(fw, layer,\n                           \"-A\", basechain,\n                           MATCH_PHYSDEV_OUT_FW,\n                           ifname,\n                           \"-g\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MATCH_PHYSDEV_OUT_FW  \"-m\", \"physdev\", \"--physdev-is-bridged\", \"--physdev-out\"",
            "#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"",
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define MATCH_PHYSDEV_OUT_FW  \"-m\", \"physdev\", \"--physdev-is-bridged\", \"--physdev-out\"\n#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesLinkTmpRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *basechain,\n                           char prefix,\n                           bool incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n        incoming ? CHAINPREFIX_HOST_IN_TEMP\n                 : CHAINPREFIX_HOST_OUT_TEMP\n    };\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    if (incoming)\n        virFirewallAddRule(fw, layer,\n                           \"-A\", basechain,\n                           MATCH_PHYSDEV_IN_FW,\n                           ifname,\n                           \"-g\", chain, NULL);\n    else\n        virFirewallAddRule(fw, layer,\n                           \"-A\", basechain,\n                           MATCH_PHYSDEV_OUT_FW,\n                           ifname,\n                           \"-g\", chain, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define HOST_IN_CHAIN      \"libvirt-host-in\"\n#define VIRT_OUT_CHAIN     \"libvirt-out\"\n#define VIRT_IN_CHAIN      \"libvirt-in\"\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesLinkTmpRootChainsFW(virFirewallPtr fw,\n                            virFirewallLayer layer,\n                            const char *ifname)\n{\n    iptablesLinkTmpRootChainFW(fw, layer, VIRT_OUT_CHAIN, 'F', false, ifname);\n    iptablesLinkTmpRootChainFW(fw, layer, VIRT_IN_CHAIN,  'F', true, ifname);\n    iptablesLinkTmpRootChainFW(fw, layer, HOST_IN_CHAIN,  'H', true, ifname);\n}"
  },
  {
    "function_name": "iptablesLinkTmpRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "570-598",
    "snippet": "static void\niptablesLinkTmpRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *basechain,\n                           char prefix,\n                           bool incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n        incoming ? CHAINPREFIX_HOST_IN_TEMP\n                 : CHAINPREFIX_HOST_OUT_TEMP\n    };\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    if (incoming)\n        virFirewallAddRule(fw, layer,\n                           \"-A\", basechain,\n                           MATCH_PHYSDEV_IN_FW,\n                           ifname,\n                           \"-g\", chain, NULL);\n    else\n        virFirewallAddRule(fw, layer,\n                           \"-A\", basechain,\n                           MATCH_PHYSDEV_OUT_FW,\n                           ifname,\n                           \"-g\", chain, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define MATCH_PHYSDEV_OUT_FW  \"-m\", \"physdev\", \"--physdev-is-bridged\", \"--physdev-out\"",
      "#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"",
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "layer",
            "\"-A\"",
            "basechain",
            "MATCH_PHYSDEV_OUT_FW",
            "ifname",
            "\"-g\"",
            "chain",
            "NULL"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_IPT_ROOT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define MATCH_PHYSDEV_OUT_FW  \"-m\", \"physdev\", \"--physdev-is-bridged\", \"--physdev-out\"\n#define MATCH_PHYSDEV_IN_FW   \"-m\", \"physdev\", \"--physdev-in\"\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesLinkTmpRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *basechain,\n                           char prefix,\n                           bool incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n        incoming ? CHAINPREFIX_HOST_IN_TEMP\n                 : CHAINPREFIX_HOST_OUT_TEMP\n    };\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    if (incoming)\n        virFirewallAddRule(fw, layer,\n                           \"-A\", basechain,\n                           MATCH_PHYSDEV_IN_FW,\n                           ifname,\n                           \"-g\", chain, NULL);\n    else\n        virFirewallAddRule(fw, layer,\n                           \"-A\", basechain,\n                           MATCH_PHYSDEV_OUT_FW,\n                           ifname,\n                           \"-g\", chain, NULL);\n}"
  },
  {
    "function_name": "iptablesRemoveRootChainsFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "559-567",
    "snippet": "static void\niptablesRemoveRootChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *ifname)\n{\n    iptablesRemoveRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRemoveRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRemoveRootChainFW(fw, layer, 'H', true, ifname);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesRemoveRootChainFW",
          "args": [
            "fw",
            "layer",
            "'H'",
            "true",
            "ifname"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "525-533",
          "snippet": "static void\niptablesRemoveRootChainFW(virFirewallPtr fw,\n                          virFirewallLayer layer,\n                          char prefix,\n                          bool incoming,\n                          const char *ifname)\n{\n    _iptablesRemoveRootChainFW(fw, layer, prefix, incoming, ifname, false);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesRemoveRootChainFW(virFirewallPtr fw,\n                          virFirewallLayer layer,\n                          char prefix,\n                          bool incoming,\n                          const char *ifname)\n{\n    _iptablesRemoveRootChainFW(fw, layer, prefix, incoming, ifname, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesRemoveRootChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           const char *ifname)\n{\n    iptablesRemoveRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRemoveRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRemoveRootChainFW(fw, layer, 'H', true, ifname);\n}"
  },
  {
    "function_name": "iptablesRemoveTmpRootChainsFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "548-556",
    "snippet": "static void\niptablesRemoveTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesRemoveTmpRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRemoveTmpRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRemoveTmpRootChainFW(fw, layer, 'H', true, ifname);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesRemoveTmpRootChainFW",
          "args": [
            "fw",
            "layer",
            "'H'",
            "true",
            "ifname"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesRemoveTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "536-545",
          "snippet": "static void\niptablesRemoveTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             char prefix,\n                             bool incoming,\n                             const char *ifname)\n{\n    _iptablesRemoveRootChainFW(fw, layer, prefix,\n                               incoming, ifname, 1);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesRemoveTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             char prefix,\n                             bool incoming,\n                             const char *ifname)\n{\n    _iptablesRemoveRootChainFW(fw, layer, prefix,\n                               incoming, ifname, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesRemoveTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesRemoveTmpRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesRemoveTmpRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesRemoveTmpRootChainFW(fw, layer, 'H', true, ifname);\n}"
  },
  {
    "function_name": "iptablesRemoveTmpRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "536-545",
    "snippet": "static void\niptablesRemoveTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             char prefix,\n                             bool incoming,\n                             const char *ifname)\n{\n    _iptablesRemoveRootChainFW(fw, layer, prefix,\n                               incoming, ifname, 1);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_iptablesRemoveRootChainFW",
          "args": [
            "fw",
            "layer",
            "prefix",
            "incoming",
            "ifname",
            "1"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "_iptablesRemoveRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "495-522",
          "snippet": "static void\n_iptablesRemoveRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           char prefix,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n    };\n\n    if (isTempChain)\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-X\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
            "#define CHAINPREFIX_HOST_OUT      'O'",
            "#define CHAINPREFIX_HOST_IN       'I'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_iptablesRemoveRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           char prefix,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n    };\n\n    if (isTempChain)\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-X\", chain, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesRemoveTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             char prefix,\n                             bool incoming,\n                             const char *ifname)\n{\n    _iptablesRemoveRootChainFW(fw, layer, prefix,\n                               incoming, ifname, 1);\n}"
  },
  {
    "function_name": "iptablesRemoveRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "525-533",
    "snippet": "static void\niptablesRemoveRootChainFW(virFirewallPtr fw,\n                          virFirewallLayer layer,\n                          char prefix,\n                          bool incoming,\n                          const char *ifname)\n{\n    _iptablesRemoveRootChainFW(fw, layer, prefix, incoming, ifname, false);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_iptablesRemoveRootChainFW",
          "args": [
            "fw",
            "layer",
            "prefix",
            "incoming",
            "ifname",
            "false"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "_iptablesRemoveRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "495-522",
          "snippet": "static void\n_iptablesRemoveRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           char prefix,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n    };\n\n    if (isTempChain)\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-X\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
            "#define CHAINPREFIX_HOST_OUT      'O'",
            "#define CHAINPREFIX_HOST_IN       'I'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_iptablesRemoveRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           char prefix,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n    };\n\n    if (isTempChain)\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-X\", chain, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesRemoveRootChainFW(virFirewallPtr fw,\n                          virFirewallLayer layer,\n                          char prefix,\n                          bool incoming,\n                          const char *ifname)\n{\n    _iptablesRemoveRootChainFW(fw, layer, prefix, incoming, ifname, false);\n}"
  },
  {
    "function_name": "_iptablesRemoveRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "495-522",
    "snippet": "static void\n_iptablesRemoveRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           char prefix,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n    };\n\n    if (isTempChain)\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-X\", chain, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'",
      "#define CHAINPREFIX_HOST_OUT      'O'",
      "#define CHAINPREFIX_HOST_IN       'I'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRuleFull",
          "args": [
            "fw",
            "layer",
            "true",
            "NULL",
            "NULL",
            "\"-X\"",
            "chain",
            "NULL"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_IPT_ROOT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n#define CHAINPREFIX_HOST_OUT      'O'\n#define CHAINPREFIX_HOST_IN       'I'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\n_iptablesRemoveRootChainFW(virFirewallPtr fw,\n                           virFirewallLayer layer,\n                           char prefix,\n                           bool incoming, const char *ifname,\n                           int isTempChain)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n        prefix,\n    };\n\n    if (isTempChain)\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN_TEMP\n                                  : CHAINPREFIX_HOST_OUT_TEMP;\n    else\n        chainPrefix[1] = incoming ? CHAINPREFIX_HOST_IN\n                                  : CHAINPREFIX_HOST_OUT;\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-F\", chain, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-X\", chain, NULL);\n}"
  },
  {
    "function_name": "iptablesCreateTmpRootChainsFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "484-492",
    "snippet": "static void\niptablesCreateTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesCreateTmpRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesCreateTmpRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesCreateTmpRootChainFW(fw, layer, 'H', true, ifname);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iptablesCreateTmpRootChainFW",
          "args": [
            "fw",
            "layer",
            "'H'",
            "true",
            "ifname"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "iptablesCreateTmpRootChainFW",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "464-481",
          "snippet": "static void\niptablesCreateTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             char prefix,\n                             bool incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n       prefix,\n       incoming ? CHAINPREFIX_HOST_IN_TEMP\n                : CHAINPREFIX_HOST_OUT_TEMP\n    };\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, layer,\n                       \"-N\", chain, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
            "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
          ],
          "globals_used": [
            "static int ebtablesRemoveBasicRules(const char *ifname);",
            "static int ebtablesCleanAll(const char *ifname);",
            "static int ebiptablesAllTeardown(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesCreateTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             char prefix,\n                             bool incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n       prefix,\n       incoming ? CHAINPREFIX_HOST_IN_TEMP\n                : CHAINPREFIX_HOST_OUT_TEMP\n    };\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, layer,\n                       \"-N\", chain, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesCreateTmpRootChainsFW(virFirewallPtr fw,\n                              virFirewallLayer layer,\n                              const char *ifname)\n{\n    iptablesCreateTmpRootChainFW(fw, layer, 'F', false, ifname);\n    iptablesCreateTmpRootChainFW(fw, layer, 'F', true, ifname);\n    iptablesCreateTmpRootChainFW(fw, layer, 'H', true, ifname);\n}"
  },
  {
    "function_name": "iptablesCreateTmpRootChainFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "464-481",
    "snippet": "static void\niptablesCreateTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             char prefix,\n                             bool incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n       prefix,\n       incoming ? CHAINPREFIX_HOST_IN_TEMP\n                : CHAINPREFIX_HOST_OUT_TEMP\n    };\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, layer,\n                       \"-N\", chain, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define CHAINPREFIX_HOST_OUT_TEMP 'P'",
      "#define CHAINPREFIX_HOST_IN_TEMP  'J'"
    ],
    "globals_used": [
      "static int ebtablesRemoveBasicRules(const char *ifname);",
      "static int ebtablesCleanAll(const char *ifname);",
      "static int ebiptablesAllTeardown(const char *ifname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "layer",
            "\"-N\"",
            "chain",
            "NULL"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINT_IPT_ROOT_CHAIN",
          "args": [
            "chain",
            "chainPrefix",
            "ifname"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define CHAINPREFIX_HOST_OUT_TEMP 'P'\n#define CHAINPREFIX_HOST_IN_TEMP  'J'\n\nstatic int ebtablesRemoveBasicRules(const char *ifname);\nstatic int ebtablesCleanAll(const char *ifname);\nstatic int ebiptablesAllTeardown(const char *ifname);\n\nstatic void\niptablesCreateTmpRootChainFW(virFirewallPtr fw,\n                             virFirewallLayer layer,\n                             char prefix,\n                             bool incoming, const char *ifname)\n{\n    char chain[MAX_CHAINNAME_LENGTH];\n    char chainPrefix[2] = {\n       prefix,\n       incoming ? CHAINPREFIX_HOST_IN_TEMP\n                : CHAINPREFIX_HOST_OUT_TEMP\n    };\n\n    PRINT_IPT_ROOT_CHAIN(chain, chainPrefix, ifname);\n\n    virFirewallAddRule(fw, layer,\n                       \"-N\", chain, NULL);\n}"
  },
  {
    "function_name": "iptablesCreateBaseChainsFW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "425-461",
    "snippet": "static void\niptablesCreateBaseChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer)\n{\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", VIRT_IN_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", VIRT_OUT_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", VIRT_IN_POST_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", HOST_IN_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"FORWARD\", \"-j\", VIRT_IN_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"FORWARD\", \"-j\", VIRT_OUT_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"FORWARD\", \"-j\", VIRT_IN_POST_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"INPUT\", \"-j\", HOST_IN_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"FORWARD\", \"1\", \"-j\", VIRT_IN_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"FORWARD\", \"2\", \"-j\", VIRT_OUT_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"FORWARD\", \"3\", \"-j\", VIRT_IN_POST_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"INPUT\", \"1\", \"-j\", HOST_IN_CHAIN, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define HOST_IN_CHAIN      \"libvirt-host-in\"",
      "#define VIRT_IN_POST_CHAIN \"libvirt-in-post\"",
      "#define VIRT_OUT_CHAIN     \"libvirt-out\"",
      "#define VIRT_IN_CHAIN      \"libvirt-in\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallAddRule",
          "args": [
            "fw",
            "layer",
            "\"-I\"",
            "\"INPUT\"",
            "\"1\"",
            "\"-j\"",
            "HOST_IN_CHAIN",
            "NULL"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "421-434",
          "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\n#define HOST_IN_CHAIN      \"libvirt-host-in\"\n#define VIRT_IN_POST_CHAIN \"libvirt-in-post\"\n#define VIRT_OUT_CHAIN     \"libvirt-out\"\n#define VIRT_IN_CHAIN      \"libvirt-in\"\n\nstatic void\niptablesCreateBaseChainsFW(virFirewallPtr fw,\n                           virFirewallLayer layer)\n{\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", VIRT_IN_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", VIRT_OUT_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", VIRT_IN_POST_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-N\", HOST_IN_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"FORWARD\", \"-j\", VIRT_IN_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"FORWARD\", \"-j\", VIRT_OUT_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"FORWARD\", \"-j\", VIRT_IN_POST_CHAIN, NULL);\n    virFirewallAddRuleFull(fw, layer,\n                           true, NULL, NULL,\n                           \"-D\", \"INPUT\", \"-j\", HOST_IN_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"FORWARD\", \"1\", \"-j\", VIRT_IN_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"FORWARD\", \"2\", \"-j\", VIRT_OUT_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"FORWARD\", \"3\", \"-j\", VIRT_IN_POST_CHAIN, NULL);\n    virFirewallAddRule(fw, layer,\n                       \"-I\", \"INPUT\", \"1\", \"-j\", HOST_IN_CHAIN, NULL);\n}"
  },
  {
    "function_name": "ebtablesHandleEthHdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "358-419",
    "snippet": "static int\nebtablesHandleEthHdr(virFirewallPtr fw,\n                     virFirewallRulePtr fwrule,\n                     virNWFilterVarCombIterPtr vars,\n                     ethHdrDataDefPtr ethHdr,\n                     bool reverse)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n    char macmask[VIR_MAC_STRING_BUFLEN];\n\n    if (HAS_ENTRY_ITEM(&ethHdr->dataSrcMACAddr)) {\n        if (printDataType(vars,\n                          macaddr, sizeof(macaddr),\n                          &ethHdr->dataSrcMACAddr) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  reverse ? \"-d\" : \"-s\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ethHdr->dataSrcMACAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n        if (HAS_ENTRY_ITEM(&ethHdr->dataSrcMACMask)) {\n            if (printDataType(vars,\n                              macmask, sizeof(macmask),\n                              &ethHdr->dataSrcMACMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", macaddr, macmask);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ethHdr->dataDstMACAddr)) {\n        if (printDataType(vars,\n                          macaddr, sizeof(macaddr),\n                          &ethHdr->dataDstMACAddr) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  reverse ? \"-s\" : \"-d\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ethHdr->dataDstMACAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n        if (HAS_ENTRY_ITEM(&ethHdr->dataDstMACMask)) {\n            if (printDataType(vars,\n                              macmask, sizeof(macmask),\n                              &ethHdr->dataDstMACMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", macaddr, macmask);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallRuleAddArg",
          "args": [
            "fw",
            "fwrule",
            "macaddr"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "541-562",
          "snippet": "void virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallRuleAddArgFormat",
          "args": [
            "fw",
            "fwrule",
            "\"%s/%s\"",
            "macaddr",
            "macmask"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "501-520",
          "snippet": "void virFirewallRuleAddArgFormat(virFirewallPtr firewall,\n                                 virFirewallRulePtr rule,\n                                 const char *fmt, ...)\n{\n    g_autofree char *arg = NULL;\n    va_list list;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, fmt);\n    arg = g_strdup_vprintf(fmt, list);\n    va_end(list);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgFormat(virFirewallPtr firewall,\n                                 virFirewallRulePtr rule,\n                                 const char *fmt, ...)\n{\n    g_autofree char *arg = NULL;\n    va_list list;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, fmt);\n    arg = g_strdup_vprintf(fmt, list);\n    va_end(list);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printDataType",
          "args": [
            "vars",
            "macmask",
            "sizeof(macmask)",
            "&ethHdr->dataDstMACMask"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "printDataTypeAsHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "349-355",
          "snippet": "static int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ethHdr->dataDstMACMask"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&ethHdr->dataDstMACAddr"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ethHdr->dataDstMACAddr"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ethHdr->dataSrcMACMask"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY_WANT_NEG_SIGN",
          "args": [
            "&ethHdr->dataSrcMACAddr"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_ENTRY_ITEM",
          "args": [
            "&ethHdr->dataSrcMACAddr"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nebtablesHandleEthHdr(virFirewallPtr fw,\n                     virFirewallRulePtr fwrule,\n                     virNWFilterVarCombIterPtr vars,\n                     ethHdrDataDefPtr ethHdr,\n                     bool reverse)\n{\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n    char macmask[VIR_MAC_STRING_BUFLEN];\n\n    if (HAS_ENTRY_ITEM(&ethHdr->dataSrcMACAddr)) {\n        if (printDataType(vars,\n                          macaddr, sizeof(macaddr),\n                          &ethHdr->dataSrcMACAddr) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  reverse ? \"-d\" : \"-s\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ethHdr->dataSrcMACAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n        if (HAS_ENTRY_ITEM(&ethHdr->dataSrcMACMask)) {\n            if (printDataType(vars,\n                              macmask, sizeof(macmask),\n                              &ethHdr->dataSrcMACMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", macaddr, macmask);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n    }\n\n    if (HAS_ENTRY_ITEM(&ethHdr->dataDstMACAddr)) {\n        if (printDataType(vars,\n                          macaddr, sizeof(macaddr),\n                          &ethHdr->dataDstMACAddr) < 0)\n            return -1;\n\n        virFirewallRuleAddArgList(fw, fwrule,\n                                  reverse ? \"-s\" : \"-d\",\n                                  NULL);\n        if (ENTRY_WANT_NEG_SIGN(&ethHdr->dataDstMACAddr))\n            virFirewallRuleAddArg(fw, fwrule, \"!\");\n\n        if (HAS_ENTRY_ITEM(&ethHdr->dataDstMACMask)) {\n            if (printDataType(vars,\n                              macmask, sizeof(macmask),\n                              &ethHdr->dataDstMACMask) < 0)\n                return -1;\n\n            virFirewallRuleAddArgFormat(fw, fwrule,\n                                        \"%s/%s\", macaddr, macmask);\n        } else {\n            virFirewallRuleAddArg(fw, fwrule, macaddr);\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "printDataTypeAsHex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "349-355",
    "snippet": "static int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_printDataType",
          "args": [
            "vars",
            "buf",
            "bufsize",
            "item",
            "1",
            "0"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "_printDataType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "184-330",
          "snippet": "static int\n_printDataType(virNWFilterVarCombIterPtr vars,\n               char *buf, int bufsize,\n               nwItemDescPtr item,\n               bool asHex, bool directionIn)\n{\n    bool done;\n    char *data;\n    uint8_t ctr;\n    virBuffer vb = VIR_BUFFER_INITIALIZER;\n    char *flags;\n\n    if (printVar(vars, buf, bufsize, item, &done) < 0)\n        return -1;\n\n    if (done)\n        return 0;\n\n    switch (item->datatype) {\n    case DATATYPE_IPADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IP address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_IPV6ADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IPv6 address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_MACADDR:\n    case DATATYPE_MACMASK:\n        if (bufsize < VIR_MAC_STRING_BUFLEN) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for MAC address\"));\n            return -1;\n        }\n\n        virMacAddrFormat(&item->u.macaddr, buf);\n    break;\n\n    case DATATYPE_IPV6MASK:\n    case DATATYPE_IPMASK:\n        if (g_snprintf(buf, bufsize, \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT32:\n    case DATATYPE_UINT32_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%u\",\n                       item->u.u32) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint32 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT16:\n    case DATATYPE_UINT16_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u16) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint16 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT8:\n    case DATATYPE_UINT8_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETNAME:\n        if (virStrcpy(buf, item->u.ipset.setname, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer to small for ipset name\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETFLAGS:\n        for (ctr = 0; ctr < item->u.ipset.numFlags; ctr++) {\n            if (ctr != 0)\n                virBufferAddLit(&vb, \",\");\n            if ((item->u.ipset.flags & (1 << ctr))) {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"dst\");\n                else\n                    virBufferAddLit(&vb, \"src\");\n            } else {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"src\");\n                else\n                    virBufferAddLit(&vb, \"dst\");\n            }\n        }\n\n        flags = virBufferContentAndReset(&vb);\n\n        if (virStrcpy(buf, flags, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for IPSETFLAGS type\"));\n            VIR_FREE(flags);\n            return -1;\n        }\n        VIR_FREE(flags);\n    break;\n\n    case DATATYPE_STRING:\n    case DATATYPE_STRINGCOPY:\n    case DATATYPE_BOOLEAN:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot print data type %x\"), item->datatype);\n        return -1;\n    case DATATYPE_LAST:\n    default:\n        virReportEnumRangeError(virNWFilterAttrDataType, item->datatype);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\n_printDataType(virNWFilterVarCombIterPtr vars,\n               char *buf, int bufsize,\n               nwItemDescPtr item,\n               bool asHex, bool directionIn)\n{\n    bool done;\n    char *data;\n    uint8_t ctr;\n    virBuffer vb = VIR_BUFFER_INITIALIZER;\n    char *flags;\n\n    if (printVar(vars, buf, bufsize, item, &done) < 0)\n        return -1;\n\n    if (done)\n        return 0;\n\n    switch (item->datatype) {\n    case DATATYPE_IPADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IP address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_IPV6ADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IPv6 address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_MACADDR:\n    case DATATYPE_MACMASK:\n        if (bufsize < VIR_MAC_STRING_BUFLEN) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for MAC address\"));\n            return -1;\n        }\n\n        virMacAddrFormat(&item->u.macaddr, buf);\n    break;\n\n    case DATATYPE_IPV6MASK:\n    case DATATYPE_IPMASK:\n        if (g_snprintf(buf, bufsize, \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT32:\n    case DATATYPE_UINT32_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%u\",\n                       item->u.u32) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint32 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT16:\n    case DATATYPE_UINT16_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u16) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint16 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT8:\n    case DATATYPE_UINT8_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETNAME:\n        if (virStrcpy(buf, item->u.ipset.setname, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer to small for ipset name\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETFLAGS:\n        for (ctr = 0; ctr < item->u.ipset.numFlags; ctr++) {\n            if (ctr != 0)\n                virBufferAddLit(&vb, \",\");\n            if ((item->u.ipset.flags & (1 << ctr))) {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"dst\");\n                else\n                    virBufferAddLit(&vb, \"src\");\n            } else {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"src\");\n                else\n                    virBufferAddLit(&vb, \"dst\");\n            }\n        }\n\n        flags = virBufferContentAndReset(&vb);\n\n        if (virStrcpy(buf, flags, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for IPSETFLAGS type\"));\n            VIR_FREE(flags);\n            return -1;\n        }\n        VIR_FREE(flags);\n    break;\n\n    case DATATYPE_STRING:\n    case DATATYPE_STRINGCOPY:\n    case DATATYPE_BOOLEAN:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot print data type %x\"), item->datatype);\n        return -1;\n    case DATATYPE_LAST:\n    default:\n        virReportEnumRangeError(virNWFilterAttrDataType, item->datatype);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintDataTypeAsHex(virNWFilterVarCombIterPtr vars,\n                   char *buf, int bufsize,\n                   nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 1, 0);\n}"
  },
  {
    "function_name": "printDataTypeDirection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "341-347",
    "snippet": "static int\nprintDataTypeDirection(virNWFilterVarCombIterPtr vars,\n                       char *buf, int bufsize,\n                       nwItemDescPtr item, bool directionIn)\n{\n    return _printDataType(vars, buf, bufsize, item, 0, directionIn);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_printDataType",
          "args": [
            "vars",
            "buf",
            "bufsize",
            "item",
            "0",
            "directionIn"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "_printDataType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "184-330",
          "snippet": "static int\n_printDataType(virNWFilterVarCombIterPtr vars,\n               char *buf, int bufsize,\n               nwItemDescPtr item,\n               bool asHex, bool directionIn)\n{\n    bool done;\n    char *data;\n    uint8_t ctr;\n    virBuffer vb = VIR_BUFFER_INITIALIZER;\n    char *flags;\n\n    if (printVar(vars, buf, bufsize, item, &done) < 0)\n        return -1;\n\n    if (done)\n        return 0;\n\n    switch (item->datatype) {\n    case DATATYPE_IPADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IP address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_IPV6ADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IPv6 address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_MACADDR:\n    case DATATYPE_MACMASK:\n        if (bufsize < VIR_MAC_STRING_BUFLEN) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for MAC address\"));\n            return -1;\n        }\n\n        virMacAddrFormat(&item->u.macaddr, buf);\n    break;\n\n    case DATATYPE_IPV6MASK:\n    case DATATYPE_IPMASK:\n        if (g_snprintf(buf, bufsize, \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT32:\n    case DATATYPE_UINT32_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%u\",\n                       item->u.u32) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint32 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT16:\n    case DATATYPE_UINT16_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u16) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint16 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT8:\n    case DATATYPE_UINT8_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETNAME:\n        if (virStrcpy(buf, item->u.ipset.setname, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer to small for ipset name\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETFLAGS:\n        for (ctr = 0; ctr < item->u.ipset.numFlags; ctr++) {\n            if (ctr != 0)\n                virBufferAddLit(&vb, \",\");\n            if ((item->u.ipset.flags & (1 << ctr))) {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"dst\");\n                else\n                    virBufferAddLit(&vb, \"src\");\n            } else {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"src\");\n                else\n                    virBufferAddLit(&vb, \"dst\");\n            }\n        }\n\n        flags = virBufferContentAndReset(&vb);\n\n        if (virStrcpy(buf, flags, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for IPSETFLAGS type\"));\n            VIR_FREE(flags);\n            return -1;\n        }\n        VIR_FREE(flags);\n    break;\n\n    case DATATYPE_STRING:\n    case DATATYPE_STRINGCOPY:\n    case DATATYPE_BOOLEAN:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot print data type %x\"), item->datatype);\n        return -1;\n    case DATATYPE_LAST:\n    default:\n        virReportEnumRangeError(virNWFilterAttrDataType, item->datatype);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\n_printDataType(virNWFilterVarCombIterPtr vars,\n               char *buf, int bufsize,\n               nwItemDescPtr item,\n               bool asHex, bool directionIn)\n{\n    bool done;\n    char *data;\n    uint8_t ctr;\n    virBuffer vb = VIR_BUFFER_INITIALIZER;\n    char *flags;\n\n    if (printVar(vars, buf, bufsize, item, &done) < 0)\n        return -1;\n\n    if (done)\n        return 0;\n\n    switch (item->datatype) {\n    case DATATYPE_IPADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IP address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_IPV6ADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IPv6 address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_MACADDR:\n    case DATATYPE_MACMASK:\n        if (bufsize < VIR_MAC_STRING_BUFLEN) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for MAC address\"));\n            return -1;\n        }\n\n        virMacAddrFormat(&item->u.macaddr, buf);\n    break;\n\n    case DATATYPE_IPV6MASK:\n    case DATATYPE_IPMASK:\n        if (g_snprintf(buf, bufsize, \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT32:\n    case DATATYPE_UINT32_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%u\",\n                       item->u.u32) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint32 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT16:\n    case DATATYPE_UINT16_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u16) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint16 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT8:\n    case DATATYPE_UINT8_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETNAME:\n        if (virStrcpy(buf, item->u.ipset.setname, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer to small for ipset name\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETFLAGS:\n        for (ctr = 0; ctr < item->u.ipset.numFlags; ctr++) {\n            if (ctr != 0)\n                virBufferAddLit(&vb, \",\");\n            if ((item->u.ipset.flags & (1 << ctr))) {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"dst\");\n                else\n                    virBufferAddLit(&vb, \"src\");\n            } else {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"src\");\n                else\n                    virBufferAddLit(&vb, \"dst\");\n            }\n        }\n\n        flags = virBufferContentAndReset(&vb);\n\n        if (virStrcpy(buf, flags, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for IPSETFLAGS type\"));\n            VIR_FREE(flags);\n            return -1;\n        }\n        VIR_FREE(flags);\n    break;\n\n    case DATATYPE_STRING:\n    case DATATYPE_STRINGCOPY:\n    case DATATYPE_BOOLEAN:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot print data type %x\"), item->datatype);\n        return -1;\n    case DATATYPE_LAST:\n    default:\n        virReportEnumRangeError(virNWFilterAttrDataType, item->datatype);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintDataTypeDirection(virNWFilterVarCombIterPtr vars,\n                       char *buf, int bufsize,\n                       nwItemDescPtr item, bool directionIn)\n{\n    return _printDataType(vars, buf, bufsize, item, 0, directionIn);\n}"
  },
  {
    "function_name": "printDataType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "333-339",
    "snippet": "static int\nprintDataType(virNWFilterVarCombIterPtr vars,\n              char *buf, int bufsize,\n              nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 0, 0);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_printDataType",
          "args": [
            "vars",
            "buf",
            "bufsize",
            "item",
            "0",
            "0"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "_printDataType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "184-330",
          "snippet": "static int\n_printDataType(virNWFilterVarCombIterPtr vars,\n               char *buf, int bufsize,\n               nwItemDescPtr item,\n               bool asHex, bool directionIn)\n{\n    bool done;\n    char *data;\n    uint8_t ctr;\n    virBuffer vb = VIR_BUFFER_INITIALIZER;\n    char *flags;\n\n    if (printVar(vars, buf, bufsize, item, &done) < 0)\n        return -1;\n\n    if (done)\n        return 0;\n\n    switch (item->datatype) {\n    case DATATYPE_IPADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IP address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_IPV6ADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IPv6 address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_MACADDR:\n    case DATATYPE_MACMASK:\n        if (bufsize < VIR_MAC_STRING_BUFLEN) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for MAC address\"));\n            return -1;\n        }\n\n        virMacAddrFormat(&item->u.macaddr, buf);\n    break;\n\n    case DATATYPE_IPV6MASK:\n    case DATATYPE_IPMASK:\n        if (g_snprintf(buf, bufsize, \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT32:\n    case DATATYPE_UINT32_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%u\",\n                       item->u.u32) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint32 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT16:\n    case DATATYPE_UINT16_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u16) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint16 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT8:\n    case DATATYPE_UINT8_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETNAME:\n        if (virStrcpy(buf, item->u.ipset.setname, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer to small for ipset name\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETFLAGS:\n        for (ctr = 0; ctr < item->u.ipset.numFlags; ctr++) {\n            if (ctr != 0)\n                virBufferAddLit(&vb, \",\");\n            if ((item->u.ipset.flags & (1 << ctr))) {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"dst\");\n                else\n                    virBufferAddLit(&vb, \"src\");\n            } else {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"src\");\n                else\n                    virBufferAddLit(&vb, \"dst\");\n            }\n        }\n\n        flags = virBufferContentAndReset(&vb);\n\n        if (virStrcpy(buf, flags, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for IPSETFLAGS type\"));\n            VIR_FREE(flags);\n            return -1;\n        }\n        VIR_FREE(flags);\n    break;\n\n    case DATATYPE_STRING:\n    case DATATYPE_STRINGCOPY:\n    case DATATYPE_BOOLEAN:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot print data type %x\"), item->datatype);\n        return -1;\n    case DATATYPE_LAST:\n    default:\n        virReportEnumRangeError(virNWFilterAttrDataType, item->datatype);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\n_printDataType(virNWFilterVarCombIterPtr vars,\n               char *buf, int bufsize,\n               nwItemDescPtr item,\n               bool asHex, bool directionIn)\n{\n    bool done;\n    char *data;\n    uint8_t ctr;\n    virBuffer vb = VIR_BUFFER_INITIALIZER;\n    char *flags;\n\n    if (printVar(vars, buf, bufsize, item, &done) < 0)\n        return -1;\n\n    if (done)\n        return 0;\n\n    switch (item->datatype) {\n    case DATATYPE_IPADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IP address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_IPV6ADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IPv6 address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_MACADDR:\n    case DATATYPE_MACMASK:\n        if (bufsize < VIR_MAC_STRING_BUFLEN) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for MAC address\"));\n            return -1;\n        }\n\n        virMacAddrFormat(&item->u.macaddr, buf);\n    break;\n\n    case DATATYPE_IPV6MASK:\n    case DATATYPE_IPMASK:\n        if (g_snprintf(buf, bufsize, \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT32:\n    case DATATYPE_UINT32_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%u\",\n                       item->u.u32) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint32 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT16:\n    case DATATYPE_UINT16_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u16) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint16 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT8:\n    case DATATYPE_UINT8_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETNAME:\n        if (virStrcpy(buf, item->u.ipset.setname, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer to small for ipset name\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETFLAGS:\n        for (ctr = 0; ctr < item->u.ipset.numFlags; ctr++) {\n            if (ctr != 0)\n                virBufferAddLit(&vb, \",\");\n            if ((item->u.ipset.flags & (1 << ctr))) {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"dst\");\n                else\n                    virBufferAddLit(&vb, \"src\");\n            } else {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"src\");\n                else\n                    virBufferAddLit(&vb, \"dst\");\n            }\n        }\n\n        flags = virBufferContentAndReset(&vb);\n\n        if (virStrcpy(buf, flags, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for IPSETFLAGS type\"));\n            VIR_FREE(flags);\n            return -1;\n        }\n        VIR_FREE(flags);\n    break;\n\n    case DATATYPE_STRING:\n    case DATATYPE_STRINGCOPY:\n    case DATATYPE_BOOLEAN:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot print data type %x\"), item->datatype);\n        return -1;\n    case DATATYPE_LAST:\n    default:\n        virReportEnumRangeError(virNWFilterAttrDataType, item->datatype);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintDataType(virNWFilterVarCombIterPtr vars,\n              char *buf, int bufsize,\n              nwItemDescPtr item)\n{\n    return _printDataType(vars, buf, bufsize, item, 0, 0);\n}"
  },
  {
    "function_name": "_printDataType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "184-330",
    "snippet": "static int\n_printDataType(virNWFilterVarCombIterPtr vars,\n               char *buf, int bufsize,\n               nwItemDescPtr item,\n               bool asHex, bool directionIn)\n{\n    bool done;\n    char *data;\n    uint8_t ctr;\n    virBuffer vb = VIR_BUFFER_INITIALIZER;\n    char *flags;\n\n    if (printVar(vars, buf, bufsize, item, &done) < 0)\n        return -1;\n\n    if (done)\n        return 0;\n\n    switch (item->datatype) {\n    case DATATYPE_IPADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IP address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_IPV6ADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IPv6 address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_MACADDR:\n    case DATATYPE_MACMASK:\n        if (bufsize < VIR_MAC_STRING_BUFLEN) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for MAC address\"));\n            return -1;\n        }\n\n        virMacAddrFormat(&item->u.macaddr, buf);\n    break;\n\n    case DATATYPE_IPV6MASK:\n    case DATATYPE_IPMASK:\n        if (g_snprintf(buf, bufsize, \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT32:\n    case DATATYPE_UINT32_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%u\",\n                       item->u.u32) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint32 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT16:\n    case DATATYPE_UINT16_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u16) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint16 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT8:\n    case DATATYPE_UINT8_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETNAME:\n        if (virStrcpy(buf, item->u.ipset.setname, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer to small for ipset name\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETFLAGS:\n        for (ctr = 0; ctr < item->u.ipset.numFlags; ctr++) {\n            if (ctr != 0)\n                virBufferAddLit(&vb, \",\");\n            if ((item->u.ipset.flags & (1 << ctr))) {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"dst\");\n                else\n                    virBufferAddLit(&vb, \"src\");\n            } else {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"src\");\n                else\n                    virBufferAddLit(&vb, \"dst\");\n            }\n        }\n\n        flags = virBufferContentAndReset(&vb);\n\n        if (virStrcpy(buf, flags, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for IPSETFLAGS type\"));\n            VIR_FREE(flags);\n            return -1;\n        }\n        VIR_FREE(flags);\n    break;\n\n    case DATATYPE_STRING:\n    case DATATYPE_STRINGCOPY:\n    case DATATYPE_BOOLEAN:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot print data type %x\"), item->datatype);\n        return -1;\n    case DATATYPE_LAST:\n    default:\n        virReportEnumRangeError(virNWFilterAttrDataType, item->datatype);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNWFilterAttrDataType",
            "item->datatype"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cannot print data type %x\")",
            "item->datatype"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot print data type %x\""
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "_virNWFilterTeardownFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_gentech_driver.c",
          "lines": "898-927",
          "snippet": "static int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdev.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_dhcpsnoop.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _virNWFilterTeardownFilter(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsocketaddr.h\"\n#include \"datatypes.h\"\n#include \"virnetdev.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_dhcpsnoop.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"virerror.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int _virNWFilterTeardownFilter(const char *ifname);\n\nstatic int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "flags"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "flags"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Buffer too small for IPSETFLAGS type\")"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpy",
          "args": [
            "buf",
            "flags",
            "bufsize"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "virStrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "780-784",
          "snippet": "int\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&vb"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&vb",
            "\"dst\""
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&vb",
            "\"src\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&vb",
            "\"src\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&vb",
            "\"dst\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&vb",
            "\",\""
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Buffer to small for ipset name\")"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Buffer too small for uint8 type\")"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "buf",
            "bufsize",
            "asHex ? \"0x%x\" : \"%d\"",
            "item->u.u8"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Buffer too small for uint16 type\")"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "buf",
            "bufsize",
            "asHex ? \"0x%x\" : \"%d\"",
            "item->u.u16"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Buffer too small for uint32 type\")"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "buf",
            "bufsize",
            "asHex ? \"0x%x\" : \"%u\"",
            "item->u.u32"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Buffer too small for uint8 type\")"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "buf",
            "bufsize",
            "\"%d\"",
            "item->u.u8"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "&item->u.macaddr",
            "buf"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Buffer too small for MAC address\")"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"buffer too small for IPv6 address\")"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "buf",
            "bufsize",
            "\"%s\"",
            "data"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&item->u.ipaddr"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"buffer too small for IP address\")"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "buf",
            "bufsize",
            "\"%s\"",
            "data"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printVar",
          "args": [
            "vars",
            "buf",
            "bufsize",
            "item",
            "&done"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "printVar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
          "lines": "151-181",
          "snippet": "static int\nprintVar(virNWFilterVarCombIterPtr vars,\n         char *buf, int bufsize,\n         nwItemDescPtr item,\n         bool *done)\n{\n    *done = false;\n\n    if ((item->flags & NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR)) {\n        const char *val;\n\n        val = virNWFilterVarCombIterGetVarValue(vars, item->varAccess);\n        if (!val) {\n            /* error has been reported */\n            return -1;\n        }\n\n        if (virStrcpy(buf, val, bufsize) < 0) {\n            const char *varName;\n\n            varName = virNWFilterVarAccessGetVarName(item->varAccess);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Buffer too small to print variable \"\n                             \"'%s' into\"), varName);\n            return -1;\n        }\n\n        *done = true;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfirewall.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"nwfilter_driver.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintVar(virNWFilterVarCombIterPtr vars,\n         char *buf, int bufsize,\n         nwItemDescPtr item,\n         bool *done)\n{\n    *done = false;\n\n    if ((item->flags & NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR)) {\n        const char *val;\n\n        val = virNWFilterVarCombIterGetVarValue(vars, item->varAccess);\n        if (!val) {\n            /* error has been reported */\n            return -1;\n        }\n\n        if (virStrcpy(buf, val, bufsize) < 0) {\n            const char *varName;\n\n            varName = virNWFilterVarAccessGetVarName(item->varAccess);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Buffer too small to print variable \"\n                             \"'%s' into\"), varName);\n            return -1;\n        }\n\n        *done = true;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\n_printDataType(virNWFilterVarCombIterPtr vars,\n               char *buf, int bufsize,\n               nwItemDescPtr item,\n               bool asHex, bool directionIn)\n{\n    bool done;\n    char *data;\n    uint8_t ctr;\n    virBuffer vb = VIR_BUFFER_INITIALIZER;\n    char *flags;\n\n    if (printVar(vars, buf, bufsize, item, &done) < 0)\n        return -1;\n\n    if (done)\n        return 0;\n\n    switch (item->datatype) {\n    case DATATYPE_IPADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IP address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_IPV6ADDR:\n        data = virSocketAddrFormat(&item->u.ipaddr);\n        if (!data)\n            return -1;\n\n        if (g_snprintf(buf, bufsize, \"%s\", data) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"buffer too small for IPv6 address\"));\n            VIR_FREE(data);\n            return -1;\n        }\n        VIR_FREE(data);\n    break;\n\n    case DATATYPE_MACADDR:\n    case DATATYPE_MACMASK:\n        if (bufsize < VIR_MAC_STRING_BUFLEN) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for MAC address\"));\n            return -1;\n        }\n\n        virMacAddrFormat(&item->u.macaddr, buf);\n    break;\n\n    case DATATYPE_IPV6MASK:\n    case DATATYPE_IPMASK:\n        if (g_snprintf(buf, bufsize, \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT32:\n    case DATATYPE_UINT32_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%u\",\n                       item->u.u32) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint32 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT16:\n    case DATATYPE_UINT16_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u16) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint16 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_UINT8:\n    case DATATYPE_UINT8_HEX:\n        if (g_snprintf(buf, bufsize, asHex ? \"0x%x\" : \"%d\",\n                       item->u.u8) >= bufsize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for uint8 type\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETNAME:\n        if (virStrcpy(buf, item->u.ipset.setname, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer to small for ipset name\"));\n            return -1;\n        }\n    break;\n\n    case DATATYPE_IPSETFLAGS:\n        for (ctr = 0; ctr < item->u.ipset.numFlags; ctr++) {\n            if (ctr != 0)\n                virBufferAddLit(&vb, \",\");\n            if ((item->u.ipset.flags & (1 << ctr))) {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"dst\");\n                else\n                    virBufferAddLit(&vb, \"src\");\n            } else {\n                if (directionIn)\n                    virBufferAddLit(&vb, \"src\");\n                else\n                    virBufferAddLit(&vb, \"dst\");\n            }\n        }\n\n        flags = virBufferContentAndReset(&vb);\n\n        if (virStrcpy(buf, flags, bufsize) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Buffer too small for IPSETFLAGS type\"));\n            VIR_FREE(flags);\n            return -1;\n        }\n        VIR_FREE(flags);\n    break;\n\n    case DATATYPE_STRING:\n    case DATATYPE_STRINGCOPY:\n    case DATATYPE_BOOLEAN:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot print data type %x\"), item->datatype);\n        return -1;\n    case DATATYPE_LAST:\n    default:\n        virReportEnumRangeError(virNWFilterAttrDataType, item->datatype);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "printVar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_ebiptables_driver.c",
    "lines": "151-181",
    "snippet": "static int\nprintVar(virNWFilterVarCombIterPtr vars,\n         char *buf, int bufsize,\n         nwItemDescPtr item,\n         bool *done)\n{\n    *done = false;\n\n    if ((item->flags & NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR)) {\n        const char *val;\n\n        val = virNWFilterVarCombIterGetVarValue(vars, item->varAccess);\n        if (!val) {\n            /* error has been reported */\n            return -1;\n        }\n\n        if (virStrcpy(buf, val, bufsize) < 0) {\n            const char *varName;\n\n            varName = virNWFilterVarAccessGetVarName(item->varAccess);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Buffer too small to print variable \"\n                             \"'%s' into\"), varName);\n            return -1;\n        }\n\n        *done = true;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfirewall.h\"",
      "#include \"virstring.h\"",
      "#include \"configmake.h\"",
      "#include \"vircommand.h\"",
      "#include \"virfile.h\"",
      "#include \"nwfilter_ebiptables_driver.h\"",
      "#include \"nwfilter_gentech_driver.h\"",
      "#include \"nwfilter_driver.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Buffer too small to print variable \"\n                             \"'%s' into\")",
            "varName"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Buffer too small to print variable \"\n                             \"'%s' into\""
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "_virNWFilterTeardownFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/nwfilter/nwfilter_gentech_driver.c",
          "lines": "898-927",
          "snippet": "static int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdev.h\"",
            "#include \"nwfilter_learnipaddr.h\"",
            "#include \"nwfilter_ipaddrmap.h\"",
            "#include \"nwfilter_dhcpsnoop.h\"",
            "#include \"nwfilter_ebiptables_driver.h\"",
            "#include \"nwfilter_gentech_driver.h\"",
            "#include \"virerror.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int _virNWFilterTeardownFilter(const char *ifname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virsocketaddr.h\"\n#include \"datatypes.h\"\n#include \"virnetdev.h\"\n#include \"nwfilter_learnipaddr.h\"\n#include \"nwfilter_ipaddrmap.h\"\n#include \"nwfilter_dhcpsnoop.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"virerror.h\"\n#include \"domain_conf.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int _virNWFilterTeardownFilter(const char *ifname);\n\nstatic int\n_virNWFilterTeardownFilter(const char *ifname)\n{\n    const char *drvname = EBIPTABLES_DRIVER_ID;\n    virNWFilterTechDriverPtr techdriver;\n    techdriver = virNWFilterTechDriverForName(drvname);\n\n    if (!techdriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get access to ACL tech \"\n                         \"driver '%s'\"),\n                       drvname);\n        return -1;\n    }\n\n    virNWFilterDHCPSnoopEnd(ifname);\n\n    virNWFilterTerminateLearnReq(ifname);\n\n    if (virNWFilterLockIface(ifname) < 0)\n        return -1;\n\n    techdriver->allTeardown(ifname);\n\n    virNWFilterIPAddrMapDelIPAddr(ifname, NULL);\n\n    virNWFilterUnlockIface(ifname);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterVarAccessGetVarName",
          "args": [
            "item->varAccess"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarAccessGetVarName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "976-980",
          "snippet": "const char *\nvirNWFilterVarAccessGetVarName(const virNWFilterVarAccess *vap)\n{\n    return vap->varName;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int virNWFilterVarAccessGetIntIterId(const virNWFilterVarAccess *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic unsigned int virNWFilterVarAccessGetIntIterId(const virNWFilterVarAccess *);\n\nconst char *\nvirNWFilterVarAccessGetVarName(const virNWFilterVarAccess *vap)\n{\n    return vap->varName;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrcpy",
          "args": [
            "buf",
            "val",
            "bufsize"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "virStrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "780-784",
          "snippet": "int\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterVarCombIterGetVarValue",
          "args": [
            "vars",
            "item->varAccess"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterVarCombIterGetVarValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_params.c",
          "lines": "550-619",
          "snippet": "const char *\nvirNWFilterVarCombIterGetVarValue(virNWFilterVarCombIterPtr ci,\n                                  const virNWFilterVarAccess *vap)\n{\n    size_t i;\n    unsigned int iterId;\n    bool found = false;\n    const char *res = NULL;\n    virNWFilterVarValuePtr value;\n    int iterIndex = -1;\n    const char *varName = virNWFilterVarAccessGetVarName(vap);\n\n    switch (virNWFilterVarAccessGetType(vap)) {\n    case VIR_NWFILTER_VAR_ACCESS_ITERATOR:\n        iterId = virNWFilterVarAccessGetIterId(vap);\n        iterIndex = virNWFilterVarCombIterGetIndexByIterId(ci, iterId);\n        if (iterIndex < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get iterator index for \"\n                             \"iterator ID %u\"), iterId);\n            return NULL;\n        }\n        break;\n    case VIR_NWFILTER_VAR_ACCESS_ELEMENT:\n        iterId = virNWFilterVarAccessGetIntIterId(vap);\n        iterIndex = virNWFilterVarCombIterGetIndexByIterId(ci, iterId);\n        if (iterIndex < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get iterator index for \"\n                             \"(internal) iterator ID %u\"), iterId);\n            return NULL;\n        }\n        break;\n    case VIR_NWFILTER_VAR_ACCESS_LAST:\n        return NULL;\n    }\n\n    for (i = 0; i < ci->iter[iterIndex].nVarNames; i++) {\n        if (STREQ(ci->iter[iterIndex].varNames[i], varName)) {\n            found = true;\n            break;\n        }\n    }\n\n    if (!found) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find variable '%s' in iterator\"),\n                       varName);\n        return NULL;\n    }\n\n    value = virHashLookup(ci->hashTable, varName);\n    if (!value) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find value for variable '%s'\"),\n                       varName);\n        return NULL;\n    }\n\n    res = virNWFilterVarValueGetNthValue(value, ci->iter[iterIndex].curValue);\n    if (!res) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get nth (%u) value of \"\n                         \"variable '%s'\"),\n                       ci->iter[iterIndex].curValue, varName);\n        return NULL;\n    }\n\n    return res;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool isValidVarValue(const char *value);",
            "static unsigned int virNWFilterVarAccessGetIntIterId(const virNWFilterVarAccess *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic bool isValidVarValue(const char *value);\nstatic unsigned int virNWFilterVarAccessGetIntIterId(const virNWFilterVarAccess *);\n\nconst char *\nvirNWFilterVarCombIterGetVarValue(virNWFilterVarCombIterPtr ci,\n                                  const virNWFilterVarAccess *vap)\n{\n    size_t i;\n    unsigned int iterId;\n    bool found = false;\n    const char *res = NULL;\n    virNWFilterVarValuePtr value;\n    int iterIndex = -1;\n    const char *varName = virNWFilterVarAccessGetVarName(vap);\n\n    switch (virNWFilterVarAccessGetType(vap)) {\n    case VIR_NWFILTER_VAR_ACCESS_ITERATOR:\n        iterId = virNWFilterVarAccessGetIterId(vap);\n        iterIndex = virNWFilterVarCombIterGetIndexByIterId(ci, iterId);\n        if (iterIndex < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get iterator index for \"\n                             \"iterator ID %u\"), iterId);\n            return NULL;\n        }\n        break;\n    case VIR_NWFILTER_VAR_ACCESS_ELEMENT:\n        iterId = virNWFilterVarAccessGetIntIterId(vap);\n        iterIndex = virNWFilterVarCombIterGetIndexByIterId(ci, iterId);\n        if (iterIndex < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get iterator index for \"\n                             \"(internal) iterator ID %u\"), iterId);\n            return NULL;\n        }\n        break;\n    case VIR_NWFILTER_VAR_ACCESS_LAST:\n        return NULL;\n    }\n\n    for (i = 0; i < ci->iter[iterIndex].nVarNames; i++) {\n        if (STREQ(ci->iter[iterIndex].varNames[i], varName)) {\n            found = true;\n            break;\n        }\n    }\n\n    if (!found) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find variable '%s' in iterator\"),\n                       varName);\n        return NULL;\n    }\n\n    value = virHashLookup(ci->hashTable, varName);\n    if (!value) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find value for variable '%s'\"),\n                       varName);\n        return NULL;\n    }\n\n    res = virNWFilterVarValueGetNthValue(value, ci->iter[iterIndex].curValue);\n    if (!res) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get nth (%u) value of \"\n                         \"variable '%s'\"),\n                       ci->iter[iterIndex].curValue, varName);\n        return NULL;\n    }\n\n    return res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfirewall.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"nwfilter_ebiptables_driver.h\"\n#include \"nwfilter_gentech_driver.h\"\n#include \"nwfilter_driver.h\"\n#include \"nwfilter_conf.h\"\n#include \"domain_conf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <config.h>\n\nstatic int\nprintVar(virNWFilterVarCombIterPtr vars,\n         char *buf, int bufsize,\n         nwItemDescPtr item,\n         bool *done)\n{\n    *done = false;\n\n    if ((item->flags & NWFILTER_ENTRY_ITEM_FLAG_HAS_VAR)) {\n        const char *val;\n\n        val = virNWFilterVarCombIterGetVarValue(vars, item->varAccess);\n        if (!val) {\n            /* error has been reported */\n            return -1;\n        }\n\n        if (virStrcpy(buf, val, bufsize) < 0) {\n            const char *varName;\n\n            varName = virNWFilterVarAccessGetVarName(item->varAccess);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Buffer too small to print variable \"\n                             \"'%s' into\"), varName);\n            return -1;\n        }\n\n        *done = true;\n    }\n    return 0;\n}"
  }
]