[
  {
    "function_name": "virFirewallApply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "804-868",
    "snippet": "int\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
      "static virMutex ruleLock = VIR_MUTEX_INITIALIZER;",
      "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&ruleLock"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Done applying groups for %p\"",
            "firewall"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Done rolling back groups for %p\"",
            "firewall"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&saved_error"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallRollbackGroup",
          "args": [
            "firewall",
            "j"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRollbackGroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "786-801",
          "snippet": "static void\nvirFirewallRollbackGroup(virFirewallPtr firewall,\n                         size_t idx)\n{\n    virFirewallGroupPtr group = firewall->groups[idx];\n    size_t i;\n\n    VIR_INFO(\"Starting rollback for group %p\", group);\n    firewall->currentGroup = idx;\n    group->addingRollback = true;\n    for (i = 0; i < group->nrollback; i++) {\n        ignore_value(virFirewallApplyRule(firewall,\n                                          group->rollback[i],\n                                          true));\n    }\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nvirFirewallRollbackGroup(virFirewallPtr firewall,\n                         size_t idx)\n{\n    virFirewallGroupPtr group = firewall->groups[idx];\n    size_t i;\n\n    VIR_INFO(\"Starting rollback for group %p\", group);\n    firewall->currentGroup = idx;\n    group->addingRollback = true;\n    for (i = 0; i < group->nrollback; i++) {\n        ignore_value(virFirewallApplyRule(firewall,\n                                          group->rollback[i],\n                                          true));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Rolling back group %zu\"",
            "j"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Checking inheritance of group %zu\"",
            "i - j"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&saved_error"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Rolling back groups up to %zu for %p\"",
            "i",
            "firewall"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallApplyGroup",
          "args": [
            "firewall",
            "i"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApplyGroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "764-783",
          "snippet": "static int\nvirFirewallApplyGroup(virFirewallPtr firewall,\n                      size_t idx)\n{\n    virFirewallGroupPtr group = firewall->groups[idx];\n    bool ignoreErrors = (group->actionFlags & VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n    size_t i;\n\n    VIR_INFO(\"Starting transaction for firewall=%p group=%p flags=0x%x\",\n             firewall, group, group->actionFlags);\n    firewall->currentGroup = idx;\n    group->addingRollback = false;\n    for (i = 0; i < group->naction; i++) {\n        if (virFirewallApplyRule(firewall,\n                                 group->action[i],\n                                 ignoreErrors) < 0)\n            return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvirFirewallApplyGroup(virFirewallPtr firewall,\n                      size_t idx)\n{\n    virFirewallGroupPtr group = firewall->groups[idx];\n    bool ignoreErrors = (group->actionFlags & VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n    size_t i;\n\n    VIR_INFO(\"Starting transaction for firewall=%p group=%p flags=0x%x\",\n             firewall, group, group->actionFlags);\n    firewall->currentGroup = idx;\n    group->addingRollback = false;\n    for (i = 0; i < group->naction; i++) {\n        if (virFirewallApplyRule(firewall,\n                                 group->action[i],\n                                 ignoreErrors) < 0)\n            return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Applying groups for %p\"",
            "firewall"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "firewall->err",
            "\"%s\"",
            "_(\"Unable to create rule\")"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to create rule\""
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to initialize a valid firewall backend\")"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&ruleLock"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic virMutex ruleLock = VIR_MUTEX_INITIALIZER;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nint\nvirFirewallApply(virFirewallPtr firewall)\n{\n    size_t i, j;\n    int ret = -1;\n\n    virMutexLock(&ruleLock);\n\n    if (currentBackend == VIR_FIREWALL_BACKEND_AUTOMATIC) {\n        /* a specific backend should have been set when the firewall\n         * object was created. If not, it means none was found.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to initialize a valid firewall backend\"));\n        goto cleanup;\n    }\n    if (!firewall || firewall->err == ENOMEM) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    if (firewall->err) {\n        virReportSystemError(firewall->err, \"%s\",\n                             _(\"Unable to create rule\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Applying groups for %p\", firewall);\n    for (i = 0; i < firewall->ngroups; i++) {\n        if (virFirewallApplyGroup(firewall, i) < 0) {\n            VIR_DEBUG(\"Rolling back groups up to %zu for %p\", i, firewall);\n            size_t first = i;\n            virErrorPtr saved_error;\n\n            virErrorPreserveLast(&saved_error);\n\n            /*\n             * Look at any inheritance markers to figure out\n             * what the first rollback group we need to apply is\n             */\n            for (j = 0; j < i; j++) {\n                VIR_DEBUG(\"Checking inheritance of group %zu\", i - j);\n                if (firewall->groups[i - j]->rollbackFlags &\n                    VIR_FIREWALL_ROLLBACK_INHERIT_PREVIOUS)\n                    first = (i - j) - 1;\n            }\n            /*\n             * Now apply all rollback groups in order\n             */\n            for (j = first; j <= i; j++) {\n                VIR_DEBUG(\"Rolling back group %zu\", j);\n                virFirewallRollbackGroup(firewall, j);\n            }\n\n            virErrorRestore(&saved_error);\n            VIR_DEBUG(\"Done rolling back groups for %p\", firewall);\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"Done applying groups for %p\", firewall);\n\n    ret = 0;\n cleanup:\n    virMutexUnlock(&ruleLock);\n    return ret;\n}"
  },
  {
    "function_name": "virFirewallRollbackGroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "786-801",
    "snippet": "static void\nvirFirewallRollbackGroup(virFirewallPtr firewall,\n                         size_t idx)\n{\n    virFirewallGroupPtr group = firewall->groups[idx];\n    size_t i;\n\n    VIR_INFO(\"Starting rollback for group %p\", group);\n    firewall->currentGroup = idx;\n    group->addingRollback = true;\n    for (i = 0; i < group->nrollback; i++) {\n        ignore_value(virFirewallApplyRule(firewall,\n                                          group->rollback[i],\n                                          true));\n    }\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virFirewallApplyRule(firewall,\n                                          group->rollback[i],\n                                          true)"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallApplyRule",
          "args": [
            "firewall",
            "group->rollback[i]",
            "true"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApplyRule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "711-762",
          "snippet": "static int\nvirFirewallApplyRule(virFirewallPtr firewall,\n                     virFirewallRulePtr rule,\n                     bool ignoreErrors)\n{\n    g_autofree char *output = NULL;\n    g_autofree char *str = virFirewallRuleToString(rule);\n    VIR_AUTOSTRINGLIST lines = NULL;\n    VIR_INFO(\"Applying rule '%s'\", NULLSTR(str));\n\n    if (rule->ignoreErrors)\n        ignoreErrors = rule->ignoreErrors;\n\n    switch (currentBackend) {\n    case VIR_FIREWALL_BACKEND_DIRECT:\n        if (virFirewallApplyRuleDirect(rule, ignoreErrors, &output) < 0)\n            return -1;\n        break;\n    case VIR_FIREWALL_BACKEND_FIREWALLD:\n        if (virFirewallApplyRuleFirewallD(rule, ignoreErrors, &output) < 0)\n            return -1;\n        break;\n\n    case VIR_FIREWALL_BACKEND_AUTOMATIC:\n    case VIR_FIREWALL_BACKEND_LAST:\n    default:\n        virReportEnumRangeError(virFirewallBackend, currentBackend);\n        return -1;\n    }\n\n    if (rule->queryCB && output) {\n        if (!(lines = virStringSplit(output, \"\\n\", -1)))\n            return -1;\n\n        VIR_DEBUG(\"Invoking query %p with '%s'\", rule->queryCB, output);\n        if (rule->queryCB(firewall, rule->layer, (const char *const *)lines, rule->queryOpaque) < 0)\n            return -1;\n\n        if (firewall->err == ENOMEM) {\n            virReportOOMError();\n            return -1;\n        }\n        if (firewall->err) {\n            virReportSystemError(firewall->err, \"%s\",\n                                 _(\"Unable to create rule\"));\n            return -1;\n        }\n\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\n\nstatic int\nvirFirewallApplyRule(virFirewallPtr firewall,\n                     virFirewallRulePtr rule,\n                     bool ignoreErrors)\n{\n    g_autofree char *output = NULL;\n    g_autofree char *str = virFirewallRuleToString(rule);\n    VIR_AUTOSTRINGLIST lines = NULL;\n    VIR_INFO(\"Applying rule '%s'\", NULLSTR(str));\n\n    if (rule->ignoreErrors)\n        ignoreErrors = rule->ignoreErrors;\n\n    switch (currentBackend) {\n    case VIR_FIREWALL_BACKEND_DIRECT:\n        if (virFirewallApplyRuleDirect(rule, ignoreErrors, &output) < 0)\n            return -1;\n        break;\n    case VIR_FIREWALL_BACKEND_FIREWALLD:\n        if (virFirewallApplyRuleFirewallD(rule, ignoreErrors, &output) < 0)\n            return -1;\n        break;\n\n    case VIR_FIREWALL_BACKEND_AUTOMATIC:\n    case VIR_FIREWALL_BACKEND_LAST:\n    default:\n        virReportEnumRangeError(virFirewallBackend, currentBackend);\n        return -1;\n    }\n\n    if (rule->queryCB && output) {\n        if (!(lines = virStringSplit(output, \"\\n\", -1)))\n            return -1;\n\n        VIR_DEBUG(\"Invoking query %p with '%s'\", rule->queryCB, output);\n        if (rule->queryCB(firewall, rule->layer, (const char *const *)lines, rule->queryOpaque) < 0)\n            return -1;\n\n        if (firewall->err == ENOMEM) {\n            virReportOOMError();\n            return -1;\n        }\n        if (firewall->err) {\n            virReportSystemError(firewall->err, \"%s\",\n                                 _(\"Unable to create rule\"));\n            return -1;\n        }\n\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Starting rollback for group %p\"",
            "group"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nvirFirewallRollbackGroup(virFirewallPtr firewall,\n                         size_t idx)\n{\n    virFirewallGroupPtr group = firewall->groups[idx];\n    size_t i;\n\n    VIR_INFO(\"Starting rollback for group %p\", group);\n    firewall->currentGroup = idx;\n    group->addingRollback = true;\n    for (i = 0; i < group->nrollback; i++) {\n        ignore_value(virFirewallApplyRule(firewall,\n                                          group->rollback[i],\n                                          true));\n    }\n}"
  },
  {
    "function_name": "virFirewallApplyGroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "764-783",
    "snippet": "static int\nvirFirewallApplyGroup(virFirewallPtr firewall,\n                      size_t idx)\n{\n    virFirewallGroupPtr group = firewall->groups[idx];\n    bool ignoreErrors = (group->actionFlags & VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n    size_t i;\n\n    VIR_INFO(\"Starting transaction for firewall=%p group=%p flags=0x%x\",\n             firewall, group, group->actionFlags);\n    firewall->currentGroup = idx;\n    group->addingRollback = false;\n    for (i = 0; i < group->naction; i++) {\n        if (virFirewallApplyRule(firewall,\n                                 group->action[i],\n                                 ignoreErrors) < 0)\n            return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallApplyRule",
          "args": [
            "firewall",
            "group->action[i]",
            "ignoreErrors"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApplyRule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "711-762",
          "snippet": "static int\nvirFirewallApplyRule(virFirewallPtr firewall,\n                     virFirewallRulePtr rule,\n                     bool ignoreErrors)\n{\n    g_autofree char *output = NULL;\n    g_autofree char *str = virFirewallRuleToString(rule);\n    VIR_AUTOSTRINGLIST lines = NULL;\n    VIR_INFO(\"Applying rule '%s'\", NULLSTR(str));\n\n    if (rule->ignoreErrors)\n        ignoreErrors = rule->ignoreErrors;\n\n    switch (currentBackend) {\n    case VIR_FIREWALL_BACKEND_DIRECT:\n        if (virFirewallApplyRuleDirect(rule, ignoreErrors, &output) < 0)\n            return -1;\n        break;\n    case VIR_FIREWALL_BACKEND_FIREWALLD:\n        if (virFirewallApplyRuleFirewallD(rule, ignoreErrors, &output) < 0)\n            return -1;\n        break;\n\n    case VIR_FIREWALL_BACKEND_AUTOMATIC:\n    case VIR_FIREWALL_BACKEND_LAST:\n    default:\n        virReportEnumRangeError(virFirewallBackend, currentBackend);\n        return -1;\n    }\n\n    if (rule->queryCB && output) {\n        if (!(lines = virStringSplit(output, \"\\n\", -1)))\n            return -1;\n\n        VIR_DEBUG(\"Invoking query %p with '%s'\", rule->queryCB, output);\n        if (rule->queryCB(firewall, rule->layer, (const char *const *)lines, rule->queryOpaque) < 0)\n            return -1;\n\n        if (firewall->err == ENOMEM) {\n            virReportOOMError();\n            return -1;\n        }\n        if (firewall->err) {\n            virReportSystemError(firewall->err, \"%s\",\n                                 _(\"Unable to create rule\"));\n            return -1;\n        }\n\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\n\nstatic int\nvirFirewallApplyRule(virFirewallPtr firewall,\n                     virFirewallRulePtr rule,\n                     bool ignoreErrors)\n{\n    g_autofree char *output = NULL;\n    g_autofree char *str = virFirewallRuleToString(rule);\n    VIR_AUTOSTRINGLIST lines = NULL;\n    VIR_INFO(\"Applying rule '%s'\", NULLSTR(str));\n\n    if (rule->ignoreErrors)\n        ignoreErrors = rule->ignoreErrors;\n\n    switch (currentBackend) {\n    case VIR_FIREWALL_BACKEND_DIRECT:\n        if (virFirewallApplyRuleDirect(rule, ignoreErrors, &output) < 0)\n            return -1;\n        break;\n    case VIR_FIREWALL_BACKEND_FIREWALLD:\n        if (virFirewallApplyRuleFirewallD(rule, ignoreErrors, &output) < 0)\n            return -1;\n        break;\n\n    case VIR_FIREWALL_BACKEND_AUTOMATIC:\n    case VIR_FIREWALL_BACKEND_LAST:\n    default:\n        virReportEnumRangeError(virFirewallBackend, currentBackend);\n        return -1;\n    }\n\n    if (rule->queryCB && output) {\n        if (!(lines = virStringSplit(output, \"\\n\", -1)))\n            return -1;\n\n        VIR_DEBUG(\"Invoking query %p with '%s'\", rule->queryCB, output);\n        if (rule->queryCB(firewall, rule->layer, (const char *const *)lines, rule->queryOpaque) < 0)\n            return -1;\n\n        if (firewall->err == ENOMEM) {\n            virReportOOMError();\n            return -1;\n        }\n        if (firewall->err) {\n            virReportSystemError(firewall->err, \"%s\",\n                                 _(\"Unable to create rule\"));\n            return -1;\n        }\n\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Starting transaction for firewall=%p group=%p flags=0x%x\"",
            "firewall",
            "group",
            "group->actionFlags"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvirFirewallApplyGroup(virFirewallPtr firewall,\n                      size_t idx)\n{\n    virFirewallGroupPtr group = firewall->groups[idx];\n    bool ignoreErrors = (group->actionFlags & VIR_FIREWALL_TRANSACTION_IGNORE_ERRORS);\n    size_t i;\n\n    VIR_INFO(\"Starting transaction for firewall=%p group=%p flags=0x%x\",\n             firewall, group, group->actionFlags);\n    firewall->currentGroup = idx;\n    group->addingRollback = false;\n    for (i = 0; i < group->naction; i++) {\n        if (virFirewallApplyRule(firewall,\n                                 group->action[i],\n                                 ignoreErrors) < 0)\n            return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virFirewallApplyRule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "711-762",
    "snippet": "static int\nvirFirewallApplyRule(virFirewallPtr firewall,\n                     virFirewallRulePtr rule,\n                     bool ignoreErrors)\n{\n    g_autofree char *output = NULL;\n    g_autofree char *str = virFirewallRuleToString(rule);\n    VIR_AUTOSTRINGLIST lines = NULL;\n    VIR_INFO(\"Applying rule '%s'\", NULLSTR(str));\n\n    if (rule->ignoreErrors)\n        ignoreErrors = rule->ignoreErrors;\n\n    switch (currentBackend) {\n    case VIR_FIREWALL_BACKEND_DIRECT:\n        if (virFirewallApplyRuleDirect(rule, ignoreErrors, &output) < 0)\n            return -1;\n        break;\n    case VIR_FIREWALL_BACKEND_FIREWALLD:\n        if (virFirewallApplyRuleFirewallD(rule, ignoreErrors, &output) < 0)\n            return -1;\n        break;\n\n    case VIR_FIREWALL_BACKEND_AUTOMATIC:\n    case VIR_FIREWALL_BACKEND_LAST:\n    default:\n        virReportEnumRangeError(virFirewallBackend, currentBackend);\n        return -1;\n    }\n\n    if (rule->queryCB && output) {\n        if (!(lines = virStringSplit(output, \"\\n\", -1)))\n            return -1;\n\n        VIR_DEBUG(\"Invoking query %p with '%s'\", rule->queryCB, output);\n        if (rule->queryCB(firewall, rule->layer, (const char *const *)lines, rule->queryOpaque) < 0)\n            return -1;\n\n        if (firewall->err == ENOMEM) {\n            virReportOOMError();\n            return -1;\n        }\n        if (firewall->err) {\n            virReportSystemError(firewall->err, \"%s\",\n                                 _(\"Unable to create rule\"));\n            return -1;\n        }\n\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "firewall->err",
            "\"%s\"",
            "_(\"Unable to create rule\")"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to create rule\""
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rule->queryCB",
          "args": [
            "firewall",
            "rule->layer",
            "(const char *const *)lines",
            "rule->queryOpaque"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Invoking query %p with '%s'\"",
            "rule->queryCB",
            "output"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplit",
          "args": [
            "output",
            "\"\\n\"",
            "-1"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "126-132",
          "snippet": "char **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virFirewallBackend",
            "currentBackend"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallApplyRuleFirewallD",
          "args": [
            "rule",
            "ignoreErrors",
            "&output"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApplyRuleFirewallD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "702-709",
          "snippet": "static int\nvirFirewallApplyRuleFirewallD(virFirewallRulePtr rule,\n                              bool ignoreErrors,\n                              char **output)\n{\n    /* wrapper necessary because virFirewallRule is a private struct */\n    return virFirewallDApplyRule(rule->layer, rule->args, rule->argsLen, ignoreErrors, output);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvirFirewallApplyRuleFirewallD(virFirewallRulePtr rule,\n                              bool ignoreErrors,\n                              char **output)\n{\n    /* wrapper necessary because virFirewallRule is a private struct */\n    return virFirewallDApplyRule(rule->layer, rule->args, rule->argsLen, ignoreErrors, output);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallApplyRuleDirect",
          "args": [
            "rule",
            "ignoreErrors",
            "&output"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallApplyRuleDirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "656-699",
          "snippet": "static int\nvirFirewallApplyRuleDirect(virFirewallRulePtr rule,\n                           bool ignoreErrors,\n                           char **output)\n{\n    size_t i;\n    const char *bin = virFirewallLayerCommandTypeToString(rule->layer);\n    g_autoptr(virCommand) cmd = NULL;\n    int status;\n    g_autofree char *error = NULL;\n\n    if (!bin) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown firewall layer %d\"),\n                       rule->layer);\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(bin, NULL);\n\n    for (i = 0; i < rule->argsLen; i++)\n        virCommandAddArg(cmd, rule->args[i]);\n\n    virCommandSetOutputBuffer(cmd, output);\n    virCommandSetErrorBuffer(cmd, &error);\n\n    if (virCommandRun(cmd, &status) < 0)\n        return -1;\n\n    if (status != 0) {\n        if (ignoreErrors) {\n            VIR_DEBUG(\"Ignoring error running command\");\n        } else {\n            g_autofree char *args = virCommandToString(cmd, false);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to apply firewall rules %s: %s\"),\n                           NULLSTR(args), NULLSTR(error));\n            VIR_FREE(*output);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvirFirewallApplyRuleDirect(virFirewallRulePtr rule,\n                           bool ignoreErrors,\n                           char **output)\n{\n    size_t i;\n    const char *bin = virFirewallLayerCommandTypeToString(rule->layer);\n    g_autoptr(virCommand) cmd = NULL;\n    int status;\n    g_autofree char *error = NULL;\n\n    if (!bin) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown firewall layer %d\"),\n                       rule->layer);\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(bin, NULL);\n\n    for (i = 0; i < rule->argsLen; i++)\n        virCommandAddArg(cmd, rule->args[i]);\n\n    virCommandSetOutputBuffer(cmd, output);\n    virCommandSetErrorBuffer(cmd, &error);\n\n    if (virCommandRun(cmd, &status) < 0)\n        return -1;\n\n    if (status != 0) {\n        if (ignoreErrors) {\n            VIR_DEBUG(\"Ignoring error running command\");\n        } else {\n            g_autofree char *args = virCommandToString(cmd, false);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to apply firewall rules %s: %s\"),\n                           NULLSTR(args), NULLSTR(error));\n            VIR_FREE(*output);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Applying rule '%s'\"",
            "NULLSTR(str)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "str"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallRuleToString",
          "args": [
            "rule"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "640-654",
          "snippet": "static char *\nvirFirewallRuleToString(virFirewallRulePtr rule)\n{\n    const char *bin = virFirewallLayerCommandTypeToString(rule->layer);\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    virBufferAdd(&buf, bin, -1);\n    for (i = 0; i < rule->argsLen; i++) {\n        virBufferAddLit(&buf, \" \");\n        virBufferAdd(&buf, rule->args[i], -1);\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *\nvirFirewallRuleToString(virFirewallRulePtr rule)\n{\n    const char *bin = virFirewallLayerCommandTypeToString(rule->layer);\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    virBufferAdd(&buf, bin, -1);\n    for (i = 0; i < rule->argsLen; i++) {\n        virBufferAddLit(&buf, \" \");\n        virBufferAdd(&buf, rule->args[i], -1);\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\n\nstatic int\nvirFirewallApplyRule(virFirewallPtr firewall,\n                     virFirewallRulePtr rule,\n                     bool ignoreErrors)\n{\n    g_autofree char *output = NULL;\n    g_autofree char *str = virFirewallRuleToString(rule);\n    VIR_AUTOSTRINGLIST lines = NULL;\n    VIR_INFO(\"Applying rule '%s'\", NULLSTR(str));\n\n    if (rule->ignoreErrors)\n        ignoreErrors = rule->ignoreErrors;\n\n    switch (currentBackend) {\n    case VIR_FIREWALL_BACKEND_DIRECT:\n        if (virFirewallApplyRuleDirect(rule, ignoreErrors, &output) < 0)\n            return -1;\n        break;\n    case VIR_FIREWALL_BACKEND_FIREWALLD:\n        if (virFirewallApplyRuleFirewallD(rule, ignoreErrors, &output) < 0)\n            return -1;\n        break;\n\n    case VIR_FIREWALL_BACKEND_AUTOMATIC:\n    case VIR_FIREWALL_BACKEND_LAST:\n    default:\n        virReportEnumRangeError(virFirewallBackend, currentBackend);\n        return -1;\n    }\n\n    if (rule->queryCB && output) {\n        if (!(lines = virStringSplit(output, \"\\n\", -1)))\n            return -1;\n\n        VIR_DEBUG(\"Invoking query %p with '%s'\", rule->queryCB, output);\n        if (rule->queryCB(firewall, rule->layer, (const char *const *)lines, rule->queryOpaque) < 0)\n            return -1;\n\n        if (firewall->err == ENOMEM) {\n            virReportOOMError();\n            return -1;\n        }\n        if (firewall->err) {\n            virReportSystemError(firewall->err, \"%s\",\n                                 _(\"Unable to create rule\"));\n            return -1;\n        }\n\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virFirewallApplyRuleFirewallD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "702-709",
    "snippet": "static int\nvirFirewallApplyRuleFirewallD(virFirewallRulePtr rule,\n                              bool ignoreErrors,\n                              char **output)\n{\n    /* wrapper necessary because virFirewallRule is a private struct */\n    return virFirewallDApplyRule(rule->layer, rule->args, rule->argsLen, ignoreErrors, output);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallDApplyRule",
          "args": [
            "rule->layer",
            "rule->args",
            "rule->argsLen",
            "ignoreErrors",
            "output"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallDApplyRule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewalld.c",
          "lines": "269-350",
          "snippet": "int\nvirFirewallDApplyRule(virFirewallLayer layer,\n                      char **args, size_t argsLen,\n                      bool ignoreErrors,\n                      char **output)\n{\n    const char *ipv = virFirewallLayerFirewallDTypeToString(layer);\n    DBusConnection *sysbus = virDBusGetSystemBus();\n    DBusMessage *reply = NULL;\n    virError error;\n    int ret = -1;\n\n    if (!sysbus)\n        return -1;\n\n    memset(&error, 0, sizeof(error));\n\n    if (!ipv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown firewall layer %d\"),\n                       layer);\n        goto cleanup;\n    }\n\n    if (virDBusCallMethod(sysbus,\n                          &reply,\n                          &error,\n                          VIR_FIREWALL_FIREWALLD_SERVICE,\n                          \"/org/fedoraproject/FirewallD1\",\n                          \"org.fedoraproject.FirewallD1.direct\",\n                          \"passthrough\",\n                          \"sa&s\",\n                          ipv,\n                          (int)argsLen,\n                          args) < 0)\n        goto cleanup;\n\n    if (error.level == VIR_ERR_ERROR) {\n        /*\n         * As of firewalld-0.3.9.3-1.fc20.noarch the name and\n         * message fields in the error look like\n         *\n         *    name=\"org.freedesktop.DBus.Python.dbus.exceptions.DBusException\"\n         * message=\"COMMAND_FAILED: '/sbin/iptables --table filter --delete\n         *          INPUT --in-interface virbr0 --protocol udp --destination-port 53\n         *          --jump ACCEPT' failed: iptables: Bad rule (does a matching rule\n         *          exist in that chain?).\"\n         *\n         * We'd like to only ignore DBus errors precisely related to the failure\n         * of iptables/ebtables commands. A well designed DBus interface would\n         * return specific named exceptions not the top level generic python dbus\n         * exception name. With this current scheme our only option is todo a\n         * sub-string match for 'COMMAND_FAILED' on the message. eg like\n         *\n         * if (ignoreErrors &&\n         *     STREQ(error.name,\n         *           \"org.freedesktop.DBus.Python.dbus.exceptions.DBusException\") &&\n         *     STRPREFIX(error.message, \"COMMAND_FAILED\"))\n         *    ...\n         *\n         * But this risks our error detecting code being broken if firewalld changes\n         * ever alter the message string, so we're avoiding doing that.\n         */\n        if (ignoreErrors) {\n            VIR_DEBUG(\"Ignoring error '%s': '%s'\",\n                      error.str1, error.message);\n        } else {\n            virReportErrorObject(&error);\n            goto cleanup;\n        }\n    } else {\n        if (virDBusMessageDecode(reply, \"s\", output) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virResetError(&error);\n    virDBusMessageUnref(reply);\n    return ret;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalldpriv.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalldpriv.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirFirewallDApplyRule(virFirewallLayer layer,\n                      char **args, size_t argsLen,\n                      bool ignoreErrors,\n                      char **output)\n{\n    const char *ipv = virFirewallLayerFirewallDTypeToString(layer);\n    DBusConnection *sysbus = virDBusGetSystemBus();\n    DBusMessage *reply = NULL;\n    virError error;\n    int ret = -1;\n\n    if (!sysbus)\n        return -1;\n\n    memset(&error, 0, sizeof(error));\n\n    if (!ipv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown firewall layer %d\"),\n                       layer);\n        goto cleanup;\n    }\n\n    if (virDBusCallMethod(sysbus,\n                          &reply,\n                          &error,\n                          VIR_FIREWALL_FIREWALLD_SERVICE,\n                          \"/org/fedoraproject/FirewallD1\",\n                          \"org.fedoraproject.FirewallD1.direct\",\n                          \"passthrough\",\n                          \"sa&s\",\n                          ipv,\n                          (int)argsLen,\n                          args) < 0)\n        goto cleanup;\n\n    if (error.level == VIR_ERR_ERROR) {\n        /*\n         * As of firewalld-0.3.9.3-1.fc20.noarch the name and\n         * message fields in the error look like\n         *\n         *    name=\"org.freedesktop.DBus.Python.dbus.exceptions.DBusException\"\n         * message=\"COMMAND_FAILED: '/sbin/iptables --table filter --delete\n         *          INPUT --in-interface virbr0 --protocol udp --destination-port 53\n         *          --jump ACCEPT' failed: iptables: Bad rule (does a matching rule\n         *          exist in that chain?).\"\n         *\n         * We'd like to only ignore DBus errors precisely related to the failure\n         * of iptables/ebtables commands. A well designed DBus interface would\n         * return specific named exceptions not the top level generic python dbus\n         * exception name. With this current scheme our only option is todo a\n         * sub-string match for 'COMMAND_FAILED' on the message. eg like\n         *\n         * if (ignoreErrors &&\n         *     STREQ(error.name,\n         *           \"org.freedesktop.DBus.Python.dbus.exceptions.DBusException\") &&\n         *     STRPREFIX(error.message, \"COMMAND_FAILED\"))\n         *    ...\n         *\n         * But this risks our error detecting code being broken if firewalld changes\n         * ever alter the message string, so we're avoiding doing that.\n         */\n        if (ignoreErrors) {\n            VIR_DEBUG(\"Ignoring error '%s': '%s'\",\n                      error.str1, error.message);\n        } else {\n            virReportErrorObject(&error);\n            goto cleanup;\n        }\n    } else {\n        if (virDBusMessageDecode(reply, \"s\", output) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virResetError(&error);\n    virDBusMessageUnref(reply);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvirFirewallApplyRuleFirewallD(virFirewallRulePtr rule,\n                              bool ignoreErrors,\n                              char **output)\n{\n    /* wrapper necessary because virFirewallRule is a private struct */\n    return virFirewallDApplyRule(rule->layer, rule->args, rule->argsLen, ignoreErrors, output);\n}"
  },
  {
    "function_name": "virFirewallApplyRuleDirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "656-699",
    "snippet": "static int\nvirFirewallApplyRuleDirect(virFirewallRulePtr rule,\n                           bool ignoreErrors,\n                           char **output)\n{\n    size_t i;\n    const char *bin = virFirewallLayerCommandTypeToString(rule->layer);\n    g_autoptr(virCommand) cmd = NULL;\n    int status;\n    g_autofree char *error = NULL;\n\n    if (!bin) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown firewall layer %d\"),\n                       rule->layer);\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(bin, NULL);\n\n    for (i = 0; i < rule->argsLen; i++)\n        virCommandAddArg(cmd, rule->args[i]);\n\n    virCommandSetOutputBuffer(cmd, output);\n    virCommandSetErrorBuffer(cmd, &error);\n\n    if (virCommandRun(cmd, &status) < 0)\n        return -1;\n\n    if (status != 0) {\n        if (ignoreErrors) {\n            VIR_DEBUG(\"Ignoring error running command\");\n        } else {\n            g_autofree char *args = virCommandToString(cmd, false);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to apply firewall rules %s: %s\"),\n                           NULLSTR(args), NULLSTR(error));\n            VIR_FREE(*output);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*output"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to apply firewall rules %s: %s\")",
            "NULLSTR(args)",
            "NULLSTR(error)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "error"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "args"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to apply firewall rules %s: %s\""
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandToString",
          "args": [
            "cmd",
            "false"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2082-2135",
          "snippet": "char *\nvirCommandToString(virCommandPtr cmd, bool linebreaks)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool prevopt = false;\n\n    /* Cannot assume virCommandRun will be called; so report the error\n     * now.  If virCommandRun is called, it will report the same error. */\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return NULL;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return NULL;\n    }\n\n    for (i = 0; i < cmd->nenv; i++) {\n        /* In shell, a='b c' has a different meaning than 'a=b c', so\n         * we must determine where the '=' lives.  */\n        char *eq = strchr(cmd->env[i], '=');\n\n        if (!eq) {\n            virBufferFreeAndReset(&buf);\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid use of command API\"));\n            return NULL;\n        }\n        eq++;\n        virBufferAdd(&buf, cmd->env[i], eq - cmd->env[i]);\n        virBufferEscapeShell(&buf, eq);\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks)\n            virBufferAddLit(&buf, \"\\\\\\n\");\n    }\n    virBufferEscapeShell(&buf, cmd->args[0]);\n    for (i = 1; i < cmd->nargs; i++) {\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks) {\n            /* Line break if this is a --arg or if\n             * the previous arg was a positional option\n             */\n            if (cmd->args[i][0] == '-' ||\n                !prevopt)\n                virBufferAddLit(&buf, \"\\\\\\n\");\n        }\n        virBufferEscapeShell(&buf, cmd->args[i]);\n        prevopt = (cmd->args[i][0] == '-');\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nchar *\nvirCommandToString(virCommandPtr cmd, bool linebreaks)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool prevopt = false;\n\n    /* Cannot assume virCommandRun will be called; so report the error\n     * now.  If virCommandRun is called, it will report the same error. */\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return NULL;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return NULL;\n    }\n\n    for (i = 0; i < cmd->nenv; i++) {\n        /* In shell, a='b c' has a different meaning than 'a=b c', so\n         * we must determine where the '=' lives.  */\n        char *eq = strchr(cmd->env[i], '=');\n\n        if (!eq) {\n            virBufferFreeAndReset(&buf);\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid use of command API\"));\n            return NULL;\n        }\n        eq++;\n        virBufferAdd(&buf, cmd->env[i], eq - cmd->env[i]);\n        virBufferEscapeShell(&buf, eq);\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks)\n            virBufferAddLit(&buf, \"\\\\\\n\");\n    }\n    virBufferEscapeShell(&buf, cmd->args[0]);\n    for (i = 1; i < cmd->nargs; i++) {\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks) {\n            /* Line break if this is a --arg or if\n             * the previous arg was a positional option\n             */\n            if (cmd->args[i][0] == '-' ||\n                !prevopt)\n                virBufferAddLit(&buf, \"\\\\\\n\");\n        }\n        virBufferEscapeShell(&buf, cmd->args[i]);\n        prevopt = (cmd->args[i][0] == '-');\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Ignoring error running command\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "&status"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetErrorBuffer",
          "args": [
            "cmd",
            "&error"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetErrorBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1903-1918",
          "snippet": "void\nvirCommandSetErrorBuffer(virCommandPtr cmd, char **errbuf)\n{\n    *errbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errbuf = errbuf;\n    cmd->errfdptr = &cmd->errfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetErrorBuffer(virCommandPtr cmd, char **errbuf)\n{\n    *errbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errbuf = errbuf;\n    cmd->errfdptr = &cmd->errfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "output"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "rule->args[i]"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "bin",
            "NULL"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown firewall layer %d\")",
            "rule->layer"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallLayerCommandTypeToString",
          "args": [
            "rule->layer"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvirFirewallApplyRuleDirect(virFirewallRulePtr rule,\n                           bool ignoreErrors,\n                           char **output)\n{\n    size_t i;\n    const char *bin = virFirewallLayerCommandTypeToString(rule->layer);\n    g_autoptr(virCommand) cmd = NULL;\n    int status;\n    g_autofree char *error = NULL;\n\n    if (!bin) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown firewall layer %d\"),\n                       rule->layer);\n        return -1;\n    }\n\n    cmd = virCommandNewArgList(bin, NULL);\n\n    for (i = 0; i < rule->argsLen; i++)\n        virCommandAddArg(cmd, rule->args[i]);\n\n    virCommandSetOutputBuffer(cmd, output);\n    virCommandSetErrorBuffer(cmd, &error);\n\n    if (virCommandRun(cmd, &status) < 0)\n        return -1;\n\n    if (status != 0) {\n        if (ignoreErrors) {\n            VIR_DEBUG(\"Ignoring error running command\");\n        } else {\n            g_autofree char *args = virCommandToString(cmd, false);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to apply firewall rules %s: %s\"),\n                           NULLSTR(args), NULLSTR(error));\n            VIR_FREE(*output);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virFirewallRuleToString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "640-654",
    "snippet": "static char *\nvirFirewallRuleToString(virFirewallRulePtr rule)\n{\n    const char *bin = virFirewallLayerCommandTypeToString(rule->layer);\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    virBufferAdd(&buf, bin, -1);\n    for (i = 0; i < rule->argsLen; i++) {\n        virBufferAddLit(&buf, \" \");\n        virBufferAdd(&buf, rule->args[i], -1);\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "&buf",
            "rule->args[i]",
            "-1"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\" \""
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallLayerCommandTypeToString",
          "args": [
            "rule->layer"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *\nvirFirewallRuleToString(virFirewallRulePtr rule)\n{\n    const char *bin = virFirewallLayerCommandTypeToString(rule->layer);\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n\n    virBufferAdd(&buf, bin, -1);\n    for (i = 0; i < rule->argsLen; i++) {\n        virBufferAddLit(&buf, \" \");\n        virBufferAdd(&buf, rule->args[i], -1);\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "virFirewallStartRollback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "622-637",
    "snippet": "void virFirewallStartRollback(virFirewallPtr firewall,\n                              unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (firewall->ngroups == 0) {\n        firewall->err = EINVAL;\n        return;\n    }\n\n    group = firewall->groups[firewall->ngroups-1];\n    group->rollbackFlags = flags;\n    group->addingRollback = true;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FIREWALL_RETURN_IF_ERROR",
          "args": [
            "firewall"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartRollback(virFirewallPtr firewall,\n                              unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (firewall->ngroups == 0) {\n        firewall->err = EINVAL;\n        return;\n    }\n\n    group = firewall->groups[firewall->ngroups-1];\n    group->rollbackFlags = flags;\n    group->addingRollback = true;\n}"
  },
  {
    "function_name": "virFirewallStartTransaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "586-607",
    "snippet": "void virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallGroupFree",
          "args": [
            "group"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallGroupFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "260-277",
          "snippet": "static void\nvirFirewallGroupFree(virFirewallGroupPtr group)\n{\n    size_t i;\n\n    if (!group)\n        return;\n\n    for (i = 0; i < group->naction; i++)\n        virFirewallRuleFree(group->action[i]);\n    VIR_FREE(group->action);\n\n    for (i = 0; i < group->nrollback; i++)\n        virFirewallRuleFree(group->rollback[i]);\n    VIR_FREE(group->rollback);\n\n    VIR_FREE(group);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nvirFirewallGroupFree(virFirewallGroupPtr group)\n{\n    size_t i;\n\n    if (!group)\n        return;\n\n    for (i = 0; i < group->naction; i++)\n        virFirewallRuleFree(group->action[i]);\n    VIR_FREE(group->action);\n\n    for (i = 0; i < group->nrollback; i++)\n        virFirewallRuleFree(group->rollback[i]);\n    VIR_FREE(group->rollback);\n\n    VIR_FREE(group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "firewall->groups",
            "firewall->ngroups",
            "1"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallGroupNew",
          "args": [],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallGroupNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "209-218",
          "snippet": "static virFirewallGroupPtr\nvirFirewallGroupNew(void)\n{\n    virFirewallGroupPtr group;\n\n    if (VIR_ALLOC(group) < 0)\n        return NULL;\n\n    return group;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallGroupPtr\nvirFirewallGroupNew(void)\n{\n    virFirewallGroupPtr group;\n\n    if (VIR_ALLOC(group) < 0)\n        return NULL;\n\n    return group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FIREWALL_RETURN_IF_ERROR",
          "args": [
            "firewall"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallStartTransaction(virFirewallPtr firewall,\n                                 unsigned int flags)\n{\n    virFirewallGroupPtr group;\n\n    VIR_FIREWALL_RETURN_IF_ERROR(firewall);\n\n    if (!(group = virFirewallGroupNew())) {\n        firewall->err = ENOMEM;\n        return;\n    }\n    group->actionFlags = flags;\n\n    if (VIR_EXPAND_N(firewall->groups,\n                     firewall->ngroups, 1) < 0) {\n        firewall->err = ENOMEM;\n        virFirewallGroupFree(group);\n        return;\n    }\n    firewall->groups[firewall->ngroups - 1] = group;\n    firewall->currentGroup = firewall->ngroups - 1;\n}"
  },
  {
    "function_name": "virFirewallRuleGetArgCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "565-570",
    "snippet": "size_t virFirewallRuleGetArgCount(virFirewallRulePtr rule)\n{\n    if (!rule)\n        return 0;\n    return rule->argsLen;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nsize_t virFirewallRuleGetArgCount(virFirewallRulePtr rule)\n{\n    if (!rule)\n        return 0;\n    return rule->argsLen;\n}"
  },
  {
    "function_name": "virFirewallRuleAddArgList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "541-562",
    "snippet": "void virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "list"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "list"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_ARG",
          "args": [
            "rule",
            "str"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "list",
            "char*"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "list",
            "rule"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FIREWALL_RULE_RETURN_IF_ERROR",
          "args": [
            "firewall",
            "rule"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgList(virFirewallPtr firewall,\n                               virFirewallRulePtr rule,\n                               ...)\n{\n    va_list list;\n    const char *str;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, rule);\n\n    while ((str = va_arg(list, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    va_end(list);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n    va_end(list);\n}"
  },
  {
    "function_name": "virFirewallRuleAddArgSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "523-538",
    "snippet": "void virFirewallRuleAddArgSet(virFirewallPtr firewall,\n                              virFirewallRulePtr rule,\n                              const char *const *args)\n{\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    while (*args) {\n        ADD_ARG(rule, *args);\n        args++;\n    }\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADD_ARG",
          "args": [
            "rule",
            "*args"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FIREWALL_RULE_RETURN_IF_ERROR",
          "args": [
            "firewall",
            "rule"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgSet(virFirewallPtr firewall,\n                              virFirewallRulePtr rule,\n                              const char *const *args)\n{\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    while (*args) {\n        ADD_ARG(rule, *args);\n        args++;\n    }\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}"
  },
  {
    "function_name": "virFirewallRuleAddArgFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "501-520",
    "snippet": "void virFirewallRuleAddArgFormat(virFirewallPtr firewall,\n                                 virFirewallRulePtr rule,\n                                 const char *fmt, ...)\n{\n    g_autofree char *arg = NULL;\n    va_list list;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, fmt);\n    arg = g_strdup_vprintf(fmt, list);\n    va_end(list);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADD_ARG",
          "args": [
            "rule",
            "arg"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "list"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_vprintf",
          "args": [
            "fmt",
            "list"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_vprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "205-213",
          "snippet": "char *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "list",
            "fmt"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FIREWALL_RULE_RETURN_IF_ERROR",
          "args": [
            "firewall",
            "rule"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArgFormat(virFirewallPtr firewall,\n                                 virFirewallRulePtr rule,\n                                 const char *fmt, ...)\n{\n    g_autofree char *arg = NULL;\n    va_list list;\n\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    va_start(list, fmt);\n    arg = g_strdup_vprintf(fmt, list);\n    va_end(list);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}"
  },
  {
    "function_name": "virFirewallRuleAddArg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "486-498",
    "snippet": "void virFirewallRuleAddArg(virFirewallPtr firewall,\n                           virFirewallRulePtr rule,\n                           const char *arg)\n{\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ADD_ARG",
          "args": [
            "rule",
            "arg"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FIREWALL_RULE_RETURN_IF_ERROR",
          "args": [
            "firewall",
            "rule"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRuleAddArg(virFirewallPtr firewall,\n                           virFirewallRulePtr rule,\n                           const char *arg)\n{\n    VIR_FIREWALL_RULE_RETURN_IF_ERROR(firewall, rule);\n\n    ADD_ARG(rule, arg);\n\n    return;\n\n no_memory:\n    firewall->err = ENOMEM;\n}"
  },
  {
    "function_name": "virFirewallRemoveRule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "444-483",
    "snippet": "void virFirewallRemoveRule(virFirewallPtr firewall,\n                           virFirewallRulePtr rule)\n{\n    size_t i;\n    virFirewallGroupPtr group;\n\n    /* Explicitly not checking firewall->err too,\n     * because if rule was partially created\n     * before hitting error we must still remove\n     * it to avoid leaking 'rule'\n     */\n    if (!firewall)\n        return;\n\n    if (firewall->ngroups == 0)\n        return;\n    group = firewall->groups[firewall->currentGroup];\n\n    if (group->addingRollback) {\n        for (i = 0; i < group->nrollback; i++) {\n            if (group->rollback[i] == rule) {\n                VIR_DELETE_ELEMENT(group->rollback,\n                                   i,\n                                   group->nrollback);\n                virFirewallRuleFree(rule);\n                break;\n            }\n        }\n    } else {\n        for (i = 0; i < group->naction; i++) {\n            if (group->action[i] == rule) {\n                VIR_DELETE_ELEMENT(group->action,\n                                   i,\n                                   group->naction);\n                virFirewallRuleFree(rule);\n                return;\n            }\n        }\n    }\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallRuleFree",
          "args": [
            "rule"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "245-257",
          "snippet": "static void\nvirFirewallRuleFree(virFirewallRulePtr rule)\n{\n    size_t i;\n\n    if (!rule)\n        return;\n\n    for (i = 0; i < rule->argsLen; i++)\n        VIR_FREE(rule->args[i]);\n    VIR_FREE(rule->args);\n    VIR_FREE(rule);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nvirFirewallRuleFree(virFirewallRulePtr rule)\n{\n    size_t i;\n\n    if (!rule)\n        return;\n\n    for (i = 0; i < rule->argsLen; i++)\n        VIR_FREE(rule->args[i]);\n    VIR_FREE(rule->args);\n    VIR_FREE(rule);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "group->action",
            "i",
            "group->naction"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "group->rollback",
            "i",
            "group->nrollback"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallRemoveRule(virFirewallPtr firewall,\n                           virFirewallRulePtr rule)\n{\n    size_t i;\n    virFirewallGroupPtr group;\n\n    /* Explicitly not checking firewall->err too,\n     * because if rule was partially created\n     * before hitting error we must still remove\n     * it to avoid leaking 'rule'\n     */\n    if (!firewall)\n        return;\n\n    if (firewall->ngroups == 0)\n        return;\n    group = firewall->groups[firewall->currentGroup];\n\n    if (group->addingRollback) {\n        for (i = 0; i < group->nrollback; i++) {\n            if (group->rollback[i] == rule) {\n                VIR_DELETE_ELEMENT(group->rollback,\n                                   i,\n                                   group->nrollback);\n                virFirewallRuleFree(rule);\n                break;\n            }\n        }\n    } else {\n        for (i = 0; i < group->naction; i++) {\n            if (group->action[i] == rule) {\n                VIR_DELETE_ELEMENT(group->action,\n                                   i,\n                                   group->naction);\n                virFirewallRuleFree(rule);\n                return;\n            }\n        }\n    }\n}"
  },
  {
    "function_name": "virFirewallAddRuleFull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "421-434",
    "snippet": "virFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallAddRuleFullV",
          "args": [
            "firewall",
            "layer",
            "ignoreErrors",
            "cb",
            "opaque",
            "args"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallAddRuleFullV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "328-396",
          "snippet": "static virFirewallRulePtr\nvirFirewallAddRuleFullV(virFirewallPtr firewall,\n                        virFirewallLayer layer,\n                        bool ignoreErrors,\n                        virFirewallQueryCallback cb,\n                        void *opaque,\n                        va_list args)\n{\n    virFirewallGroupPtr group;\n    virFirewallRulePtr rule;\n    char *str;\n\n    VIR_FIREWALL_RETURN_NULL_IF_ERROR(firewall);\n\n    if (firewall->ngroups == 0) {\n        firewall->err = EINVAL;\n        return NULL;\n    }\n    group = firewall->groups[firewall->currentGroup];\n\n\n    if (VIR_ALLOC(rule) < 0)\n        goto no_memory;\n\n    rule->layer = layer;\n    rule->queryCB = cb;\n    rule->queryOpaque = opaque;\n    rule->ignoreErrors = ignoreErrors;\n\n    switch (rule->layer) {\n    case VIR_FIREWALL_LAYER_ETHERNET:\n        if (ebtablesUseLock)\n            ADD_ARG(rule, \"--concurrent\");\n        break;\n    case VIR_FIREWALL_LAYER_IPV4:\n        if (iptablesUseLock)\n            ADD_ARG(rule, \"-w\");\n        break;\n    case VIR_FIREWALL_LAYER_IPV6:\n        if (ip6tablesUseLock)\n            ADD_ARG(rule, \"-w\");\n        break;\n    case VIR_FIREWALL_LAYER_LAST:\n        break;\n    }\n\n    while ((str = va_arg(args, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    if (group->addingRollback) {\n        if (VIR_APPEND_ELEMENT_COPY(group->rollback,\n                                    group->nrollback,\n                                    rule) < 0)\n            goto no_memory;\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(group->action,\n                                    group->naction,\n                                    rule) < 0)\n            goto no_memory;\n    }\n\n\n    return rule;\n\n no_memory:\n    firewall->err = ENOMEM;\n    virFirewallRuleFree(rule);\n    return NULL;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool iptablesUseLock;",
            "static bool ip6tablesUseLock;",
            "static bool ebtablesUseLock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool iptablesUseLock;\nstatic bool ip6tablesUseLock;\nstatic bool ebtablesUseLock;\n\nstatic virFirewallRulePtr\nvirFirewallAddRuleFullV(virFirewallPtr firewall,\n                        virFirewallLayer layer,\n                        bool ignoreErrors,\n                        virFirewallQueryCallback cb,\n                        void *opaque,\n                        va_list args)\n{\n    virFirewallGroupPtr group;\n    virFirewallRulePtr rule;\n    char *str;\n\n    VIR_FIREWALL_RETURN_NULL_IF_ERROR(firewall);\n\n    if (firewall->ngroups == 0) {\n        firewall->err = EINVAL;\n        return NULL;\n    }\n    group = firewall->groups[firewall->currentGroup];\n\n\n    if (VIR_ALLOC(rule) < 0)\n        goto no_memory;\n\n    rule->layer = layer;\n    rule->queryCB = cb;\n    rule->queryOpaque = opaque;\n    rule->ignoreErrors = ignoreErrors;\n\n    switch (rule->layer) {\n    case VIR_FIREWALL_LAYER_ETHERNET:\n        if (ebtablesUseLock)\n            ADD_ARG(rule, \"--concurrent\");\n        break;\n    case VIR_FIREWALL_LAYER_IPV4:\n        if (iptablesUseLock)\n            ADD_ARG(rule, \"-w\");\n        break;\n    case VIR_FIREWALL_LAYER_IPV6:\n        if (ip6tablesUseLock)\n            ADD_ARG(rule, \"-w\");\n        break;\n    case VIR_FIREWALL_LAYER_LAST:\n        break;\n    }\n\n    while ((str = va_arg(args, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    if (group->addingRollback) {\n        if (VIR_APPEND_ELEMENT_COPY(group->rollback,\n                                    group->nrollback,\n                                    rule) < 0)\n            goto no_memory;\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(group->action,\n                                    group->naction,\n                                    rule) < 0)\n            goto no_memory;\n    }\n\n\n    return rule;\n\n no_memory:\n    firewall->err = ENOMEM;\n    virFirewallRuleFree(rule);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "opaque"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallRulePtr virFirewallAddRuleFull(virFirewallPtr firewall,\n                                          virFirewallLayer layer,\n                                          bool ignoreErrors,\n                                          virFirewallQueryCallback cb,\n                                          void *opaque,\n                                          ...)\n{\n    virFirewallRulePtr rule;\n    va_list args;\n    va_start(args, opaque);\n    rule = virFirewallAddRuleFullV(firewall, layer, ignoreErrors, cb, opaque, args);\n    va_end(args);\n    return rule;\n}"
  },
  {
    "function_name": "virFirewallAddRuleFullV",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "328-396",
    "snippet": "static virFirewallRulePtr\nvirFirewallAddRuleFullV(virFirewallPtr firewall,\n                        virFirewallLayer layer,\n                        bool ignoreErrors,\n                        virFirewallQueryCallback cb,\n                        void *opaque,\n                        va_list args)\n{\n    virFirewallGroupPtr group;\n    virFirewallRulePtr rule;\n    char *str;\n\n    VIR_FIREWALL_RETURN_NULL_IF_ERROR(firewall);\n\n    if (firewall->ngroups == 0) {\n        firewall->err = EINVAL;\n        return NULL;\n    }\n    group = firewall->groups[firewall->currentGroup];\n\n\n    if (VIR_ALLOC(rule) < 0)\n        goto no_memory;\n\n    rule->layer = layer;\n    rule->queryCB = cb;\n    rule->queryOpaque = opaque;\n    rule->ignoreErrors = ignoreErrors;\n\n    switch (rule->layer) {\n    case VIR_FIREWALL_LAYER_ETHERNET:\n        if (ebtablesUseLock)\n            ADD_ARG(rule, \"--concurrent\");\n        break;\n    case VIR_FIREWALL_LAYER_IPV4:\n        if (iptablesUseLock)\n            ADD_ARG(rule, \"-w\");\n        break;\n    case VIR_FIREWALL_LAYER_IPV6:\n        if (ip6tablesUseLock)\n            ADD_ARG(rule, \"-w\");\n        break;\n    case VIR_FIREWALL_LAYER_LAST:\n        break;\n    }\n\n    while ((str = va_arg(args, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    if (group->addingRollback) {\n        if (VIR_APPEND_ELEMENT_COPY(group->rollback,\n                                    group->nrollback,\n                                    rule) < 0)\n            goto no_memory;\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(group->action,\n                                    group->naction,\n                                    rule) < 0)\n            goto no_memory;\n    }\n\n\n    return rule;\n\n no_memory:\n    firewall->err = ENOMEM;\n    virFirewallRuleFree(rule);\n    return NULL;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool iptablesUseLock;",
      "static bool ip6tablesUseLock;",
      "static bool ebtablesUseLock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallRuleFree",
          "args": [
            "rule"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "245-257",
          "snippet": "static void\nvirFirewallRuleFree(virFirewallRulePtr rule)\n{\n    size_t i;\n\n    if (!rule)\n        return;\n\n    for (i = 0; i < rule->argsLen; i++)\n        VIR_FREE(rule->args[i]);\n    VIR_FREE(rule->args);\n    VIR_FREE(rule);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nvirFirewallRuleFree(virFirewallRulePtr rule)\n{\n    size_t i;\n\n    if (!rule)\n        return;\n\n    for (i = 0; i < rule->argsLen; i++)\n        VIR_FREE(rule->args[i]);\n    VIR_FREE(rule->args);\n    VIR_FREE(rule);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT_COPY",
          "args": [
            "group->action",
            "group->naction",
            "rule"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT_COPY",
          "args": [
            "group->rollback",
            "group->nrollback",
            "rule"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_ARG",
          "args": [
            "rule",
            "str"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "char*"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_ARG",
          "args": [
            "rule",
            "\"-w\""
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_ARG",
          "args": [
            "rule",
            "\"-w\""
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADD_ARG",
          "args": [
            "rule",
            "\"--concurrent\""
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "rule"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FIREWALL_RETURN_NULL_IF_ERROR",
          "args": [
            "firewall"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool iptablesUseLock;\nstatic bool ip6tablesUseLock;\nstatic bool ebtablesUseLock;\n\nstatic virFirewallRulePtr\nvirFirewallAddRuleFullV(virFirewallPtr firewall,\n                        virFirewallLayer layer,\n                        bool ignoreErrors,\n                        virFirewallQueryCallback cb,\n                        void *opaque,\n                        va_list args)\n{\n    virFirewallGroupPtr group;\n    virFirewallRulePtr rule;\n    char *str;\n\n    VIR_FIREWALL_RETURN_NULL_IF_ERROR(firewall);\n\n    if (firewall->ngroups == 0) {\n        firewall->err = EINVAL;\n        return NULL;\n    }\n    group = firewall->groups[firewall->currentGroup];\n\n\n    if (VIR_ALLOC(rule) < 0)\n        goto no_memory;\n\n    rule->layer = layer;\n    rule->queryCB = cb;\n    rule->queryOpaque = opaque;\n    rule->ignoreErrors = ignoreErrors;\n\n    switch (rule->layer) {\n    case VIR_FIREWALL_LAYER_ETHERNET:\n        if (ebtablesUseLock)\n            ADD_ARG(rule, \"--concurrent\");\n        break;\n    case VIR_FIREWALL_LAYER_IPV4:\n        if (iptablesUseLock)\n            ADD_ARG(rule, \"-w\");\n        break;\n    case VIR_FIREWALL_LAYER_IPV6:\n        if (ip6tablesUseLock)\n            ADD_ARG(rule, \"-w\");\n        break;\n    case VIR_FIREWALL_LAYER_LAST:\n        break;\n    }\n\n    while ((str = va_arg(args, char *)) != NULL)\n        ADD_ARG(rule, str);\n\n    if (group->addingRollback) {\n        if (VIR_APPEND_ELEMENT_COPY(group->rollback,\n                                    group->nrollback,\n                                    rule) < 0)\n            goto no_memory;\n    } else {\n        if (VIR_APPEND_ELEMENT_COPY(group->action,\n                                    group->naction,\n                                    rule) < 0)\n            goto no_memory;\n    }\n\n\n    return rule;\n\n no_memory:\n    firewall->err = ENOMEM;\n    virFirewallRuleFree(rule);\n    return NULL;\n}"
  },
  {
    "function_name": "virFirewallFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "286-298",
    "snippet": "void virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "firewall"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "firewall->groups"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallGroupFree",
          "args": [
            "firewall->groups[i]"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallGroupFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "260-277",
          "snippet": "static void\nvirFirewallGroupFree(virFirewallGroupPtr group)\n{\n    size_t i;\n\n    if (!group)\n        return;\n\n    for (i = 0; i < group->naction; i++)\n        virFirewallRuleFree(group->action[i]);\n    VIR_FREE(group->action);\n\n    for (i = 0; i < group->nrollback; i++)\n        virFirewallRuleFree(group->rollback[i]);\n    VIR_FREE(group->rollback);\n\n    VIR_FREE(group);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nvirFirewallGroupFree(virFirewallGroupPtr group)\n{\n    size_t i;\n\n    if (!group)\n        return;\n\n    for (i = 0; i < group->naction; i++)\n        virFirewallRuleFree(group->action[i]);\n    VIR_FREE(group->action);\n\n    for (i = 0; i < group->nrollback; i++)\n        virFirewallRuleFree(group->rollback[i]);\n    VIR_FREE(group->rollback);\n\n    VIR_FREE(group);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virFirewallFree(virFirewallPtr firewall)\n{\n    size_t i;\n\n    if (!firewall)\n        return;\n\n    for (i = 0; i < firewall->ngroups; i++)\n        virFirewallGroupFree(firewall->groups[i]);\n    VIR_FREE(firewall->groups);\n\n    VIR_FREE(firewall);\n}"
  },
  {
    "function_name": "virFirewallGroupFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "260-277",
    "snippet": "static void\nvirFirewallGroupFree(virFirewallGroupPtr group)\n{\n    size_t i;\n\n    if (!group)\n        return;\n\n    for (i = 0; i < group->naction; i++)\n        virFirewallRuleFree(group->action[i]);\n    VIR_FREE(group->action);\n\n    for (i = 0; i < group->nrollback; i++)\n        virFirewallRuleFree(group->rollback[i]);\n    VIR_FREE(group->rollback);\n\n    VIR_FREE(group);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "group"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "group->rollback"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallRuleFree",
          "args": [
            "group->rollback[i]"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallRuleFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "245-257",
          "snippet": "static void\nvirFirewallRuleFree(virFirewallRulePtr rule)\n{\n    size_t i;\n\n    if (!rule)\n        return;\n\n    for (i = 0; i < rule->argsLen; i++)\n        VIR_FREE(rule->args[i]);\n    VIR_FREE(rule->args);\n    VIR_FREE(rule);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nvirFirewallRuleFree(virFirewallRulePtr rule)\n{\n    size_t i;\n\n    if (!rule)\n        return;\n\n    for (i = 0; i < rule->argsLen; i++)\n        VIR_FREE(rule->args[i]);\n    VIR_FREE(rule->args);\n    VIR_FREE(rule);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "group->action"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nvirFirewallGroupFree(virFirewallGroupPtr group)\n{\n    size_t i;\n\n    if (!group)\n        return;\n\n    for (i = 0; i < group->naction; i++)\n        virFirewallRuleFree(group->action[i]);\n    VIR_FREE(group->action);\n\n    for (i = 0; i < group->nrollback; i++)\n        virFirewallRuleFree(group->rollback[i]);\n    VIR_FREE(group->rollback);\n\n    VIR_FREE(group);\n}"
  },
  {
    "function_name": "virFirewallRuleFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "245-257",
    "snippet": "static void\nvirFirewallRuleFree(virFirewallRulePtr rule)\n{\n    size_t i;\n\n    if (!rule)\n        return;\n\n    for (i = 0; i < rule->argsLen; i++)\n        VIR_FREE(rule->args[i]);\n    VIR_FREE(rule->args);\n    VIR_FREE(rule);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "rule"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "rule->args"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "rule->args[i]"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nvirFirewallRuleFree(virFirewallRulePtr rule)\n{\n    size_t i;\n\n    if (!rule)\n        return;\n\n    for (i = 0; i < rule->argsLen; i++)\n        VIR_FREE(rule->args[i]);\n    VIR_FREE(rule->args);\n    VIR_FREE(rule);\n}"
  },
  {
    "function_name": "virFirewallNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "231-242",
    "snippet": "virFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "firewall"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallInitialize",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirFirewallPtr virFirewallNew(void)\n{\n    virFirewallPtr firewall;\n\n    if (virFirewallInitialize() < 0)\n        return NULL;\n\n    if (VIR_ALLOC(firewall) < 0)\n        return NULL;\n\n    return firewall;\n}"
  },
  {
    "function_name": "virFirewallGroupNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "209-218",
    "snippet": "static virFirewallGroupPtr\nvirFirewallGroupNew(void)\n{\n    virFirewallGroupPtr group;\n\n    if (VIR_ALLOC(group) < 0)\n        return NULL;\n\n    return group;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "group"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallGroupPtr\nvirFirewallGroupNew(void)\n{\n    virFirewallGroupPtr group;\n\n    if (VIR_ALLOC(group) < 0)\n        return NULL;\n\n    return group;\n}"
  },
  {
    "function_name": "virFirewallSetBackend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "198-207",
    "snippet": "int\nvirFirewallSetBackend(virFirewallBackend backend)\n{\n    currentBackend = backend;\n\n    if (virFirewallInitialize() < 0)\n        return -1;\n\n    return virFirewallValidateBackend(backend);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
      "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallValidateBackend",
          "args": [
            "backend"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallValidateBackend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "146-196",
          "snippet": "static int\nvirFirewallValidateBackend(virFirewallBackend backend)\n{\n    VIR_DEBUG(\"Validating backend %d\", backend);\n    if (backend == VIR_FIREWALL_BACKEND_AUTOMATIC ||\n        backend == VIR_FIREWALL_BACKEND_FIREWALLD) {\n        int rv = virFirewallDIsRegistered();\n\n        VIR_DEBUG(\"Firewalld is registered ? %d\", rv);\n        if (rv < 0) {\n            if (rv == -2) {\n                if (backend == VIR_FIREWALL_BACKEND_FIREWALLD) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"firewalld firewall backend requested, but service is not running\"));\n                    return -1;\n                } else {\n                    VIR_DEBUG(\"firewalld service not running, trying direct backend\");\n                    backend = VIR_FIREWALL_BACKEND_DIRECT;\n                }\n            } else {\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"firewalld service running, using firewalld backend\");\n            backend = VIR_FIREWALL_BACKEND_FIREWALLD;\n        }\n    }\n\n    if (backend == VIR_FIREWALL_BACKEND_DIRECT) {\n        const char *commands[] = {\n            IPTABLES_PATH, IP6TABLES_PATH, EBTABLES_PATH\n        };\n        size_t i;\n\n        for (i = 0; i < G_N_ELEMENTS(commands); i++) {\n            if (!virFileIsExecutable(commands[i])) {\n                virReportSystemError(errno,\n                                     _(\"direct firewall backend requested, but %s is not available\"),\n                                     commands[i]);\n                return -1;\n            }\n        }\n        VIR_DEBUG(\"found iptables/ip6tables/ebtables, using direct backend\");\n    }\n\n    currentBackend = backend;\n\n    virFirewallCheckUpdateLocking();\n\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
            "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend)\n{\n    VIR_DEBUG(\"Validating backend %d\", backend);\n    if (backend == VIR_FIREWALL_BACKEND_AUTOMATIC ||\n        backend == VIR_FIREWALL_BACKEND_FIREWALLD) {\n        int rv = virFirewallDIsRegistered();\n\n        VIR_DEBUG(\"Firewalld is registered ? %d\", rv);\n        if (rv < 0) {\n            if (rv == -2) {\n                if (backend == VIR_FIREWALL_BACKEND_FIREWALLD) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"firewalld firewall backend requested, but service is not running\"));\n                    return -1;\n                } else {\n                    VIR_DEBUG(\"firewalld service not running, trying direct backend\");\n                    backend = VIR_FIREWALL_BACKEND_DIRECT;\n                }\n            } else {\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"firewalld service running, using firewalld backend\");\n            backend = VIR_FIREWALL_BACKEND_FIREWALLD;\n        }\n    }\n\n    if (backend == VIR_FIREWALL_BACKEND_DIRECT) {\n        const char *commands[] = {\n            IPTABLES_PATH, IP6TABLES_PATH, EBTABLES_PATH\n        };\n        size_t i;\n\n        for (i = 0; i < G_N_ELEMENTS(commands); i++) {\n            if (!virFileIsExecutable(commands[i])) {\n                virReportSystemError(errno,\n                                     _(\"direct firewall backend requested, but %s is not available\"),\n                                     commands[i]);\n                return -1;\n            }\n        }\n        VIR_DEBUG(\"found iptables/ip6tables/ebtables, using direct backend\");\n    }\n\n    currentBackend = backend;\n\n    virFirewallCheckUpdateLocking();\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFirewallInitialize",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nint\nvirFirewallSetBackend(virFirewallBackend backend)\n{\n    currentBackend = backend;\n\n    if (virFirewallInitialize() < 0)\n        return -1;\n\n    return virFirewallValidateBackend(backend);\n}"
  },
  {
    "function_name": "virFirewallValidateBackend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "146-196",
    "snippet": "static int\nvirFirewallValidateBackend(virFirewallBackend backend)\n{\n    VIR_DEBUG(\"Validating backend %d\", backend);\n    if (backend == VIR_FIREWALL_BACKEND_AUTOMATIC ||\n        backend == VIR_FIREWALL_BACKEND_FIREWALLD) {\n        int rv = virFirewallDIsRegistered();\n\n        VIR_DEBUG(\"Firewalld is registered ? %d\", rv);\n        if (rv < 0) {\n            if (rv == -2) {\n                if (backend == VIR_FIREWALL_BACKEND_FIREWALLD) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"firewalld firewall backend requested, but service is not running\"));\n                    return -1;\n                } else {\n                    VIR_DEBUG(\"firewalld service not running, trying direct backend\");\n                    backend = VIR_FIREWALL_BACKEND_DIRECT;\n                }\n            } else {\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"firewalld service running, using firewalld backend\");\n            backend = VIR_FIREWALL_BACKEND_FIREWALLD;\n        }\n    }\n\n    if (backend == VIR_FIREWALL_BACKEND_DIRECT) {\n        const char *commands[] = {\n            IPTABLES_PATH, IP6TABLES_PATH, EBTABLES_PATH\n        };\n        size_t i;\n\n        for (i = 0; i < G_N_ELEMENTS(commands); i++) {\n            if (!virFileIsExecutable(commands[i])) {\n                virReportSystemError(errno,\n                                     _(\"direct firewall backend requested, but %s is not available\"),\n                                     commands[i]);\n                return -1;\n            }\n        }\n        VIR_DEBUG(\"found iptables/ip6tables/ebtables, using direct backend\");\n    }\n\n    currentBackend = backend;\n\n    virFirewallCheckUpdateLocking();\n\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
      "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallCheckUpdateLocking",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallCheckUpdateLocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "124-144",
          "snippet": "static void\nvirFirewallCheckUpdateLocking(void)\n{\n    const char *iptablesArgs[] = {\n        IPTABLES_PATH, \"-w\", \"-L\", \"-n\", NULL,\n    };\n    const char *ip6tablesArgs[] = {\n        IP6TABLES_PATH, \"-w\", \"-L\", \"-n\", NULL,\n    };\n    const char *ebtablesArgs[] = {\n        EBTABLES_PATH, \"--concurrent\", \"-L\", NULL,\n    };\n    if (lockOverride)\n        return;\n    virFirewallCheckUpdateLock(&iptablesUseLock,\n                               iptablesArgs);\n    virFirewallCheckUpdateLock(&ip6tablesUseLock,\n                               ip6tablesArgs);\n    virFirewallCheckUpdateLock(&ebtablesUseLock,\n                               ebtablesArgs);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool iptablesUseLock;",
            "static bool ip6tablesUseLock;",
            "static bool ebtablesUseLock;",
            "static bool lockOverride;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool iptablesUseLock;\nstatic bool ip6tablesUseLock;\nstatic bool ebtablesUseLock;\nstatic bool lockOverride;\n\nstatic void\nvirFirewallCheckUpdateLocking(void)\n{\n    const char *iptablesArgs[] = {\n        IPTABLES_PATH, \"-w\", \"-L\", \"-n\", NULL,\n    };\n    const char *ip6tablesArgs[] = {\n        IP6TABLES_PATH, \"-w\", \"-L\", \"-n\", NULL,\n    };\n    const char *ebtablesArgs[] = {\n        EBTABLES_PATH, \"--concurrent\", \"-L\", NULL,\n    };\n    if (lockOverride)\n        return;\n    virFirewallCheckUpdateLock(&iptablesUseLock,\n                               iptablesArgs);\n    virFirewallCheckUpdateLock(&ip6tablesUseLock,\n                               ip6tablesArgs);\n    virFirewallCheckUpdateLock(&ebtablesUseLock,\n                               ebtablesArgs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"found iptables/ip6tables/ebtables, using direct backend\""
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"direct firewall backend requested, but %s is not available\")",
            "commands[i]"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"direct firewall backend requested, but %s is not available\""
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileIsExecutable",
          "args": [
            "commands[i]"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsExecutable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1886-1899",
          "snippet": "bool\nvirFileIsExecutable(const char *file)\n{\n    struct stat sb;\n\n    /* We would also want to check faccessat if we cared about ACLs,\n     * but we don't.  */\n    if (stat(file, &sb) < 0)\n        return false;\n    if (S_ISREG(sb.st_mode) && (sb.st_mode & 0111) != 0)\n        return true;\n    errno = S_ISDIR(sb.st_mode) ? EISDIR : EACCES;\n    return false;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileIsExecutable(const char *file)\n{\n    struct stat sb;\n\n    /* We would also want to check faccessat if we cared about ACLs,\n     * but we don't.  */\n    if (stat(file, &sb) < 0)\n        return false;\n    if (S_ISREG(sb.st_mode) && (sb.st_mode & 0111) != 0)\n        return true;\n    errno = S_ISDIR(sb.st_mode) ? EISDIR : EACCES;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "commands"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"firewalld service running, using firewalld backend\""
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"firewalld service not running, trying direct backend\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"firewalld firewall backend requested, but service is not running\")"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Firewalld is registered ? %d\"",
            "rv"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFirewallDIsRegistered",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallDIsRegistered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewalld.c",
          "lines": "66-70",
          "snippet": "int\nvirFirewallDIsRegistered(void)\n{\n    return virDBusIsServiceRegistered(VIR_FIREWALL_FIREWALLD_SERVICE);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalldpriv.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewall.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalldpriv.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewall.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirFirewallDIsRegistered(void)\n{\n    return virDBusIsServiceRegistered(VIR_FIREWALL_FIREWALLD_SERVICE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Validating backend %d\"",
            "backend"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend)\n{\n    VIR_DEBUG(\"Validating backend %d\", backend);\n    if (backend == VIR_FIREWALL_BACKEND_AUTOMATIC ||\n        backend == VIR_FIREWALL_BACKEND_FIREWALLD) {\n        int rv = virFirewallDIsRegistered();\n\n        VIR_DEBUG(\"Firewalld is registered ? %d\", rv);\n        if (rv < 0) {\n            if (rv == -2) {\n                if (backend == VIR_FIREWALL_BACKEND_FIREWALLD) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"firewalld firewall backend requested, but service is not running\"));\n                    return -1;\n                } else {\n                    VIR_DEBUG(\"firewalld service not running, trying direct backend\");\n                    backend = VIR_FIREWALL_BACKEND_DIRECT;\n                }\n            } else {\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"firewalld service running, using firewalld backend\");\n            backend = VIR_FIREWALL_BACKEND_FIREWALLD;\n        }\n    }\n\n    if (backend == VIR_FIREWALL_BACKEND_DIRECT) {\n        const char *commands[] = {\n            IPTABLES_PATH, IP6TABLES_PATH, EBTABLES_PATH\n        };\n        size_t i;\n\n        for (i = 0; i < G_N_ELEMENTS(commands); i++) {\n            if (!virFileIsExecutable(commands[i])) {\n                virReportSystemError(errno,\n                                     _(\"direct firewall backend requested, but %s is not available\"),\n                                     commands[i]);\n                return -1;\n            }\n        }\n        VIR_DEBUG(\"found iptables/ip6tables/ebtables, using direct backend\");\n    }\n\n    currentBackend = backend;\n\n    virFirewallCheckUpdateLocking();\n\n    return 0;\n}"
  },
  {
    "function_name": "virFirewallCheckUpdateLocking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "124-144",
    "snippet": "static void\nvirFirewallCheckUpdateLocking(void)\n{\n    const char *iptablesArgs[] = {\n        IPTABLES_PATH, \"-w\", \"-L\", \"-n\", NULL,\n    };\n    const char *ip6tablesArgs[] = {\n        IP6TABLES_PATH, \"-w\", \"-L\", \"-n\", NULL,\n    };\n    const char *ebtablesArgs[] = {\n        EBTABLES_PATH, \"--concurrent\", \"-L\", NULL,\n    };\n    if (lockOverride)\n        return;\n    virFirewallCheckUpdateLock(&iptablesUseLock,\n                               iptablesArgs);\n    virFirewallCheckUpdateLock(&ip6tablesUseLock,\n                               ip6tablesArgs);\n    virFirewallCheckUpdateLock(&ebtablesUseLock,\n                               ebtablesArgs);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool iptablesUseLock;",
      "static bool ip6tablesUseLock;",
      "static bool ebtablesUseLock;",
      "static bool lockOverride;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallCheckUpdateLock",
          "args": [
            "&ebtablesUseLock",
            "ebtablesArgs"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallCheckUpdateLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "110-122",
          "snippet": "static void\nvirFirewallCheckUpdateLock(bool *lockflag,\n                           const char *const*args)\n{\n    int status; /* Ignore failed commands without logging them */\n    g_autoptr(virCommand) cmd = virCommandNewArgs(args);\n    if (virCommandRun(cmd, &status) < 0 || status) {\n        VIR_INFO(\"locking not supported by %s\", args[0]);\n    } else {\n        VIR_INFO(\"using locking for %s\", args[0]);\n        *lockflag = true;\n    }\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nvirFirewallCheckUpdateLock(bool *lockflag,\n                           const char *const*args)\n{\n    int status; /* Ignore failed commands without logging them */\n    g_autoptr(virCommand) cmd = virCommandNewArgs(args);\n    if (virCommandRun(cmd, &status) < 0 || status) {\n        VIR_INFO(\"locking not supported by %s\", args[0]);\n    } else {\n        VIR_INFO(\"using locking for %s\", args[0]);\n        *lockflag = true;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool iptablesUseLock;\nstatic bool ip6tablesUseLock;\nstatic bool ebtablesUseLock;\nstatic bool lockOverride;\n\nstatic void\nvirFirewallCheckUpdateLocking(void)\n{\n    const char *iptablesArgs[] = {\n        IPTABLES_PATH, \"-w\", \"-L\", \"-n\", NULL,\n    };\n    const char *ip6tablesArgs[] = {\n        IP6TABLES_PATH, \"-w\", \"-L\", \"-n\", NULL,\n    };\n    const char *ebtablesArgs[] = {\n        EBTABLES_PATH, \"--concurrent\", \"-L\", NULL,\n    };\n    if (lockOverride)\n        return;\n    virFirewallCheckUpdateLock(&iptablesUseLock,\n                               iptablesArgs);\n    virFirewallCheckUpdateLock(&ip6tablesUseLock,\n                               ip6tablesArgs);\n    virFirewallCheckUpdateLock(&ebtablesUseLock,\n                               ebtablesArgs);\n}"
  },
  {
    "function_name": "virFirewallCheckUpdateLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "110-122",
    "snippet": "static void\nvirFirewallCheckUpdateLock(bool *lockflag,\n                           const char *const*args)\n{\n    int status; /* Ignore failed commands without logging them */\n    g_autoptr(virCommand) cmd = virCommandNewArgs(args);\n    if (virCommandRun(cmd, &status) < 0 || status) {\n        VIR_INFO(\"locking not supported by %s\", args[0]);\n    } else {\n        VIR_INFO(\"using locking for %s\", args[0]);\n        *lockflag = true;\n    }\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"using locking for %s\"",
            "args[0]"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"locking not supported by %s\"",
            "args[0]"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "&status"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgs",
          "args": [
            "args"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "937-958",
          "snippet": "virCommandPtr\nvirCommandNewArgs(const char *const*args)\n{\n    virCommandPtr cmd;\n\n    if (VIR_ALLOC(cmd) < 0)\n        return NULL;\n\n    cmd->handshakeWait[0] = -1;\n    cmd->handshakeWait[1] = -1;\n    cmd->handshakeNotify[0] = -1;\n    cmd->handshakeNotify[1] = -1;\n\n    cmd->infd = cmd->inpipe = cmd->outfd = cmd->errfd = -1;\n    cmd->pid = -1;\n    cmd->uid = -1;\n    cmd->gid = -1;\n\n    virCommandAddArgSet(cmd, args);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgs(const char *const*args)\n{\n    virCommandPtr cmd;\n\n    if (VIR_ALLOC(cmd) < 0)\n        return NULL;\n\n    cmd->handshakeWait[0] = -1;\n    cmd->handshakeWait[1] = -1;\n    cmd->handshakeNotify[0] = -1;\n    cmd->handshakeNotify[1] = -1;\n\n    cmd->infd = cmd->inpipe = cmd->outfd = cmd->errfd = -1;\n    cmd->pid = -1;\n    cmd->uid = -1;\n    cmd->gid = -1;\n\n    virCommandAddArgSet(cmd, args);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic void\nvirFirewallCheckUpdateLock(bool *lockflag,\n                           const char *const*args)\n{\n    int status; /* Ignore failed commands without logging them */\n    g_autoptr(virCommand) cmd = virCommandNewArgs(args);\n    if (virCommandRun(cmd, &status) < 0 || status) {\n        VIR_INFO(\"locking not supported by %s\", args[0]);\n    } else {\n        VIR_INFO(\"using locking for %s\", args[0]);\n        *lockflag = true;\n    }\n}"
  },
  {
    "function_name": "virFirewallSetLockOverride",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "104-108",
    "snippet": "void\nvirFirewallSetLockOverride(bool avoid)\n{\n    lockOverride = avoid;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lockOverride;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic bool lockOverride;\n\nvoid\nvirFirewallSetLockOverride(bool avoid)\n{\n    lockOverride = avoid;\n}"
  },
  {
    "function_name": "virFirewallOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
    "lines": "91-95",
    "snippet": "static int\nvirFirewallOnceInit(void)\n{\n    return virFirewallValidateBackend(currentBackend);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfirewalld.h\"",
      "#include \"virfirewallpriv.h\"",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirewallValidateBackend",
          "args": [
            "currentBackend"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "virFirewallValidateBackend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirewall.c",
          "lines": "146-196",
          "snippet": "static int\nvirFirewallValidateBackend(virFirewallBackend backend)\n{\n    VIR_DEBUG(\"Validating backend %d\", backend);\n    if (backend == VIR_FIREWALL_BACKEND_AUTOMATIC ||\n        backend == VIR_FIREWALL_BACKEND_FIREWALLD) {\n        int rv = virFirewallDIsRegistered();\n\n        VIR_DEBUG(\"Firewalld is registered ? %d\", rv);\n        if (rv < 0) {\n            if (rv == -2) {\n                if (backend == VIR_FIREWALL_BACKEND_FIREWALLD) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"firewalld firewall backend requested, but service is not running\"));\n                    return -1;\n                } else {\n                    VIR_DEBUG(\"firewalld service not running, trying direct backend\");\n                    backend = VIR_FIREWALL_BACKEND_DIRECT;\n                }\n            } else {\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"firewalld service running, using firewalld backend\");\n            backend = VIR_FIREWALL_BACKEND_FIREWALLD;\n        }\n    }\n\n    if (backend == VIR_FIREWALL_BACKEND_DIRECT) {\n        const char *commands[] = {\n            IPTABLES_PATH, IP6TABLES_PATH, EBTABLES_PATH\n        };\n        size_t i;\n\n        for (i = 0; i < G_N_ELEMENTS(commands); i++) {\n            if (!virFileIsExecutable(commands[i])) {\n                virReportSystemError(errno,\n                                     _(\"direct firewall backend requested, but %s is not available\"),\n                                     commands[i]);\n                return -1;\n            }\n        }\n        VIR_DEBUG(\"found iptables/ip6tables/ebtables, using direct backend\");\n    }\n\n    currentBackend = backend;\n\n    virFirewallCheckUpdateLocking();\n\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfirewalld.h\"",
            "#include \"virfirewallpriv.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;",
            "static int\nvirFirewallValidateBackend(virFirewallBackend backend);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend);\n\nstatic int\nvirFirewallValidateBackend(virFirewallBackend backend)\n{\n    VIR_DEBUG(\"Validating backend %d\", backend);\n    if (backend == VIR_FIREWALL_BACKEND_AUTOMATIC ||\n        backend == VIR_FIREWALL_BACKEND_FIREWALLD) {\n        int rv = virFirewallDIsRegistered();\n\n        VIR_DEBUG(\"Firewalld is registered ? %d\", rv);\n        if (rv < 0) {\n            if (rv == -2) {\n                if (backend == VIR_FIREWALL_BACKEND_FIREWALLD) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"firewalld firewall backend requested, but service is not running\"));\n                    return -1;\n                } else {\n                    VIR_DEBUG(\"firewalld service not running, trying direct backend\");\n                    backend = VIR_FIREWALL_BACKEND_DIRECT;\n                }\n            } else {\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"firewalld service running, using firewalld backend\");\n            backend = VIR_FIREWALL_BACKEND_FIREWALLD;\n        }\n    }\n\n    if (backend == VIR_FIREWALL_BACKEND_DIRECT) {\n        const char *commands[] = {\n            IPTABLES_PATH, IP6TABLES_PATH, EBTABLES_PATH\n        };\n        size_t i;\n\n        for (i = 0; i < G_N_ELEMENTS(commands); i++) {\n            if (!virFileIsExecutable(commands[i])) {\n                virReportSystemError(errno,\n                                     _(\"direct firewall backend requested, but %s is not available\"),\n                                     commands[i]);\n                return -1;\n            }\n        }\n        VIR_DEBUG(\"found iptables/ip6tables/ebtables, using direct backend\");\n    }\n\n    currentBackend = backend;\n\n    virFirewallCheckUpdateLocking();\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virfirewalld.h\"\n#include \"virfirewallpriv.h\"\n#include <stdarg.h>\n#include <config.h>\n\nstatic virFirewallBackend currentBackend = VIR_FIREWALL_BACKEND_AUTOMATIC;\n\nstatic int\nvirFirewallOnceInit(void)\n{\n    return virFirewallValidateBackend(currentBackend);\n}"
  }
]