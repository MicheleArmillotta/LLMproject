[
  {
    "function_name": "virCommandRunNul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "3356-3365",
    "snippet": "int\nvirCommandRunNul(virCommandPtr cmd G_GNUC_UNUSED,\n                 size_t n_columns G_GNUC_UNUSED,\n                 virCommandRunNulFunc func G_GNUC_UNUSED,\n                 void *data G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"%s not implemented on Win32\")",
            "__FUNCTION__"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s not implemented on Win32\""
          ],
          "line": 3363
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunNul(virCommandPtr cmd G_GNUC_UNUSED,\n                 size_t n_columns G_GNUC_UNUSED,\n                 virCommandRunNulFunc func G_GNUC_UNUSED,\n                 void *data G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}"
  },
  {
    "function_name": "virCommandRunRegex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "3341-3354",
    "snippet": "int\nvirCommandRunRegex(virCommandPtr cmd G_GNUC_UNUSED,\n                   int nregex G_GNUC_UNUSED,\n                   const char **regex G_GNUC_UNUSED,\n                   int *nvars G_GNUC_UNUSED,\n                   virCommandRunRegexFunc func G_GNUC_UNUSED,\n                   void *data G_GNUC_UNUSED,\n                   const char *prefix G_GNUC_UNUSED,\n                   int *exitstatus G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"%s not implemented on Win32\")",
            "__FUNCTION__"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s not implemented on Win32\""
          ],
          "line": 3352
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunRegex(virCommandPtr cmd G_GNUC_UNUSED,\n                   int nregex G_GNUC_UNUSED,\n                   const char **regex G_GNUC_UNUSED,\n                   int *nvars G_GNUC_UNUSED,\n                   virCommandRunRegexFunc func G_GNUC_UNUSED,\n                   void *data G_GNUC_UNUSED,\n                   const char *prefix G_GNUC_UNUSED,\n                   int *exitstatus G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"%s not implemented on Win32\"), __FUNCTION__);\n    return -1;\n}"
  },
  {
    "function_name": "virCommandRunNul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "3266-3337",
    "snippet": "int\nvirCommandRunNul(virCommandPtr cmd,\n                 size_t n_columns,\n                 virCommandRunNulFunc func,\n                 void *data)\n{\n    size_t n_tok = 0;\n    int fd = -1;\n    FILE *fp = NULL;\n    char **v;\n    int ret = -1;\n    size_t i;\n\n    if (n_columns == 0)\n        return -1;\n\n    if (VIR_ALLOC_N(v, n_columns) < 0)\n        return -1;\n    for (i = 0; i < n_columns; i++)\n        v[i] = NULL;\n\n    virCommandSetOutputFD(cmd, &fd);\n    if (virCommandRunAsync(cmd, NULL) < 0)\n        goto cleanup;\n\n    if ((fp = VIR_FDOPEN(fd, \"r\")) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"cannot open file using fd\"));\n        goto cleanup;\n    }\n\n    while (1) {\n        char *buf = NULL;\n        size_t buf_len = 0;\n        /* Be careful: even when it returns -1,\n           this use of getdelim allocates memory.  */\n        ssize_t tok_len = getdelim(&buf, &buf_len, 0, fp);\n        v[n_tok] = buf;\n        if (tok_len < 0) {\n            /* Maybe EOF, maybe an error.\n               If n_tok > 0, then we know it's an error.  */\n            if (n_tok && func(n_tok, v, data) < 0)\n                goto cleanup;\n            break;\n        }\n        ++n_tok;\n        if (n_tok == n_columns) {\n            if (func(n_tok, v, data) < 0)\n                goto cleanup;\n            n_tok = 0;\n            for (i = 0; i < n_columns; i++)\n                VIR_FREE(v[i]);\n        }\n    }\n\n    if (feof(fp) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"read error on pipe\"));\n        goto cleanup;\n    }\n\n    ret = virCommandWait(cmd, NULL);\n cleanup:\n    for (i = 0; i < n_columns; i++)\n        VIR_FREE(v[i]);\n    VIR_FREE(v);\n\n    VIR_FORCE_FCLOSE(fp);\n    VIR_FORCE_CLOSE(fd);\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 3334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_FCLOSE",
          "args": [
            "fp"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "v"
          ],
          "line": 3331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "v[i]"
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandWait",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 3327
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2940-2946",
          "snippet": "int\nvirCommandWait(virCommandPtr cmd G_GNUC_UNUSED, int *exitstatus G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandWait(virCommandPtr cmd G_GNUC_UNUSED, int *exitstatus G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"read error on pipe\")"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"read error on pipe\""
          ],
          "line": 3323
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "feof",
          "args": [
            "fp"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "v[i]"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "n_tok",
            "v",
            "data"
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "n_tok",
            "v",
            "data"
          ],
          "line": 3307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getdelim",
          "args": [
            "&buf",
            "&buf_len",
            "0",
            "fp"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot open file using fd\")"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FDOPEN",
          "args": [
            "fd",
            "\"r\""
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRunAsync",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 3288
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputFD",
          "args": [
            "cmd",
            "&fd"
          ],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1958-1971",
          "snippet": "void\nvirCommandSetOutputFD(virCommandPtr cmd, int *outfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outfdptr = outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputFD(virCommandPtr cmd, int *outfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outfdptr = outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "v",
            "n_columns"
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunNul(virCommandPtr cmd,\n                 size_t n_columns,\n                 virCommandRunNulFunc func,\n                 void *data)\n{\n    size_t n_tok = 0;\n    int fd = -1;\n    FILE *fp = NULL;\n    char **v;\n    int ret = -1;\n    size_t i;\n\n    if (n_columns == 0)\n        return -1;\n\n    if (VIR_ALLOC_N(v, n_columns) < 0)\n        return -1;\n    for (i = 0; i < n_columns; i++)\n        v[i] = NULL;\n\n    virCommandSetOutputFD(cmd, &fd);\n    if (virCommandRunAsync(cmd, NULL) < 0)\n        goto cleanup;\n\n    if ((fp = VIR_FDOPEN(fd, \"r\")) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"cannot open file using fd\"));\n        goto cleanup;\n    }\n\n    while (1) {\n        char *buf = NULL;\n        size_t buf_len = 0;\n        /* Be careful: even when it returns -1,\n           this use of getdelim allocates memory.  */\n        ssize_t tok_len = getdelim(&buf, &buf_len, 0, fp);\n        v[n_tok] = buf;\n        if (tok_len < 0) {\n            /* Maybe EOF, maybe an error.\n               If n_tok > 0, then we know it's an error.  */\n            if (n_tok && func(n_tok, v, data) < 0)\n                goto cleanup;\n            break;\n        }\n        ++n_tok;\n        if (n_tok == n_columns) {\n            if (func(n_tok, v, data) < 0)\n                goto cleanup;\n            n_tok = 0;\n            for (i = 0; i < n_columns; i++)\n                VIR_FREE(v[i]);\n        }\n    }\n\n    if (feof(fp) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"read error on pipe\"));\n        goto cleanup;\n    }\n\n    ret = virCommandWait(cmd, NULL);\n cleanup:\n    for (i = 0; i < n_columns; i++)\n        VIR_FREE(v[i]);\n    VIR_FREE(v);\n\n    VIR_FORCE_FCLOSE(fp);\n    VIR_FORCE_CLOSE(fd);\n\n    return ret;\n}"
  },
  {
    "function_name": "virCommandRunRegex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "3157-3253",
    "snippet": "int\nvirCommandRunRegex(virCommandPtr cmd,\n                   int nregex,\n                   const char **regex,\n                   int *nvars,\n                   virCommandRunRegexFunc func,\n                   void *data,\n                   const char *prefix,\n                   int *exitstatus)\n{\n    GRegex **reg = NULL;\n    size_t i, j, k;\n    int totgroups = 0, ngroup = 0;\n    char **groups;\n    g_autofree char *outbuf = NULL;\n    VIR_AUTOSTRINGLIST lines = NULL;\n    int ret = -1;\n\n    /* Compile all regular expressions */\n    if (VIR_ALLOC_N(reg, nregex) < 0)\n        return -1;\n\n    for (i = 0; i < nregex; i++) {\n        g_autoptr(GError) err = NULL;\n        reg[i] = g_regex_new(regex[i], G_REGEX_OPTIMIZE, 0, &err);\n        if (!reg[i]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to compile regex %s\"), err->message);\n            for (j = 0; j < i; j++)\n                g_regex_unref(reg[j]);\n            VIR_FREE(reg);\n            return -1;\n        }\n\n        totgroups += nvars[i];\n    }\n\n    /* Storage for matched variables */\n    if (VIR_ALLOC_N(groups, totgroups) < 0)\n        goto cleanup;\n\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, exitstatus) < 0)\n        goto cleanup;\n\n    if (!outbuf) {\n        /* no output */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(lines = virStringSplit(outbuf, \"\\n\", 0)))\n        goto cleanup;\n\n    for (k = 0; lines[k]; k++) {\n        g_autoptr(GMatchInfo) info = NULL;\n        const char *p = NULL;\n\n        /* ignore any command prefix */\n        if (prefix)\n            p = STRSKIP(lines[k], prefix);\n        if (!p)\n            p = lines[k];\n\n        ngroup = 0;\n        for (i = 0; i < nregex; i++) {\n            if (!(g_regex_match(reg[i], p, 0, &info)))\n                break;\n\n            /* NB match #0 is the full pattern, so we offset j by 1 */\n            for (j = 1; j <= nvars[i]; j++)\n                groups[ngroup++] = g_match_info_fetch(info, j);\n        }\n        /* We've matched on the last regex, so callback time */\n        if (i == nregex) {\n            if (((*func)(groups, data)) < 0)\n                goto cleanup;\n        }\n\n        for (j = 0; j < ngroup; j++)\n            VIR_FREE(groups[j]);\n    }\n\n    ret = 0;\n cleanup:\n    if (groups) {\n        for (j = 0; j < totgroups; j++)\n            VIR_FREE(groups[j]);\n        VIR_FREE(groups);\n    }\n\n    for (i = 0; i < nregex; i++)\n        g_regex_unref(reg[i]);\n\n    VIR_FREE(reg);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "reg"
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_regex_unref",
          "args": [
            "reg[i]"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "groups"
          ],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "groups[j]"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "groups[j]"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "groups",
            "data"
          ],
          "line": 3232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_match_info_fetch",
          "args": [
            "info",
            "j"
          ],
          "line": 3228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_regex_match",
          "args": [
            "reg[i]",
            "p",
            "0",
            "&info"
          ],
          "line": 3223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "lines[k]",
            "prefix"
          ],
          "line": 3217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplit",
          "args": [
            "outbuf",
            "\"\\n\"",
            "0"
          ],
          "line": 3208
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "126-132",
          "snippet": "char **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "exitstatus"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "&outbuf"
          ],
          "line": 3198
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "groups",
            "totgroups"
          ],
          "line": 3195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "reg"
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_regex_unref",
          "args": [
            "reg[j]"
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to compile regex %s\")",
            "err->message"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to compile regex %s\""
          ],
          "line": 3184
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_regex_new",
          "args": [
            "regex[i]",
            "G_REGEX_OPTIMIZE",
            "0",
            "&err"
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "reg",
            "nregex"
          ],
          "line": 3176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunRegex(virCommandPtr cmd,\n                   int nregex,\n                   const char **regex,\n                   int *nvars,\n                   virCommandRunRegexFunc func,\n                   void *data,\n                   const char *prefix,\n                   int *exitstatus)\n{\n    GRegex **reg = NULL;\n    size_t i, j, k;\n    int totgroups = 0, ngroup = 0;\n    char **groups;\n    g_autofree char *outbuf = NULL;\n    VIR_AUTOSTRINGLIST lines = NULL;\n    int ret = -1;\n\n    /* Compile all regular expressions */\n    if (VIR_ALLOC_N(reg, nregex) < 0)\n        return -1;\n\n    for (i = 0; i < nregex; i++) {\n        g_autoptr(GError) err = NULL;\n        reg[i] = g_regex_new(regex[i], G_REGEX_OPTIMIZE, 0, &err);\n        if (!reg[i]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to compile regex %s\"), err->message);\n            for (j = 0; j < i; j++)\n                g_regex_unref(reg[j]);\n            VIR_FREE(reg);\n            return -1;\n        }\n\n        totgroups += nvars[i];\n    }\n\n    /* Storage for matched variables */\n    if (VIR_ALLOC_N(groups, totgroups) < 0)\n        goto cleanup;\n\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, exitstatus) < 0)\n        goto cleanup;\n\n    if (!outbuf) {\n        /* no output */\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(lines = virStringSplit(outbuf, \"\\n\", 0)))\n        goto cleanup;\n\n    for (k = 0; lines[k]; k++) {\n        g_autoptr(GMatchInfo) info = NULL;\n        const char *p = NULL;\n\n        /* ignore any command prefix */\n        if (prefix)\n            p = STRSKIP(lines[k], prefix);\n        if (!p)\n            p = lines[k];\n\n        ngroup = 0;\n        for (i = 0; i < nregex; i++) {\n            if (!(g_regex_match(reg[i], p, 0, &info)))\n                break;\n\n            /* NB match #0 is the full pattern, so we offset j by 1 */\n            for (j = 1; j <= nvars[i]; j++)\n                groups[ngroup++] = g_match_info_fetch(info, j);\n        }\n        /* We've matched on the last regex, so callback time */\n        if (i == nregex) {\n            if (((*func)(groups, data)) < 0)\n                goto cleanup;\n        }\n\n        for (j = 0; j < ngroup; j++)\n            VIR_FREE(groups[j]);\n    }\n\n    ret = 0;\n cleanup:\n    if (groups) {\n        for (j = 0; j < totgroups; j++)\n            VIR_FREE(groups[j]);\n        VIR_FREE(groups);\n    }\n\n    for (i = 0; i < nregex; i++)\n        g_regex_unref(reg[i]);\n\n    VIR_FREE(reg);\n    return ret;\n}"
  },
  {
    "function_name": "virCommandSetDryRun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "3125-3133",
    "snippet": "void\nvirCommandSetDryRun(virBufferPtr buf,\n                    virCommandDryRunCallback cb,\n                    void *opaque)\n{\n    dryRunBuffer = buf;\n    dryRunCallback = cb;\n    dryRunOpaque = opaque;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virBufferPtr dryRunBuffer;",
      "static virCommandDryRunCallback dryRunCallback;",
      "static void *dryRunOpaque;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic virBufferPtr dryRunBuffer;\nstatic virCommandDryRunCallback dryRunCallback;\nstatic void *dryRunOpaque;\n\nvoid\nvirCommandSetDryRun(virBufferPtr buf,\n                    virCommandDryRunCallback cb,\n                    void *opaque)\n{\n    dryRunBuffer = buf;\n    dryRunCallback = cb;\n    dryRunOpaque = opaque;\n}"
  },
  {
    "function_name": "virCommandDoAsyncIO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "3084-3091",
    "snippet": "void\nvirCommandDoAsyncIO(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_ASYNC_IO | VIR_EXEC_NONBLOCK;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandDoAsyncIO(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_ASYNC_IO | VIR_EXEC_NONBLOCK;\n}"
  },
  {
    "function_name": "virCommandFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2992-3047",
    "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandFreeSendBuffers",
          "args": [
            "cmd"
          ],
          "line": 3044
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFreeSendBuffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1717-1727",
          "snippet": "static void\nvirCommandFreeSendBuffers(virCommandPtr cmd)\n{\n    size_t i;\n\n    for (i = 0; i < virCommandGetNumSendBuffers(cmd); i++) {\n        VIR_FORCE_CLOSE(cmd->sendBuffers[i].fd);\n        VIR_FREE(cmd->sendBuffers[i].buffer);\n    }\n    VIR_FREE(cmd->sendBuffers);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic void\nvirCommandFreeSendBuffers(virCommandPtr cmd)\n{\n    size_t i;\n\n    for (i = 0; i < virCommandGetNumSendBuffers(cmd); i++) {\n        VIR_FORCE_CLOSE(cmd->sendBuffers[i].fd);\n        VIR_FREE(cmd->sendBuffers[i].buffer);\n    }\n    VIR_FREE(cmd->sendBuffers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->appArmorProfile"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->seLinuxLabel"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandAbort",
          "args": [
            "cmd"
          ],
          "line": 3035
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2949-2955",
          "snippet": "void\nvirCommandAbort(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    /* Mingw lacks WNOHANG and kill().  But since we haven't ported\n     * virExec to mingw yet, there's no process to be killed,\n     * making this implementation trivially correct for now :)  */\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAbort(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    /* Mingw lacks WNOHANG and kill().  But since we haven't ported\n     * virExec to mingw yet, there's no process to be killed,\n     * making this implementation trivially correct for now :)  */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->pidfile"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->handshakeNotify[1]"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->handshakeWait[0]"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->pwd"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->env"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->env[i]"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->args"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->args[i]"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->errfd"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->outfd"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->inbuf"
          ],
          "line": 3010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->asyncioThread"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadJoin",
          "args": [
            "cmd->asyncioThread"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadJoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "326-329",
          "snippet": "void virThreadJoin(virThreadPtr thread)\n{\n    pthread_join(thread->thread, NULL);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virThreadJoin(virThreadPtr thread)\n{\n    pthread_join(thread->thread, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->passfd"
          ],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->passfd[i].fd"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
  },
  {
    "function_name": "virCommandHandshakeNotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2975-2980",
    "snippet": "int virCommandHandshakeNotify(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Executing new processes is not supported on Win32 platform\")"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Executing new processes is not supported on Win32 platform\""
          ],
          "line": 2978
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint virCommandHandshakeNotify(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virCommandHandshakeWait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2967-2972",
    "snippet": "int virCommandHandshakeWait(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Executing new processes is not supported on Win32 platform\")"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Executing new processes is not supported on Win32 platform\""
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint virCommandHandshakeWait(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virCommandRequireHandshake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2958-2964",
    "snippet": "void virCommandRequireHandshake(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->has_error = ENOSYS;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid virCommandRequireHandshake(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->has_error = ENOSYS;\n}"
  },
  {
    "function_name": "virCommandAbort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2949-2955",
    "snippet": "void\nvirCommandAbort(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    /* Mingw lacks WNOHANG and kill().  But since we haven't ported\n     * virExec to mingw yet, there's no process to be killed,\n     * making this implementation trivially correct for now :)  */\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAbort(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    /* Mingw lacks WNOHANG and kill().  But since we haven't ported\n     * virExec to mingw yet, there's no process to be killed,\n     * making this implementation trivially correct for now :)  */\n}"
  },
  {
    "function_name": "virCommandWait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2940-2946",
    "snippet": "int\nvirCommandWait(virCommandPtr cmd G_GNUC_UNUSED, int *exitstatus G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Executing new processes is not supported on Win32 platform\")"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Executing new processes is not supported on Win32 platform\""
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandWait(virCommandPtr cmd G_GNUC_UNUSED, int *exitstatus G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virCommandRunAsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2931-2937",
    "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Executing new processes is not supported on Win32 platform\")"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Executing new processes is not supported on Win32 platform\""
          ],
          "line": 2935
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virCommandRun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2922-2928",
    "snippet": "int\nvirCommandRun(virCommandPtr cmd G_GNUC_UNUSED, int *exitstatus G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Executing new processes is not supported on Win32 platform\")"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Executing new processes is not supported on Win32 platform\""
          ],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRun(virCommandPtr cmd G_GNUC_UNUSED, int *exitstatus G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virCommandExec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2912-2919",
    "snippet": "int\nvirCommandExec(virCommandPtr cmd G_GNUC_UNUSED, gid_t *groups G_GNUC_UNUSED,\n               int ngroups G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Executing new processes is not supported on Win32 platform\")"
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Executing new processes is not supported on Win32 platform\""
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandExec(virCommandPtr cmd G_GNUC_UNUSED, gid_t *groups G_GNUC_UNUSED,\n               int ngroups G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virCommandSetSendBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2897-2909",
    "snippet": "int\nvirCommandSetSendBuffer(virCommandPtr cmd,\n                        int fd G_GNUC_UNUSED,\n                        unsigned char *buffer G_GNUC_UNUSED,\n                        size_t buflen G_GNUC_UNUSED)\n{\n    if (!cmd || cmd->has_error)\n        return -1;\n\n    cmd->has_error = ENOTSUP;\n\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandSetSendBuffer(virCommandPtr cmd,\n                        int fd G_GNUC_UNUSED,\n                        unsigned char *buffer G_GNUC_UNUSED,\n                        size_t buflen G_GNUC_UNUSED)\n{\n    if (!cmd || cmd->has_error)\n        return -1;\n\n    cmd->has_error = ENOTSUP;\n\n    return -1;\n}"
  },
  {
    "function_name": "virCommandHandshakeNotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2868-2895",
    "snippet": "int virCommandHandshakeNotify(virCommandPtr cmd)\n{\n    char c = '1';\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return -1;\n    }\n    if (cmd->has_error || !cmd->handshake) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return -1;\n    }\n\n    if (cmd->handshakeNotify[1] == -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Handshake is already complete\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"Notify handshake on %d\", cmd->handshakeNotify[1]);\n    if (safewrite(cmd->handshakeNotify[1], &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to notify child process\"));\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n        return -1;\n    }\n    VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->handshakeNotify[1]"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->handshakeNotify[1]"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to notify child process\")"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to notify child process\""
          ],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "cmd->handshakeNotify[1]",
            "&c",
            "sizeof(c)"
          ],
          "line": 2888
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Notify handshake on %d\"",
            "cmd->handshakeNotify[1]"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Handshake is already complete\")"
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"invalid use of command API\")"
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint virCommandHandshakeNotify(virCommandPtr cmd)\n{\n    char c = '1';\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return -1;\n    }\n    if (cmd->has_error || !cmd->handshake) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return -1;\n    }\n\n    if (cmd->handshakeNotify[1] == -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Handshake is already complete\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"Notify handshake on %d\", cmd->handshakeNotify[1]);\n    if (safewrite(cmd->handshakeNotify[1], &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to notify child process\"));\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n        return -1;\n    }\n    VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    return 0;\n}"
  },
  {
    "function_name": "virCommandHandshakeWait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2803-2859",
    "snippet": "int virCommandHandshakeWait(virCommandPtr cmd)\n{\n    char c;\n    int rv;\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return -1;\n    }\n    if (cmd->has_error || !cmd->handshake) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return -1;\n    }\n\n    if (cmd->handshakeWait[0] == -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Handshake is already complete\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"Wait for handshake on %d\", cmd->handshakeWait[0]);\n    if ((rv = saferead(cmd->handshakeWait[0], &c, sizeof(c))) != sizeof(c)) {\n        if (rv < 0)\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to wait for child process\"));\n        else\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"Child quit during startup handshake\"));\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        return -1;\n    }\n    if (c != '1') {\n        g_autofree char *msg = NULL;\n        ssize_t len;\n        if (VIR_ALLOC_N(msg, 1024) < 0) {\n            VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n            return -1;\n        }\n        /* Close the handshakeNotify fd before trying to read anything\n         * further on the handshakeWait pipe; so that a child waiting\n         * on our acknowledgment will die rather than deadlock.  */\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n\n        if ((len = saferead(cmd->handshakeWait[0], msg, 1024)) < 0) {\n            VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n            virReportSystemError(errno, \"%s\",\n                                 _(\"No error message from child failure\"));\n            return -1;\n        }\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        msg[len-1] = '\\0';\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", msg);\n        return -1;\n    }\n    VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->handshakeWait[0]"
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "msg"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->handshakeWait[0]"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"No error message from child failure\")"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No error message from child failure\""
          ],
          "line": 2849
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->handshakeWait[0]"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "saferead",
          "args": [
            "cmd->handshakeWait[0]",
            "msg",
            "1024"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "saferead_lim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1330-1372",
          "snippet": "static char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->handshakeNotify[1]"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->handshakeWait[0]"
          ],
          "line": 2838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "msg",
            "1024"
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->handshakeWait[0]"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EIO",
            "\"%s\"",
            "_(\"Child quit during startup handshake\")"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to wait for child process\")"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Wait for handshake on %d\"",
            "cmd->handshakeWait[0]"
          ],
          "line": 2823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Handshake is already complete\")"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"invalid use of command API\")"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 2808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint virCommandHandshakeWait(virCommandPtr cmd)\n{\n    char c;\n    int rv;\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return -1;\n    }\n    if (cmd->has_error || !cmd->handshake) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return -1;\n    }\n\n    if (cmd->handshakeWait[0] == -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Handshake is already complete\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"Wait for handshake on %d\", cmd->handshakeWait[0]);\n    if ((rv = saferead(cmd->handshakeWait[0], &c, sizeof(c))) != sizeof(c)) {\n        if (rv < 0)\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to wait for child process\"));\n        else\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"Child quit during startup handshake\"));\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        return -1;\n    }\n    if (c != '1') {\n        g_autofree char *msg = NULL;\n        ssize_t len;\n        if (VIR_ALLOC_N(msg, 1024) < 0) {\n            VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n            return -1;\n        }\n        /* Close the handshakeNotify fd before trying to read anything\n         * further on the handshakeWait pipe; so that a child waiting\n         * on our acknowledgment will die rather than deadlock.  */\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n\n        if ((len = saferead(cmd->handshakeWait[0], msg, 1024)) < 0) {\n            VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n            virReportSystemError(errno, \"%s\",\n                                 _(\"No error message from child failure\"));\n            return -1;\n        }\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        msg[len-1] = '\\0';\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", msg);\n        return -1;\n    }\n    VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n    return 0;\n}"
  },
  {
    "function_name": "virCommandRequireHandshake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2763-2794",
    "snippet": "void virCommandRequireHandshake(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->handshake) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"Cannot require handshake twice\");\n        return;\n    }\n\n    if (virPipeQuiet(cmd->handshakeWait) < 0) {\n        cmd->has_error = errno;\n        return;\n    }\n    if (virPipeQuiet(cmd->handshakeNotify) < 0) {\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeWait[1]);\n        cmd->has_error = errno;\n        return;\n    }\n\n    VIR_DEBUG(\"Transfer handshake wait=%d notify=%d, \"\n              \"keep handshake wait=%d notify=%d\",\n              cmd->handshakeWait[1], cmd->handshakeNotify[0],\n              cmd->handshakeWait[0], cmd->handshakeNotify[1]);\n    virCommandPassFD(cmd, cmd->handshakeWait[1],\n                     VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    virCommandPassFD(cmd, cmd->handshakeNotify[0],\n                     VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    cmd->handshake = true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandPassFD",
          "args": [
            "cmd",
            "cmd->handshakeNotify[0]",
            "VIR_COMMAND_PASS_FD_CLOSE_PARENT"
          ],
          "line": 2791
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandPassFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1024-1049",
          "snippet": "void\nvirCommandPassFD(virCommandPtr cmd, int fd, unsigned int flags)\n{\n    int ret = 0;\n\n    if (!cmd) {\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n\n    if (fd <= STDERR_FILENO) {\n        VIR_DEBUG(\"invalid fd %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        if (!cmd->has_error)\n            cmd->has_error = -1;\n        return;\n    }\n\n    if ((ret = virCommandFDSet(cmd, fd, flags)) != 0) {\n        if (!cmd->has_error)\n            cmd->has_error = ret;\n        VIR_DEBUG(\"cannot preserve %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandPassFD(virCommandPtr cmd, int fd, unsigned int flags)\n{\n    int ret = 0;\n\n    if (!cmd) {\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n\n    if (fd <= STDERR_FILENO) {\n        VIR_DEBUG(\"invalid fd %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        if (!cmd->has_error)\n            cmd->has_error = -1;\n        return;\n    }\n\n    if ((ret = virCommandFDSet(cmd, fd, flags)) != 0) {\n        if (!cmd->has_error)\n            cmd->has_error = ret;\n        VIR_DEBUG(\"cannot preserve %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Transfer handshake wait=%d notify=%d, \"\n              \"keep handshake wait=%d notify=%d\"",
            "cmd->handshakeWait[1]",
            "cmd->handshakeNotify[0]",
            "cmd->handshakeWait[0]",
            "cmd->handshakeNotify[1]"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->handshakeWait[1]"
          ],
          "line": 2780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->handshakeWait[0]"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPipeQuiet",
          "args": [
            "cmd->handshakeNotify"
          ],
          "line": 2778
        },
        "resolved": true,
        "details": {
          "function_name": "virPipeQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1806-1810",
          "snippet": "int\nvirPipeQuiet(int fds[2])\n{\n    return virPipeImpl(fds, false, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPipeQuiet(int fds[2])\n{\n    return virPipeImpl(fds, false, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Cannot require handshake twice\""
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid virCommandRequireHandshake(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->handshake) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"Cannot require handshake twice\");\n        return;\n    }\n\n    if (virPipeQuiet(cmd->handshakeWait) < 0) {\n        cmd->has_error = errno;\n        return;\n    }\n    if (virPipeQuiet(cmd->handshakeNotify) < 0) {\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeWait[1]);\n        cmd->has_error = errno;\n        return;\n    }\n\n    VIR_DEBUG(\"Transfer handshake wait=%d notify=%d, \"\n              \"keep handshake wait=%d notify=%d\",\n              cmd->handshakeWait[1], cmd->handshakeNotify[0],\n              cmd->handshakeWait[0], cmd->handshakeNotify[1]);\n    virCommandPassFD(cmd, cmd->handshakeWait[1],\n                     VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    virCommandPassFD(cmd, cmd->handshakeNotify[0],\n                     VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    cmd->handshake = true;\n}"
  },
  {
    "function_name": "virCommandAbort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2743-2751",
    "snippet": "void\nvirCommandAbort(virCommandPtr cmd)\n{\n    if (!cmd || cmd->pid == -1)\n        return;\n    virProcessAbort(cmd->pid);\n    cmd->pid = -1;\n    cmd->reap = false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virProcessAbort",
          "args": [
            "cmd->pid"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "288-293",
          "snippet": "void\nvirProcessAbort(pid_t pid)\n{\n    /* Not yet ported to mingw.  Any volunteers?  */\n    VIR_DEBUG(\"failed to reap child %lld, abandoning it\", (long long)pid);\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirProcessAbort(pid_t pid)\n{\n    /* Not yet ported to mingw.  Any volunteers?  */\n    VIR_DEBUG(\"failed to reap child %lld, abandoning it\", (long long)pid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAbort(virCommandPtr cmd)\n{\n    if (!cmd || cmd->pid == -1)\n        return;\n    virProcessAbort(cmd->pid);\n    cmd->pid = -1;\n    cmd->reap = false;\n}"
  },
  {
    "function_name": "virCommandWait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2658-2731",
    "snippet": "int\nvirCommandWait(virCommandPtr cmd, int *exitstatus)\n{\n    int ret;\n    int status = 0;\n\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return -1;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return -1;\n    }\n\n    if (dryRunBuffer || dryRunCallback) {\n        VIR_DEBUG(\"Dry run requested, returning status %d\",\n                  dryRunStatus);\n        if (exitstatus)\n            *exitstatus = dryRunStatus;\n        else if (dryRunStatus)\n            return -1;\n        return 0;\n    }\n\n    if (cmd->pid == -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"command is not yet running\"));\n        return -1;\n    }\n\n    /* If virProcessWait reaps pid but then returns failure because\n     * exitstatus was NULL, then a second virCommandWait would risk\n     * calling waitpid on an unrelated process.  Besides, that error\n     * message is not as detailed as what we can provide.  So, we\n     * guarantee that virProcessWait only fails due to failure to wait,\n     * and repeat the exitstatus check code ourselves.  */\n    ret = virProcessWait(cmd->pid, &status, true);\n    if (cmd->flags & VIR_EXEC_ASYNC_IO) {\n        cmd->flags &= ~VIR_EXEC_ASYNC_IO;\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n        VIR_FORCE_CLOSE(cmd->inpipe);\n        if (cmd->has_error) {\n            const char *msg = _(\"Error while processing command's IO\");\n            if (cmd->has_error < 0)\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", msg);\n            else\n                virReportSystemError(cmd->has_error, \"%s\", msg);\n            ret = -1;\n        }\n    }\n    if (ret == 0) {\n        cmd->pid = -1;\n        cmd->reap = false;\n        if (exitstatus && (cmd->rawStatus || WIFEXITED(status))) {\n            *exitstatus = cmd->rawStatus ? status : WEXITSTATUS(status);\n        } else if (status) {\n            g_autofree char *str = virCommandToString(cmd, false);\n            g_autofree char *st = virProcessTranslateStatus(status);\n            bool haveErrMsg = cmd->errbuf && *cmd->errbuf && (*cmd->errbuf)[0];\n\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Child process (%s) unexpected %s%s%s\"),\n                           str ? str : cmd->args[0], NULLSTR(st),\n                           haveErrMsg ? \": \" : \"\",\n                           haveErrMsg ? *cmd->errbuf : \"\");\n            return -1;\n        }\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virBufferPtr dryRunBuffer;",
      "static virCommandDryRunCallback dryRunCallback;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Child process (%s) unexpected %s%s%s\")",
            "str ? str : cmd->args[0]",
            "NULLSTR(st)",
            "haveErrMsg ? \": \" : \"\"",
            "haveErrMsg ? *cmd->errbuf : \"\""
          ],
          "line": 2721
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "st"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Child process (%s) unexpected %s%s%s\""
          ],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessTranslateStatus",
          "args": [
            "status"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessTranslateStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "281-285",
          "snippet": "char *\nvirProcessTranslateStatus(int status)\n{\n    return g_strdup_printf(_(\"invalid value %d\"), status);\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *\nvirProcessTranslateStatus(int status)\n{\n    return g_strdup_printf(_(\"invalid value %d\"), status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandToString",
          "args": [
            "cmd",
            "false"
          ],
          "line": 2717
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2082-2135",
          "snippet": "char *\nvirCommandToString(virCommandPtr cmd, bool linebreaks)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool prevopt = false;\n\n    /* Cannot assume virCommandRun will be called; so report the error\n     * now.  If virCommandRun is called, it will report the same error. */\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return NULL;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return NULL;\n    }\n\n    for (i = 0; i < cmd->nenv; i++) {\n        /* In shell, a='b c' has a different meaning than 'a=b c', so\n         * we must determine where the '=' lives.  */\n        char *eq = strchr(cmd->env[i], '=');\n\n        if (!eq) {\n            virBufferFreeAndReset(&buf);\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid use of command API\"));\n            return NULL;\n        }\n        eq++;\n        virBufferAdd(&buf, cmd->env[i], eq - cmd->env[i]);\n        virBufferEscapeShell(&buf, eq);\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks)\n            virBufferAddLit(&buf, \"\\\\\\n\");\n    }\n    virBufferEscapeShell(&buf, cmd->args[0]);\n    for (i = 1; i < cmd->nargs; i++) {\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks) {\n            /* Line break if this is a --arg or if\n             * the previous arg was a positional option\n             */\n            if (cmd->args[i][0] == '-' ||\n                !prevopt)\n                virBufferAddLit(&buf, \"\\\\\\n\");\n        }\n        virBufferEscapeShell(&buf, cmd->args[i]);\n        prevopt = (cmd->args[i][0] == '-');\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nchar *\nvirCommandToString(virCommandPtr cmd, bool linebreaks)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool prevopt = false;\n\n    /* Cannot assume virCommandRun will be called; so report the error\n     * now.  If virCommandRun is called, it will report the same error. */\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return NULL;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return NULL;\n    }\n\n    for (i = 0; i < cmd->nenv; i++) {\n        /* In shell, a='b c' has a different meaning than 'a=b c', so\n         * we must determine where the '=' lives.  */\n        char *eq = strchr(cmd->env[i], '=');\n\n        if (!eq) {\n            virBufferFreeAndReset(&buf);\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid use of command API\"));\n            return NULL;\n        }\n        eq++;\n        virBufferAdd(&buf, cmd->env[i], eq - cmd->env[i]);\n        virBufferEscapeShell(&buf, eq);\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks)\n            virBufferAddLit(&buf, \"\\\\\\n\");\n    }\n    virBufferEscapeShell(&buf, cmd->args[0]);\n    for (i = 1; i < cmd->nargs; i++) {\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks) {\n            /* Line break if this is a --arg or if\n             * the previous arg was a positional option\n             */\n            if (cmd->args[i][0] == '-' ||\n                !prevopt)\n                virBufferAddLit(&buf, \"\\\\\\n\");\n        }\n        virBufferEscapeShell(&buf, cmd->args[i]);\n        prevopt = (cmd->args[i][0] == '-');\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "cmd->has_error",
            "\"%s\"",
            "msg"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "msg"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->inpipe"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->asyncioThread"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadJoin",
          "args": [
            "cmd->asyncioThread"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadJoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "326-329",
          "snippet": "void virThreadJoin(virThreadPtr thread)\n{\n    pthread_join(thread->thread, NULL);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virThreadJoin(virThreadPtr thread)\n{\n    pthread_join(thread->thread, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessWait",
          "args": [
            "cmd->pid",
            "&status",
            "true"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "296-302",
          "snippet": "int\nvirProcessWait(pid_t pid, int *exitstatus G_GNUC_UNUSED, bool raw G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, _(\"unable to wait for process %lld\"),\n                         (long long) pid);\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessWait(pid_t pid, int *exitstatus G_GNUC_UNUSED, bool raw G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, _(\"unable to wait for process %lld\"),\n                         (long long) pid);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"command is not yet running\")"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Dry run requested, returning status %d\"",
            "dryRunStatus"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"invalid use of command API\")"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic virBufferPtr dryRunBuffer;\nstatic virCommandDryRunCallback dryRunCallback;\n\nint\nvirCommandWait(virCommandPtr cmd, int *exitstatus)\n{\n    int ret;\n    int status = 0;\n\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return -1;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return -1;\n    }\n\n    if (dryRunBuffer || dryRunCallback) {\n        VIR_DEBUG(\"Dry run requested, returning status %d\",\n                  dryRunStatus);\n        if (exitstatus)\n            *exitstatus = dryRunStatus;\n        else if (dryRunStatus)\n            return -1;\n        return 0;\n    }\n\n    if (cmd->pid == -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"command is not yet running\"));\n        return -1;\n    }\n\n    /* If virProcessWait reaps pid but then returns failure because\n     * exitstatus was NULL, then a second virCommandWait would risk\n     * calling waitpid on an unrelated process.  Besides, that error\n     * message is not as detailed as what we can provide.  So, we\n     * guarantee that virProcessWait only fails due to failure to wait,\n     * and repeat the exitstatus check code ourselves.  */\n    ret = virProcessWait(cmd->pid, &status, true);\n    if (cmd->flags & VIR_EXEC_ASYNC_IO) {\n        cmd->flags &= ~VIR_EXEC_ASYNC_IO;\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n        VIR_FORCE_CLOSE(cmd->inpipe);\n        if (cmd->has_error) {\n            const char *msg = _(\"Error while processing command's IO\");\n            if (cmd->has_error < 0)\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", msg);\n            else\n                virReportSystemError(cmd->has_error, \"%s\", msg);\n            ret = -1;\n        }\n    }\n    if (ret == 0) {\n        cmd->pid = -1;\n        cmd->reap = false;\n        if (exitstatus && (cmd->rawStatus || WIFEXITED(status))) {\n            *exitstatus = cmd->rawStatus ? status : WEXITSTATUS(status);\n        } else if (status) {\n            g_autofree char *str = virCommandToString(cmd, false);\n            g_autofree char *st = virProcessTranslateStatus(status);\n            bool haveErrMsg = cmd->errbuf && *cmd->errbuf && (*cmd->errbuf)[0];\n\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Child process (%s) unexpected %s%s%s\"),\n                           str ? str : cmd->args[0], NULLSTR(st),\n                           haveErrMsg ? \": \" : \"\",\n                           haveErrMsg ? *cmd->errbuf : \"\");\n            return -1;\n        }\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virCommandRunAsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2503-2640",
    "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd, pid_t *pid)\n{\n    int ret = -1;\n    g_autofree char *str = NULL;\n    size_t i;\n    bool synchronous = false;\n    int infd[2] = {-1, -1};\n\n    if (!cmd || cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return -1;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return -1;\n    }\n\n    synchronous = cmd->flags & VIR_EXEC_RUN_SYNC;\n    cmd->flags &= ~VIR_EXEC_RUN_SYNC;\n\n    /* Buffer management can only be requested via virCommandRun or\n     * virCommandDoAsyncIO. */\n    if (cmd->inbuf && cmd->infd == -1 &&\n        (synchronous || cmd->flags & VIR_EXEC_ASYNC_IO)) {\n        if (virPipe(infd) < 0) {\n            cmd->has_error = -1;\n            return -1;\n        }\n        cmd->infd = infd[0];\n        cmd->inpipe = infd[1];\n\n        if (fcntl(cmd->inpipe, F_SETFL, O_NONBLOCK) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"fcntl failed to set O_NONBLOCK\"));\n            cmd->has_error = -1;\n            ret = -1;\n            goto cleanup;\n        }\n    } else if ((cmd->inbuf && cmd->infd == -1) ||\n               (cmd->outbuf && cmd->outfdptr != &cmd->outfd) ||\n               (cmd->errbuf && cmd->errfdptr != &cmd->errfd)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot mix string I/O with asynchronous command\"));\n        return -1;\n    }\n\n    if (cmd->pid != -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"command is already running as pid %lld\"),\n                       (long long) cmd->pid);\n        goto cleanup;\n    }\n\n    if (!synchronous && (cmd->flags & VIR_EXEC_DAEMON)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"daemonized command cannot use virCommandRunAsync\"));\n        goto cleanup;\n    }\n    if (cmd->pwd && (cmd->flags & VIR_EXEC_DAEMON)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"daemonized command cannot set working directory %s\"),\n                       cmd->pwd);\n        goto cleanup;\n    }\n    if (cmd->pidfile && !(cmd->flags & VIR_EXEC_DAEMON)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"creation of pid file requires daemonized command\"));\n        goto cleanup;\n    }\n\n    str = virCommandToString(cmd, false);\n    if (dryRunBuffer || dryRunCallback) {\n        dryRunStatus = 0;\n        if (!str) {\n            /* error already reported by virCommandToString */\n            goto cleanup;\n        }\n\n        if (dryRunBuffer) {\n            VIR_DEBUG(\"Dry run requested, appending stringified \"\n                      \"command to dryRunBuffer=%p\", dryRunBuffer);\n            virBufferAdd(dryRunBuffer, str, -1);\n            virBufferAddChar(dryRunBuffer, '\\n');\n        }\n        if (dryRunCallback) {\n            dryRunCallback((const char *const*)cmd->args,\n                           (const char *const*)cmd->env,\n                           cmd->inbuf, cmd->outbuf, cmd->errbuf,\n                           &dryRunStatus, dryRunOpaque);\n        }\n        ret = 0;\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"About to run %s\", str ? str : cmd->args[0]);\n    ret = virExec(cmd);\n    VIR_DEBUG(\"Command result %d, with PID %d\",\n              ret, (int)cmd->pid);\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (ret == 0 && pid)\n        *pid = cmd->pid;\n    else\n        cmd->reap = true;\n\n    if (ret == 0 && cmd->flags & VIR_EXEC_ASYNC_IO) {\n        if (cmd->inbuf)\n            VIR_FORCE_CLOSE(cmd->infd);\n        /* clear any error so we can catch if the helper thread reports one */\n        cmd->has_error = 0;\n        if (VIR_ALLOC(cmd->asyncioThread) < 0 ||\n            virThreadCreateFull(cmd->asyncioThread, true,\n                                virCommandDoAsyncIOHelper,\n                                \"cmd-async-io\", false, cmd) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to create thread \"\n                                   \"to process command's IO\"));\n            VIR_FREE(cmd->asyncioThread);\n            virCommandAbort(cmd);\n            ret = -1;\n        }\n    }\n\n cleanup:\n    if (ret < 0) {\n        VIR_FORCE_CLOSE(cmd->infd);\n        VIR_FORCE_CLOSE(cmd->inpipe);\n    }\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virBufferPtr dryRunBuffer;",
      "static virCommandDryRunCallback dryRunCallback;",
      "static void *dryRunOpaque;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->inpipe"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->infd"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandAbort",
          "args": [
            "cmd"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2949-2955",
          "snippet": "void\nvirCommandAbort(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    /* Mingw lacks WNOHANG and kill().  But since we haven't ported\n     * virExec to mingw yet, there's no process to be killed,\n     * making this implementation trivially correct for now :)  */\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAbort(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    /* Mingw lacks WNOHANG and kill().  But since we haven't ported\n     * virExec to mingw yet, there's no process to be killed,\n     * making this implementation trivially correct for now :)  */\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->asyncioThread"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to create thread \"\n                                   \"to process command's IO\")"
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to create thread \"\n                                   \"to process command's IO\""
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadCreateFull",
          "args": [
            "cmd->asyncioThread",
            "true",
            "virCommandDoAsyncIOHelper",
            "\"cmd-async-io\"",
            "false",
            "cmd"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "242-283",
          "snippet": "int virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "cmd->asyncioThread"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->infd"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->passfd"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->passfd[i].fd"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Command result %d, with PID %d\"",
            "ret",
            "(int)cmd->pid"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virExec",
          "args": [
            "cmd"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "virExec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "608-862",
          "snippet": "static int\nvirExec(virCommandPtr cmd)\n{\n    pid_t pid;\n    int null = -1;\n    int pipeout[2] = {-1, -1};\n    int pipeerr[2] = {-1, -1};\n    int childin = cmd->infd;\n    int childout = -1;\n    int childerr = -1;\n    g_autofree char *binarystr = NULL;\n    const char *binary = NULL;\n    int ret;\n    g_autofree gid_t *groups = NULL;\n    int ngroups;\n\n    if (cmd->args[0][0] != '/') {\n        if (!(binary = binarystr = virFindFileInPath(cmd->args[0]))) {\n            virReportSystemError(ENOENT,\n                                 _(\"Cannot find '%s' in path\"),\n                                 cmd->args[0]);\n            return -1;\n        }\n    } else {\n        binary = cmd->args[0];\n    }\n\n    if (childin < 0) {\n        if (getDevNull(&null) < 0)\n            goto cleanup;\n        childin = null;\n    }\n\n    if (cmd->outfdptr != NULL) {\n        if (*cmd->outfdptr == -1) {\n            if (virPipe(pipeout) < 0)\n                goto cleanup;\n\n            if ((cmd->flags & VIR_EXEC_NONBLOCK) &&\n                virSetNonBlock(pipeout[0]) == -1) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Failed to set non-blocking file descriptor flag\"));\n                goto cleanup;\n            }\n\n            childout = pipeout[1];\n        } else {\n            childout = *cmd->outfdptr;\n        }\n    } else {\n        if (getDevNull(&null) < 0)\n            goto cleanup;\n        childout = null;\n    }\n\n    if (cmd->errfdptr != NULL) {\n        if (cmd->errfdptr == cmd->outfdptr) {\n            childerr = childout;\n        } else if (*cmd->errfdptr == -1) {\n            if (virPipe(pipeerr) < 0)\n                goto cleanup;\n\n            if ((cmd->flags & VIR_EXEC_NONBLOCK) &&\n                virSetNonBlock(pipeerr[0]) == -1) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Failed to set non-blocking file descriptor flag\"));\n                goto cleanup;\n            }\n\n            childerr = pipeerr[1];\n        } else {\n            childerr = *cmd->errfdptr;\n        }\n    } else {\n        if (getDevNull(&null) < 0)\n            goto cleanup;\n        childerr = null;\n    }\n\n    if ((ngroups = virGetGroupList(cmd->uid, cmd->gid, &groups)) < 0)\n        goto cleanup;\n\n    pid = virFork();\n\n    if (pid < 0)\n        goto cleanup;\n\n    if (pid) { /* parent */\n        VIR_FORCE_CLOSE(null);\n        if (cmd->outfdptr && *cmd->outfdptr == -1) {\n            VIR_FORCE_CLOSE(pipeout[1]);\n            *cmd->outfdptr = pipeout[0];\n        }\n        if (cmd->errfdptr && *cmd->errfdptr == -1) {\n            VIR_FORCE_CLOSE(pipeerr[1]);\n            *cmd->errfdptr = pipeerr[0];\n        }\n\n        cmd->pid = pid;\n\n        return 0;\n    }\n\n    /* child */\n\n    if (cmd->mask)\n        umask(cmd->mask);\n    ret = EXIT_CANCELED;\n\n    if (virCommandMassClose(cmd, childin, childout, childerr) < 0)\n        goto fork_error;\n\n    if (prepareStdFd(childin, STDIN_FILENO) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to setup stdin file handle\"));\n        goto fork_error;\n    }\n    if (childout > 0 && prepareStdFd(childout, STDOUT_FILENO) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to setup stdout file handle\"));\n        goto fork_error;\n    }\n    if (childerr > 0 && prepareStdFd(childerr, STDERR_FILENO) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to setup stderr file handle\"));\n        goto fork_error;\n    }\n\n    if (childin != STDIN_FILENO && childin != null &&\n        childin != childerr && childin != childout)\n        VIR_FORCE_CLOSE(childin);\n    if (childout > STDERR_FILENO && childout != null && childout != childerr)\n        VIR_FORCE_CLOSE(childout);\n    if (childerr > STDERR_FILENO && childerr != null)\n        VIR_FORCE_CLOSE(childerr);\n    VIR_FORCE_CLOSE(null);\n\n    /* Initialize full logging for a while */\n    virLogSetFromEnv();\n\n    /* Daemonize as late as possible, so the parent process can detect\n     * the above errors with wait* */\n    if (cmd->flags & VIR_EXEC_DAEMON) {\n        if (setsid() < 0) {\n            virReportSystemError(errno,\n                                 \"%s\", _(\"cannot become session leader\"));\n            goto fork_error;\n        }\n\n        if (chdir(\"/\") < 0) {\n            virReportSystemError(errno,\n                                 \"%s\", _(\"cannot change to root directory\"));\n            goto fork_error;\n        }\n\n        pid = fork();\n        if (pid < 0) {\n            virReportSystemError(errno,\n                                 \"%s\", _(\"cannot fork child process\"));\n            goto fork_error;\n        }\n\n        if (pid > 0) {\n            if (cmd->pidfile && (virPidFileWritePath(cmd->pidfile, pid) < 0)) {\n                if (virProcessKillPainfully(pid, true) >= 0)\n                    virReportSystemError(errno,\n                                         _(\"could not write pidfile %s for %d\"),\n                                         cmd->pidfile, pid);\n                goto fork_error;\n            }\n            _exit(EXIT_SUCCESS);\n        }\n    }\n\n    if (virProcessSetMaxMemLock(0, cmd->maxMemLock) < 0)\n        goto fork_error;\n    if (virProcessSetMaxProcesses(0, cmd->maxProcesses) < 0)\n        goto fork_error;\n    if (virProcessSetMaxFiles(0, cmd->maxFiles) < 0)\n        goto fork_error;\n    if (cmd->setMaxCore &&\n        virProcessSetMaxCoreSize(0, cmd->maxCore) < 0)\n        goto fork_error;\n\n    if (cmd->hook) {\n        VIR_DEBUG(\"Run hook %p %p\", cmd->hook, cmd->opaque);\n        ret = cmd->hook(cmd->opaque);\n        VIR_DEBUG(\"Done hook %d\", ret);\n        if (ret < 0)\n           goto fork_error;\n    }\n\n# if defined(WITH_SECDRIVER_SELINUX)\n    if (cmd->seLinuxLabel) {\n        VIR_DEBUG(\"Setting child security label to %s\", cmd->seLinuxLabel);\n        if (setexeccon_raw(cmd->seLinuxLabel) == -1) {\n            virReportSystemError(errno,\n                                 _(\"unable to set SELinux security context \"\n                                   \"'%s' for '%s'\"),\n                                 cmd->seLinuxLabel, cmd->args[0]);\n            if (security_getenforce() == 1)\n                goto fork_error;\n        }\n    }\n# endif\n# if defined(WITH_SECDRIVER_APPARMOR)\n    if (cmd->appArmorProfile) {\n        VIR_DEBUG(\"Setting child AppArmor profile to %s\", cmd->appArmorProfile);\n        if (aa_change_profile(cmd->appArmorProfile) < 0) {\n            virReportSystemError(errno,\n                                 _(\"unable to set AppArmor profile '%s' \"\n                                   \"for '%s'\"),\n                                 cmd->appArmorProfile, cmd->args[0]);\n            goto fork_error;\n        }\n    }\n# endif\n\n    if (virExecCommon(cmd, groups, ngroups) < 0)\n        goto fork_error;\n\n    if (virCommandHandshakeChild(cmd) < 0)\n       goto fork_error;\n\n    /* Close logging again to ensure no FDs leak to child */\n    virLogReset();\n\n    if (cmd->env)\n        execve(binary, cmd->args, cmd->env);\n    else\n        execv(binary, cmd->args);\n\n    ret = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n    virReportSystemError(errno,\n                         _(\"cannot execute binary %s\"),\n                         cmd->args[0]);\n\n fork_error:\n    virDispatchError(NULL);\n    _exit(ret);\n\n cleanup:\n    /* This is cleanup of parent process only - child\n       should never jump here on error */\n\n    /* NB we don't virReportError() on any failures here\n       because the code which jumped here already raised\n       an error condition which we must not overwrite */\n    VIR_FORCE_CLOSE(pipeerr[0]);\n    VIR_FORCE_CLOSE(pipeerr[1]);\n    VIR_FORCE_CLOSE(pipeout[0]);\n    VIR_FORCE_CLOSE(pipeout[1]);\n    VIR_FORCE_CLOSE(null);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirExec(virCommandPtr cmd)\n{\n    pid_t pid;\n    int null = -1;\n    int pipeout[2] = {-1, -1};\n    int pipeerr[2] = {-1, -1};\n    int childin = cmd->infd;\n    int childout = -1;\n    int childerr = -1;\n    g_autofree char *binarystr = NULL;\n    const char *binary = NULL;\n    int ret;\n    g_autofree gid_t *groups = NULL;\n    int ngroups;\n\n    if (cmd->args[0][0] != '/') {\n        if (!(binary = binarystr = virFindFileInPath(cmd->args[0]))) {\n            virReportSystemError(ENOENT,\n                                 _(\"Cannot find '%s' in path\"),\n                                 cmd->args[0]);\n            return -1;\n        }\n    } else {\n        binary = cmd->args[0];\n    }\n\n    if (childin < 0) {\n        if (getDevNull(&null) < 0)\n            goto cleanup;\n        childin = null;\n    }\n\n    if (cmd->outfdptr != NULL) {\n        if (*cmd->outfdptr == -1) {\n            if (virPipe(pipeout) < 0)\n                goto cleanup;\n\n            if ((cmd->flags & VIR_EXEC_NONBLOCK) &&\n                virSetNonBlock(pipeout[0]) == -1) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Failed to set non-blocking file descriptor flag\"));\n                goto cleanup;\n            }\n\n            childout = pipeout[1];\n        } else {\n            childout = *cmd->outfdptr;\n        }\n    } else {\n        if (getDevNull(&null) < 0)\n            goto cleanup;\n        childout = null;\n    }\n\n    if (cmd->errfdptr != NULL) {\n        if (cmd->errfdptr == cmd->outfdptr) {\n            childerr = childout;\n        } else if (*cmd->errfdptr == -1) {\n            if (virPipe(pipeerr) < 0)\n                goto cleanup;\n\n            if ((cmd->flags & VIR_EXEC_NONBLOCK) &&\n                virSetNonBlock(pipeerr[0]) == -1) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Failed to set non-blocking file descriptor flag\"));\n                goto cleanup;\n            }\n\n            childerr = pipeerr[1];\n        } else {\n            childerr = *cmd->errfdptr;\n        }\n    } else {\n        if (getDevNull(&null) < 0)\n            goto cleanup;\n        childerr = null;\n    }\n\n    if ((ngroups = virGetGroupList(cmd->uid, cmd->gid, &groups)) < 0)\n        goto cleanup;\n\n    pid = virFork();\n\n    if (pid < 0)\n        goto cleanup;\n\n    if (pid) { /* parent */\n        VIR_FORCE_CLOSE(null);\n        if (cmd->outfdptr && *cmd->outfdptr == -1) {\n            VIR_FORCE_CLOSE(pipeout[1]);\n            *cmd->outfdptr = pipeout[0];\n        }\n        if (cmd->errfdptr && *cmd->errfdptr == -1) {\n            VIR_FORCE_CLOSE(pipeerr[1]);\n            *cmd->errfdptr = pipeerr[0];\n        }\n\n        cmd->pid = pid;\n\n        return 0;\n    }\n\n    /* child */\n\n    if (cmd->mask)\n        umask(cmd->mask);\n    ret = EXIT_CANCELED;\n\n    if (virCommandMassClose(cmd, childin, childout, childerr) < 0)\n        goto fork_error;\n\n    if (prepareStdFd(childin, STDIN_FILENO) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to setup stdin file handle\"));\n        goto fork_error;\n    }\n    if (childout > 0 && prepareStdFd(childout, STDOUT_FILENO) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to setup stdout file handle\"));\n        goto fork_error;\n    }\n    if (childerr > 0 && prepareStdFd(childerr, STDERR_FILENO) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to setup stderr file handle\"));\n        goto fork_error;\n    }\n\n    if (childin != STDIN_FILENO && childin != null &&\n        childin != childerr && childin != childout)\n        VIR_FORCE_CLOSE(childin);\n    if (childout > STDERR_FILENO && childout != null && childout != childerr)\n        VIR_FORCE_CLOSE(childout);\n    if (childerr > STDERR_FILENO && childerr != null)\n        VIR_FORCE_CLOSE(childerr);\n    VIR_FORCE_CLOSE(null);\n\n    /* Initialize full logging for a while */\n    virLogSetFromEnv();\n\n    /* Daemonize as late as possible, so the parent process can detect\n     * the above errors with wait* */\n    if (cmd->flags & VIR_EXEC_DAEMON) {\n        if (setsid() < 0) {\n            virReportSystemError(errno,\n                                 \"%s\", _(\"cannot become session leader\"));\n            goto fork_error;\n        }\n\n        if (chdir(\"/\") < 0) {\n            virReportSystemError(errno,\n                                 \"%s\", _(\"cannot change to root directory\"));\n            goto fork_error;\n        }\n\n        pid = fork();\n        if (pid < 0) {\n            virReportSystemError(errno,\n                                 \"%s\", _(\"cannot fork child process\"));\n            goto fork_error;\n        }\n\n        if (pid > 0) {\n            if (cmd->pidfile && (virPidFileWritePath(cmd->pidfile, pid) < 0)) {\n                if (virProcessKillPainfully(pid, true) >= 0)\n                    virReportSystemError(errno,\n                                         _(\"could not write pidfile %s for %d\"),\n                                         cmd->pidfile, pid);\n                goto fork_error;\n            }\n            _exit(EXIT_SUCCESS);\n        }\n    }\n\n    if (virProcessSetMaxMemLock(0, cmd->maxMemLock) < 0)\n        goto fork_error;\n    if (virProcessSetMaxProcesses(0, cmd->maxProcesses) < 0)\n        goto fork_error;\n    if (virProcessSetMaxFiles(0, cmd->maxFiles) < 0)\n        goto fork_error;\n    if (cmd->setMaxCore &&\n        virProcessSetMaxCoreSize(0, cmd->maxCore) < 0)\n        goto fork_error;\n\n    if (cmd->hook) {\n        VIR_DEBUG(\"Run hook %p %p\", cmd->hook, cmd->opaque);\n        ret = cmd->hook(cmd->opaque);\n        VIR_DEBUG(\"Done hook %d\", ret);\n        if (ret < 0)\n           goto fork_error;\n    }\n\n# if defined(WITH_SECDRIVER_SELINUX)\n    if (cmd->seLinuxLabel) {\n        VIR_DEBUG(\"Setting child security label to %s\", cmd->seLinuxLabel);\n        if (setexeccon_raw(cmd->seLinuxLabel) == -1) {\n            virReportSystemError(errno,\n                                 _(\"unable to set SELinux security context \"\n                                   \"'%s' for '%s'\"),\n                                 cmd->seLinuxLabel, cmd->args[0]);\n            if (security_getenforce() == 1)\n                goto fork_error;\n        }\n    }\n# endif\n# if defined(WITH_SECDRIVER_APPARMOR)\n    if (cmd->appArmorProfile) {\n        VIR_DEBUG(\"Setting child AppArmor profile to %s\", cmd->appArmorProfile);\n        if (aa_change_profile(cmd->appArmorProfile) < 0) {\n            virReportSystemError(errno,\n                                 _(\"unable to set AppArmor profile '%s' \"\n                                   \"for '%s'\"),\n                                 cmd->appArmorProfile, cmd->args[0]);\n            goto fork_error;\n        }\n    }\n# endif\n\n    if (virExecCommon(cmd, groups, ngroups) < 0)\n        goto fork_error;\n\n    if (virCommandHandshakeChild(cmd) < 0)\n       goto fork_error;\n\n    /* Close logging again to ensure no FDs leak to child */\n    virLogReset();\n\n    if (cmd->env)\n        execve(binary, cmd->args, cmd->env);\n    else\n        execv(binary, cmd->args);\n\n    ret = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n    virReportSystemError(errno,\n                         _(\"cannot execute binary %s\"),\n                         cmd->args[0]);\n\n fork_error:\n    virDispatchError(NULL);\n    _exit(ret);\n\n cleanup:\n    /* This is cleanup of parent process only - child\n       should never jump here on error */\n\n    /* NB we don't virReportError() on any failures here\n       because the code which jumped here already raised\n       an error condition which we must not overwrite */\n    VIR_FORCE_CLOSE(pipeerr[0]);\n    VIR_FORCE_CLOSE(pipeerr[1]);\n    VIR_FORCE_CLOSE(pipeout[0]);\n    VIR_FORCE_CLOSE(pipeout[1]);\n    VIR_FORCE_CLOSE(null);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"About to run %s\"",
            "str ? str : cmd->args[0]"
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dryRunCallback",
          "args": [
            "(const char *const*)cmd->args",
            "(const char *const*)cmd->env",
            "cmd->inbuf",
            "cmd->outbuf",
            "cmd->errbuf",
            "&dryRunStatus",
            "dryRunOpaque"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddChar",
          "args": [
            "dryRunBuffer",
            "'\\n'"
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "206-210",
          "snippet": "void\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "dryRunBuffer",
            "str",
            "-1"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Dry run requested, appending stringified \"\n                      \"command to dryRunBuffer=%p\"",
            "dryRunBuffer"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandToString",
          "args": [
            "cmd",
            "false"
          ],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2082-2135",
          "snippet": "char *\nvirCommandToString(virCommandPtr cmd, bool linebreaks)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool prevopt = false;\n\n    /* Cannot assume virCommandRun will be called; so report the error\n     * now.  If virCommandRun is called, it will report the same error. */\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return NULL;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return NULL;\n    }\n\n    for (i = 0; i < cmd->nenv; i++) {\n        /* In shell, a='b c' has a different meaning than 'a=b c', so\n         * we must determine where the '=' lives.  */\n        char *eq = strchr(cmd->env[i], '=');\n\n        if (!eq) {\n            virBufferFreeAndReset(&buf);\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid use of command API\"));\n            return NULL;\n        }\n        eq++;\n        virBufferAdd(&buf, cmd->env[i], eq - cmd->env[i]);\n        virBufferEscapeShell(&buf, eq);\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks)\n            virBufferAddLit(&buf, \"\\\\\\n\");\n    }\n    virBufferEscapeShell(&buf, cmd->args[0]);\n    for (i = 1; i < cmd->nargs; i++) {\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks) {\n            /* Line break if this is a --arg or if\n             * the previous arg was a positional option\n             */\n            if (cmd->args[i][0] == '-' ||\n                !prevopt)\n                virBufferAddLit(&buf, \"\\\\\\n\");\n        }\n        virBufferEscapeShell(&buf, cmd->args[i]);\n        prevopt = (cmd->args[i][0] == '-');\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nchar *\nvirCommandToString(virCommandPtr cmd, bool linebreaks)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool prevopt = false;\n\n    /* Cannot assume virCommandRun will be called; so report the error\n     * now.  If virCommandRun is called, it will report the same error. */\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return NULL;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return NULL;\n    }\n\n    for (i = 0; i < cmd->nenv; i++) {\n        /* In shell, a='b c' has a different meaning than 'a=b c', so\n         * we must determine where the '=' lives.  */\n        char *eq = strchr(cmd->env[i], '=');\n\n        if (!eq) {\n            virBufferFreeAndReset(&buf);\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid use of command API\"));\n            return NULL;\n        }\n        eq++;\n        virBufferAdd(&buf, cmd->env[i], eq - cmd->env[i]);\n        virBufferEscapeShell(&buf, eq);\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks)\n            virBufferAddLit(&buf, \"\\\\\\n\");\n    }\n    virBufferEscapeShell(&buf, cmd->args[0]);\n    for (i = 1; i < cmd->nargs; i++) {\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks) {\n            /* Line break if this is a --arg or if\n             * the previous arg was a positional option\n             */\n            if (cmd->args[i][0] == '-' ||\n                !prevopt)\n                virBufferAddLit(&buf, \"\\\\\\n\");\n        }\n        virBufferEscapeShell(&buf, cmd->args[i]);\n        prevopt = (cmd->args[i][0] == '-');\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"creation of pid file requires daemonized command\")"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"daemonized command cannot set working directory %s\")",
            "cmd->pwd"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"daemonized command cannot use virCommandRunAsync\")"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"command is already running as pid %lld\")",
            "(long long) cmd->pid"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot mix string I/O with asynchronous command\")"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"fcntl failed to set O_NONBLOCK\")"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "cmd->inpipe",
            "F_SETFL",
            "O_NONBLOCK"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPipe",
          "args": [
            "infd"
          ],
          "line": 2529
        },
        "resolved": true,
        "details": {
          "function_name": "virPipeNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1813-1817",
          "snippet": "int\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"invalid use of command API\")"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic virBufferPtr dryRunBuffer;\nstatic virCommandDryRunCallback dryRunCallback;\nstatic void *dryRunOpaque;\n\nint\nvirCommandRunAsync(virCommandPtr cmd, pid_t *pid)\n{\n    int ret = -1;\n    g_autofree char *str = NULL;\n    size_t i;\n    bool synchronous = false;\n    int infd[2] = {-1, -1};\n\n    if (!cmd || cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return -1;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return -1;\n    }\n\n    synchronous = cmd->flags & VIR_EXEC_RUN_SYNC;\n    cmd->flags &= ~VIR_EXEC_RUN_SYNC;\n\n    /* Buffer management can only be requested via virCommandRun or\n     * virCommandDoAsyncIO. */\n    if (cmd->inbuf && cmd->infd == -1 &&\n        (synchronous || cmd->flags & VIR_EXEC_ASYNC_IO)) {\n        if (virPipe(infd) < 0) {\n            cmd->has_error = -1;\n            return -1;\n        }\n        cmd->infd = infd[0];\n        cmd->inpipe = infd[1];\n\n        if (fcntl(cmd->inpipe, F_SETFL, O_NONBLOCK) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"fcntl failed to set O_NONBLOCK\"));\n            cmd->has_error = -1;\n            ret = -1;\n            goto cleanup;\n        }\n    } else if ((cmd->inbuf && cmd->infd == -1) ||\n               (cmd->outbuf && cmd->outfdptr != &cmd->outfd) ||\n               (cmd->errbuf && cmd->errfdptr != &cmd->errfd)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot mix string I/O with asynchronous command\"));\n        return -1;\n    }\n\n    if (cmd->pid != -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"command is already running as pid %lld\"),\n                       (long long) cmd->pid);\n        goto cleanup;\n    }\n\n    if (!synchronous && (cmd->flags & VIR_EXEC_DAEMON)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"daemonized command cannot use virCommandRunAsync\"));\n        goto cleanup;\n    }\n    if (cmd->pwd && (cmd->flags & VIR_EXEC_DAEMON)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"daemonized command cannot set working directory %s\"),\n                       cmd->pwd);\n        goto cleanup;\n    }\n    if (cmd->pidfile && !(cmd->flags & VIR_EXEC_DAEMON)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"creation of pid file requires daemonized command\"));\n        goto cleanup;\n    }\n\n    str = virCommandToString(cmd, false);\n    if (dryRunBuffer || dryRunCallback) {\n        dryRunStatus = 0;\n        if (!str) {\n            /* error already reported by virCommandToString */\n            goto cleanup;\n        }\n\n        if (dryRunBuffer) {\n            VIR_DEBUG(\"Dry run requested, appending stringified \"\n                      \"command to dryRunBuffer=%p\", dryRunBuffer);\n            virBufferAdd(dryRunBuffer, str, -1);\n            virBufferAddChar(dryRunBuffer, '\\n');\n        }\n        if (dryRunCallback) {\n            dryRunCallback((const char *const*)cmd->args,\n                           (const char *const*)cmd->env,\n                           cmd->inbuf, cmd->outbuf, cmd->errbuf,\n                           &dryRunStatus, dryRunOpaque);\n        }\n        ret = 0;\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"About to run %s\", str ? str : cmd->args[0]);\n    ret = virExec(cmd);\n    VIR_DEBUG(\"Command result %d, with PID %d\",\n              ret, (int)cmd->pid);\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (ret == 0 && pid)\n        *pid = cmd->pid;\n    else\n        cmd->reap = true;\n\n    if (ret == 0 && cmd->flags & VIR_EXEC_ASYNC_IO) {\n        if (cmd->inbuf)\n            VIR_FORCE_CLOSE(cmd->infd);\n        /* clear any error so we can catch if the helper thread reports one */\n        cmd->has_error = 0;\n        if (VIR_ALLOC(cmd->asyncioThread) < 0 ||\n            virThreadCreateFull(cmd->asyncioThread, true,\n                                virCommandDoAsyncIOHelper,\n                                \"cmd-async-io\", false, cmd) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to create thread \"\n                                   \"to process command's IO\"));\n            VIR_FREE(cmd->asyncioThread);\n            virCommandAbort(cmd);\n            ret = -1;\n        }\n    }\n\n cleanup:\n    if (ret < 0) {\n        VIR_FORCE_CLOSE(cmd->infd);\n        VIR_FORCE_CLOSE(cmd->inpipe);\n    }\n    return ret;\n}"
  },
  {
    "function_name": "virCommandDoAsyncIOHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2472-2480",
    "snippet": "static void\nvirCommandDoAsyncIOHelper(void *opaque)\n{\n    virCommandPtr cmd = opaque;\n    if (virCommandProcessIO(cmd) < 0) {\n        /* If something went wrong, save errno or -1 */\n        cmd->has_error = errno ? errno : -1;\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandProcessIO",
          "args": [
            "cmd"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandProcessIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2142-2295",
          "snippet": "static int\nvirCommandProcessIO(virCommandPtr cmd)\n{\n    int outfd = -1, errfd = -1;\n    size_t inlen = 0, outlen = 0, errlen = 0;\n    size_t inoff = 0;\n    int ret = 0;\n    g_autofree struct pollfd *fds = NULL;\n\n    if (dryRunBuffer || dryRunCallback) {\n        VIR_DEBUG(\"Dry run requested, skipping I/O processing\");\n        return 0;\n    }\n\n    /* With an input buffer, feed data to child\n     * via pipe */\n    if (cmd->inbuf)\n        inlen = strlen(cmd->inbuf);\n\n    /* With out/err buffer, the outfd/errfd have been filled with an\n     * FD for us.  Guarantee an allocated string with partial results\n     * even if we encounter a later failure, as well as freeing any\n     * results accumulated over a prior run of the same command.  */\n    if (cmd->outbuf) {\n        outfd = cmd->outfd;\n        VIR_FREE(*cmd->outbuf);\n        if (VIR_ALLOC_N(*cmd->outbuf, 1) < 0)\n            ret = -1;\n    }\n    if (cmd->errbuf) {\n        errfd = cmd->errfd;\n        VIR_FREE(*cmd->errbuf);\n        if (VIR_ALLOC_N(*cmd->errbuf, 1) < 0)\n            ret = -1;\n    }\n    if (ret == -1)\n        goto cleanup;\n    ret = -1;\n\n    if (VIR_ALLOC_N(fds, 3 + virCommandGetNumSendBuffers(cmd)) < 0)\n        goto cleanup;\n\n    for (;;) {\n        size_t i;\n        int nfds = 0;\n\n        if (cmd->inpipe != -1) {\n            fds[nfds].fd = cmd->inpipe;\n            fds[nfds].events = POLLOUT;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n        if (outfd != -1) {\n            fds[nfds].fd = outfd;\n            fds[nfds].events = POLLIN;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n        if (errfd != -1) {\n            fds[nfds].fd = errfd;\n            fds[nfds].events = POLLIN;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n\n        nfds += virCommandSendBuffersFillPollfd(cmd, fds, nfds);\n\n        if (nfds == 0)\n            break;\n\n        if (poll(fds, nfds, -1) < 0) {\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n            virReportSystemError(errno, \"%s\",\n                                 _(\"unable to poll on child\"));\n            goto cleanup;\n        }\n\n        for (i = 0; i < nfds; i++) {\n            if (fds[i].revents & (POLLIN | POLLHUP | POLLERR) &&\n                (fds[i].fd == errfd || fds[i].fd == outfd)) {\n                char data[1024];\n                char **buf;\n                size_t *len;\n                int done;\n                if (fds[i].fd == outfd) {\n                    buf = cmd->outbuf;\n                    len = &outlen;\n                } else {\n                    buf = cmd->errbuf;\n                    len = &errlen;\n                }\n                /* Silence a false positive from clang. */\n                sa_assert(buf);\n\n                done = read(fds[i].fd, data, sizeof(data));\n                if (done < 0) {\n                    if (errno != EINTR &&\n                        errno != EAGAIN) {\n                        virReportSystemError(errno, \"%s\",\n                                             (fds[i].fd == outfd) ?\n                                             _(\"unable to read child stdout\") :\n                                             _(\"unable to read child stderr\"));\n                        goto cleanup;\n                    }\n                } else if (done == 0) {\n                    if (fds[i].fd == outfd)\n                        outfd = -1;\n                    else\n                        errfd = -1;\n                } else {\n                    if (VIR_REALLOC_N(*buf, *len + done + 1) < 0)\n                        goto cleanup;\n                    memcpy(*buf + *len, data, done);\n                    *len += done;\n                }\n            }\n\n            if (fds[i].revents & (POLLOUT | POLLHUP | POLLERR) &&\n                fds[i].fd == cmd->inpipe) {\n                int done;\n\n                done = write(cmd->inpipe, cmd->inbuf + inoff,\n                             inlen - inoff);\n                if (done < 0) {\n                    if (errno == EPIPE) {\n                        VIR_DEBUG(\"child closed stdin early, ignoring EPIPE \"\n                                  \"on fd %d\", cmd->inpipe);\n                        VIR_FORCE_CLOSE(cmd->inpipe);\n                    } else if (errno != EINTR && errno != EAGAIN) {\n                        virReportSystemError(errno, \"%s\",\n                                             _(\"unable to write to child input\"));\n                        goto cleanup;\n                    }\n                } else {\n                    inoff += done;\n                    if (inoff == inlen)\n                        VIR_FORCE_CLOSE(cmd->inpipe);\n                }\n            } else if (fds[i].revents & (POLLOUT | POLLHUP | POLLERR)) {\n                if (virCommandSendBuffersHandlePoll(cmd, &fds[i]) < 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    if (cmd->outbuf && *cmd->outbuf)\n        (*cmd->outbuf)[outlen] = '\\0';\n    if (cmd->errbuf && *cmd->errbuf)\n        (*cmd->errbuf)[errlen] = '\\0';\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virBufferPtr dryRunBuffer;",
            "static virCommandDryRunCallback dryRunCallback;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic virBufferPtr dryRunBuffer;\nstatic virCommandDryRunCallback dryRunCallback;\n\nstatic int\nvirCommandProcessIO(virCommandPtr cmd)\n{\n    int outfd = -1, errfd = -1;\n    size_t inlen = 0, outlen = 0, errlen = 0;\n    size_t inoff = 0;\n    int ret = 0;\n    g_autofree struct pollfd *fds = NULL;\n\n    if (dryRunBuffer || dryRunCallback) {\n        VIR_DEBUG(\"Dry run requested, skipping I/O processing\");\n        return 0;\n    }\n\n    /* With an input buffer, feed data to child\n     * via pipe */\n    if (cmd->inbuf)\n        inlen = strlen(cmd->inbuf);\n\n    /* With out/err buffer, the outfd/errfd have been filled with an\n     * FD for us.  Guarantee an allocated string with partial results\n     * even if we encounter a later failure, as well as freeing any\n     * results accumulated over a prior run of the same command.  */\n    if (cmd->outbuf) {\n        outfd = cmd->outfd;\n        VIR_FREE(*cmd->outbuf);\n        if (VIR_ALLOC_N(*cmd->outbuf, 1) < 0)\n            ret = -1;\n    }\n    if (cmd->errbuf) {\n        errfd = cmd->errfd;\n        VIR_FREE(*cmd->errbuf);\n        if (VIR_ALLOC_N(*cmd->errbuf, 1) < 0)\n            ret = -1;\n    }\n    if (ret == -1)\n        goto cleanup;\n    ret = -1;\n\n    if (VIR_ALLOC_N(fds, 3 + virCommandGetNumSendBuffers(cmd)) < 0)\n        goto cleanup;\n\n    for (;;) {\n        size_t i;\n        int nfds = 0;\n\n        if (cmd->inpipe != -1) {\n            fds[nfds].fd = cmd->inpipe;\n            fds[nfds].events = POLLOUT;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n        if (outfd != -1) {\n            fds[nfds].fd = outfd;\n            fds[nfds].events = POLLIN;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n        if (errfd != -1) {\n            fds[nfds].fd = errfd;\n            fds[nfds].events = POLLIN;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n\n        nfds += virCommandSendBuffersFillPollfd(cmd, fds, nfds);\n\n        if (nfds == 0)\n            break;\n\n        if (poll(fds, nfds, -1) < 0) {\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n            virReportSystemError(errno, \"%s\",\n                                 _(\"unable to poll on child\"));\n            goto cleanup;\n        }\n\n        for (i = 0; i < nfds; i++) {\n            if (fds[i].revents & (POLLIN | POLLHUP | POLLERR) &&\n                (fds[i].fd == errfd || fds[i].fd == outfd)) {\n                char data[1024];\n                char **buf;\n                size_t *len;\n                int done;\n                if (fds[i].fd == outfd) {\n                    buf = cmd->outbuf;\n                    len = &outlen;\n                } else {\n                    buf = cmd->errbuf;\n                    len = &errlen;\n                }\n                /* Silence a false positive from clang. */\n                sa_assert(buf);\n\n                done = read(fds[i].fd, data, sizeof(data));\n                if (done < 0) {\n                    if (errno != EINTR &&\n                        errno != EAGAIN) {\n                        virReportSystemError(errno, \"%s\",\n                                             (fds[i].fd == outfd) ?\n                                             _(\"unable to read child stdout\") :\n                                             _(\"unable to read child stderr\"));\n                        goto cleanup;\n                    }\n                } else if (done == 0) {\n                    if (fds[i].fd == outfd)\n                        outfd = -1;\n                    else\n                        errfd = -1;\n                } else {\n                    if (VIR_REALLOC_N(*buf, *len + done + 1) < 0)\n                        goto cleanup;\n                    memcpy(*buf + *len, data, done);\n                    *len += done;\n                }\n            }\n\n            if (fds[i].revents & (POLLOUT | POLLHUP | POLLERR) &&\n                fds[i].fd == cmd->inpipe) {\n                int done;\n\n                done = write(cmd->inpipe, cmd->inbuf + inoff,\n                             inlen - inoff);\n                if (done < 0) {\n                    if (errno == EPIPE) {\n                        VIR_DEBUG(\"child closed stdin early, ignoring EPIPE \"\n                                  \"on fd %d\", cmd->inpipe);\n                        VIR_FORCE_CLOSE(cmd->inpipe);\n                    } else if (errno != EINTR && errno != EAGAIN) {\n                        virReportSystemError(errno, \"%s\",\n                                             _(\"unable to write to child input\"));\n                        goto cleanup;\n                    }\n                } else {\n                    inoff += done;\n                    if (inoff == inlen)\n                        VIR_FORCE_CLOSE(cmd->inpipe);\n                }\n            } else if (fds[i].revents & (POLLOUT | POLLHUP | POLLERR)) {\n                if (virCommandSendBuffersHandlePoll(cmd, &fds[i]) < 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    if (cmd->outbuf && *cmd->outbuf)\n        (*cmd->outbuf)[outlen] = '\\0';\n    if (cmd->errbuf && *cmd->errbuf)\n        (*cmd->errbuf)[errlen] = '\\0';\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic void\nvirCommandDoAsyncIOHelper(void *opaque)\n{\n    virCommandPtr cmd = opaque;\n    if (virCommandProcessIO(cmd) < 0) {\n        /* If something went wrong, save errno or -1 */\n        cmd->has_error = errno ? errno : -1;\n    }\n}"
  },
  {
    "function_name": "virCommandRun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2349-2469",
    "snippet": "int\nvirCommandRun(virCommandPtr cmd, int *exitstatus)\n{\n    int ret = 0;\n    char *outbuf = NULL;\n    char *errbuf = NULL;\n    struct stat st;\n    bool string_io;\n    bool async_io = false;\n    char *str;\n    int tmpfd;\n\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return -1;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return -1;\n    }\n\n    /* Avoid deadlock, by requiring that any open fd not under our\n     * control must be visiting a regular file, or that we are\n     * daemonized and no string io is required.  */\n    string_io = cmd->inbuf || cmd->outbuf || cmd->errbuf;\n    if (cmd->infd != -1 &&\n        (fstat(cmd->infd, &st) < 0 || !S_ISREG(st.st_mode)))\n        async_io = true;\n    if (cmd->outfdptr && cmd->outfdptr != &cmd->outfd &&\n        (*cmd->outfdptr == -1 ||\n         fstat(*cmd->outfdptr, &st) < 0 || !S_ISREG(st.st_mode)))\n        async_io = true;\n    if (cmd->errfdptr && cmd->errfdptr != &cmd->errfd &&\n        (*cmd->errfdptr == -1 ||\n         fstat(*cmd->errfdptr, &st) < 0 || !S_ISREG(st.st_mode)))\n        async_io = true;\n    if (async_io) {\n        if (!(cmd->flags & VIR_EXEC_DAEMON) || string_io) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot mix caller fds with blocking execution\"));\n            return -1;\n        }\n    } else {\n        if ((cmd->flags & VIR_EXEC_DAEMON) && string_io) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot mix string I/O with daemon\"));\n            return -1;\n        }\n    }\n\n    /* If caller requested the same string for stdout and stderr, then\n     * merge those into one string.  */\n    if (cmd->outbuf && cmd->outbuf == cmd->errbuf) {\n        cmd->errfdptr = &cmd->outfd;\n        cmd->errbuf = NULL;\n    }\n\n    /* If caller hasn't requested capture of stdout/err, then capture\n     * it ourselves so we can log it.  But the intermediate child for\n     * a daemon has no expected output, and we don't want our\n     * capturing pipes passed on to the daemon grandchild.\n     */\n    if (!(cmd->flags & VIR_EXEC_DAEMON)) {\n        if (!cmd->outfdptr) {\n            cmd->outfdptr = &cmd->outfd;\n            cmd->outbuf = &outbuf;\n            string_io = true;\n        }\n        if (!cmd->errfdptr) {\n            cmd->errfdptr = &cmd->errfd;\n            cmd->errbuf = &errbuf;\n            string_io = true;\n        }\n    }\n\n    cmd->flags |= VIR_EXEC_RUN_SYNC;\n    if (virCommandRunAsync(cmd, NULL) < 0) {\n        cmd->has_error = -1;\n        return -1;\n    }\n\n    if (string_io) {\n        VIR_FORCE_CLOSE(cmd->infd);\n        ret = virCommandProcessIO(cmd);\n    }\n\n    if (virCommandWait(cmd, exitstatus) < 0)\n        ret = -1;\n\n    str = (exitstatus ? virProcessTranslateStatus(*exitstatus)\n           : (char *) \"status 0\");\n    VIR_DEBUG(\"Result %s, stdout: '%s' stderr: '%s'\",\n              NULLSTR(str),\n              cmd->outbuf ? NULLSTR(*cmd->outbuf) : \"(null)\",\n              cmd->errbuf ? NULLSTR(*cmd->errbuf) : \"(null)\");\n    if (exitstatus)\n        VIR_FREE(str);\n\n    /* Reset any capturing, in case caller runs\n     * this identical command again */\n    VIR_FORCE_CLOSE(cmd->inpipe);\n    if (cmd->outbuf == &outbuf) {\n        tmpfd = cmd->outfd;\n        if (VIR_CLOSE(cmd->outfd) < 0)\n            VIR_DEBUG(\"ignoring failed close on fd %d\", tmpfd);\n        cmd->outfdptr = NULL;\n        cmd->outbuf = NULL;\n        VIR_FREE(outbuf);\n    }\n    if (cmd->errbuf == &errbuf) {\n        tmpfd = cmd->errfd;\n        if (VIR_CLOSE(cmd->errfd) < 0)\n            VIR_DEBUG(\"ignoring failed close on fd %d\", tmpfd);\n        cmd->errfdptr = NULL;\n        cmd->errbuf = NULL;\n        VIR_FREE(errbuf);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "errbuf"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"ignoring failed close on fd %d\"",
            "tmpfd"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "cmd->errfd"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "outbuf"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"ignoring failed close on fd %d\"",
            "tmpfd"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "cmd->outfd"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->inpipe"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Result %s, stdout: '%s' stderr: '%s'\"",
            "NULLSTR(str)",
            "cmd->outbuf ? NULLSTR(*cmd->outbuf) : \"(null)\"",
            "cmd->errbuf ? NULLSTR(*cmd->errbuf) : \"(null)\""
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "*cmd->errbuf"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "*cmd->outbuf"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "str"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virProcessTranslateStatus",
          "args": [
            "*exitstatus"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessTranslateStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "281-285",
          "snippet": "char *\nvirProcessTranslateStatus(int status)\n{\n    return g_strdup_printf(_(\"invalid value %d\"), status);\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *\nvirProcessTranslateStatus(int status)\n{\n    return g_strdup_printf(_(\"invalid value %d\"), status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandWait",
          "args": [
            "cmd",
            "exitstatus"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2940-2946",
          "snippet": "int\nvirCommandWait(virCommandPtr cmd G_GNUC_UNUSED, int *exitstatus G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandWait(virCommandPtr cmd G_GNUC_UNUSED, int *exitstatus G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandProcessIO",
          "args": [
            "cmd"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandProcessIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2142-2295",
          "snippet": "static int\nvirCommandProcessIO(virCommandPtr cmd)\n{\n    int outfd = -1, errfd = -1;\n    size_t inlen = 0, outlen = 0, errlen = 0;\n    size_t inoff = 0;\n    int ret = 0;\n    g_autofree struct pollfd *fds = NULL;\n\n    if (dryRunBuffer || dryRunCallback) {\n        VIR_DEBUG(\"Dry run requested, skipping I/O processing\");\n        return 0;\n    }\n\n    /* With an input buffer, feed data to child\n     * via pipe */\n    if (cmd->inbuf)\n        inlen = strlen(cmd->inbuf);\n\n    /* With out/err buffer, the outfd/errfd have been filled with an\n     * FD for us.  Guarantee an allocated string with partial results\n     * even if we encounter a later failure, as well as freeing any\n     * results accumulated over a prior run of the same command.  */\n    if (cmd->outbuf) {\n        outfd = cmd->outfd;\n        VIR_FREE(*cmd->outbuf);\n        if (VIR_ALLOC_N(*cmd->outbuf, 1) < 0)\n            ret = -1;\n    }\n    if (cmd->errbuf) {\n        errfd = cmd->errfd;\n        VIR_FREE(*cmd->errbuf);\n        if (VIR_ALLOC_N(*cmd->errbuf, 1) < 0)\n            ret = -1;\n    }\n    if (ret == -1)\n        goto cleanup;\n    ret = -1;\n\n    if (VIR_ALLOC_N(fds, 3 + virCommandGetNumSendBuffers(cmd)) < 0)\n        goto cleanup;\n\n    for (;;) {\n        size_t i;\n        int nfds = 0;\n\n        if (cmd->inpipe != -1) {\n            fds[nfds].fd = cmd->inpipe;\n            fds[nfds].events = POLLOUT;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n        if (outfd != -1) {\n            fds[nfds].fd = outfd;\n            fds[nfds].events = POLLIN;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n        if (errfd != -1) {\n            fds[nfds].fd = errfd;\n            fds[nfds].events = POLLIN;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n\n        nfds += virCommandSendBuffersFillPollfd(cmd, fds, nfds);\n\n        if (nfds == 0)\n            break;\n\n        if (poll(fds, nfds, -1) < 0) {\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n            virReportSystemError(errno, \"%s\",\n                                 _(\"unable to poll on child\"));\n            goto cleanup;\n        }\n\n        for (i = 0; i < nfds; i++) {\n            if (fds[i].revents & (POLLIN | POLLHUP | POLLERR) &&\n                (fds[i].fd == errfd || fds[i].fd == outfd)) {\n                char data[1024];\n                char **buf;\n                size_t *len;\n                int done;\n                if (fds[i].fd == outfd) {\n                    buf = cmd->outbuf;\n                    len = &outlen;\n                } else {\n                    buf = cmd->errbuf;\n                    len = &errlen;\n                }\n                /* Silence a false positive from clang. */\n                sa_assert(buf);\n\n                done = read(fds[i].fd, data, sizeof(data));\n                if (done < 0) {\n                    if (errno != EINTR &&\n                        errno != EAGAIN) {\n                        virReportSystemError(errno, \"%s\",\n                                             (fds[i].fd == outfd) ?\n                                             _(\"unable to read child stdout\") :\n                                             _(\"unable to read child stderr\"));\n                        goto cleanup;\n                    }\n                } else if (done == 0) {\n                    if (fds[i].fd == outfd)\n                        outfd = -1;\n                    else\n                        errfd = -1;\n                } else {\n                    if (VIR_REALLOC_N(*buf, *len + done + 1) < 0)\n                        goto cleanup;\n                    memcpy(*buf + *len, data, done);\n                    *len += done;\n                }\n            }\n\n            if (fds[i].revents & (POLLOUT | POLLHUP | POLLERR) &&\n                fds[i].fd == cmd->inpipe) {\n                int done;\n\n                done = write(cmd->inpipe, cmd->inbuf + inoff,\n                             inlen - inoff);\n                if (done < 0) {\n                    if (errno == EPIPE) {\n                        VIR_DEBUG(\"child closed stdin early, ignoring EPIPE \"\n                                  \"on fd %d\", cmd->inpipe);\n                        VIR_FORCE_CLOSE(cmd->inpipe);\n                    } else if (errno != EINTR && errno != EAGAIN) {\n                        virReportSystemError(errno, \"%s\",\n                                             _(\"unable to write to child input\"));\n                        goto cleanup;\n                    }\n                } else {\n                    inoff += done;\n                    if (inoff == inlen)\n                        VIR_FORCE_CLOSE(cmd->inpipe);\n                }\n            } else if (fds[i].revents & (POLLOUT | POLLHUP | POLLERR)) {\n                if (virCommandSendBuffersHandlePoll(cmd, &fds[i]) < 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    if (cmd->outbuf && *cmd->outbuf)\n        (*cmd->outbuf)[outlen] = '\\0';\n    if (cmd->errbuf && *cmd->errbuf)\n        (*cmd->errbuf)[errlen] = '\\0';\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virBufferPtr dryRunBuffer;",
            "static virCommandDryRunCallback dryRunCallback;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic virBufferPtr dryRunBuffer;\nstatic virCommandDryRunCallback dryRunCallback;\n\nstatic int\nvirCommandProcessIO(virCommandPtr cmd)\n{\n    int outfd = -1, errfd = -1;\n    size_t inlen = 0, outlen = 0, errlen = 0;\n    size_t inoff = 0;\n    int ret = 0;\n    g_autofree struct pollfd *fds = NULL;\n\n    if (dryRunBuffer || dryRunCallback) {\n        VIR_DEBUG(\"Dry run requested, skipping I/O processing\");\n        return 0;\n    }\n\n    /* With an input buffer, feed data to child\n     * via pipe */\n    if (cmd->inbuf)\n        inlen = strlen(cmd->inbuf);\n\n    /* With out/err buffer, the outfd/errfd have been filled with an\n     * FD for us.  Guarantee an allocated string with partial results\n     * even if we encounter a later failure, as well as freeing any\n     * results accumulated over a prior run of the same command.  */\n    if (cmd->outbuf) {\n        outfd = cmd->outfd;\n        VIR_FREE(*cmd->outbuf);\n        if (VIR_ALLOC_N(*cmd->outbuf, 1) < 0)\n            ret = -1;\n    }\n    if (cmd->errbuf) {\n        errfd = cmd->errfd;\n        VIR_FREE(*cmd->errbuf);\n        if (VIR_ALLOC_N(*cmd->errbuf, 1) < 0)\n            ret = -1;\n    }\n    if (ret == -1)\n        goto cleanup;\n    ret = -1;\n\n    if (VIR_ALLOC_N(fds, 3 + virCommandGetNumSendBuffers(cmd)) < 0)\n        goto cleanup;\n\n    for (;;) {\n        size_t i;\n        int nfds = 0;\n\n        if (cmd->inpipe != -1) {\n            fds[nfds].fd = cmd->inpipe;\n            fds[nfds].events = POLLOUT;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n        if (outfd != -1) {\n            fds[nfds].fd = outfd;\n            fds[nfds].events = POLLIN;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n        if (errfd != -1) {\n            fds[nfds].fd = errfd;\n            fds[nfds].events = POLLIN;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n\n        nfds += virCommandSendBuffersFillPollfd(cmd, fds, nfds);\n\n        if (nfds == 0)\n            break;\n\n        if (poll(fds, nfds, -1) < 0) {\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n            virReportSystemError(errno, \"%s\",\n                                 _(\"unable to poll on child\"));\n            goto cleanup;\n        }\n\n        for (i = 0; i < nfds; i++) {\n            if (fds[i].revents & (POLLIN | POLLHUP | POLLERR) &&\n                (fds[i].fd == errfd || fds[i].fd == outfd)) {\n                char data[1024];\n                char **buf;\n                size_t *len;\n                int done;\n                if (fds[i].fd == outfd) {\n                    buf = cmd->outbuf;\n                    len = &outlen;\n                } else {\n                    buf = cmd->errbuf;\n                    len = &errlen;\n                }\n                /* Silence a false positive from clang. */\n                sa_assert(buf);\n\n                done = read(fds[i].fd, data, sizeof(data));\n                if (done < 0) {\n                    if (errno != EINTR &&\n                        errno != EAGAIN) {\n                        virReportSystemError(errno, \"%s\",\n                                             (fds[i].fd == outfd) ?\n                                             _(\"unable to read child stdout\") :\n                                             _(\"unable to read child stderr\"));\n                        goto cleanup;\n                    }\n                } else if (done == 0) {\n                    if (fds[i].fd == outfd)\n                        outfd = -1;\n                    else\n                        errfd = -1;\n                } else {\n                    if (VIR_REALLOC_N(*buf, *len + done + 1) < 0)\n                        goto cleanup;\n                    memcpy(*buf + *len, data, done);\n                    *len += done;\n                }\n            }\n\n            if (fds[i].revents & (POLLOUT | POLLHUP | POLLERR) &&\n                fds[i].fd == cmd->inpipe) {\n                int done;\n\n                done = write(cmd->inpipe, cmd->inbuf + inoff,\n                             inlen - inoff);\n                if (done < 0) {\n                    if (errno == EPIPE) {\n                        VIR_DEBUG(\"child closed stdin early, ignoring EPIPE \"\n                                  \"on fd %d\", cmd->inpipe);\n                        VIR_FORCE_CLOSE(cmd->inpipe);\n                    } else if (errno != EINTR && errno != EAGAIN) {\n                        virReportSystemError(errno, \"%s\",\n                                             _(\"unable to write to child input\"));\n                        goto cleanup;\n                    }\n                } else {\n                    inoff += done;\n                    if (inoff == inlen)\n                        VIR_FORCE_CLOSE(cmd->inpipe);\n                }\n            } else if (fds[i].revents & (POLLOUT | POLLHUP | POLLERR)) {\n                if (virCommandSendBuffersHandlePoll(cmd, &fds[i]) < 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    if (cmd->outbuf && *cmd->outbuf)\n        (*cmd->outbuf)[outlen] = '\\0';\n    if (cmd->errbuf && *cmd->errbuf)\n        (*cmd->errbuf)[errlen] = '\\0';\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->infd"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRunAsync",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot mix string I/O with daemon\")"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot mix string I/O with daemon\""
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot mix caller fds with blocking execution\")"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "*cmd->errfdptr",
            "&st"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "*cmd->outfdptr",
            "&st"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st.st_mode"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "cmd->infd",
            "&st"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"invalid use of command API\")"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRun(virCommandPtr cmd, int *exitstatus)\n{\n    int ret = 0;\n    char *outbuf = NULL;\n    char *errbuf = NULL;\n    struct stat st;\n    bool string_io;\n    bool async_io = false;\n    char *str;\n    int tmpfd;\n\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return -1;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return -1;\n    }\n\n    /* Avoid deadlock, by requiring that any open fd not under our\n     * control must be visiting a regular file, or that we are\n     * daemonized and no string io is required.  */\n    string_io = cmd->inbuf || cmd->outbuf || cmd->errbuf;\n    if (cmd->infd != -1 &&\n        (fstat(cmd->infd, &st) < 0 || !S_ISREG(st.st_mode)))\n        async_io = true;\n    if (cmd->outfdptr && cmd->outfdptr != &cmd->outfd &&\n        (*cmd->outfdptr == -1 ||\n         fstat(*cmd->outfdptr, &st) < 0 || !S_ISREG(st.st_mode)))\n        async_io = true;\n    if (cmd->errfdptr && cmd->errfdptr != &cmd->errfd &&\n        (*cmd->errfdptr == -1 ||\n         fstat(*cmd->errfdptr, &st) < 0 || !S_ISREG(st.st_mode)))\n        async_io = true;\n    if (async_io) {\n        if (!(cmd->flags & VIR_EXEC_DAEMON) || string_io) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot mix caller fds with blocking execution\"));\n            return -1;\n        }\n    } else {\n        if ((cmd->flags & VIR_EXEC_DAEMON) && string_io) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot mix string I/O with daemon\"));\n            return -1;\n        }\n    }\n\n    /* If caller requested the same string for stdout and stderr, then\n     * merge those into one string.  */\n    if (cmd->outbuf && cmd->outbuf == cmd->errbuf) {\n        cmd->errfdptr = &cmd->outfd;\n        cmd->errbuf = NULL;\n    }\n\n    /* If caller hasn't requested capture of stdout/err, then capture\n     * it ourselves so we can log it.  But the intermediate child for\n     * a daemon has no expected output, and we don't want our\n     * capturing pipes passed on to the daemon grandchild.\n     */\n    if (!(cmd->flags & VIR_EXEC_DAEMON)) {\n        if (!cmd->outfdptr) {\n            cmd->outfdptr = &cmd->outfd;\n            cmd->outbuf = &outbuf;\n            string_io = true;\n        }\n        if (!cmd->errfdptr) {\n            cmd->errfdptr = &cmd->errfd;\n            cmd->errbuf = &errbuf;\n            string_io = true;\n        }\n    }\n\n    cmd->flags |= VIR_EXEC_RUN_SYNC;\n    if (virCommandRunAsync(cmd, NULL) < 0) {\n        cmd->has_error = -1;\n        return -1;\n    }\n\n    if (string_io) {\n        VIR_FORCE_CLOSE(cmd->infd);\n        ret = virCommandProcessIO(cmd);\n    }\n\n    if (virCommandWait(cmd, exitstatus) < 0)\n        ret = -1;\n\n    str = (exitstatus ? virProcessTranslateStatus(*exitstatus)\n           : (char *) \"status 0\");\n    VIR_DEBUG(\"Result %s, stdout: '%s' stderr: '%s'\",\n              NULLSTR(str),\n              cmd->outbuf ? NULLSTR(*cmd->outbuf) : \"(null)\",\n              cmd->errbuf ? NULLSTR(*cmd->errbuf) : \"(null)\");\n    if (exitstatus)\n        VIR_FREE(str);\n\n    /* Reset any capturing, in case caller runs\n     * this identical command again */\n    VIR_FORCE_CLOSE(cmd->inpipe);\n    if (cmd->outbuf == &outbuf) {\n        tmpfd = cmd->outfd;\n        if (VIR_CLOSE(cmd->outfd) < 0)\n            VIR_DEBUG(\"ignoring failed close on fd %d\", tmpfd);\n        cmd->outfdptr = NULL;\n        cmd->outbuf = NULL;\n        VIR_FREE(outbuf);\n    }\n    if (cmd->errbuf == &errbuf) {\n        tmpfd = cmd->errfd;\n        if (VIR_CLOSE(cmd->errfd) < 0)\n            VIR_DEBUG(\"ignoring failed close on fd %d\", tmpfd);\n        cmd->errfdptr = NULL;\n        cmd->errbuf = NULL;\n        VIR_FREE(errbuf);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virCommandExec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2310-2331",
    "snippet": "int virCommandExec(virCommandPtr cmd, gid_t *groups, int ngroups)\n{\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return -1;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return -1;\n    }\n\n    if (virExecCommon(cmd, groups, ngroups) < 0)\n        return -1;\n\n    execve(cmd->args[0], cmd->args, cmd->env);\n\n    virReportSystemError(errno,\n                         _(\"cannot execute binary %s\"),\n                         cmd->args[0]);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot execute binary %s\")",
            "cmd->args[0]"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot execute binary %s\""
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "cmd->args[0]",
            "cmd->args",
            "cmd->env"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virExecCommon",
          "args": [
            "cmd",
            "groups",
            "ngroups"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "virExecCommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "422-444",
          "snippet": "static int\nvirExecCommon(virCommandPtr cmd, gid_t *groups, int ngroups)\n{\n    if (cmd->uid != (uid_t)-1 || cmd->gid != (gid_t)-1 ||\n        cmd->capabilities || (cmd->flags & VIR_EXEC_CLEAR_CAPS)) {\n        VIR_DEBUG(\"Setting child uid:gid to %d:%d with caps %llx\",\n                  (int)cmd->uid, (int)cmd->gid, cmd->capabilities);\n        if (virSetUIDGIDWithCaps(cmd->uid, cmd->gid, groups, ngroups,\n                                 cmd->capabilities,\n                                 !!(cmd->flags & VIR_EXEC_CLEAR_CAPS)) < 0)\n            return -1;\n    }\n\n    if (cmd->pwd) {\n        VIR_DEBUG(\"Running child in %s\", cmd->pwd);\n        if (chdir(cmd->pwd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to change to %s\"), cmd->pwd);\n            return -1;\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirExecCommon(virCommandPtr cmd, gid_t *groups, int ngroups)\n{\n    if (cmd->uid != (uid_t)-1 || cmd->gid != (gid_t)-1 ||\n        cmd->capabilities || (cmd->flags & VIR_EXEC_CLEAR_CAPS)) {\n        VIR_DEBUG(\"Setting child uid:gid to %d:%d with caps %llx\",\n                  (int)cmd->uid, (int)cmd->gid, cmd->capabilities);\n        if (virSetUIDGIDWithCaps(cmd->uid, cmd->gid, groups, ngroups,\n                                 cmd->capabilities,\n                                 !!(cmd->flags & VIR_EXEC_CLEAR_CAPS)) < 0)\n            return -1;\n    }\n\n    if (cmd->pwd) {\n        VIR_DEBUG(\"Running child in %s\", cmd->pwd);\n        if (chdir(cmd->pwd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to change to %s\"), cmd->pwd);\n            return -1;\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"invalid use of command API\")"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint virCommandExec(virCommandPtr cmd, gid_t *groups, int ngroups)\n{\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return -1;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return -1;\n    }\n\n    if (virExecCommon(cmd, groups, ngroups) < 0)\n        return -1;\n\n    execve(cmd->args[0], cmd->args, cmd->env);\n\n    virReportSystemError(errno,\n                         _(\"cannot execute binary %s\"),\n                         cmd->args[0]);\n    return -1;\n}"
  },
  {
    "function_name": "virCommandProcessIO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2142-2295",
    "snippet": "static int\nvirCommandProcessIO(virCommandPtr cmd)\n{\n    int outfd = -1, errfd = -1;\n    size_t inlen = 0, outlen = 0, errlen = 0;\n    size_t inoff = 0;\n    int ret = 0;\n    g_autofree struct pollfd *fds = NULL;\n\n    if (dryRunBuffer || dryRunCallback) {\n        VIR_DEBUG(\"Dry run requested, skipping I/O processing\");\n        return 0;\n    }\n\n    /* With an input buffer, feed data to child\n     * via pipe */\n    if (cmd->inbuf)\n        inlen = strlen(cmd->inbuf);\n\n    /* With out/err buffer, the outfd/errfd have been filled with an\n     * FD for us.  Guarantee an allocated string with partial results\n     * even if we encounter a later failure, as well as freeing any\n     * results accumulated over a prior run of the same command.  */\n    if (cmd->outbuf) {\n        outfd = cmd->outfd;\n        VIR_FREE(*cmd->outbuf);\n        if (VIR_ALLOC_N(*cmd->outbuf, 1) < 0)\n            ret = -1;\n    }\n    if (cmd->errbuf) {\n        errfd = cmd->errfd;\n        VIR_FREE(*cmd->errbuf);\n        if (VIR_ALLOC_N(*cmd->errbuf, 1) < 0)\n            ret = -1;\n    }\n    if (ret == -1)\n        goto cleanup;\n    ret = -1;\n\n    if (VIR_ALLOC_N(fds, 3 + virCommandGetNumSendBuffers(cmd)) < 0)\n        goto cleanup;\n\n    for (;;) {\n        size_t i;\n        int nfds = 0;\n\n        if (cmd->inpipe != -1) {\n            fds[nfds].fd = cmd->inpipe;\n            fds[nfds].events = POLLOUT;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n        if (outfd != -1) {\n            fds[nfds].fd = outfd;\n            fds[nfds].events = POLLIN;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n        if (errfd != -1) {\n            fds[nfds].fd = errfd;\n            fds[nfds].events = POLLIN;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n\n        nfds += virCommandSendBuffersFillPollfd(cmd, fds, nfds);\n\n        if (nfds == 0)\n            break;\n\n        if (poll(fds, nfds, -1) < 0) {\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n            virReportSystemError(errno, \"%s\",\n                                 _(\"unable to poll on child\"));\n            goto cleanup;\n        }\n\n        for (i = 0; i < nfds; i++) {\n            if (fds[i].revents & (POLLIN | POLLHUP | POLLERR) &&\n                (fds[i].fd == errfd || fds[i].fd == outfd)) {\n                char data[1024];\n                char **buf;\n                size_t *len;\n                int done;\n                if (fds[i].fd == outfd) {\n                    buf = cmd->outbuf;\n                    len = &outlen;\n                } else {\n                    buf = cmd->errbuf;\n                    len = &errlen;\n                }\n                /* Silence a false positive from clang. */\n                sa_assert(buf);\n\n                done = read(fds[i].fd, data, sizeof(data));\n                if (done < 0) {\n                    if (errno != EINTR &&\n                        errno != EAGAIN) {\n                        virReportSystemError(errno, \"%s\",\n                                             (fds[i].fd == outfd) ?\n                                             _(\"unable to read child stdout\") :\n                                             _(\"unable to read child stderr\"));\n                        goto cleanup;\n                    }\n                } else if (done == 0) {\n                    if (fds[i].fd == outfd)\n                        outfd = -1;\n                    else\n                        errfd = -1;\n                } else {\n                    if (VIR_REALLOC_N(*buf, *len + done + 1) < 0)\n                        goto cleanup;\n                    memcpy(*buf + *len, data, done);\n                    *len += done;\n                }\n            }\n\n            if (fds[i].revents & (POLLOUT | POLLHUP | POLLERR) &&\n                fds[i].fd == cmd->inpipe) {\n                int done;\n\n                done = write(cmd->inpipe, cmd->inbuf + inoff,\n                             inlen - inoff);\n                if (done < 0) {\n                    if (errno == EPIPE) {\n                        VIR_DEBUG(\"child closed stdin early, ignoring EPIPE \"\n                                  \"on fd %d\", cmd->inpipe);\n                        VIR_FORCE_CLOSE(cmd->inpipe);\n                    } else if (errno != EINTR && errno != EAGAIN) {\n                        virReportSystemError(errno, \"%s\",\n                                             _(\"unable to write to child input\"));\n                        goto cleanup;\n                    }\n                } else {\n                    inoff += done;\n                    if (inoff == inlen)\n                        VIR_FORCE_CLOSE(cmd->inpipe);\n                }\n            } else if (fds[i].revents & (POLLOUT | POLLHUP | POLLERR)) {\n                if (virCommandSendBuffersHandlePoll(cmd, &fds[i]) < 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    if (cmd->outbuf && *cmd->outbuf)\n        (*cmd->outbuf)[outlen] = '\\0';\n    if (cmd->errbuf && *cmd->errbuf)\n        (*cmd->errbuf)[errlen] = '\\0';\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virBufferPtr dryRunBuffer;",
      "static virCommandDryRunCallback dryRunCallback;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandSendBuffersHandlePoll",
          "args": [
            "cmd",
            "&fds[i]"
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSendBuffersHandlePoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1793-1826",
          "snippet": "static int\nvirCommandSendBuffersHandlePoll(virCommandPtr cmd,\n                                struct pollfd *fds)\n{\n    size_t i;\n    ssize_t done;\n\n    for (i = 0; i < virCommandGetNumSendBuffers(cmd); i++) {\n        if (fds->fd == cmd->sendBuffers[i].fd)\n            break;\n    }\n    if (i == virCommandGetNumSendBuffers(cmd))\n        return 0;\n\n    done = write(fds->fd,\n                 cmd->sendBuffers[i].buffer + cmd->sendBuffers[i].offset,\n                 cmd->sendBuffers[i].buflen - cmd->sendBuffers[i].offset);\n    if (done < 0) {\n        if (errno == EPIPE) {\n            VIR_DEBUG(\"child closed PIPE early, ignoring EPIPE \"\n                      \"on fd %d\", cmd->sendBuffers[i].fd);\n            VIR_FORCE_CLOSE(cmd->sendBuffers[i].fd);\n        } else if (errno != EINTR && errno != EAGAIN) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"unable to write to child input\"));\n            return -1;\n        }\n    } else {\n        cmd->sendBuffers[i].offset += done;\n        if (cmd->sendBuffers[i].offset == cmd->sendBuffers[i].buflen)\n            VIR_FORCE_CLOSE(cmd->sendBuffers[i].fd);\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandSendBuffersHandlePoll(virCommandPtr cmd,\n                                struct pollfd *fds)\n{\n    size_t i;\n    ssize_t done;\n\n    for (i = 0; i < virCommandGetNumSendBuffers(cmd); i++) {\n        if (fds->fd == cmd->sendBuffers[i].fd)\n            break;\n    }\n    if (i == virCommandGetNumSendBuffers(cmd))\n        return 0;\n\n    done = write(fds->fd,\n                 cmd->sendBuffers[i].buffer + cmd->sendBuffers[i].offset,\n                 cmd->sendBuffers[i].buflen - cmd->sendBuffers[i].offset);\n    if (done < 0) {\n        if (errno == EPIPE) {\n            VIR_DEBUG(\"child closed PIPE early, ignoring EPIPE \"\n                      \"on fd %d\", cmd->sendBuffers[i].fd);\n            VIR_FORCE_CLOSE(cmd->sendBuffers[i].fd);\n        } else if (errno != EINTR && errno != EAGAIN) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"unable to write to child input\"));\n            return -1;\n        }\n    } else {\n        cmd->sendBuffers[i].offset += done;\n        if (cmd->sendBuffers[i].offset == cmd->sendBuffers[i].buflen)\n            VIR_FORCE_CLOSE(cmd->sendBuffers[i].fd);\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->inpipe"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"unable to write to child input\")"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to write to child input\""
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->inpipe"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"child closed stdin early, ignoring EPIPE \"\n                                  \"on fd %d\"",
            "cmd->inpipe"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "cmd->inpipe",
            "cmd->inbuf + inoff",
            "inlen - inoff"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*buf + *len",
            "data",
            "done"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "*buf",
            "*len + done + 1"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "(fds[i].fd == outfd) ?\n                                             _(\"unable to read child stdout\") :\n                                             _(\"unable to read child stderr\")"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fds[i].fd",
            "data",
            "sizeof(data)"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "pthread_sigmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "84-92",
          "snippet": "static inline int pthread_sigmask(int how,\n                                  const void *set,\n                                  void *old)\n{\n    (void) how;\n    (void) set;\n    (void) old;\n    return 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int pthread_sigmask(int how,\n                                  const void *set,\n                                  void *old)\n{\n    (void) how;\n    (void) set;\n    (void) old;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sa_assert",
          "args": [
            "buf"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"unable to poll on child\")"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "fds",
            "nfds",
            "-1"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandSendBuffersFillPollfd",
          "args": [
            "cmd",
            "fds",
            "nfds"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSendBuffersFillPollfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1773-1790",
          "snippet": "static int\nvirCommandSendBuffersFillPollfd(virCommandPtr cmd,\n                                struct pollfd *fds,\n                                int startidx)\n{\n    size_t i, j;\n\n    for (i = 0, j = 0; i < virCommandGetNumSendBuffers(cmd); i++) {\n        if (cmd->sendBuffers[i].fd >= 0) {\n            fds[startidx + j].fd = cmd->sendBuffers[i].fd;\n            fds[startidx + j].events = POLLOUT;\n            fds[startidx + j].revents = 0;\n            j++;\n        }\n    }\n\n    return j;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandSendBuffersFillPollfd(virCommandPtr cmd,\n                                struct pollfd *fds,\n                                int startidx)\n{\n    size_t i, j;\n\n    for (i = 0, j = 0; i < virCommandGetNumSendBuffers(cmd); i++) {\n        if (cmd->sendBuffers[i].fd >= 0) {\n            fds[startidx + j].fd = cmd->sendBuffers[i].fd;\n            fds[startidx + j].events = POLLOUT;\n            fds[startidx + j].revents = 0;\n            j++;\n        }\n    }\n\n    return j;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "fds",
            "3 + virCommandGetNumSendBuffers(cmd)"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandGetNumSendBuffers",
          "args": [
            "cmd"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandGetNumSendBuffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1710-1714",
          "snippet": "static int\nvirCommandGetNumSendBuffers(virCommandPtr cmd)\n{\n    return cmd->numSendBuffers;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandGetNumSendBuffers(virCommandPtr cmd)\n{\n    return cmd->numSendBuffers;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*cmd->errbuf",
            "1"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*cmd->errbuf"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*cmd->outbuf",
            "1"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*cmd->outbuf"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd->inbuf"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Dry run requested, skipping I/O processing\""
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic virBufferPtr dryRunBuffer;\nstatic virCommandDryRunCallback dryRunCallback;\n\nstatic int\nvirCommandProcessIO(virCommandPtr cmd)\n{\n    int outfd = -1, errfd = -1;\n    size_t inlen = 0, outlen = 0, errlen = 0;\n    size_t inoff = 0;\n    int ret = 0;\n    g_autofree struct pollfd *fds = NULL;\n\n    if (dryRunBuffer || dryRunCallback) {\n        VIR_DEBUG(\"Dry run requested, skipping I/O processing\");\n        return 0;\n    }\n\n    /* With an input buffer, feed data to child\n     * via pipe */\n    if (cmd->inbuf)\n        inlen = strlen(cmd->inbuf);\n\n    /* With out/err buffer, the outfd/errfd have been filled with an\n     * FD for us.  Guarantee an allocated string with partial results\n     * even if we encounter a later failure, as well as freeing any\n     * results accumulated over a prior run of the same command.  */\n    if (cmd->outbuf) {\n        outfd = cmd->outfd;\n        VIR_FREE(*cmd->outbuf);\n        if (VIR_ALLOC_N(*cmd->outbuf, 1) < 0)\n            ret = -1;\n    }\n    if (cmd->errbuf) {\n        errfd = cmd->errfd;\n        VIR_FREE(*cmd->errbuf);\n        if (VIR_ALLOC_N(*cmd->errbuf, 1) < 0)\n            ret = -1;\n    }\n    if (ret == -1)\n        goto cleanup;\n    ret = -1;\n\n    if (VIR_ALLOC_N(fds, 3 + virCommandGetNumSendBuffers(cmd)) < 0)\n        goto cleanup;\n\n    for (;;) {\n        size_t i;\n        int nfds = 0;\n\n        if (cmd->inpipe != -1) {\n            fds[nfds].fd = cmd->inpipe;\n            fds[nfds].events = POLLOUT;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n        if (outfd != -1) {\n            fds[nfds].fd = outfd;\n            fds[nfds].events = POLLIN;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n        if (errfd != -1) {\n            fds[nfds].fd = errfd;\n            fds[nfds].events = POLLIN;\n            fds[nfds].revents = 0;\n            nfds++;\n        }\n\n        nfds += virCommandSendBuffersFillPollfd(cmd, fds, nfds);\n\n        if (nfds == 0)\n            break;\n\n        if (poll(fds, nfds, -1) < 0) {\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n            virReportSystemError(errno, \"%s\",\n                                 _(\"unable to poll on child\"));\n            goto cleanup;\n        }\n\n        for (i = 0; i < nfds; i++) {\n            if (fds[i].revents & (POLLIN | POLLHUP | POLLERR) &&\n                (fds[i].fd == errfd || fds[i].fd == outfd)) {\n                char data[1024];\n                char **buf;\n                size_t *len;\n                int done;\n                if (fds[i].fd == outfd) {\n                    buf = cmd->outbuf;\n                    len = &outlen;\n                } else {\n                    buf = cmd->errbuf;\n                    len = &errlen;\n                }\n                /* Silence a false positive from clang. */\n                sa_assert(buf);\n\n                done = read(fds[i].fd, data, sizeof(data));\n                if (done < 0) {\n                    if (errno != EINTR &&\n                        errno != EAGAIN) {\n                        virReportSystemError(errno, \"%s\",\n                                             (fds[i].fd == outfd) ?\n                                             _(\"unable to read child stdout\") :\n                                             _(\"unable to read child stderr\"));\n                        goto cleanup;\n                    }\n                } else if (done == 0) {\n                    if (fds[i].fd == outfd)\n                        outfd = -1;\n                    else\n                        errfd = -1;\n                } else {\n                    if (VIR_REALLOC_N(*buf, *len + done + 1) < 0)\n                        goto cleanup;\n                    memcpy(*buf + *len, data, done);\n                    *len += done;\n                }\n            }\n\n            if (fds[i].revents & (POLLOUT | POLLHUP | POLLERR) &&\n                fds[i].fd == cmd->inpipe) {\n                int done;\n\n                done = write(cmd->inpipe, cmd->inbuf + inoff,\n                             inlen - inoff);\n                if (done < 0) {\n                    if (errno == EPIPE) {\n                        VIR_DEBUG(\"child closed stdin early, ignoring EPIPE \"\n                                  \"on fd %d\", cmd->inpipe);\n                        VIR_FORCE_CLOSE(cmd->inpipe);\n                    } else if (errno != EINTR && errno != EAGAIN) {\n                        virReportSystemError(errno, \"%s\",\n                                             _(\"unable to write to child input\"));\n                        goto cleanup;\n                    }\n                } else {\n                    inoff += done;\n                    if (inoff == inlen)\n                        VIR_FORCE_CLOSE(cmd->inpipe);\n                }\n            } else if (fds[i].revents & (POLLOUT | POLLHUP | POLLERR)) {\n                if (virCommandSendBuffersHandlePoll(cmd, &fds[i]) < 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    if (cmd->outbuf && *cmd->outbuf)\n        (*cmd->outbuf)[outlen] = '\\0';\n    if (cmd->errbuf && *cmd->errbuf)\n        (*cmd->errbuf)[errlen] = '\\0';\n    return ret;\n}"
  },
  {
    "function_name": "virCommandToString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2082-2135",
    "snippet": "char *\nvirCommandToString(virCommandPtr cmd, bool linebreaks)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool prevopt = false;\n\n    /* Cannot assume virCommandRun will be called; so report the error\n     * now.  If virCommandRun is called, it will report the same error. */\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return NULL;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return NULL;\n    }\n\n    for (i = 0; i < cmd->nenv; i++) {\n        /* In shell, a='b c' has a different meaning than 'a=b c', so\n         * we must determine where the '=' lives.  */\n        char *eq = strchr(cmd->env[i], '=');\n\n        if (!eq) {\n            virBufferFreeAndReset(&buf);\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid use of command API\"));\n            return NULL;\n        }\n        eq++;\n        virBufferAdd(&buf, cmd->env[i], eq - cmd->env[i]);\n        virBufferEscapeShell(&buf, eq);\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks)\n            virBufferAddLit(&buf, \"\\\\\\n\");\n    }\n    virBufferEscapeShell(&buf, cmd->args[0]);\n    for (i = 1; i < cmd->nargs; i++) {\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks) {\n            /* Line break if this is a --arg or if\n             * the previous arg was a positional option\n             */\n            if (cmd->args[i][0] == '-' ||\n                !prevopt)\n                virBufferAddLit(&buf, \"\\\\\\n\");\n        }\n        virBufferEscapeShell(&buf, cmd->args[i]);\n        prevopt = (cmd->args[i][0] == '-');\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeShell",
          "args": [
            "&buf",
            "cmd->args[i]"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeShell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "554-597",
          "snippet": "void\nvirBufferEscapeShell(virBufferPtr buf, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    /* Only quote if str includes shell metacharacters. */\n    if (*str && !strpbrk(str, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\")) {\n        virBufferAdd(buf, str, -1);\n        return;\n    }\n\n    if (*str) {\n        len = strlen(str);\n\n        escaped = g_malloc0_n(len + 1, 4);\n    } else {\n        virBufferAddLit(buf, \"''\");\n        return;\n    }\n\n    cur = str;\n    out = escaped;\n\n    *out++ = '\\'';\n    while (*cur != 0) {\n        if (*cur == '\\'') {\n            *out++ = '\\'';\n            /* Replace literal ' with a close ', a \\', and a open ' */\n            *out++ = '\\\\';\n            *out++ = '\\'';\n        }\n        *out++ = *cur++;\n    }\n    *out++ = '\\'';\n    *out = 0;\n\n    virBufferAdd(buf, escaped, -1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeShell(virBufferPtr buf, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    /* Only quote if str includes shell metacharacters. */\n    if (*str && !strpbrk(str, \"\\r\\t\\n !\\\"#$&'()*;<>?[\\\\]^`{|}~\")) {\n        virBufferAdd(buf, str, -1);\n        return;\n    }\n\n    if (*str) {\n        len = strlen(str);\n\n        escaped = g_malloc0_n(len + 1, 4);\n    } else {\n        virBufferAddLit(buf, \"''\");\n        return;\n    }\n\n    cur = str;\n    out = escaped;\n\n    *out++ = '\\'';\n    while (*cur != 0) {\n        if (*cur == '\\'') {\n            *out++ = '\\'';\n            /* Replace literal ' with a close ', a \\', and a open ' */\n            *out++ = '\\\\';\n            *out++ = '\\'';\n        }\n        *out++ = *cur++;\n    }\n    *out++ = '\\'';\n    *out = 0;\n\n    virBufferAdd(buf, escaped, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"\\\\\\n\""
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddChar",
          "args": [
            "&buf",
            "' '"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "206-210",
          "snippet": "void\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"\\\\\\n\""
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "&buf",
            "cmd->env[i]",
            "eq - cmd->env[i]"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"invalid use of command API\")"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid use of command API\""
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cmd->env[i]",
            "'='"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"invalid use of command API\")"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nchar *\nvirCommandToString(virCommandPtr cmd, bool linebreaks)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool prevopt = false;\n\n    /* Cannot assume virCommandRun will be called; so report the error\n     * now.  If virCommandRun is called, it will report the same error. */\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return NULL;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return NULL;\n    }\n\n    for (i = 0; i < cmd->nenv; i++) {\n        /* In shell, a='b c' has a different meaning than 'a=b c', so\n         * we must determine where the '=' lives.  */\n        char *eq = strchr(cmd->env[i], '=');\n\n        if (!eq) {\n            virBufferFreeAndReset(&buf);\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid use of command API\"));\n            return NULL;\n        }\n        eq++;\n        virBufferAdd(&buf, cmd->env[i], eq - cmd->env[i]);\n        virBufferEscapeShell(&buf, eq);\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks)\n            virBufferAddLit(&buf, \"\\\\\\n\");\n    }\n    virBufferEscapeShell(&buf, cmd->args[0]);\n    for (i = 1; i < cmd->nargs; i++) {\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks) {\n            /* Line break if this is a --arg or if\n             * the previous arg was a positional option\n             */\n            if (cmd->args[i][0] == '-' ||\n                !prevopt)\n                virBufferAddLit(&buf, \"\\\\\\n\");\n        }\n        virBufferEscapeShell(&buf, cmd->args[i]);\n        prevopt = (cmd->args[i][0] == '-');\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "virCommandWriteArgLog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2039-2067",
    "snippet": "void\nvirCommandWriteArgLog(virCommandPtr cmd, int logfd)\n{\n    int ioError = 0;\n    size_t i;\n\n    /* Any errors will be reported later by virCommandRun, which means\n     * no command will be run, so there is nothing to log. */\n    if (!cmd || cmd->has_error)\n        return;\n\n    for (i = 0; i < cmd->nenv; i++) {\n        if (safewrite(logfd, cmd->env[i], strlen(cmd->env[i])) < 0)\n            ioError = errno;\n        if (safewrite(logfd, \" \", 1) < 0)\n            ioError = errno;\n    }\n    for (i = 0; i < cmd->nargs; i++) {\n        if (safewrite(logfd, cmd->args[i], strlen(cmd->args[i])) < 0)\n            ioError = errno;\n        if (safewrite(logfd, i == cmd->nargs - 1 ? \"\\n\" : \" \", 1) < 0)\n            ioError = errno;\n    }\n\n    if (ioError) {\n        VIR_WARN(\"Unable to write command %s args to logfile: %s\",\n                 cmd->args[0], g_strerror(ioError));\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to write command %s args to logfile: %s\"",
            "cmd->args[0]",
            "g_strerror(ioError)"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "ioError"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "logfd",
            "i == cmd->nargs - 1 ? \"\\n\" : \" \"",
            "1"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd->args[i]"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd->env[i]"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandWriteArgLog(virCommandPtr cmd, int logfd)\n{\n    int ioError = 0;\n    size_t i;\n\n    /* Any errors will be reported later by virCommandRun, which means\n     * no command will be run, so there is nothing to log. */\n    if (!cmd || cmd->has_error)\n        return;\n\n    for (i = 0; i < cmd->nenv; i++) {\n        if (safewrite(logfd, cmd->env[i], strlen(cmd->env[i])) < 0)\n            ioError = errno;\n        if (safewrite(logfd, \" \", 1) < 0)\n            ioError = errno;\n    }\n    for (i = 0; i < cmd->nargs; i++) {\n        if (safewrite(logfd, cmd->args[i], strlen(cmd->args[i])) < 0)\n            ioError = errno;\n        if (safewrite(logfd, i == cmd->nargs - 1 ? \"\\n\" : \" \", 1) < 0)\n            ioError = errno;\n    }\n\n    if (ioError) {\n        VIR_WARN(\"Unable to write command %s args to logfile: %s\",\n                 cmd->args[0], g_strerror(ioError));\n    }\n}"
  },
  {
    "function_name": "virCommandSetPreExecHook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "2013-2026",
    "snippet": "void\nvirCommandSetPreExecHook(virCommandPtr cmd, virExecHook hook, void *opaque)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->hook) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify hook twice\");\n        return;\n    }\n    cmd->hook = hook;\n    cmd->opaque = opaque;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cannot specify hook twice\""
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetPreExecHook(virCommandPtr cmd, virExecHook hook, void *opaque)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->hook) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify hook twice\");\n        return;\n    }\n    cmd->hook = hook;\n    cmd->opaque = opaque;\n}"
  },
  {
    "function_name": "virCommandSetErrorFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1984-1997",
    "snippet": "void\nvirCommandSetErrorFD(virCommandPtr cmd, int *errfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errfdptr = errfd;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cannot specify stderr twice\""
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetErrorFD(virCommandPtr cmd, int *errfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errfdptr = errfd;\n}"
  },
  {
    "function_name": "virCommandSetOutputFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1958-1971",
    "snippet": "void\nvirCommandSetOutputFD(virCommandPtr cmd, int *outfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outfdptr = outfd;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cannot specify output twice\""
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputFD(virCommandPtr cmd, int *outfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outfdptr = outfd;\n}"
  },
  {
    "function_name": "virCommandSetInputFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1928-1946",
    "snippet": "void\nvirCommandSetInputFD(virCommandPtr cmd, int infd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->infd != -1 || cmd->inbuf) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify input twice\");\n        return;\n    }\n    if (infd < 0) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify invalid input fd\");\n        return;\n    }\n\n    cmd->infd = infd;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cannot specify invalid input fd\""
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cannot specify input twice\""
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetInputFD(virCommandPtr cmd, int infd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->infd != -1 || cmd->inbuf) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify input twice\");\n        return;\n    }\n    if (infd < 0) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify invalid input fd\");\n        return;\n    }\n\n    cmd->infd = infd;\n}"
  },
  {
    "function_name": "virCommandSetErrorBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1903-1918",
    "snippet": "void\nvirCommandSetErrorBuffer(virCommandPtr cmd, char **errbuf)\n{\n    *errbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errbuf = errbuf;\n    cmd->errfdptr = &cmd->errfd;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cannot specify stderr twice\""
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetErrorBuffer(virCommandPtr cmd, char **errbuf)\n{\n    *errbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errbuf = errbuf;\n    cmd->errfdptr = &cmd->errfd;\n}"
  },
  {
    "function_name": "virCommandSetOutputBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1869-1884",
    "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cannot specify output twice\""
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
  },
  {
    "function_name": "virCommandSetInputBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1840-1853",
    "snippet": "void\nvirCommandSetInputBuffer(virCommandPtr cmd, const char *inbuf)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->infd != -1 || cmd->inbuf) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify input twice\");\n        return;\n    }\n\n    cmd->inbuf = g_strdup(inbuf);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "inbuf"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cannot specify input twice\""
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetInputBuffer(virCommandPtr cmd, const char *inbuf)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->infd != -1 || cmd->inbuf) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify input twice\");\n        return;\n    }\n\n    cmd->inbuf = g_strdup(inbuf);\n}"
  },
  {
    "function_name": "virCommandSendBuffersHandlePoll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1793-1826",
    "snippet": "static int\nvirCommandSendBuffersHandlePoll(virCommandPtr cmd,\n                                struct pollfd *fds)\n{\n    size_t i;\n    ssize_t done;\n\n    for (i = 0; i < virCommandGetNumSendBuffers(cmd); i++) {\n        if (fds->fd == cmd->sendBuffers[i].fd)\n            break;\n    }\n    if (i == virCommandGetNumSendBuffers(cmd))\n        return 0;\n\n    done = write(fds->fd,\n                 cmd->sendBuffers[i].buffer + cmd->sendBuffers[i].offset,\n                 cmd->sendBuffers[i].buflen - cmd->sendBuffers[i].offset);\n    if (done < 0) {\n        if (errno == EPIPE) {\n            VIR_DEBUG(\"child closed PIPE early, ignoring EPIPE \"\n                      \"on fd %d\", cmd->sendBuffers[i].fd);\n            VIR_FORCE_CLOSE(cmd->sendBuffers[i].fd);\n        } else if (errno != EINTR && errno != EAGAIN) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"unable to write to child input\"));\n            return -1;\n        }\n    } else {\n        cmd->sendBuffers[i].offset += done;\n        if (cmd->sendBuffers[i].offset == cmd->sendBuffers[i].buflen)\n            VIR_FORCE_CLOSE(cmd->sendBuffers[i].fd);\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->sendBuffers[i].fd"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"unable to write to child input\")"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to write to child input\""
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->sendBuffers[i].fd"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"child closed PIPE early, ignoring EPIPE \"\n                      \"on fd %d\"",
            "cmd->sendBuffers[i].fd"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fds->fd",
            "cmd->sendBuffers[i].buffer + cmd->sendBuffers[i].offset",
            "cmd->sendBuffers[i].buflen - cmd->sendBuffers[i].offset"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandGetNumSendBuffers",
          "args": [
            "cmd"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandGetNumSendBuffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1710-1714",
          "snippet": "static int\nvirCommandGetNumSendBuffers(virCommandPtr cmd)\n{\n    return cmd->numSendBuffers;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandGetNumSendBuffers(virCommandPtr cmd)\n{\n    return cmd->numSendBuffers;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandSendBuffersHandlePoll(virCommandPtr cmd,\n                                struct pollfd *fds)\n{\n    size_t i;\n    ssize_t done;\n\n    for (i = 0; i < virCommandGetNumSendBuffers(cmd); i++) {\n        if (fds->fd == cmd->sendBuffers[i].fd)\n            break;\n    }\n    if (i == virCommandGetNumSendBuffers(cmd))\n        return 0;\n\n    done = write(fds->fd,\n                 cmd->sendBuffers[i].buffer + cmd->sendBuffers[i].offset,\n                 cmd->sendBuffers[i].buflen - cmd->sendBuffers[i].offset);\n    if (done < 0) {\n        if (errno == EPIPE) {\n            VIR_DEBUG(\"child closed PIPE early, ignoring EPIPE \"\n                      \"on fd %d\", cmd->sendBuffers[i].fd);\n            VIR_FORCE_CLOSE(cmd->sendBuffers[i].fd);\n        } else if (errno != EINTR && errno != EAGAIN) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"unable to write to child input\"));\n            return -1;\n        }\n    } else {\n        cmd->sendBuffers[i].offset += done;\n        if (cmd->sendBuffers[i].offset == cmd->sendBuffers[i].buflen)\n            VIR_FORCE_CLOSE(cmd->sendBuffers[i].fd);\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virCommandSendBuffersFillPollfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1773-1790",
    "snippet": "static int\nvirCommandSendBuffersFillPollfd(virCommandPtr cmd,\n                                struct pollfd *fds,\n                                int startidx)\n{\n    size_t i, j;\n\n    for (i = 0, j = 0; i < virCommandGetNumSendBuffers(cmd); i++) {\n        if (cmd->sendBuffers[i].fd >= 0) {\n            fds[startidx + j].fd = cmd->sendBuffers[i].fd;\n            fds[startidx + j].events = POLLOUT;\n            fds[startidx + j].revents = 0;\n            j++;\n        }\n    }\n\n    return j;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandGetNumSendBuffers",
          "args": [
            "cmd"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandGetNumSendBuffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1710-1714",
          "snippet": "static int\nvirCommandGetNumSendBuffers(virCommandPtr cmd)\n{\n    return cmd->numSendBuffers;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandGetNumSendBuffers(virCommandPtr cmd)\n{\n    return cmd->numSendBuffers;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandSendBuffersFillPollfd(virCommandPtr cmd,\n                                struct pollfd *fds,\n                                int startidx)\n{\n    size_t i, j;\n\n    for (i = 0, j = 0; i < virCommandGetNumSendBuffers(cmd); i++) {\n        if (cmd->sendBuffers[i].fd >= 0) {\n            fds[startidx + j].fd = cmd->sendBuffers[i].fd;\n            fds[startidx + j].events = POLLOUT;\n            fds[startidx + j].revents = 0;\n            j++;\n        }\n    }\n\n    return j;\n}"
  },
  {
    "function_name": "virCommandSetSendBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1739-1770",
    "snippet": "int\nvirCommandSetSendBuffer(virCommandPtr cmd,\n                        int fd,\n                        unsigned char *buffer, size_t buflen)\n{\n    size_t i;\n\n    if (!cmd || cmd->has_error)\n        return -1;\n\n    if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"fcntl failed to set O_NONBLOCK\"));\n        cmd->has_error = errno;\n        return -1;\n    }\n\n    i = virCommandGetNumSendBuffers(cmd);\n    if (VIR_REALLOC_N(cmd->sendBuffers, i + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return -1;\n    }\n\n    cmd->sendBuffers[i].fd = fd;\n    cmd->sendBuffers[i].buffer = buffer;\n    cmd->sendBuffers[i].buflen = buflen;\n    cmd->sendBuffers[i].offset = 0;\n\n    cmd->numSendBuffers++;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "cmd->sendBuffers",
            "i + 1"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandGetNumSendBuffers",
          "args": [
            "cmd"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandGetNumSendBuffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1710-1714",
          "snippet": "static int\nvirCommandGetNumSendBuffers(virCommandPtr cmd)\n{\n    return cmd->numSendBuffers;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandGetNumSendBuffers(virCommandPtr cmd)\n{\n    return cmd->numSendBuffers;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"fcntl failed to set O_NONBLOCK\")"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"fcntl failed to set O_NONBLOCK\""
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETFL",
            "O_NONBLOCK"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandSetSendBuffer(virCommandPtr cmd,\n                        int fd,\n                        unsigned char *buffer, size_t buflen)\n{\n    size_t i;\n\n    if (!cmd || cmd->has_error)\n        return -1;\n\n    if (fcntl(fd, F_SETFL, O_NONBLOCK) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"fcntl failed to set O_NONBLOCK\"));\n        cmd->has_error = errno;\n        return -1;\n    }\n\n    i = virCommandGetNumSendBuffers(cmd);\n    if (VIR_REALLOC_N(cmd->sendBuffers, i + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return -1;\n    }\n\n    cmd->sendBuffers[i].fd = fd;\n    cmd->sendBuffers[i].buffer = buffer;\n    cmd->sendBuffers[i].buflen = buflen;\n    cmd->sendBuffers[i].offset = 0;\n\n    cmd->numSendBuffers++;\n\n    return 0;\n}"
  },
  {
    "function_name": "virCommandFreeSendBuffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1717-1727",
    "snippet": "static void\nvirCommandFreeSendBuffers(virCommandPtr cmd)\n{\n    size_t i;\n\n    for (i = 0; i < virCommandGetNumSendBuffers(cmd); i++) {\n        VIR_FORCE_CLOSE(cmd->sendBuffers[i].fd);\n        VIR_FREE(cmd->sendBuffers[i].buffer);\n    }\n    VIR_FREE(cmd->sendBuffers);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->sendBuffers"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->sendBuffers[i].buffer"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->sendBuffers[i].fd"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandGetNumSendBuffers",
          "args": [
            "cmd"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandGetNumSendBuffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1710-1714",
          "snippet": "static int\nvirCommandGetNumSendBuffers(virCommandPtr cmd)\n{\n    return cmd->numSendBuffers;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandGetNumSendBuffers(virCommandPtr cmd)\n{\n    return cmd->numSendBuffers;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic void\nvirCommandFreeSendBuffers(virCommandPtr cmd)\n{\n    size_t i;\n\n    for (i = 0; i < virCommandGetNumSendBuffers(cmd); i++) {\n        VIR_FORCE_CLOSE(cmd->sendBuffers[i].fd);\n        VIR_FREE(cmd->sendBuffers[i].buffer);\n    }\n    VIR_FREE(cmd->sendBuffers);\n}"
  },
  {
    "function_name": "virCommandGetNumSendBuffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1710-1714",
    "snippet": "static int\nvirCommandGetNumSendBuffers(virCommandPtr cmd)\n{\n    return cmd->numSendBuffers;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandGetNumSendBuffers(virCommandPtr cmd)\n{\n    return cmd->numSendBuffers;\n}"
  },
  {
    "function_name": "virCommandSetWorkingDirectory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1695-1707",
    "snippet": "void\nvirCommandSetWorkingDirectory(virCommandPtr cmd, const char *pwd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->pwd) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot set directory twice\");\n    } else {\n        cmd->pwd = g_strdup(pwd);\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "pwd"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cannot set directory twice\""
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetWorkingDirectory(virCommandPtr cmd, const char *pwd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->pwd) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot set directory twice\");\n    } else {\n        cmd->pwd = g_strdup(pwd);\n    }\n}"
  },
  {
    "function_name": "virCommandAddArgList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1655-1684",
    "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "list"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "arg"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "list",
            "char*"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "list",
            "cmd"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "cmd->args",
            "cmd->maxargs",
            "cmd->nargs",
            "narg + 1"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "list"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "list",
            "constchar *"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "list",
            "cmd"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
  },
  {
    "function_name": "virCommandAddArgSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1617-1646",
    "snippet": "void\nvirCommandAddArgSet(virCommandPtr cmd, const char *const*vals)\n{\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (vals[0] == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n\n    while (vals[narg] != NULL)\n        narg++;\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    narg = 0;\n    while (vals[narg] != NULL) {\n        char *arg;\n\n        arg = g_strdup(vals[narg++]);\n        cmd->args[cmd->nargs++] = arg;\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "vals[narg++]"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "cmd->args",
            "cmd->maxargs",
            "cmd->nargs",
            "narg + 1"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgSet(virCommandPtr cmd, const char *const*vals)\n{\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (vals[0] == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n\n    while (vals[narg] != NULL)\n        narg++;\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    narg = 0;\n    while (vals[narg] != NULL) {\n        char *arg;\n\n        arg = g_strdup(vals[narg++]);\n        cmd->args[cmd->nargs++] = arg;\n    }\n}"
  },
  {
    "function_name": "virCommandAddArgPair",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1600-1608",
    "snippet": "void\nvirCommandAddArgPair(virCommandPtr cmd, const char *name, const char *val)\n{\n    if (name == NULL || val == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n    virCommandAddArgFormat(cmd, \"%s=%s\", name, val);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"%s=%s\"",
            "name",
            "val"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgPair(virCommandPtr cmd, const char *name, const char *val)\n{\n    if (name == NULL || val == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n    virCommandAddArgFormat(cmd, \"%s=%s\", name, val);\n}"
  },
  {
    "function_name": "virCommandAddArgFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1569-1590",
    "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "arg"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "cmd->args",
            "cmd->maxargs",
            "cmd->nargs",
            "1 + 1"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "list"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_vprintf",
          "args": [
            "format",
            "list"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_vprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "205-213",
          "snippet": "char *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "list",
            "format"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
  },
  {
    "function_name": "virCommandAddArgBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1539-1558",
    "snippet": "void\nvirCommandAddArgBuffer(virCommandPtr cmd, virBufferPtr buf)\n{\n    if (!cmd || cmd->has_error) {\n        virBufferFreeAndReset(buf);\n        return;\n    }\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        virBufferFreeAndReset(buf);\n        return;\n    }\n\n    cmd->args[cmd->nargs] = virBufferContentAndReset(buf);\n    if (!cmd->args[cmd->nargs])\n        cmd->args[cmd->nargs] = g_strdup(\"\");\n    cmd->nargs++;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"\""
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "buf"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "buf"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "cmd->args",
            "cmd->maxargs",
            "cmd->nargs",
            "1 + 1"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgBuffer(virCommandPtr cmd, virBufferPtr buf)\n{\n    if (!cmd || cmd->has_error) {\n        virBufferFreeAndReset(buf);\n        return;\n    }\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        virBufferFreeAndReset(buf);\n        return;\n    }\n\n    cmd->args[cmd->nargs] = virBufferContentAndReset(buf);\n    if (!cmd->args[cmd->nargs])\n        cmd->args[cmd->nargs] = g_strdup(\"\");\n    cmd->nargs++;\n}"
  },
  {
    "function_name": "virCommandAddArg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1504-1528",
    "snippet": "void\nvirCommandAddArg(virCommandPtr cmd, const char *val)\n{\n    char *arg;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (val == NULL) {\n        cmd->has_error = EINVAL;\n        abort();\n        return;\n    }\n\n    arg = g_strdup(val);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "arg"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "cmd->args",
            "cmd->maxargs",
            "cmd->nargs",
            "1 + 1"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "val"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArg(virCommandPtr cmd, const char *val)\n{\n    char *arg;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (val == NULL) {\n        cmd->has_error = EINVAL;\n        abort();\n        return;\n    }\n\n    arg = g_strdup(val);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
  },
  {
    "function_name": "virCommandAddEnvXDG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1477-1494",
    "snippet": "void\nvirCommandAddEnvXDG(virCommandPtr cmd, const char *baseDir)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 3) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvFormat(cmd, \"XDG_DATA_HOME=%s/%s\",\n                           baseDir, \".local/share\");\n    virCommandAddEnvFormat(cmd, \"XDG_CACHE_HOME=%s/%s\",\n                           baseDir, \".cache\");\n    virCommandAddEnvFormat(cmd, \"XDG_CONFIG_HOME=%s/%s\",\n                           baseDir, \".config\");\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddEnvFormat",
          "args": [
            "cmd",
            "\"XDG_CONFIG_HOME=%s/%s\"",
            "baseDir",
            "\".config\""
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1346-1360",
          "snippet": "void\nvirCommandAddEnvFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *env;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    env = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    virCommandAddEnv(cmd, env);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *env;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    env = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    virCommandAddEnv(cmd, env);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "cmd->env",
            "cmd->maxenv",
            "cmd->nenv",
            "3"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvXDG(virCommandPtr cmd, const char *baseDir)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 3) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvFormat(cmd, \"XDG_DATA_HOME=%s/%s\",\n                           baseDir, \".local/share\");\n    virCommandAddEnvFormat(cmd, \"XDG_CACHE_HOME=%s/%s\",\n                           baseDir, \".cache\");\n    virCommandAddEnvFormat(cmd, \"XDG_CONFIG_HOME=%s/%s\",\n                           baseDir, \".config\");\n}"
  },
  {
    "function_name": "virCommandAddEnvPassCommon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1454-1474",
    "snippet": "void\nvirCommandAddEnvPassCommon(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 9) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvPair(cmd, \"LC_ALL\", \"C\");\n\n    virCommandAddEnvPass(cmd, \"LD_PRELOAD\");\n    virCommandAddEnvPass(cmd, \"LD_LIBRARY_PATH\");\n    virCommandAddEnvPass(cmd, \"PATH\");\n    virCommandAddEnvPass(cmd, \"HOME\");\n    virCommandAddEnvPass(cmd, \"USER\");\n    virCommandAddEnvPass(cmd, \"LOGNAME\");\n    virCommandAddEnvPass(cmd, \"TMPDIR\");\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddEnvPass",
          "args": [
            "cmd",
            "\"TMPDIR\""
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvPass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1434-1444",
          "snippet": "void\nvirCommandAddEnvPass(virCommandPtr cmd, const char *name)\n{\n    const char *value;\n    if (!cmd || cmd->has_error)\n        return;\n\n    value = getenv(name);\n    if (value)\n        virCommandAddEnvPair(cmd, name, value);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvPass(virCommandPtr cmd, const char *name)\n{\n    const char *value;\n    if (!cmd || cmd->has_error)\n        return;\n\n    value = getenv(name);\n    if (value)\n        virCommandAddEnvPair(cmd, name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddEnvPair",
          "args": [
            "cmd",
            "\"LC_ALL\"",
            "\"C\""
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1371-1375",
          "snippet": "void\nvirCommandAddEnvPair(virCommandPtr cmd, const char *name, const char *value)\n{\n    virCommandAddEnvFormat(cmd, \"%s=%s\", name, value);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvPair(virCommandPtr cmd, const char *name, const char *value)\n{\n    virCommandAddEnvFormat(cmd, \"%s=%s\", name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "cmd->env",
            "cmd->maxenv",
            "cmd->nenv",
            "9"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvPassCommon(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 9) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvPair(cmd, \"LC_ALL\", \"C\");\n\n    virCommandAddEnvPass(cmd, \"LD_PRELOAD\");\n    virCommandAddEnvPass(cmd, \"LD_LIBRARY_PATH\");\n    virCommandAddEnvPass(cmd, \"PATH\");\n    virCommandAddEnvPass(cmd, \"HOME\");\n    virCommandAddEnvPass(cmd, \"USER\");\n    virCommandAddEnvPass(cmd, \"LOGNAME\");\n    virCommandAddEnvPass(cmd, \"TMPDIR\");\n}"
  },
  {
    "function_name": "virCommandAddEnvPass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1434-1444",
    "snippet": "void\nvirCommandAddEnvPass(virCommandPtr cmd, const char *name)\n{\n    const char *value;\n    if (!cmd || cmd->has_error)\n        return;\n\n    value = getenv(name);\n    if (value)\n        virCommandAddEnvPair(cmd, name, value);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddEnvPair",
          "args": [
            "cmd",
            "name",
            "value"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1371-1375",
          "snippet": "void\nvirCommandAddEnvPair(virCommandPtr cmd, const char *name, const char *value)\n{\n    virCommandAddEnvFormat(cmd, \"%s=%s\", name, value);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvPair(virCommandPtr cmd, const char *name, const char *value)\n{\n    virCommandAddEnvFormat(cmd, \"%s=%s\", name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "name"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvPass(virCommandPtr cmd, const char *name)\n{\n    const char *value;\n    if (!cmd || cmd->has_error)\n        return;\n\n    value = getenv(name);\n    if (value)\n        virCommandAddEnvPair(cmd, name, value);\n}"
  },
  {
    "function_name": "virCommandAddEnvBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1409-1423",
    "snippet": "void\nvirCommandAddEnvBuffer(virCommandPtr cmd, virBufferPtr buf)\n{\n    if (!cmd || cmd->has_error) {\n        virBufferFreeAndReset(buf);\n        return;\n    }\n\n    if (!virBufferUse(buf)) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n\n    virCommandAddEnv(cmd, virBufferContentAndReset(buf));\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddEnv",
          "args": [
            "cmd",
            "virBufferContentAndReset(buf)"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvXDG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1477-1494",
          "snippet": "void\nvirCommandAddEnvXDG(virCommandPtr cmd, const char *baseDir)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 3) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvFormat(cmd, \"XDG_DATA_HOME=%s/%s\",\n                           baseDir, \".local/share\");\n    virCommandAddEnvFormat(cmd, \"XDG_CACHE_HOME=%s/%s\",\n                           baseDir, \".cache\");\n    virCommandAddEnvFormat(cmd, \"XDG_CONFIG_HOME=%s/%s\",\n                           baseDir, \".config\");\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvXDG(virCommandPtr cmd, const char *baseDir)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 3) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvFormat(cmd, \"XDG_DATA_HOME=%s/%s\",\n                           baseDir, \".local/share\");\n    virCommandAddEnvFormat(cmd, \"XDG_CACHE_HOME=%s/%s\",\n                           baseDir, \".cache\");\n    virCommandAddEnvFormat(cmd, \"XDG_CONFIG_HOME=%s/%s\",\n                           baseDir, \".config\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "buf"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferUse",
          "args": [
            "buf"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferUse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "285-292",
          "snippet": "size_t\nvirBufferUse(const virBuffer *buf)\n{\n    if (!buf || !buf->str)\n        return 0;\n\n    return buf->str->len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nsize_t\nvirBufferUse(const virBuffer *buf)\n{\n    if (!buf || !buf->str)\n        return 0;\n\n    return buf->str->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "buf"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvBuffer(virCommandPtr cmd, virBufferPtr buf)\n{\n    if (!cmd || cmd->has_error) {\n        virBufferFreeAndReset(buf);\n        return;\n    }\n\n    if (!virBufferUse(buf)) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n\n    virCommandAddEnv(cmd, virBufferContentAndReset(buf));\n}"
  },
  {
    "function_name": "virCommandAddEnvString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1386-1397",
    "snippet": "void\nvirCommandAddEnvString(virCommandPtr cmd, const char *str)\n{\n    char *env;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    env = g_strdup(str);\n\n    virCommandAddEnv(cmd, env);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddEnv",
          "args": [
            "cmd",
            "env"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvXDG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1477-1494",
          "snippet": "void\nvirCommandAddEnvXDG(virCommandPtr cmd, const char *baseDir)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 3) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvFormat(cmd, \"XDG_DATA_HOME=%s/%s\",\n                           baseDir, \".local/share\");\n    virCommandAddEnvFormat(cmd, \"XDG_CACHE_HOME=%s/%s\",\n                           baseDir, \".cache\");\n    virCommandAddEnvFormat(cmd, \"XDG_CONFIG_HOME=%s/%s\",\n                           baseDir, \".config\");\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvXDG(virCommandPtr cmd, const char *baseDir)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 3) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvFormat(cmd, \"XDG_DATA_HOME=%s/%s\",\n                           baseDir, \".local/share\");\n    virCommandAddEnvFormat(cmd, \"XDG_CACHE_HOME=%s/%s\",\n                           baseDir, \".cache\");\n    virCommandAddEnvFormat(cmd, \"XDG_CONFIG_HOME=%s/%s\",\n                           baseDir, \".config\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "str"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvString(virCommandPtr cmd, const char *str)\n{\n    char *env;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    env = g_strdup(str);\n\n    virCommandAddEnv(cmd, env);\n}"
  },
  {
    "function_name": "virCommandAddEnvPair",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1371-1375",
    "snippet": "void\nvirCommandAddEnvPair(virCommandPtr cmd, const char *name, const char *value)\n{\n    virCommandAddEnvFormat(cmd, \"%s=%s\", name, value);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddEnvFormat",
          "args": [
            "cmd",
            "\"%s=%s\"",
            "name",
            "value"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1346-1360",
          "snippet": "void\nvirCommandAddEnvFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *env;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    env = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    virCommandAddEnv(cmd, env);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *env;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    env = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    virCommandAddEnv(cmd, env);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvPair(virCommandPtr cmd, const char *name, const char *value)\n{\n    virCommandAddEnvFormat(cmd, \"%s=%s\", name, value);\n}"
  },
  {
    "function_name": "virCommandAddEnvFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1346-1360",
    "snippet": "void\nvirCommandAddEnvFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *env;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    env = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    virCommandAddEnv(cmd, env);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddEnv",
          "args": [
            "cmd",
            "env"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddEnvXDG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1477-1494",
          "snippet": "void\nvirCommandAddEnvXDG(virCommandPtr cmd, const char *baseDir)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 3) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvFormat(cmd, \"XDG_DATA_HOME=%s/%s\",\n                           baseDir, \".local/share\");\n    virCommandAddEnvFormat(cmd, \"XDG_CACHE_HOME=%s/%s\",\n                           baseDir, \".cache\");\n    virCommandAddEnvFormat(cmd, \"XDG_CONFIG_HOME=%s/%s\",\n                           baseDir, \".config\");\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvXDG(virCommandPtr cmd, const char *baseDir)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 3) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    virCommandAddEnvFormat(cmd, \"XDG_DATA_HOME=%s/%s\",\n                           baseDir, \".local/share\");\n    virCommandAddEnvFormat(cmd, \"XDG_CACHE_HOME=%s/%s\",\n                           baseDir, \".cache\");\n    virCommandAddEnvFormat(cmd, \"XDG_CONFIG_HOME=%s/%s\",\n                           baseDir, \".config\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "list"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_vprintf",
          "args": [
            "format",
            "list"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_vprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "205-213",
          "snippet": "char *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "list",
            "format"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddEnvFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *env;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    env = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    virCommandAddEnv(cmd, env);\n}"
  },
  {
    "function_name": "virCommandAddEnv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1311-1336",
    "snippet": "static void\nvirCommandAddEnv(virCommandPtr cmd, char *env)\n{\n    size_t namelen;\n    size_t i;\n\n    /* Search for the name in the existing environment. */\n    namelen = strcspn(env, \"=\");\n    for (i = 0; i < cmd->nenv; ++i) {\n        /* + 1 because we want to match the '=' character too. */\n        if (STREQLEN(cmd->env[i], env, namelen + 1)) {\n            VIR_FREE(cmd->env[i]);\n            cmd->env[i] = env;\n            return;\n        }\n    }\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 1 + 1) < 0) {\n        VIR_FREE(env);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->env[cmd->nenv++] = env;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "env"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "cmd->env",
            "cmd->maxenv",
            "cmd->nenv",
            "1 + 1"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->env[i]"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQLEN",
          "args": [
            "cmd->env[i]",
            "env",
            "namelen + 1"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "env",
            "\"=\""
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic void\nvirCommandAddEnv(virCommandPtr cmd, char *env)\n{\n    size_t namelen;\n    size_t i;\n\n    /* Search for the name in the existing environment. */\n    namelen = strcspn(env, \"=\");\n    for (i = 0; i < cmd->nenv; ++i) {\n        /* + 1 because we want to match the '=' character too. */\n        if (STREQLEN(cmd->env[i], env, namelen + 1)) {\n            VIR_FREE(cmd->env[i]);\n            cmd->env[i] = env;\n            return;\n        }\n    }\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->env, cmd->maxenv, cmd->nenv, 1 + 1) < 0) {\n        VIR_FREE(env);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->env[cmd->nenv++] = env;\n}"
  },
  {
    "function_name": "virCommandRawStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1298-1305",
    "snippet": "void\nvirCommandRawStatus(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->rawStatus = true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandRawStatus(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->rawStatus = true;\n}"
  },
  {
    "function_name": "virCommandNonblockingFDs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1279-1286",
    "snippet": "void\nvirCommandNonblockingFDs(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_NONBLOCK;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandNonblockingFDs(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_NONBLOCK;\n}"
  },
  {
    "function_name": "virCommandDaemonize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1263-1270",
    "snippet": "void\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}"
  },
  {
    "function_name": "virCommandSetAppArmorProfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1240-1252",
    "snippet": "void\nvirCommandSetAppArmorProfile(virCommandPtr cmd,\n                             const char *profile G_GNUC_UNUSED)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n    cmd->appArmorProfile = g_strdup(profile);\n#endif\n    return;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "profile"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->appArmorProfile"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetAppArmorProfile(virCommandPtr cmd,\n                             const char *profile G_GNUC_UNUSED)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n    cmd->appArmorProfile = g_strdup(profile);\n#endif\n    return;\n}"
  },
  {
    "function_name": "virCommandSetSELinuxLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1216-1228",
    "snippet": "void\nvirCommandSetSELinuxLabel(virCommandPtr cmd,\n                          const char *label G_GNUC_UNUSED)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n    cmd->seLinuxLabel = g_strdup(label);\n#endif\n    return;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "label"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->seLinuxLabel"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetSELinuxLabel(virCommandPtr cmd,\n                          const char *label G_GNUC_UNUSED)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n    cmd->seLinuxLabel = g_strdup(label);\n#endif\n    return;\n}"
  },
  {
    "function_name": "virCommandAllowCap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1195-1203",
    "snippet": "void\nvirCommandAllowCap(virCommandPtr cmd,\n                   int capability)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->capabilities |= (1ULL << capability);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAllowCap(virCommandPtr cmd,\n                   int capability)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->capabilities |= (1ULL << capability);\n}"
  },
  {
    "function_name": "virCommandClearCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1179-1186",
    "snippet": "void\nvirCommandClearCaps(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_CLEAR_CAPS;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandClearCaps(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_CLEAR_CAPS;\n}"
  },
  {
    "function_name": "virCommandSetUmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1165-1171",
    "snippet": "void virCommandSetUmask(virCommandPtr cmd, int mask)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->mask = mask;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid virCommandSetUmask(virCommandPtr cmd, int mask)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->mask = mask;\n}"
  },
  {
    "function_name": "virCommandSetMaxCoreSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1156-1163",
    "snippet": "void virCommandSetMaxCoreSize(virCommandPtr cmd, unsigned long long bytes)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->maxCore = bytes;\n    cmd->setMaxCore = true;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid virCommandSetMaxCoreSize(virCommandPtr cmd, unsigned long long bytes)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->maxCore = bytes;\n    cmd->setMaxCore = true;\n}"
  },
  {
    "function_name": "virCommandSetMaxFiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1147-1154",
    "snippet": "void\nvirCommandSetMaxFiles(virCommandPtr cmd, unsigned int files)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->maxFiles = files;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetMaxFiles(virCommandPtr cmd, unsigned int files)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->maxFiles = files;\n}"
  },
  {
    "function_name": "virCommandSetMaxProcesses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1138-1145",
    "snippet": "void\nvirCommandSetMaxProcesses(virCommandPtr cmd, unsigned int procs)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->maxProcesses = procs;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetMaxProcesses(virCommandPtr cmd, unsigned int procs)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->maxProcesses = procs;\n}"
  },
  {
    "function_name": "virCommandSetMaxMemLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1129-1136",
    "snippet": "void\nvirCommandSetMaxMemLock(virCommandPtr cmd, unsigned long long bytes)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->maxMemLock = bytes;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetMaxMemLock(virCommandPtr cmd, unsigned long long bytes)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->maxMemLock = bytes;\n}"
  },
  {
    "function_name": "virCommandSetUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1120-1127",
    "snippet": "void\nvirCommandSetUID(virCommandPtr cmd, uid_t uid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->uid = uid;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetUID(virCommandPtr cmd, uid_t uid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->uid = uid;\n}"
  },
  {
    "function_name": "virCommandSetGID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1111-1118",
    "snippet": "void\nvirCommandSetGID(virCommandPtr cmd, gid_t gid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->gid = gid;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetGID(virCommandPtr cmd, gid_t gid)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->gid = gid;\n}"
  },
  {
    "function_name": "virCommandGetUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1104-1108",
    "snippet": "uid_t\nvirCommandGetUID(virCommandPtr cmd)\n{\n    return cmd->uid;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nuid_t\nvirCommandGetUID(virCommandPtr cmd)\n{\n    return cmd->uid;\n}"
  },
  {
    "function_name": "virCommandGetGID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1097-1101",
    "snippet": "gid_t\nvirCommandGetGID(virCommandPtr cmd)\n{\n    return cmd->gid;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\ngid_t\nvirCommandGetGID(virCommandPtr cmd)\n{\n    return cmd->gid;\n}"
  },
  {
    "function_name": "virCommandSetPidFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1086-1094",
    "snippet": "void\nvirCommandSetPidFile(virCommandPtr cmd, const char *pidfile)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    VIR_FREE(cmd->pidfile);\n    cmd->pidfile = g_strdup(pidfile);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "pidfile"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cmd->pidfile"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetPidFile(virCommandPtr cmd, const char *pidfile)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    VIR_FREE(cmd->pidfile);\n    cmd->pidfile = g_strdup(pidfile);\n}"
  },
  {
    "function_name": "virCommandPassFDGetFDIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1061-1076",
    "snippet": "int\nvirCommandPassFDGetFDIndex(virCommandPtr cmd, int fd)\n{\n    size_t i = 0;\n\n    if (!cmd || cmd->has_error)\n        return -1;\n\n    while (i < cmd->npassfd) {\n        if (cmd->passfd[i].fd == fd)\n            return i;\n        i++;\n    }\n\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandPassFDGetFDIndex(virCommandPtr cmd, int fd)\n{\n    size_t i = 0;\n\n    if (!cmd || cmd->has_error)\n        return -1;\n\n    while (i < cmd->npassfd) {\n        if (cmd->passfd[i].fd == fd)\n            return i;\n        i++;\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "virCommandPassFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "1024-1049",
    "snippet": "void\nvirCommandPassFD(virCommandPtr cmd, int fd, unsigned int flags)\n{\n    int ret = 0;\n\n    if (!cmd) {\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n\n    if (fd <= STDERR_FILENO) {\n        VIR_DEBUG(\"invalid fd %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        if (!cmd->has_error)\n            cmd->has_error = -1;\n        return;\n    }\n\n    if ((ret = virCommandFDSet(cmd, fd, flags)) != 0) {\n        if (!cmd->has_error)\n            cmd->has_error = ret;\n        VIR_DEBUG(\"cannot preserve %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_COMMAND_MAYBE_CLOSE_FD",
          "args": [
            "fd",
            "flags"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cannot preserve %d\"",
            "fd"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandFDSet",
          "args": [
            "cmd",
            "fd",
            "flags"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFDSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "203-221",
          "snippet": "static int\nvirCommandFDSet(virCommandPtr cmd,\n                int fd,\n                unsigned int flags)\n{\n    if (!cmd || fd < 0)\n        return -1;\n\n    if (virCommandFDIsSet(cmd, fd))\n        return 0;\n\n    if (VIR_EXPAND_N(cmd->passfd, cmd->npassfd, 1) < 0)\n        return ENOMEM;\n\n    cmd->passfd[cmd->npassfd - 1].fd = fd;\n    cmd->passfd[cmd->npassfd - 1].flags = flags;\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandFDSet(virCommandPtr cmd,\n                int fd,\n                unsigned int flags)\n{\n    if (!cmd || fd < 0)\n        return -1;\n\n    if (virCommandFDIsSet(cmd, fd))\n        return 0;\n\n    if (VIR_EXPAND_N(cmd->passfd, cmd->npassfd, 1) < 0)\n        return ENOMEM;\n\n    cmd->passfd[cmd->npassfd - 1].fd = fd;\n    cmd->passfd[cmd->npassfd - 1].flags = flags;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_COMMAND_MAYBE_CLOSE_FD",
          "args": [
            "fd",
            "flags"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"invalid fd %d\"",
            "fd"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_COMMAND_MAYBE_CLOSE_FD",
          "args": [
            "fd",
            "flags"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandPassFD(virCommandPtr cmd, int fd, unsigned int flags)\n{\n    int ret = 0;\n\n    if (!cmd) {\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n\n    if (fd <= STDERR_FILENO) {\n        VIR_DEBUG(\"invalid fd %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        if (!cmd->has_error)\n            cmd->has_error = -1;\n        return;\n    }\n\n    if ((ret = virCommandFDSet(cmd, fd, flags)) != 0) {\n        if (!cmd->has_error)\n            cmd->has_error = ret;\n        VIR_DEBUG(\"cannot preserve %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n}"
  },
  {
    "function_name": "virCommandNewVAList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "990-1002",
    "snippet": "virCommandPtr\nvirCommandNewVAList(const char *binary, va_list list)\n{\n    virCommandPtr cmd = virCommandNew(binary);\n    const char *arg;\n\n    if (!cmd || cmd->has_error)\n        return cmd;\n\n    while ((arg = va_arg(list, const char *)) != NULL)\n        virCommandAddArg(cmd, arg);\n    return cmd;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "arg"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "list",
            "constchar *"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "binary"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewVAList(const char *binary, va_list list)\n{\n    virCommandPtr cmd = virCommandNew(binary);\n    const char *arg;\n\n    if (!cmd || cmd->has_error)\n        return cmd;\n\n    while ((arg = va_arg(list, const char *)) != NULL)\n        virCommandAddArg(cmd, arg);\n    return cmd;\n}"
  },
  {
    "function_name": "virCommandNewArgList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "969-980",
    "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "list"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandNewVAList",
          "args": [
            "binary",
            "list"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewVAList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "990-1002",
          "snippet": "virCommandPtr\nvirCommandNewVAList(const char *binary, va_list list)\n{\n    virCommandPtr cmd = virCommandNew(binary);\n    const char *arg;\n\n    if (!cmd || cmd->has_error)\n        return cmd;\n\n    while ((arg = va_arg(list, const char *)) != NULL)\n        virCommandAddArg(cmd, arg);\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewVAList(const char *binary, va_list list)\n{\n    virCommandPtr cmd = virCommandNew(binary);\n    const char *arg;\n\n    if (!cmd || cmd->has_error)\n        return cmd;\n\n    while ((arg = va_arg(list, const char *)) != NULL)\n        virCommandAddArg(cmd, arg);\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "list",
            "binary"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
  },
  {
    "function_name": "virCommandNewArgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "937-958",
    "snippet": "virCommandPtr\nvirCommandNewArgs(const char *const*args)\n{\n    virCommandPtr cmd;\n\n    if (VIR_ALLOC(cmd) < 0)\n        return NULL;\n\n    cmd->handshakeWait[0] = -1;\n    cmd->handshakeWait[1] = -1;\n    cmd->handshakeNotify[0] = -1;\n    cmd->handshakeNotify[1] = -1;\n\n    cmd->infd = cmd->inpipe = cmd->outfd = cmd->errfd = -1;\n    cmd->pid = -1;\n    cmd->uid = -1;\n    cmd->gid = -1;\n\n    virCommandAddArgSet(cmd, args);\n\n    return cmd;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandAddArgSet",
          "args": [
            "cmd",
            "args"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1617-1646",
          "snippet": "void\nvirCommandAddArgSet(virCommandPtr cmd, const char *const*vals)\n{\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (vals[0] == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n\n    while (vals[narg] != NULL)\n        narg++;\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    narg = 0;\n    while (vals[narg] != NULL) {\n        char *arg;\n\n        arg = g_strdup(vals[narg++]);\n        cmd->args[cmd->nargs++] = arg;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgSet(virCommandPtr cmd, const char *const*vals)\n{\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (vals[0] == NULL) {\n        cmd->has_error = EINVAL;\n        return;\n    }\n\n    while (vals[narg] != NULL)\n        narg++;\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    narg = 0;\n    while (vals[narg] != NULL) {\n        char *arg;\n\n        arg = g_strdup(vals[narg++]);\n        cmd->args[cmd->nargs++] = arg;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "cmd"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgs(const char *const*args)\n{\n    virCommandPtr cmd;\n\n    if (VIR_ALLOC(cmd) < 0)\n        return NULL;\n\n    cmd->handshakeWait[0] = -1;\n    cmd->handshakeWait[1] = -1;\n    cmd->handshakeNotify[0] = -1;\n    cmd->handshakeNotify[1] = -1;\n\n    cmd->infd = cmd->inpipe = cmd->outfd = cmd->errfd = -1;\n    cmd->pid = -1;\n    cmd->uid = -1;\n    cmd->gid = -1;\n\n    virCommandAddArgSet(cmd, args);\n\n    return cmd;\n}"
  },
  {
    "function_name": "virCommandNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "921-927",
    "snippet": "virCommandPtr\nvirCommandNew(const char *binary)\n{\n    const char *const args[] = { binary, NULL };\n\n    return virCommandNewArgs(args);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandNewArgs",
          "args": [
            "args"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "937-958",
          "snippet": "virCommandPtr\nvirCommandNewArgs(const char *const*args)\n{\n    virCommandPtr cmd;\n\n    if (VIR_ALLOC(cmd) < 0)\n        return NULL;\n\n    cmd->handshakeWait[0] = -1;\n    cmd->handshakeWait[1] = -1;\n    cmd->handshakeNotify[0] = -1;\n    cmd->handshakeNotify[1] = -1;\n\n    cmd->infd = cmd->inpipe = cmd->outfd = cmd->errfd = -1;\n    cmd->pid = -1;\n    cmd->uid = -1;\n    cmd->gid = -1;\n\n    virCommandAddArgSet(cmd, args);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgs(const char *const*args)\n{\n    virCommandPtr cmd;\n\n    if (VIR_ALLOC(cmd) < 0)\n        return NULL;\n\n    cmd->handshakeWait[0] = -1;\n    cmd->handshakeWait[1] = -1;\n    cmd->handshakeNotify[0] = -1;\n    cmd->handshakeNotify[1] = -1;\n\n    cmd->infd = cmd->inpipe = cmd->outfd = cmd->errfd = -1;\n    cmd->pid = -1;\n    cmd->uid = -1;\n    cmd->gid = -1;\n\n    virCommandAddArgSet(cmd, args);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNew(const char *binary)\n{\n    const char *const args[] = { binary, NULL };\n\n    return virCommandNewArgs(args);\n}"
  },
  {
    "function_name": "virFork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "902-908",
    "snippet": "pid_t\nvirFork(void)\n{\n    errno = ENOTSUP;\n\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\npid_t\nvirFork(void)\n{\n    errno = ENOTSUP;\n\n    return -1;\n}"
  },
  {
    "function_name": "virRun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "890-900",
    "snippet": "int\nvirRun(const char *const *argv G_GNUC_UNUSED,\n       int *status)\n{\n    if (status)\n        *status = ENOTSUP;\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virRun is not implemented for WIN32\"));\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"virRun is not implemented for WIN32\")"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"virRun is not implemented for WIN32\""
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirRun(const char *const *argv G_GNUC_UNUSED,\n       int *status)\n{\n    if (status)\n        *status = ENOTSUP;\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virRun is not implemented for WIN32\"));\n    return -1;\n}"
  },
  {
    "function_name": "virRun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "880-886",
    "snippet": "int\nvirRun(const char *const*argv, int *status)\n{\n    g_autoptr(virCommand) cmd = virCommandNewArgs(argv);\n\n    return virCommandRun(cmd, status);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "status"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgs",
          "args": [
            "argv"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "937-958",
          "snippet": "virCommandPtr\nvirCommandNewArgs(const char *const*args)\n{\n    virCommandPtr cmd;\n\n    if (VIR_ALLOC(cmd) < 0)\n        return NULL;\n\n    cmd->handshakeWait[0] = -1;\n    cmd->handshakeWait[1] = -1;\n    cmd->handshakeNotify[0] = -1;\n    cmd->handshakeNotify[1] = -1;\n\n    cmd->infd = cmd->inpipe = cmd->outfd = cmd->errfd = -1;\n    cmd->pid = -1;\n    cmd->uid = -1;\n    cmd->gid = -1;\n\n    virCommandAddArgSet(cmd, args);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgs(const char *const*args)\n{\n    virCommandPtr cmd;\n\n    if (VIR_ALLOC(cmd) < 0)\n        return NULL;\n\n    cmd->handshakeWait[0] = -1;\n    cmd->handshakeWait[1] = -1;\n    cmd->handshakeNotify[0] = -1;\n    cmd->handshakeNotify[1] = -1;\n\n    cmd->infd = cmd->inpipe = cmd->outfd = cmd->errfd = -1;\n    cmd->pid = -1;\n    cmd->uid = -1;\n    cmd->gid = -1;\n\n    virCommandAddArgSet(cmd, args);\n\n    return cmd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirRun(const char *const*argv, int *status)\n{\n    g_autoptr(virCommand) cmd = virCommandNewArgs(argv);\n\n    return virCommandRun(cmd, status);\n}"
  },
  {
    "function_name": "virExec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "608-862",
    "snippet": "static int\nvirExec(virCommandPtr cmd)\n{\n    pid_t pid;\n    int null = -1;\n    int pipeout[2] = {-1, -1};\n    int pipeerr[2] = {-1, -1};\n    int childin = cmd->infd;\n    int childout = -1;\n    int childerr = -1;\n    g_autofree char *binarystr = NULL;\n    const char *binary = NULL;\n    int ret;\n    g_autofree gid_t *groups = NULL;\n    int ngroups;\n\n    if (cmd->args[0][0] != '/') {\n        if (!(binary = binarystr = virFindFileInPath(cmd->args[0]))) {\n            virReportSystemError(ENOENT,\n                                 _(\"Cannot find '%s' in path\"),\n                                 cmd->args[0]);\n            return -1;\n        }\n    } else {\n        binary = cmd->args[0];\n    }\n\n    if (childin < 0) {\n        if (getDevNull(&null) < 0)\n            goto cleanup;\n        childin = null;\n    }\n\n    if (cmd->outfdptr != NULL) {\n        if (*cmd->outfdptr == -1) {\n            if (virPipe(pipeout) < 0)\n                goto cleanup;\n\n            if ((cmd->flags & VIR_EXEC_NONBLOCK) &&\n                virSetNonBlock(pipeout[0]) == -1) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Failed to set non-blocking file descriptor flag\"));\n                goto cleanup;\n            }\n\n            childout = pipeout[1];\n        } else {\n            childout = *cmd->outfdptr;\n        }\n    } else {\n        if (getDevNull(&null) < 0)\n            goto cleanup;\n        childout = null;\n    }\n\n    if (cmd->errfdptr != NULL) {\n        if (cmd->errfdptr == cmd->outfdptr) {\n            childerr = childout;\n        } else if (*cmd->errfdptr == -1) {\n            if (virPipe(pipeerr) < 0)\n                goto cleanup;\n\n            if ((cmd->flags & VIR_EXEC_NONBLOCK) &&\n                virSetNonBlock(pipeerr[0]) == -1) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Failed to set non-blocking file descriptor flag\"));\n                goto cleanup;\n            }\n\n            childerr = pipeerr[1];\n        } else {\n            childerr = *cmd->errfdptr;\n        }\n    } else {\n        if (getDevNull(&null) < 0)\n            goto cleanup;\n        childerr = null;\n    }\n\n    if ((ngroups = virGetGroupList(cmd->uid, cmd->gid, &groups)) < 0)\n        goto cleanup;\n\n    pid = virFork();\n\n    if (pid < 0)\n        goto cleanup;\n\n    if (pid) { /* parent */\n        VIR_FORCE_CLOSE(null);\n        if (cmd->outfdptr && *cmd->outfdptr == -1) {\n            VIR_FORCE_CLOSE(pipeout[1]);\n            *cmd->outfdptr = pipeout[0];\n        }\n        if (cmd->errfdptr && *cmd->errfdptr == -1) {\n            VIR_FORCE_CLOSE(pipeerr[1]);\n            *cmd->errfdptr = pipeerr[0];\n        }\n\n        cmd->pid = pid;\n\n        return 0;\n    }\n\n    /* child */\n\n    if (cmd->mask)\n        umask(cmd->mask);\n    ret = EXIT_CANCELED;\n\n    if (virCommandMassClose(cmd, childin, childout, childerr) < 0)\n        goto fork_error;\n\n    if (prepareStdFd(childin, STDIN_FILENO) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to setup stdin file handle\"));\n        goto fork_error;\n    }\n    if (childout > 0 && prepareStdFd(childout, STDOUT_FILENO) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to setup stdout file handle\"));\n        goto fork_error;\n    }\n    if (childerr > 0 && prepareStdFd(childerr, STDERR_FILENO) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to setup stderr file handle\"));\n        goto fork_error;\n    }\n\n    if (childin != STDIN_FILENO && childin != null &&\n        childin != childerr && childin != childout)\n        VIR_FORCE_CLOSE(childin);\n    if (childout > STDERR_FILENO && childout != null && childout != childerr)\n        VIR_FORCE_CLOSE(childout);\n    if (childerr > STDERR_FILENO && childerr != null)\n        VIR_FORCE_CLOSE(childerr);\n    VIR_FORCE_CLOSE(null);\n\n    /* Initialize full logging for a while */\n    virLogSetFromEnv();\n\n    /* Daemonize as late as possible, so the parent process can detect\n     * the above errors with wait* */\n    if (cmd->flags & VIR_EXEC_DAEMON) {\n        if (setsid() < 0) {\n            virReportSystemError(errno,\n                                 \"%s\", _(\"cannot become session leader\"));\n            goto fork_error;\n        }\n\n        if (chdir(\"/\") < 0) {\n            virReportSystemError(errno,\n                                 \"%s\", _(\"cannot change to root directory\"));\n            goto fork_error;\n        }\n\n        pid = fork();\n        if (pid < 0) {\n            virReportSystemError(errno,\n                                 \"%s\", _(\"cannot fork child process\"));\n            goto fork_error;\n        }\n\n        if (pid > 0) {\n            if (cmd->pidfile && (virPidFileWritePath(cmd->pidfile, pid) < 0)) {\n                if (virProcessKillPainfully(pid, true) >= 0)\n                    virReportSystemError(errno,\n                                         _(\"could not write pidfile %s for %d\"),\n                                         cmd->pidfile, pid);\n                goto fork_error;\n            }\n            _exit(EXIT_SUCCESS);\n        }\n    }\n\n    if (virProcessSetMaxMemLock(0, cmd->maxMemLock) < 0)\n        goto fork_error;\n    if (virProcessSetMaxProcesses(0, cmd->maxProcesses) < 0)\n        goto fork_error;\n    if (virProcessSetMaxFiles(0, cmd->maxFiles) < 0)\n        goto fork_error;\n    if (cmd->setMaxCore &&\n        virProcessSetMaxCoreSize(0, cmd->maxCore) < 0)\n        goto fork_error;\n\n    if (cmd->hook) {\n        VIR_DEBUG(\"Run hook %p %p\", cmd->hook, cmd->opaque);\n        ret = cmd->hook(cmd->opaque);\n        VIR_DEBUG(\"Done hook %d\", ret);\n        if (ret < 0)\n           goto fork_error;\n    }\n\n# if defined(WITH_SECDRIVER_SELINUX)\n    if (cmd->seLinuxLabel) {\n        VIR_DEBUG(\"Setting child security label to %s\", cmd->seLinuxLabel);\n        if (setexeccon_raw(cmd->seLinuxLabel) == -1) {\n            virReportSystemError(errno,\n                                 _(\"unable to set SELinux security context \"\n                                   \"'%s' for '%s'\"),\n                                 cmd->seLinuxLabel, cmd->args[0]);\n            if (security_getenforce() == 1)\n                goto fork_error;\n        }\n    }\n# endif\n# if defined(WITH_SECDRIVER_APPARMOR)\n    if (cmd->appArmorProfile) {\n        VIR_DEBUG(\"Setting child AppArmor profile to %s\", cmd->appArmorProfile);\n        if (aa_change_profile(cmd->appArmorProfile) < 0) {\n            virReportSystemError(errno,\n                                 _(\"unable to set AppArmor profile '%s' \"\n                                   \"for '%s'\"),\n                                 cmd->appArmorProfile, cmd->args[0]);\n            goto fork_error;\n        }\n    }\n# endif\n\n    if (virExecCommon(cmd, groups, ngroups) < 0)\n        goto fork_error;\n\n    if (virCommandHandshakeChild(cmd) < 0)\n       goto fork_error;\n\n    /* Close logging again to ensure no FDs leak to child */\n    virLogReset();\n\n    if (cmd->env)\n        execve(binary, cmd->args, cmd->env);\n    else\n        execv(binary, cmd->args);\n\n    ret = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n    virReportSystemError(errno,\n                         _(\"cannot execute binary %s\"),\n                         cmd->args[0]);\n\n fork_error:\n    virDispatchError(NULL);\n    _exit(ret);\n\n cleanup:\n    /* This is cleanup of parent process only - child\n       should never jump here on error */\n\n    /* NB we don't virReportError() on any failures here\n       because the code which jumped here already raised\n       an error condition which we must not overwrite */\n    VIR_FORCE_CLOSE(pipeerr[0]);\n    VIR_FORCE_CLOSE(pipeerr[1]);\n    VIR_FORCE_CLOSE(pipeout[0]);\n    VIR_FORCE_CLOSE(pipeout[1]);\n    VIR_FORCE_CLOSE(null);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "null"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "pipeout[1]"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "pipeout[0]"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "pipeerr[1]"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "pipeerr[0]"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "ret"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDispatchError",
          "args": [
            "NULL"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "virDispatchError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "695-728",
          "snippet": "void\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot execute binary %s\")",
            "cmd->args[0]"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot execute binary %s\""
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "execv",
          "args": [
            "binary",
            "cmd->args"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execve",
          "args": [
            "binary",
            "cmd->args",
            "cmd->env"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLogReset",
          "args": [],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "virLogResetOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "373-379",
          "snippet": "static void\nvirLogResetOutputs(void)\n{\n    virLogOutputListFree(virLogOutputs, virLogNbOutputs);\n    virLogOutputs = NULL;\n    virLogNbOutputs = 0;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogOutputPtr *virLogOutputs;",
            "static size_t virLogNbOutputs;",
            "static void virLogResetOutputs(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogOutputPtr *virLogOutputs;\nstatic size_t virLogNbOutputs;\nstatic void virLogResetOutputs(void);\n\nstatic void\nvirLogResetOutputs(void)\n{\n    virLogOutputListFree(virLogOutputs, virLogNbOutputs);\n    virLogOutputs = NULL;\n    virLogNbOutputs = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandHandshakeChild",
          "args": [
            "cmd"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandHandshakeChild",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "380-420",
          "snippet": "static int\nvirCommandHandshakeChild(virCommandPtr cmd)\n{\n    char c = '1';\n    int rv;\n\n    if (!cmd->handshake)\n       return true;\n\n    VIR_DEBUG(\"Notifying parent for handshake start on %d\",\n              cmd->handshakeWait[1]);\n    if (safewrite(cmd->handshakeWait[1], &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to notify parent process\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"Waiting on parent for handshake complete on %d\",\n              cmd->handshakeNotify[0]);\n    if ((rv = saferead(cmd->handshakeNotify[0], &c,\n                       sizeof(c))) != sizeof(c)) {\n        if (rv < 0)\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to wait on parent process\"));\n        else\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"libvirtd quit during handshake\"));\n        return -1;\n    }\n    if (c != '1') {\n        virReportSystemError(EINVAL,\n                             _(\"Unexpected confirm code '%c' from parent\"),\n                             c);\n        return -1;\n    }\n    VIR_FORCE_CLOSE(cmd->handshakeWait[1]);\n    VIR_FORCE_CLOSE(cmd->handshakeNotify[0]);\n\n    VIR_DEBUG(\"Handshake with parent is done\");\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandHandshakeChild(virCommandPtr cmd)\n{\n    char c = '1';\n    int rv;\n\n    if (!cmd->handshake)\n       return true;\n\n    VIR_DEBUG(\"Notifying parent for handshake start on %d\",\n              cmd->handshakeWait[1]);\n    if (safewrite(cmd->handshakeWait[1], &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to notify parent process\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"Waiting on parent for handshake complete on %d\",\n              cmd->handshakeNotify[0]);\n    if ((rv = saferead(cmd->handshakeNotify[0], &c,\n                       sizeof(c))) != sizeof(c)) {\n        if (rv < 0)\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to wait on parent process\"));\n        else\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"libvirtd quit during handshake\"));\n        return -1;\n    }\n    if (c != '1') {\n        virReportSystemError(EINVAL,\n                             _(\"Unexpected confirm code '%c' from parent\"),\n                             c);\n        return -1;\n    }\n    VIR_FORCE_CLOSE(cmd->handshakeWait[1]);\n    VIR_FORCE_CLOSE(cmd->handshakeNotify[0]);\n\n    VIR_DEBUG(\"Handshake with parent is done\");\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virExecCommon",
          "args": [
            "cmd",
            "groups",
            "ngroups"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "virExecCommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "422-444",
          "snippet": "static int\nvirExecCommon(virCommandPtr cmd, gid_t *groups, int ngroups)\n{\n    if (cmd->uid != (uid_t)-1 || cmd->gid != (gid_t)-1 ||\n        cmd->capabilities || (cmd->flags & VIR_EXEC_CLEAR_CAPS)) {\n        VIR_DEBUG(\"Setting child uid:gid to %d:%d with caps %llx\",\n                  (int)cmd->uid, (int)cmd->gid, cmd->capabilities);\n        if (virSetUIDGIDWithCaps(cmd->uid, cmd->gid, groups, ngroups,\n                                 cmd->capabilities,\n                                 !!(cmd->flags & VIR_EXEC_CLEAR_CAPS)) < 0)\n            return -1;\n    }\n\n    if (cmd->pwd) {\n        VIR_DEBUG(\"Running child in %s\", cmd->pwd);\n        if (chdir(cmd->pwd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to change to %s\"), cmd->pwd);\n            return -1;\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirExecCommon(virCommandPtr cmd, gid_t *groups, int ngroups)\n{\n    if (cmd->uid != (uid_t)-1 || cmd->gid != (gid_t)-1 ||\n        cmd->capabilities || (cmd->flags & VIR_EXEC_CLEAR_CAPS)) {\n        VIR_DEBUG(\"Setting child uid:gid to %d:%d with caps %llx\",\n                  (int)cmd->uid, (int)cmd->gid, cmd->capabilities);\n        if (virSetUIDGIDWithCaps(cmd->uid, cmd->gid, groups, ngroups,\n                                 cmd->capabilities,\n                                 !!(cmd->flags & VIR_EXEC_CLEAR_CAPS)) < 0)\n            return -1;\n    }\n\n    if (cmd->pwd) {\n        VIR_DEBUG(\"Running child in %s\", cmd->pwd);\n        if (chdir(cmd->pwd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to change to %s\"), cmd->pwd);\n            return -1;\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to set AppArmor profile '%s' \"\n                                   \"for '%s'\")",
            "cmd->appArmorProfile",
            "cmd->args[0]"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_change_profile",
          "args": [
            "cmd->appArmorProfile"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting child AppArmor profile to %s\"",
            "cmd->appArmorProfile"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_getenforce",
          "args": [],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to set SELinux security context \"\n                                   \"'%s' for '%s'\")",
            "cmd->seLinuxLabel",
            "cmd->args[0]"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setexeccon_raw",
          "args": [
            "cmd->seLinuxLabel"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting child security label to %s\"",
            "cmd->seLinuxLabel"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Done hook %d\"",
            "ret"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd->hook",
          "args": [
            "cmd->opaque"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Run hook %p %p\"",
            "cmd->hook",
            "cmd->opaque"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virProcessSetMaxCoreSize",
          "args": [
            "0",
            "cmd->maxCore"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessSetMaxCoreSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "949-958",
          "snippet": "int\nvirProcessSetMaxCoreSize(pid_t pid G_GNUC_UNUSED,\n                         unsigned long long bytes)\n{\n    if (bytes == 0)\n        return 0;\n\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessSetMaxCoreSize(pid_t pid G_GNUC_UNUSED,\n                         unsigned long long bytes)\n{\n    if (bytes == 0)\n        return 0;\n\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessSetMaxFiles",
          "args": [
            "0",
            "cmd->maxFiles"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessSetMaxFiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "912-920",
          "snippet": "int\nvirProcessSetMaxFiles(pid_t pid G_GNUC_UNUSED, unsigned int files)\n{\n    if (files == 0)\n        return 0;\n\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessSetMaxFiles(pid_t pid G_GNUC_UNUSED, unsigned int files)\n{\n    if (files == 0)\n        return 0;\n\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessSetMaxProcesses",
          "args": [
            "0",
            "cmd->maxProcesses"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessSetMaxProcesses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "864-872",
          "snippet": "int\nvirProcessSetMaxProcesses(pid_t pid G_GNUC_UNUSED, unsigned int procs)\n{\n    if (procs == 0)\n        return 0;\n\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessSetMaxProcesses(pid_t pid G_GNUC_UNUSED, unsigned int procs)\n{\n    if (procs == 0)\n        return 0;\n\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessSetMaxMemLock",
          "args": [
            "0",
            "cmd->maxMemLock"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessSetMaxMemLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "772-780",
          "snippet": "int\nvirProcessSetMaxMemLock(pid_t pid G_GNUC_UNUSED, unsigned long long bytes)\n{\n    if (bytes == 0)\n        return 0;\n\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessSetMaxMemLock(pid_t pid G_GNUC_UNUSED, unsigned long long bytes)\n{\n    if (bytes == 0)\n        return 0;\n\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"could not write pidfile %s for %d\")",
            "cmd->pidfile",
            "pid"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virProcessKillPainfully",
          "args": [
            "pid",
            "true"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessKillPainfully",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "437-440",
          "snippet": "int virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileWritePath",
          "args": [
            "cmd->pidfile",
            "pid"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileWritePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "54-83",
          "snippet": "int virPidFileWritePath(const char *pidfile,\n                        pid_t pid)\n{\n    int rc;\n    int fd;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if ((fd = open(pidfile,\n                   O_WRONLY | O_CREAT | O_TRUNC,\n                   S_IRUSR | S_IWUSR)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileWritePath(const char *pidfile,\n                        pid_t pid)\n{\n    int rc;\n    int fd;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if ((fd = open(pidfile,\n                   O_WRONLY | O_CREAT | O_TRUNC,\n                   S_IRUSR | S_IWUSR)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot fork child process\")"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot change to root directory\")"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot become session leader\")"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLogSetFromEnv",
          "args": [],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetFromEnv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1208-1225",
          "snippet": "void\nvirLogSetFromEnv(void)\n{\n    const char *debugEnv;\n\n    if (virLogInitialize() < 0)\n        return;\n\n    debugEnv = getenv(\"LIBVIRT_DEBUG\");\n    if (debugEnv && *debugEnv)\n        virLogSetDefaultPriority(virLogParseDefaultPriority(debugEnv));\n    debugEnv = getenv(\"LIBVIRT_LOG_FILTERS\");\n    if (debugEnv && *debugEnv)\n        virLogSetFilters(debugEnv);\n    debugEnv = getenv(\"LIBVIRT_LOG_OUTPUTS\");\n    if (debugEnv && *debugEnv)\n        virLogSetOutputs(debugEnv);\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirLogSetFromEnv(void)\n{\n    const char *debugEnv;\n\n    if (virLogInitialize() < 0)\n        return;\n\n    debugEnv = getenv(\"LIBVIRT_DEBUG\");\n    if (debugEnv && *debugEnv)\n        virLogSetDefaultPriority(virLogParseDefaultPriority(debugEnv));\n    debugEnv = getenv(\"LIBVIRT_LOG_FILTERS\");\n    if (debugEnv && *debugEnv)\n        virLogSetFilters(debugEnv);\n    debugEnv = getenv(\"LIBVIRT_LOG_OUTPUTS\");\n    if (debugEnv && *debugEnv)\n        virLogSetOutputs(debugEnv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "null"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "childerr"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "childout"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "childin"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to setup stderr file handle\")"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepareStdFd",
          "args": [
            "childerr",
            "STDERR_FILENO"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "prepareStdFd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "364-372",
          "snippet": "static int\nprepareStdFd(int fd, int std)\n{\n    if (fd == std)\n        return virSetInherit(fd, true);\n    if (dup2(fd, std) != std)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nprepareStdFd(int fd, int std)\n{\n    if (fd == std)\n        return virSetInherit(fd, true);\n    if (dup2(fd, std) != std)\n        return -1;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to setup stdout file handle\")"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to setup stdin file handle\")"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandMassClose",
          "args": [
            "cmd",
            "childin",
            "childout",
            "childerr"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandMassClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "551-599",
          "snippet": "static int\nvirCommandMassClose(virCommandPtr cmd,\n                    int childin,\n                    int childout,\n                    int childerr)\n{\n    g_autoptr(virBitmap) fds = NULL;\n    int openmax = sysconf(_SC_OPEN_MAX);\n    int fd = -1;\n\n    /* In general, it is not safe to call malloc() between fork() and exec()\n     * because the child might have forked at the worst possible time, i.e.\n     * when another thread was in malloc() and thus held its lock. That is to\n     * say, POSIX does not mandate malloc() to be async-safe. Fortunately,\n     * glibc developers are aware of this and made malloc() async-safe.\n     * Therefore we can safely allocate memory here (and transitively call\n     * opendir/readdir) without a deadlock. */\n\n    if (openmax < 0) {\n        virReportSystemError(errno, \"%s\", _(\"sysconf(_SC_OPEN_MAX) failed\"));\n        return -1;\n    }\n\n    if (!(fds = virBitmapNew(openmax)))\n        return -1;\n\n#  ifdef __linux__\n    if (virCommandMassCloseGetFDsLinux(cmd, fds) < 0)\n        return -1;\n#  else\n    if (virCommandMassCloseGetFDsGeneric(cmd, fds) < 0)\n        return -1;\n#  endif\n\n    fd = virBitmapNextSetBit(fds, 2);\n    for (; fd >= 0; fd = virBitmapNextSetBit(fds, fd)) {\n        if (fd == childin || fd == childout || fd == childerr)\n            continue;\n        if (!virCommandFDIsSet(cmd, fd)) {\n            int tmpfd = fd;\n            VIR_MASS_CLOSE(tmpfd);\n        } else if (virSetInherit(fd, true) < 0) {\n            virReportSystemError(errno, _(\"failed to preserve fd %d\"), fd);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandMassClose(virCommandPtr cmd,\n                    int childin,\n                    int childout,\n                    int childerr)\n{\n    g_autoptr(virBitmap) fds = NULL;\n    int openmax = sysconf(_SC_OPEN_MAX);\n    int fd = -1;\n\n    /* In general, it is not safe to call malloc() between fork() and exec()\n     * because the child might have forked at the worst possible time, i.e.\n     * when another thread was in malloc() and thus held its lock. That is to\n     * say, POSIX does not mandate malloc() to be async-safe. Fortunately,\n     * glibc developers are aware of this and made malloc() async-safe.\n     * Therefore we can safely allocate memory here (and transitively call\n     * opendir/readdir) without a deadlock. */\n\n    if (openmax < 0) {\n        virReportSystemError(errno, \"%s\", _(\"sysconf(_SC_OPEN_MAX) failed\"));\n        return -1;\n    }\n\n    if (!(fds = virBitmapNew(openmax)))\n        return -1;\n\n#  ifdef __linux__\n    if (virCommandMassCloseGetFDsLinux(cmd, fds) < 0)\n        return -1;\n#  else\n    if (virCommandMassCloseGetFDsGeneric(cmd, fds) < 0)\n        return -1;\n#  endif\n\n    fd = virBitmapNextSetBit(fds, 2);\n    for (; fd >= 0; fd = virBitmapNextSetBit(fds, fd)) {\n        if (fd == childin || fd == childout || fd == childerr)\n            continue;\n        if (!virCommandFDIsSet(cmd, fd)) {\n            int tmpfd = fd;\n            VIR_MASS_CLOSE(tmpfd);\n        } else if (virSetInherit(fd, true) < 0) {\n            virReportSystemError(errno, _(\"failed to preserve fd %d\"), fd);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "cmd->mask"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "pipeerr[1]"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "pipeout[1]"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "null"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFork",
          "args": [],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "virFork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "902-908",
          "snippet": "pid_t\nvirFork(void)\n{\n    errno = ENOTSUP;\n\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\npid_t\nvirFork(void)\n{\n    errno = ENOTSUP;\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetGroupList",
          "args": [
            "cmd->uid",
            "cmd->gid",
            "&groups"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "virGetGroupList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1059-1065",
          "snippet": "int\nvirGetGroupList(uid_t uid G_GNUC_UNUSED, gid_t gid G_GNUC_UNUSED,\n                gid_t **list)\n{\n    *list = NULL;\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirGetGroupList(uid_t uid G_GNUC_UNUSED, gid_t gid G_GNUC_UNUSED,\n                gid_t **list)\n{\n    *list = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getDevNull",
          "args": [
            "&null"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "getDevNull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "350-360",
          "snippet": "static int\ngetDevNull(int *null)\n{\n    if (*null == -1 && (*null = open(\"/dev/null\", O_RDWR|O_CLOEXEC)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot open %s\"),\n                             \"/dev/null\");\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\ngetDevNull(int *null)\n{\n    if (*null == -1 && (*null = open(\"/dev/null\", O_RDWR|O_CLOEXEC)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot open %s\"),\n                             \"/dev/null\");\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Failed to set non-blocking file descriptor flag\")"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetNonBlock",
          "args": [
            "pipeerr[0]"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "virSetNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "126-129",
          "snippet": "int virSetNonBlock(int fd)\n{\n    return virSetBlocking(fd, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetNonBlock(int fd)\n{\n    return virSetBlocking(fd, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPipe",
          "args": [
            "pipeerr"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "virPipeNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1813-1817",
          "snippet": "int\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Failed to set non-blocking file descriptor flag\")"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOENT",
            "_(\"Cannot find '%s' in path\")",
            "cmd->args[0]"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFindFileInPath",
          "args": [
            "cmd->args[0]"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "virFindFileInPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1657-1709",
          "snippet": "char *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirExec(virCommandPtr cmd)\n{\n    pid_t pid;\n    int null = -1;\n    int pipeout[2] = {-1, -1};\n    int pipeerr[2] = {-1, -1};\n    int childin = cmd->infd;\n    int childout = -1;\n    int childerr = -1;\n    g_autofree char *binarystr = NULL;\n    const char *binary = NULL;\n    int ret;\n    g_autofree gid_t *groups = NULL;\n    int ngroups;\n\n    if (cmd->args[0][0] != '/') {\n        if (!(binary = binarystr = virFindFileInPath(cmd->args[0]))) {\n            virReportSystemError(ENOENT,\n                                 _(\"Cannot find '%s' in path\"),\n                                 cmd->args[0]);\n            return -1;\n        }\n    } else {\n        binary = cmd->args[0];\n    }\n\n    if (childin < 0) {\n        if (getDevNull(&null) < 0)\n            goto cleanup;\n        childin = null;\n    }\n\n    if (cmd->outfdptr != NULL) {\n        if (*cmd->outfdptr == -1) {\n            if (virPipe(pipeout) < 0)\n                goto cleanup;\n\n            if ((cmd->flags & VIR_EXEC_NONBLOCK) &&\n                virSetNonBlock(pipeout[0]) == -1) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Failed to set non-blocking file descriptor flag\"));\n                goto cleanup;\n            }\n\n            childout = pipeout[1];\n        } else {\n            childout = *cmd->outfdptr;\n        }\n    } else {\n        if (getDevNull(&null) < 0)\n            goto cleanup;\n        childout = null;\n    }\n\n    if (cmd->errfdptr != NULL) {\n        if (cmd->errfdptr == cmd->outfdptr) {\n            childerr = childout;\n        } else if (*cmd->errfdptr == -1) {\n            if (virPipe(pipeerr) < 0)\n                goto cleanup;\n\n            if ((cmd->flags & VIR_EXEC_NONBLOCK) &&\n                virSetNonBlock(pipeerr[0]) == -1) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Failed to set non-blocking file descriptor flag\"));\n                goto cleanup;\n            }\n\n            childerr = pipeerr[1];\n        } else {\n            childerr = *cmd->errfdptr;\n        }\n    } else {\n        if (getDevNull(&null) < 0)\n            goto cleanup;\n        childerr = null;\n    }\n\n    if ((ngroups = virGetGroupList(cmd->uid, cmd->gid, &groups)) < 0)\n        goto cleanup;\n\n    pid = virFork();\n\n    if (pid < 0)\n        goto cleanup;\n\n    if (pid) { /* parent */\n        VIR_FORCE_CLOSE(null);\n        if (cmd->outfdptr && *cmd->outfdptr == -1) {\n            VIR_FORCE_CLOSE(pipeout[1]);\n            *cmd->outfdptr = pipeout[0];\n        }\n        if (cmd->errfdptr && *cmd->errfdptr == -1) {\n            VIR_FORCE_CLOSE(pipeerr[1]);\n            *cmd->errfdptr = pipeerr[0];\n        }\n\n        cmd->pid = pid;\n\n        return 0;\n    }\n\n    /* child */\n\n    if (cmd->mask)\n        umask(cmd->mask);\n    ret = EXIT_CANCELED;\n\n    if (virCommandMassClose(cmd, childin, childout, childerr) < 0)\n        goto fork_error;\n\n    if (prepareStdFd(childin, STDIN_FILENO) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to setup stdin file handle\"));\n        goto fork_error;\n    }\n    if (childout > 0 && prepareStdFd(childout, STDOUT_FILENO) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to setup stdout file handle\"));\n        goto fork_error;\n    }\n    if (childerr > 0 && prepareStdFd(childerr, STDERR_FILENO) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"failed to setup stderr file handle\"));\n        goto fork_error;\n    }\n\n    if (childin != STDIN_FILENO && childin != null &&\n        childin != childerr && childin != childout)\n        VIR_FORCE_CLOSE(childin);\n    if (childout > STDERR_FILENO && childout != null && childout != childerr)\n        VIR_FORCE_CLOSE(childout);\n    if (childerr > STDERR_FILENO && childerr != null)\n        VIR_FORCE_CLOSE(childerr);\n    VIR_FORCE_CLOSE(null);\n\n    /* Initialize full logging for a while */\n    virLogSetFromEnv();\n\n    /* Daemonize as late as possible, so the parent process can detect\n     * the above errors with wait* */\n    if (cmd->flags & VIR_EXEC_DAEMON) {\n        if (setsid() < 0) {\n            virReportSystemError(errno,\n                                 \"%s\", _(\"cannot become session leader\"));\n            goto fork_error;\n        }\n\n        if (chdir(\"/\") < 0) {\n            virReportSystemError(errno,\n                                 \"%s\", _(\"cannot change to root directory\"));\n            goto fork_error;\n        }\n\n        pid = fork();\n        if (pid < 0) {\n            virReportSystemError(errno,\n                                 \"%s\", _(\"cannot fork child process\"));\n            goto fork_error;\n        }\n\n        if (pid > 0) {\n            if (cmd->pidfile && (virPidFileWritePath(cmd->pidfile, pid) < 0)) {\n                if (virProcessKillPainfully(pid, true) >= 0)\n                    virReportSystemError(errno,\n                                         _(\"could not write pidfile %s for %d\"),\n                                         cmd->pidfile, pid);\n                goto fork_error;\n            }\n            _exit(EXIT_SUCCESS);\n        }\n    }\n\n    if (virProcessSetMaxMemLock(0, cmd->maxMemLock) < 0)\n        goto fork_error;\n    if (virProcessSetMaxProcesses(0, cmd->maxProcesses) < 0)\n        goto fork_error;\n    if (virProcessSetMaxFiles(0, cmd->maxFiles) < 0)\n        goto fork_error;\n    if (cmd->setMaxCore &&\n        virProcessSetMaxCoreSize(0, cmd->maxCore) < 0)\n        goto fork_error;\n\n    if (cmd->hook) {\n        VIR_DEBUG(\"Run hook %p %p\", cmd->hook, cmd->opaque);\n        ret = cmd->hook(cmd->opaque);\n        VIR_DEBUG(\"Done hook %d\", ret);\n        if (ret < 0)\n           goto fork_error;\n    }\n\n# if defined(WITH_SECDRIVER_SELINUX)\n    if (cmd->seLinuxLabel) {\n        VIR_DEBUG(\"Setting child security label to %s\", cmd->seLinuxLabel);\n        if (setexeccon_raw(cmd->seLinuxLabel) == -1) {\n            virReportSystemError(errno,\n                                 _(\"unable to set SELinux security context \"\n                                   \"'%s' for '%s'\"),\n                                 cmd->seLinuxLabel, cmd->args[0]);\n            if (security_getenforce() == 1)\n                goto fork_error;\n        }\n    }\n# endif\n# if defined(WITH_SECDRIVER_APPARMOR)\n    if (cmd->appArmorProfile) {\n        VIR_DEBUG(\"Setting child AppArmor profile to %s\", cmd->appArmorProfile);\n        if (aa_change_profile(cmd->appArmorProfile) < 0) {\n            virReportSystemError(errno,\n                                 _(\"unable to set AppArmor profile '%s' \"\n                                   \"for '%s'\"),\n                                 cmd->appArmorProfile, cmd->args[0]);\n            goto fork_error;\n        }\n    }\n# endif\n\n    if (virExecCommon(cmd, groups, ngroups) < 0)\n        goto fork_error;\n\n    if (virCommandHandshakeChild(cmd) < 0)\n       goto fork_error;\n\n    /* Close logging again to ensure no FDs leak to child */\n    virLogReset();\n\n    if (cmd->env)\n        execve(binary, cmd->args, cmd->env);\n    else\n        execv(binary, cmd->args);\n\n    ret = errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE;\n    virReportSystemError(errno,\n                         _(\"cannot execute binary %s\"),\n                         cmd->args[0]);\n\n fork_error:\n    virDispatchError(NULL);\n    _exit(ret);\n\n cleanup:\n    /* This is cleanup of parent process only - child\n       should never jump here on error */\n\n    /* NB we don't virReportError() on any failures here\n       because the code which jumped here already raised\n       an error condition which we must not overwrite */\n    VIR_FORCE_CLOSE(pipeerr[0]);\n    VIR_FORCE_CLOSE(pipeerr[1]);\n    VIR_FORCE_CLOSE(pipeout[0]);\n    VIR_FORCE_CLOSE(pipeout[1]);\n    VIR_FORCE_CLOSE(null);\n    return -1;\n}"
  },
  {
    "function_name": "virCommandMassClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "551-599",
    "snippet": "static int\nvirCommandMassClose(virCommandPtr cmd,\n                    int childin,\n                    int childout,\n                    int childerr)\n{\n    g_autoptr(virBitmap) fds = NULL;\n    int openmax = sysconf(_SC_OPEN_MAX);\n    int fd = -1;\n\n    /* In general, it is not safe to call malloc() between fork() and exec()\n     * because the child might have forked at the worst possible time, i.e.\n     * when another thread was in malloc() and thus held its lock. That is to\n     * say, POSIX does not mandate malloc() to be async-safe. Fortunately,\n     * glibc developers are aware of this and made malloc() async-safe.\n     * Therefore we can safely allocate memory here (and transitively call\n     * opendir/readdir) without a deadlock. */\n\n    if (openmax < 0) {\n        virReportSystemError(errno, \"%s\", _(\"sysconf(_SC_OPEN_MAX) failed\"));\n        return -1;\n    }\n\n    if (!(fds = virBitmapNew(openmax)))\n        return -1;\n\n#  ifdef __linux__\n    if (virCommandMassCloseGetFDsLinux(cmd, fds) < 0)\n        return -1;\n#  else\n    if (virCommandMassCloseGetFDsGeneric(cmd, fds) < 0)\n        return -1;\n#  endif\n\n    fd = virBitmapNextSetBit(fds, 2);\n    for (; fd >= 0; fd = virBitmapNextSetBit(fds, fd)) {\n        if (fd == childin || fd == childout || fd == childerr)\n            continue;\n        if (!virCommandFDIsSet(cmd, fd)) {\n            int tmpfd = fd;\n            VIR_MASS_CLOSE(tmpfd);\n        } else if (virSetInherit(fd, true) < 0) {\n            virReportSystemError(errno, _(\"failed to preserve fd %d\"), fd);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to preserve fd %d\")",
            "fd"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to preserve fd %d\""
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetInherit",
          "args": [
            "fd",
            "true"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "virSetInherit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "104-111",
          "snippet": "int virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_MASS_CLOSE",
          "args": [
            "tmpfd"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandFDIsSet",
          "args": [
            "cmd",
            "fd"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFDIsSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "174-187",
          "snippet": "static bool\nvirCommandFDIsSet(virCommandPtr cmd,\n                  int fd)\n{\n    size_t i = 0;\n    if (!cmd)\n        return false;\n\n    while (i < cmd->npassfd)\n        if (cmd->passfd[i++].fd == fd)\n            return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic bool\nvirCommandFDIsSet(virCommandPtr cmd,\n                  int fd)\n{\n    size_t i = 0;\n    if (!cmd)\n        return false;\n\n    while (i < cmd->npassfd)\n        if (cmd->passfd[i++].fd == fd)\n            return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNextSetBit",
          "args": [
            "fds",
            "fd"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextSetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "986-1014",
          "snippet": "ssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandMassCloseGetFDsGeneric",
          "args": [
            "cmd",
            "fds"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandMassCloseGetFDsGeneric",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "488-494",
          "snippet": "static int\nvirCommandMassCloseGetFDsGeneric(virCommandPtr cmd G_GNUC_UNUSED,\n                                 virBitmapPtr fds)\n{\n    virBitmapSetAll(fds);\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandMassCloseGetFDsGeneric(virCommandPtr cmd G_GNUC_UNUSED,\n                                 virBitmapPtr fds)\n{\n    virBitmapSetAll(fds);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandMassCloseGetFDsLinux",
          "args": [
            "cmd",
            "fds"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandMassCloseGetFDsLinux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "451-484",
          "snippet": "static int\nvirCommandMassCloseGetFDsLinux(virCommandPtr cmd G_GNUC_UNUSED,\n                               virBitmapPtr fds)\n{\n    DIR *dp = NULL;\n    struct dirent *entry;\n    const char *dirName = \"/proc/self/fd\";\n    int rc;\n    int ret = -1;\n\n    if (virDirOpen(&dp, dirName) < 0)\n        return -1;\n\n    while ((rc = virDirRead(dp, &entry, dirName)) > 0) {\n        int fd;\n\n        if (virStrToLong_i(entry->d_name, NULL, 10, &fd) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse FD: %s\"),\n                           entry->d_name);\n            goto cleanup;\n        }\n\n        ignore_value(virBitmapSetBit(fds, fd));\n    }\n\n    if (rc < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dp);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandMassCloseGetFDsLinux(virCommandPtr cmd G_GNUC_UNUSED,\n                               virBitmapPtr fds)\n{\n    DIR *dp = NULL;\n    struct dirent *entry;\n    const char *dirName = \"/proc/self/fd\";\n    int rc;\n    int ret = -1;\n\n    if (virDirOpen(&dp, dirName) < 0)\n        return -1;\n\n    while ((rc = virDirRead(dp, &entry, dirName)) > 0) {\n        int fd;\n\n        if (virStrToLong_i(entry->d_name, NULL, 10, &fd) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse FD: %s\"),\n                           entry->d_name);\n            goto cleanup;\n        }\n\n        ignore_value(virBitmapSetBit(fds, fd));\n    }\n\n    if (rc < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dp);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "openmax"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"sysconf(_SC_OPEN_MAX) failed\")"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysconf",
          "args": [
            "_SC_OPEN_MAX"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandMassClose(virCommandPtr cmd,\n                    int childin,\n                    int childout,\n                    int childerr)\n{\n    g_autoptr(virBitmap) fds = NULL;\n    int openmax = sysconf(_SC_OPEN_MAX);\n    int fd = -1;\n\n    /* In general, it is not safe to call malloc() between fork() and exec()\n     * because the child might have forked at the worst possible time, i.e.\n     * when another thread was in malloc() and thus held its lock. That is to\n     * say, POSIX does not mandate malloc() to be async-safe. Fortunately,\n     * glibc developers are aware of this and made malloc() async-safe.\n     * Therefore we can safely allocate memory here (and transitively call\n     * opendir/readdir) without a deadlock. */\n\n    if (openmax < 0) {\n        virReportSystemError(errno, \"%s\", _(\"sysconf(_SC_OPEN_MAX) failed\"));\n        return -1;\n    }\n\n    if (!(fds = virBitmapNew(openmax)))\n        return -1;\n\n#  ifdef __linux__\n    if (virCommandMassCloseGetFDsLinux(cmd, fds) < 0)\n        return -1;\n#  else\n    if (virCommandMassCloseGetFDsGeneric(cmd, fds) < 0)\n        return -1;\n#  endif\n\n    fd = virBitmapNextSetBit(fds, 2);\n    for (; fd >= 0; fd = virBitmapNextSetBit(fds, fd)) {\n        if (fd == childin || fd == childout || fd == childerr)\n            continue;\n        if (!virCommandFDIsSet(cmd, fd)) {\n            int tmpfd = fd;\n            VIR_MASS_CLOSE(tmpfd);\n        } else if (virSetInherit(fd, true) < 0) {\n            virReportSystemError(errno, _(\"failed to preserve fd %d\"), fd);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virCommandMassClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "499-547",
    "snippet": "static int\nvirCommandMassClose(virCommandPtr cmd,\n                    int childin,\n                    int childout,\n                    int childerr)\n{\n    int lastfd = -1;\n    int fd = -1;\n    size_t i;\n\n    /*\n     * Two phases of closing.\n     *\n     * The first (inefficient) phase iterates over FDs,\n     * preserving certain FDs we need to pass down, and\n     * closing others. The number of iterations is bounded\n     * to the number of the biggest FD we need to preserve.\n     *\n     * The second (speedy) phase uses closefrom() to cull\n     * all remaining FDs in the process.\n     *\n     * Usually the first phase will be fairly quick only\n     * processing a handful of low FD numbers, and thus using\n     * closefrom() is a massive win for high ulimit() NFILES\n     * values.\n     */\n    lastfd = MAX(lastfd, childin);\n    lastfd = MAX(lastfd, childout);\n    lastfd = MAX(lastfd, childerr);\n\n    for (i = 0; i < cmd->npassfd; i++)\n        lastfd = MAX(lastfd, cmd->passfd[i].fd);\n\n    for (fd = 0; fd <= lastfd; fd++) {\n        if (fd == childin || fd == childout || fd == childerr)\n            continue;\n        if (!virCommandFDIsSet(cmd, fd)) {\n            int tmpfd = fd;\n            VIR_MASS_CLOSE(tmpfd);\n        } else if (virSetInherit(fd, true) < 0) {\n            virReportSystemError(errno, _(\"failed to preserve fd %d\"), fd);\n            return -1;\n        }\n    }\n\n    closefrom(lastfd + 1);\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closefrom",
          "args": [
            "lastfd + 1"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to preserve fd %d\")",
            "fd"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to preserve fd %d\""
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetInherit",
          "args": [
            "fd",
            "true"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "virSetInherit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "104-111",
          "snippet": "int virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_MASS_CLOSE",
          "args": [
            "tmpfd"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandFDIsSet",
          "args": [
            "cmd",
            "fd"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFDIsSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "174-187",
          "snippet": "static bool\nvirCommandFDIsSet(virCommandPtr cmd,\n                  int fd)\n{\n    size_t i = 0;\n    if (!cmd)\n        return false;\n\n    while (i < cmd->npassfd)\n        if (cmd->passfd[i++].fd == fd)\n            return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic bool\nvirCommandFDIsSet(virCommandPtr cmd,\n                  int fd)\n{\n    size_t i = 0;\n    if (!cmd)\n        return false;\n\n    while (i < cmd->npassfd)\n        if (cmd->passfd[i++].fd == fd)\n            return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "lastfd",
            "cmd->passfd[i].fd"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "lastfd",
            "childerr"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "lastfd",
            "childout"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "lastfd",
            "childin"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandMassClose(virCommandPtr cmd,\n                    int childin,\n                    int childout,\n                    int childerr)\n{\n    int lastfd = -1;\n    int fd = -1;\n    size_t i;\n\n    /*\n     * Two phases of closing.\n     *\n     * The first (inefficient) phase iterates over FDs,\n     * preserving certain FDs we need to pass down, and\n     * closing others. The number of iterations is bounded\n     * to the number of the biggest FD we need to preserve.\n     *\n     * The second (speedy) phase uses closefrom() to cull\n     * all remaining FDs in the process.\n     *\n     * Usually the first phase will be fairly quick only\n     * processing a handful of low FD numbers, and thus using\n     * closefrom() is a massive win for high ulimit() NFILES\n     * values.\n     */\n    lastfd = MAX(lastfd, childin);\n    lastfd = MAX(lastfd, childout);\n    lastfd = MAX(lastfd, childerr);\n\n    for (i = 0; i < cmd->npassfd; i++)\n        lastfd = MAX(lastfd, cmd->passfd[i].fd);\n\n    for (fd = 0; fd <= lastfd; fd++) {\n        if (fd == childin || fd == childout || fd == childerr)\n            continue;\n        if (!virCommandFDIsSet(cmd, fd)) {\n            int tmpfd = fd;\n            VIR_MASS_CLOSE(tmpfd);\n        } else if (virSetInherit(fd, true) < 0) {\n            virReportSystemError(errno, _(\"failed to preserve fd %d\"), fd);\n            return -1;\n        }\n    }\n\n    closefrom(lastfd + 1);\n\n    return 0;\n}"
  },
  {
    "function_name": "virCommandMassCloseGetFDsGeneric",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "488-494",
    "snippet": "static int\nvirCommandMassCloseGetFDsGeneric(virCommandPtr cmd G_GNUC_UNUSED,\n                                 virBitmapPtr fds)\n{\n    virBitmapSetAll(fds);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapSetAll",
          "args": [
            "fds"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "895-906",
          "snippet": "void virBitmapSetAll(virBitmapPtr bitmap)\n{\n    int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n    memset(bitmap->map, 0xff,\n           bitmap->map_len * (VIR_BITMAP_BITS_PER_UNIT / CHAR_BIT));\n\n    /* Ensure tail bits are clear.  */\n    if (tail)\n        bitmap->map[bitmap->map_len - 1] &=\n            -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nvoid virBitmapSetAll(virBitmapPtr bitmap)\n{\n    int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n    memset(bitmap->map, 0xff,\n           bitmap->map_len * (VIR_BITMAP_BITS_PER_UNIT / CHAR_BIT));\n\n    /* Ensure tail bits are clear.  */\n    if (tail)\n        bitmap->map[bitmap->map_len - 1] &=\n            -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandMassCloseGetFDsGeneric(virCommandPtr cmd G_GNUC_UNUSED,\n                                 virBitmapPtr fds)\n{\n    virBitmapSetAll(fds);\n    return 0;\n}"
  },
  {
    "function_name": "virCommandMassCloseGetFDsLinux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "451-484",
    "snippet": "static int\nvirCommandMassCloseGetFDsLinux(virCommandPtr cmd G_GNUC_UNUSED,\n                               virBitmapPtr fds)\n{\n    DIR *dp = NULL;\n    struct dirent *entry;\n    const char *dirName = \"/proc/self/fd\";\n    int rc;\n    int ret = -1;\n\n    if (virDirOpen(&dp, dirName) < 0)\n        return -1;\n\n    while ((rc = virDirRead(dp, &entry, dirName)) > 0) {\n        int fd;\n\n        if (virStrToLong_i(entry->d_name, NULL, 10, &fd) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse FD: %s\"),\n                           entry->d_name);\n            goto cleanup;\n        }\n\n        ignore_value(virBitmapSetBit(fds, fd));\n    }\n\n    if (rc < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dp);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dp"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(fds, fd)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "fds",
            "fd"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unable to parse FD: %s\")",
            "entry->d_name"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to parse FD: %s\""
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "entry->d_name",
            "NULL",
            "10",
            "&fd"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "dp",
            "&entry",
            "dirName"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpen",
          "args": [
            "&dp",
            "dirName"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandMassCloseGetFDsLinux(virCommandPtr cmd G_GNUC_UNUSED,\n                               virBitmapPtr fds)\n{\n    DIR *dp = NULL;\n    struct dirent *entry;\n    const char *dirName = \"/proc/self/fd\";\n    int rc;\n    int ret = -1;\n\n    if (virDirOpen(&dp, dirName) < 0)\n        return -1;\n\n    while ((rc = virDirRead(dp, &entry, dirName)) > 0) {\n        int fd;\n\n        if (virStrToLong_i(entry->d_name, NULL, 10, &fd) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to parse FD: %s\"),\n                           entry->d_name);\n            goto cleanup;\n        }\n\n        ignore_value(virBitmapSetBit(fds, fd));\n    }\n\n    if (rc < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_DIR_CLOSE(dp);\n    return ret;\n}"
  },
  {
    "function_name": "virExecCommon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "422-444",
    "snippet": "static int\nvirExecCommon(virCommandPtr cmd, gid_t *groups, int ngroups)\n{\n    if (cmd->uid != (uid_t)-1 || cmd->gid != (gid_t)-1 ||\n        cmd->capabilities || (cmd->flags & VIR_EXEC_CLEAR_CAPS)) {\n        VIR_DEBUG(\"Setting child uid:gid to %d:%d with caps %llx\",\n                  (int)cmd->uid, (int)cmd->gid, cmd->capabilities);\n        if (virSetUIDGIDWithCaps(cmd->uid, cmd->gid, groups, ngroups,\n                                 cmd->capabilities,\n                                 !!(cmd->flags & VIR_EXEC_CLEAR_CAPS)) < 0)\n            return -1;\n    }\n\n    if (cmd->pwd) {\n        VIR_DEBUG(\"Running child in %s\", cmd->pwd);\n        if (chdir(cmd->pwd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to change to %s\"), cmd->pwd);\n            return -1;\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to change to %s\")",
            "cmd->pwd"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to change to %s\""
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "cmd->pwd"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Running child in %s\"",
            "cmd->pwd"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetUIDGIDWithCaps",
          "args": [
            "cmd->uid",
            "cmd->gid",
            "groups",
            "ngroups",
            "cmd->capabilities",
            "!!(cmd->flags & VIR_EXEC_CLEAR_CAPS)"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "virSetUIDGIDWithCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1314-1320",
          "snippet": "int\nvirSetUIDGIDWithCaps(uid_t uid, gid_t gid, gid_t *groups, int ngroups,\n                     unsigned long long capBits G_GNUC_UNUSED,\n                     bool clearExistingCaps G_GNUC_UNUSED)\n{\n    return virSetUIDGID(uid, gid, groups, ngroups);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirSetUIDGIDWithCaps(uid_t uid, gid_t gid, gid_t *groups, int ngroups,\n                     unsigned long long capBits G_GNUC_UNUSED,\n                     bool clearExistingCaps G_GNUC_UNUSED)\n{\n    return virSetUIDGID(uid, gid, groups, ngroups);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting child uid:gid to %d:%d with caps %llx\"",
            "(int)cmd->uid",
            "(int)cmd->gid",
            "cmd->capabilities"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirExecCommon(virCommandPtr cmd, gid_t *groups, int ngroups)\n{\n    if (cmd->uid != (uid_t)-1 || cmd->gid != (gid_t)-1 ||\n        cmd->capabilities || (cmd->flags & VIR_EXEC_CLEAR_CAPS)) {\n        VIR_DEBUG(\"Setting child uid:gid to %d:%d with caps %llx\",\n                  (int)cmd->uid, (int)cmd->gid, cmd->capabilities);\n        if (virSetUIDGIDWithCaps(cmd->uid, cmd->gid, groups, ngroups,\n                                 cmd->capabilities,\n                                 !!(cmd->flags & VIR_EXEC_CLEAR_CAPS)) < 0)\n            return -1;\n    }\n\n    if (cmd->pwd) {\n        VIR_DEBUG(\"Running child in %s\", cmd->pwd);\n        if (chdir(cmd->pwd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to change to %s\"), cmd->pwd);\n            return -1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virCommandHandshakeChild",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "380-420",
    "snippet": "static int\nvirCommandHandshakeChild(virCommandPtr cmd)\n{\n    char c = '1';\n    int rv;\n\n    if (!cmd->handshake)\n       return true;\n\n    VIR_DEBUG(\"Notifying parent for handshake start on %d\",\n              cmd->handshakeWait[1]);\n    if (safewrite(cmd->handshakeWait[1], &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to notify parent process\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"Waiting on parent for handshake complete on %d\",\n              cmd->handshakeNotify[0]);\n    if ((rv = saferead(cmd->handshakeNotify[0], &c,\n                       sizeof(c))) != sizeof(c)) {\n        if (rv < 0)\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to wait on parent process\"));\n        else\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"libvirtd quit during handshake\"));\n        return -1;\n    }\n    if (c != '1') {\n        virReportSystemError(EINVAL,\n                             _(\"Unexpected confirm code '%c' from parent\"),\n                             c);\n        return -1;\n    }\n    VIR_FORCE_CLOSE(cmd->handshakeWait[1]);\n    VIR_FORCE_CLOSE(cmd->handshakeNotify[0]);\n\n    VIR_DEBUG(\"Handshake with parent is done\");\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Handshake with parent is done\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->handshakeNotify[0]"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "cmd->handshakeWait[1]"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EINVAL",
            "_(\"Unexpected confirm code '%c' from parent\")",
            "c"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected confirm code '%c' from parent\""
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EIO",
            "\"%s\"",
            "_(\"libvirtd quit during handshake\")"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to wait on parent process\")"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "saferead",
          "args": [
            "cmd->handshakeNotify[0]",
            "&c",
            "sizeof(c)"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "saferead_lim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1330-1372",
          "snippet": "static char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Waiting on parent for handshake complete on %d\"",
            "cmd->handshakeNotify[0]"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to notify parent process\")"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "cmd->handshakeWait[1]",
            "&c",
            "sizeof(c)"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Notifying parent for handshake start on %d\"",
            "cmd->handshakeWait[1]"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandHandshakeChild(virCommandPtr cmd)\n{\n    char c = '1';\n    int rv;\n\n    if (!cmd->handshake)\n       return true;\n\n    VIR_DEBUG(\"Notifying parent for handshake start on %d\",\n              cmd->handshakeWait[1]);\n    if (safewrite(cmd->handshakeWait[1], &c, sizeof(c)) != sizeof(c)) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to notify parent process\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"Waiting on parent for handshake complete on %d\",\n              cmd->handshakeNotify[0]);\n    if ((rv = saferead(cmd->handshakeNotify[0], &c,\n                       sizeof(c))) != sizeof(c)) {\n        if (rv < 0)\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to wait on parent process\"));\n        else\n            virReportSystemError(EIO, \"%s\",\n                                 _(\"libvirtd quit during handshake\"));\n        return -1;\n    }\n    if (c != '1') {\n        virReportSystemError(EINVAL,\n                             _(\"Unexpected confirm code '%c' from parent\"),\n                             c);\n        return -1;\n    }\n    VIR_FORCE_CLOSE(cmd->handshakeWait[1]);\n    VIR_FORCE_CLOSE(cmd->handshakeNotify[0]);\n\n    VIR_DEBUG(\"Handshake with parent is done\");\n    return 0;\n}"
  },
  {
    "function_name": "prepareStdFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "364-372",
    "snippet": "static int\nprepareStdFd(int fd, int std)\n{\n    if (fd == std)\n        return virSetInherit(fd, true);\n    if (dup2(fd, std) != std)\n        return -1;\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "fd",
            "std"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetInherit",
          "args": [
            "fd",
            "true"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "virSetInherit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "104-111",
          "snippet": "int virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nprepareStdFd(int fd, int std)\n{\n    if (fd == std)\n        return virSetInherit(fd, true);\n    if (dup2(fd, std) != std)\n        return -1;\n    return 0;\n}"
  },
  {
    "function_name": "getDevNull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "350-360",
    "snippet": "static int\ngetDevNull(int *null)\n{\n    if (*null == -1 && (*null = open(\"/dev/null\", O_RDWR|O_CLOEXEC)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot open %s\"),\n                             \"/dev/null\");\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot open %s\")",
            "\"/dev/null\""
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot open %s\""
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_RDWR|O_CLOEXEC"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\ngetDevNull(int *null)\n{\n    if (*null == -1 && (*null = open(\"/dev/null\", O_RDWR|O_CLOEXEC)) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot open %s\"),\n                             \"/dev/null\");\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virFork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "246-343",
    "snippet": "pid_t\nvirFork(void)\n{\n    sigset_t oldmask, newmask;\n    struct sigaction sig_action;\n    int saved_errno;\n    pid_t pid;\n\n    /*\n     * Need to block signals now, so that child process can safely\n     * kill off caller's signal handlers without a race.\n     */\n    sigfillset(&newmask);\n    if (pthread_sigmask(SIG_SETMASK, &newmask, &oldmask) != 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot block signals\"));\n        return -1;\n    }\n\n    /* Ensure we hold the logging lock, to protect child processes\n     * from deadlocking on another thread's inherited mutex state */\n    virLogLock();\n\n    pid = fork();\n    saved_errno = errno; /* save for caller */\n\n    /* Unlock for both parent and child process */\n    virLogUnlock();\n\n    if (pid < 0) {\n        /* attempt to restore signal mask, but ignore failure, to\n         * avoid obscuring the fork failure */\n        ignore_value(pthread_sigmask(SIG_SETMASK, &oldmask, NULL));\n        virReportSystemError(saved_errno,\n                             \"%s\", _(\"cannot fork child process\"));\n        errno = saved_errno;\n\n    } else if (pid) {\n        /* parent process */\n\n        /* Restore our original signal mask now that the child is\n         * safely running. Only documented failures are EFAULT (not\n         * possible, since we are using just-grabbed mask) or EINVAL\n         * (not possible, since we are using correct arguments).  */\n        ignore_value(pthread_sigmask(SIG_SETMASK, &oldmask, NULL));\n\n    } else {\n        /* child process */\n\n        int logprio;\n        size_t i;\n\n        /* Remove any error callback so errors in child now get sent\n         * to stderr where they stand a fighting chance of being seen\n         * and logged */\n        virSetErrorFunc(NULL, NULL);\n        virSetErrorLogPriorityFunc(NULL);\n\n        /* Make sure any hook logging is sent to stderr, since child\n         * process may close the logfile FDs */\n        logprio = virLogGetDefaultPriority();\n        virLogReset();\n        virLogSetDefaultPriority(logprio);\n\n        /* Clear out all signal handlers from parent so nothing\n         * unexpected can happen in our child once we unblock\n         * signals */\n        sig_action.sa_handler = SIG_DFL;\n        sig_action.sa_flags = 0;\n        sigemptyset(&sig_action.sa_mask);\n\n        for (i = 1; i < NSIG; i++) {\n            /* Only possible errors are EFAULT or EINVAL The former\n             * won't happen, the latter we expect, so no need to check\n             * return value */\n            ignore_value(sigaction(i, &sig_action, NULL));\n        }\n\n        /* Code that runs between fork & execve might trigger\n         * SIG_PIPE, so we must explicitly set that to a no-op\n         * handler. This handler will get reset to SIG_DFL when\n         * execve() runs\n         */\n        sig_action.sa_handler = virDummyHandler;\n        ignore_value(sigaction(SIGPIPE, &sig_action, NULL));\n\n        /* Unmask all signals in child, since we've no idea what the\n         * caller's done with their signal mask and don't want to\n         * propagate that to children */\n        sigemptyset(&newmask);\n        if (pthread_sigmask(SIG_SETMASK, &newmask, NULL) != 0) {\n            virReportSystemError(errno, \"%s\", _(\"cannot unblock signals\"));\n            virDispatchError(NULL);\n            _exit(EXIT_CANCELED);\n        }\n    }\n    return pid;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "EXIT_CANCELED"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDispatchError",
          "args": [
            "NULL"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "virDispatchError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "695-728",
          "snippet": "void\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot unblock signals\")"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot unblock signals\""
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_sigmask",
          "args": [
            "SIG_SETMASK",
            "&newmask",
            "NULL"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "pthread_sigmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "84-92",
          "snippet": "static inline int pthread_sigmask(int how,\n                                  const void *set,\n                                  void *old)\n{\n    (void) how;\n    (void) set;\n    (void) old;\n    return 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int pthread_sigmask(int how,\n                                  const void *set,\n                                  void *old)\n{\n    (void) how;\n    (void) set;\n    (void) old;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&newmask"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "sigaction(SIGPIPE, &sig_action, NULL)"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGPIPE",
            "&sig_action",
            "NULL"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "sigaction(i, &sig_action, NULL)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "i",
            "&sig_action",
            "NULL"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sig_action.sa_mask"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLogSetDefaultPriority",
          "args": [
            "logprio"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetDefaultPriority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "304-318",
          "snippet": "int\nvirLogSetDefaultPriority(virLogPriority priority)\n{\n    if ((priority < VIR_LOG_DEBUG) || (priority > VIR_LOG_ERROR)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to set logging priority, argument '%u' is \"\n                         \"invalid\"), priority);\n        return -1;\n    }\n    if (virLogInitialize() < 0)\n        return -1;\n\n    virLogDefaultPriority = priority;\n    return 0;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;\n\nint\nvirLogSetDefaultPriority(virLogPriority priority)\n{\n    if ((priority < VIR_LOG_DEBUG) || (priority > VIR_LOG_ERROR)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Failed to set logging priority, argument '%u' is \"\n                         \"invalid\"), priority);\n        return -1;\n    }\n    if (virLogInitialize() < 0)\n        return -1;\n\n    virLogDefaultPriority = priority;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogReset",
          "args": [],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "virLogResetOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "373-379",
          "snippet": "static void\nvirLogResetOutputs(void)\n{\n    virLogOutputListFree(virLogOutputs, virLogNbOutputs);\n    virLogOutputs = NULL;\n    virLogNbOutputs = 0;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogOutputPtr *virLogOutputs;",
            "static size_t virLogNbOutputs;",
            "static void virLogResetOutputs(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogOutputPtr *virLogOutputs;\nstatic size_t virLogNbOutputs;\nstatic void virLogResetOutputs(void);\n\nstatic void\nvirLogResetOutputs(void)\n{\n    virLogOutputListFree(virLogOutputs, virLogNbOutputs);\n    virLogOutputs = NULL;\n    virLogNbOutputs = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogGetDefaultPriority",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "virLogGetDefaultPriority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1063-1067",
          "snippet": "virLogPriority\nvirLogGetDefaultPriority(void)\n{\n    return virLogDefaultPriority;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic virLogPriority virLogDefaultPriority = VIR_LOG_DEFAULT;\n\nvirLogPriority\nvirLogGetDefaultPriority(void)\n{\n    return virLogDefaultPriority;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetErrorLogPriorityFunc",
          "args": [
            "NULL"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorLogPriorityFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1391-1394",
          "snippet": "void virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;\n\nvoid virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetErrorFunc",
          "args": [
            "NULL",
            "NULL"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "609-614",
          "snippet": "void\nvirSetErrorFunc(void *userData, virErrorFunc handler)\n{\n    virErrorHandler = handler;\n    virUserData = userData;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirSetErrorFunc(void *userData, virErrorFunc handler)\n{\n    virErrorHandler = handler;\n    virUserData = userData;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "pthread_sigmask(SIG_SETMASK, &oldmask, NULL)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "saved_errno",
            "\"%s\"",
            "_(\"cannot fork child process\")"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "pthread_sigmask(SIG_SETMASK, &oldmask, NULL)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLogUnlock",
          "args": [],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "virLogUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "137-141",
          "snippet": "void\nvirLogUnlock(void)\n{\n    virMutexUnlock(&virLogMutex);\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virMutex virLogMutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nvirMutex virLogMutex;\n\nvoid\nvirLogUnlock(void)\n{\n    virMutexUnlock(&virLogMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLogLock",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "virLogLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "130-134",
          "snippet": "void\nvirLogLock(void)\n{\n    virMutexLock(&virLogMutex);\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virMutex virLogMutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nvirMutex virLogMutex;\n\nvoid\nvirLogLock(void)\n{\n    virMutexLock(&virLogMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot block signals\")"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigfillset",
          "args": [
            "&newmask"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\npid_t\nvirFork(void)\n{\n    sigset_t oldmask, newmask;\n    struct sigaction sig_action;\n    int saved_errno;\n    pid_t pid;\n\n    /*\n     * Need to block signals now, so that child process can safely\n     * kill off caller's signal handlers without a race.\n     */\n    sigfillset(&newmask);\n    if (pthread_sigmask(SIG_SETMASK, &newmask, &oldmask) != 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot block signals\"));\n        return -1;\n    }\n\n    /* Ensure we hold the logging lock, to protect child processes\n     * from deadlocking on another thread's inherited mutex state */\n    virLogLock();\n\n    pid = fork();\n    saved_errno = errno; /* save for caller */\n\n    /* Unlock for both parent and child process */\n    virLogUnlock();\n\n    if (pid < 0) {\n        /* attempt to restore signal mask, but ignore failure, to\n         * avoid obscuring the fork failure */\n        ignore_value(pthread_sigmask(SIG_SETMASK, &oldmask, NULL));\n        virReportSystemError(saved_errno,\n                             \"%s\", _(\"cannot fork child process\"));\n        errno = saved_errno;\n\n    } else if (pid) {\n        /* parent process */\n\n        /* Restore our original signal mask now that the child is\n         * safely running. Only documented failures are EFAULT (not\n         * possible, since we are using just-grabbed mask) or EINVAL\n         * (not possible, since we are using correct arguments).  */\n        ignore_value(pthread_sigmask(SIG_SETMASK, &oldmask, NULL));\n\n    } else {\n        /* child process */\n\n        int logprio;\n        size_t i;\n\n        /* Remove any error callback so errors in child now get sent\n         * to stderr where they stand a fighting chance of being seen\n         * and logged */\n        virSetErrorFunc(NULL, NULL);\n        virSetErrorLogPriorityFunc(NULL);\n\n        /* Make sure any hook logging is sent to stderr, since child\n         * process may close the logfile FDs */\n        logprio = virLogGetDefaultPriority();\n        virLogReset();\n        virLogSetDefaultPriority(logprio);\n\n        /* Clear out all signal handlers from parent so nothing\n         * unexpected can happen in our child once we unblock\n         * signals */\n        sig_action.sa_handler = SIG_DFL;\n        sig_action.sa_flags = 0;\n        sigemptyset(&sig_action.sa_mask);\n\n        for (i = 1; i < NSIG; i++) {\n            /* Only possible errors are EFAULT or EINVAL The former\n             * won't happen, the latter we expect, so no need to check\n             * return value */\n            ignore_value(sigaction(i, &sig_action, NULL));\n        }\n\n        /* Code that runs between fork & execve might trigger\n         * SIG_PIPE, so we must explicitly set that to a no-op\n         * handler. This handler will get reset to SIG_DFL when\n         * execve() runs\n         */\n        sig_action.sa_handler = virDummyHandler;\n        ignore_value(sigaction(SIGPIPE, &sig_action, NULL));\n\n        /* Unmask all signals in child, since we've no idea what the\n         * caller's done with their signal mask and don't want to\n         * propagate that to children */\n        sigemptyset(&newmask);\n        if (pthread_sigmask(SIG_SETMASK, &newmask, NULL) != 0) {\n            virReportSystemError(errno, \"%s\", _(\"cannot unblock signals\"));\n            virDispatchError(NULL);\n            _exit(EXIT_CANCELED);\n        }\n    }\n    return pid;\n}"
  },
  {
    "function_name": "virDummyHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "225-227",
    "snippet": "static void virDummyHandler(int sig G_GNUC_UNUSED)\n{\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic void virDummyHandler(int sig G_GNUC_UNUSED)\n{\n}"
  },
  {
    "function_name": "virCommandFDSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "203-221",
    "snippet": "static int\nvirCommandFDSet(virCommandPtr cmd,\n                int fd,\n                unsigned int flags)\n{\n    if (!cmd || fd < 0)\n        return -1;\n\n    if (virCommandFDIsSet(cmd, fd))\n        return 0;\n\n    if (VIR_EXPAND_N(cmd->passfd, cmd->npassfd, 1) < 0)\n        return ENOMEM;\n\n    cmd->passfd[cmd->npassfd - 1].fd = fd;\n    cmd->passfd[cmd->npassfd - 1].flags = flags;\n\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "cmd->passfd",
            "cmd->npassfd",
            "1"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandFDIsSet",
          "args": [
            "cmd",
            "fd"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFDIsSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "174-187",
          "snippet": "static bool\nvirCommandFDIsSet(virCommandPtr cmd,\n                  int fd)\n{\n    size_t i = 0;\n    if (!cmd)\n        return false;\n\n    while (i < cmd->npassfd)\n        if (cmd->passfd[i++].fd == fd)\n            return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic bool\nvirCommandFDIsSet(virCommandPtr cmd,\n                  int fd)\n{\n    size_t i = 0;\n    if (!cmd)\n        return false;\n\n    while (i < cmd->npassfd)\n        if (cmd->passfd[i++].fd == fd)\n            return true;\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic int\nvirCommandFDSet(virCommandPtr cmd,\n                int fd,\n                unsigned int flags)\n{\n    if (!cmd || fd < 0)\n        return -1;\n\n    if (virCommandFDIsSet(cmd, fd))\n        return 0;\n\n    if (VIR_EXPAND_N(cmd->passfd, cmd->npassfd, 1) < 0)\n        return ENOMEM;\n\n    cmd->passfd[cmd->npassfd - 1].fd = fd;\n    cmd->passfd[cmd->npassfd - 1].flags = flags;\n\n    return 0;\n}"
  },
  {
    "function_name": "virCommandFDIsSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
    "lines": "174-187",
    "snippet": "static bool\nvirCommandFDIsSet(virCommandPtr cmd,\n                  int fd)\n{\n    size_t i = 0;\n    if (!cmd)\n        return false;\n\n    while (i < cmd->npassfd)\n        if (cmd->passfd[i++].fd == fd)\n            return true;\n\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommandpriv.h\"",
      "#include \"viralloc.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "# include <cap-ng.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "# include <sys/wait.h>",
      "#include <sys/stat.h>",
      "#include <stdarg.h>",
      "#include <signal.h>",
      "# include <poll.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nstatic bool\nvirCommandFDIsSet(virCommandPtr cmd,\n                  int fd)\n{\n    size_t i = 0;\n    if (!cmd)\n        return false;\n\n    while (i < cmd->npassfd)\n        if (cmd->passfd[i++].fd == fd)\n            return true;\n\n    return false;\n}"
  }
]