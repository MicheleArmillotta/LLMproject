[
  {
    "function_name": "virVMXFormatSVGA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "4013-4041",
    "snippet": "int\nvirVMXFormatSVGA(virDomainVideoDefPtr def, virBufferPtr buffer)\n{\n    unsigned long long vram;\n\n    if (def->type != VIR_DOMAIN_VIDEO_TYPE_VMVGA) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported video device type '%s'\"),\n                       virDomainVideoTypeToString(def->type));\n        return -1;\n    }\n\n    /*\n     * For Windows guests the VRAM size should be a multiple of 64 kilobyte.\n     * See http://kb.vmware.com/kb/1003 and http://kb.vmware.com/kb/1001558\n     */\n    vram = VIR_DIV_UP(def->vram, 64) * 64;\n\n    if (def->heads > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Multi-head video devices are unsupported\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"svga.vramSize = \\\"%lld\\\"\\n\",\n                      vram * 1024); /* kilobyte to byte */\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buffer",
            "\"svga.vramSize = \\\"%lld\\\"\\n\"",
            "vram * 1024"
          ],
          "line": 4037
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Multi-head video devices are unsupported\")"
          ],
          "line": 4032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Multi-head video devices are unsupported\""
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "def->vram",
            "64"
          ],
          "line": 4029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported video device type '%s'\")",
            "virDomainVideoTypeToString(def->type)"
          ],
          "line": 4019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVideoTypeToString",
          "args": [
            "def->type"
          ],
          "line": 4021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatSVGA(virDomainVideoDefPtr def, virBufferPtr buffer)\n{\n    unsigned long long vram;\n\n    if (def->type != VIR_DOMAIN_VIDEO_TYPE_VMVGA) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported video device type '%s'\"),\n                       virDomainVideoTypeToString(def->type));\n        return -1;\n    }\n\n    /*\n     * For Windows guests the VRAM size should be a multiple of 64 kilobyte.\n     * See http://kb.vmware.com/kb/1003 and http://kb.vmware.com/kb/1001558\n     */\n    vram = VIR_DIV_UP(def->vram, 64) * 64;\n\n    if (def->heads > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Multi-head video devices are unsupported\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"svga.vramSize = \\\"%lld\\\"\\n\",\n                      vram * 1024); /* kilobyte to byte */\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXFormatParallel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "3961-4009",
    "snippet": "int\nvirVMXFormatParallel(virVMXContext *ctx, virDomainChrDefPtr def,\n                     virBufferPtr buffer)\n{\n    char *fileName = NULL;\n\n    if (def->target.port < 0 || def->target.port > 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Parallel port index %d out of [0..2] range\"),\n                       def->target.port);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"parallel%d.present = \\\"true\\\"\\n\",\n                      def->target.port);\n\n    /* def:type -> vmx:fileType and def:data.file.path -> vmx:fileName */\n    switch (def->source->type) {\n      case VIR_DOMAIN_CHR_TYPE_DEV:\n        virBufferAsprintf(buffer, \"parallel%d.fileType = \\\"device\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"parallel%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, def->source->data.file.path);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_FILE:\n        virBufferAsprintf(buffer, \"parallel%d.fileType = \\\"file\\\"\\n\",\n                          def->target.port);\n\n        fileName = ctx->formatFileName(def->source->data.file.path, ctx->opaque);\n\n        if (fileName == NULL)\n            return -1;\n\n        virBufferAsprintf(buffer, \"parallel%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, fileName);\n\n        VIR_FREE(fileName);\n        break;\n\n      default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported character device type '%s'\"),\n                       virDomainChrTypeToString(def->source->type));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported character device type '%s'\")",
            "virDomainChrTypeToString(def->source->type)"
          ],
          "line": 4002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrTypeToString",
          "args": [
            "def->source->type"
          ],
          "line": 4004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported character device type '%s'\""
          ],
          "line": 4003
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileName"
          ],
          "line": 3998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buffer",
            "\"parallel%d.fileName = \\\"%s\\\"\\n\"",
            "def->target.port",
            "fileName"
          ],
          "line": 3995
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctx->formatFileName",
          "args": [
            "def->source->data.file.path",
            "ctx->opaque"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Parallel port index %d out of [0..2] range\")",
            "def->target.port"
          ],
          "line": 3968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatParallel(virVMXContext *ctx, virDomainChrDefPtr def,\n                     virBufferPtr buffer)\n{\n    char *fileName = NULL;\n\n    if (def->target.port < 0 || def->target.port > 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Parallel port index %d out of [0..2] range\"),\n                       def->target.port);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"parallel%d.present = \\\"true\\\"\\n\",\n                      def->target.port);\n\n    /* def:type -> vmx:fileType and def:data.file.path -> vmx:fileName */\n    switch (def->source->type) {\n      case VIR_DOMAIN_CHR_TYPE_DEV:\n        virBufferAsprintf(buffer, \"parallel%d.fileType = \\\"device\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"parallel%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, def->source->data.file.path);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_FILE:\n        virBufferAsprintf(buffer, \"parallel%d.fileType = \\\"file\\\"\\n\",\n                          def->target.port);\n\n        fileName = ctx->formatFileName(def->source->data.file.path, ctx->opaque);\n\n        if (fileName == NULL)\n            return -1;\n\n        virBufferAsprintf(buffer, \"parallel%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, fileName);\n\n        VIR_FREE(fileName);\n        break;\n\n      default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported character device type '%s'\"),\n                       virDomainChrTypeToString(def->source->type));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXFormatSerial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "3855-3957",
    "snippet": "int\nvirVMXFormatSerial(virVMXContext *ctx, virDomainChrDefPtr def,\n                   virBufferPtr buffer)\n{\n    char *fileName = NULL;\n    const char *protocol;\n\n    if (def->target.port < 0 || def->target.port > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Serial port index %d out of [0..3] range\"),\n                       def->target.port);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"serial%d.present = \\\"true\\\"\\n\", def->target.port);\n\n    /* def:type -> vmx:fileType and def:data.file.path -> vmx:fileName */\n    switch (def->source->type) {\n      case VIR_DOMAIN_CHR_TYPE_DEV:\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"device\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, def->source->data.file.path);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_FILE:\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"file\\\"\\n\",\n                          def->target.port);\n\n        fileName = ctx->formatFileName(def->source->data.file.path, ctx->opaque);\n\n        if (fileName == NULL)\n            return -1;\n\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, fileName);\n\n        VIR_FREE(fileName);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_PIPE:\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"pipe\\\"\\n\",\n                          def->target.port);\n        /* FIXME: Based on VI Client GUI default */\n        virBufferAsprintf(buffer, \"serial%d.pipe.endPoint = \\\"client\\\"\\n\",\n                          def->target.port);\n        /* FIXME: Based on VI Client GUI default */\n        virBufferAsprintf(buffer, \"serial%d.tryNoRxLoss = \\\"false\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, def->source->data.file.path);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_TCP:\n        switch (def->source->data.tcp.protocol) {\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW:\n            protocol = \"tcp\";\n            break;\n\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET:\n            protocol = \"telnet\";\n            break;\n\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNETS:\n            protocol = \"telnets\";\n            break;\n\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_TLS:\n            protocol = \"ssl\";\n            break;\n\n          default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported character device TCP protocol '%s'\"),\n                           virDomainChrTcpProtocolTypeToString(\n                               def->source->data.tcp.protocol));\n            return -1;\n        }\n\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"network\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s://%s:%s\\\"\\n\",\n                          def->target.port, protocol, def->source->data.tcp.host,\n                          def->source->data.tcp.service);\n        virBufferAsprintf(buffer, \"serial%d.network.endPoint = \\\"%s\\\"\\n\",\n                          def->target.port,\n                          def->source->data.tcp.listen ? \"server\" : \"client\");\n        break;\n\n      default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported character device type '%s'\"),\n                       virDomainChrTypeToString(def->source->type));\n        return -1;\n    }\n\n    /* vmx:yieldOnMsrRead */\n    /* FIXME: Based on VI Client GUI default */\n    virBufferAsprintf(buffer, \"serial%d.yieldOnMsrRead = \\\"true\\\"\\n\",\n                      def->target.port);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buffer",
            "\"serial%d.yieldOnMsrRead = \\\"true\\\"\\n\"",
            "def->target.port"
          ],
          "line": 3953
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported character device type '%s'\")",
            "virDomainChrTypeToString(def->source->type)"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrTypeToString",
          "args": [
            "def->source->type"
          ],
          "line": 3947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported character device type '%s'\""
          ],
          "line": 3946
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported character device TCP protocol '%s'\")",
            "virDomainChrTcpProtocolTypeToString(\n                               def->source->data.tcp.protocol)"
          ],
          "line": 3927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrTcpProtocolTypeToString",
          "args": [
            "def->source->data.tcp.protocol"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileName"
          ],
          "line": 3892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctx->formatFileName",
          "args": [
            "def->source->data.file.path",
            "ctx->opaque"
          ],
          "line": 3884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Serial port index %d out of [0..3] range\")",
            "def->target.port"
          ],
          "line": 3863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatSerial(virVMXContext *ctx, virDomainChrDefPtr def,\n                   virBufferPtr buffer)\n{\n    char *fileName = NULL;\n    const char *protocol;\n\n    if (def->target.port < 0 || def->target.port > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Serial port index %d out of [0..3] range\"),\n                       def->target.port);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"serial%d.present = \\\"true\\\"\\n\", def->target.port);\n\n    /* def:type -> vmx:fileType and def:data.file.path -> vmx:fileName */\n    switch (def->source->type) {\n      case VIR_DOMAIN_CHR_TYPE_DEV:\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"device\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, def->source->data.file.path);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_FILE:\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"file\\\"\\n\",\n                          def->target.port);\n\n        fileName = ctx->formatFileName(def->source->data.file.path, ctx->opaque);\n\n        if (fileName == NULL)\n            return -1;\n\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, fileName);\n\n        VIR_FREE(fileName);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_PIPE:\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"pipe\\\"\\n\",\n                          def->target.port);\n        /* FIXME: Based on VI Client GUI default */\n        virBufferAsprintf(buffer, \"serial%d.pipe.endPoint = \\\"client\\\"\\n\",\n                          def->target.port);\n        /* FIXME: Based on VI Client GUI default */\n        virBufferAsprintf(buffer, \"serial%d.tryNoRxLoss = \\\"false\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, def->source->data.file.path);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_TCP:\n        switch (def->source->data.tcp.protocol) {\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW:\n            protocol = \"tcp\";\n            break;\n\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET:\n            protocol = \"telnet\";\n            break;\n\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNETS:\n            protocol = \"telnets\";\n            break;\n\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_TLS:\n            protocol = \"ssl\";\n            break;\n\n          default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported character device TCP protocol '%s'\"),\n                           virDomainChrTcpProtocolTypeToString(\n                               def->source->data.tcp.protocol));\n            return -1;\n        }\n\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"network\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s://%s:%s\\\"\\n\",\n                          def->target.port, protocol, def->source->data.tcp.host,\n                          def->source->data.tcp.service);\n        virBufferAsprintf(buffer, \"serial%d.network.endPoint = \\\"%s\\\"\\n\",\n                          def->target.port,\n                          def->source->data.tcp.listen ? \"server\" : \"client\");\n        break;\n\n      default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported character device type '%s'\"),\n                       virDomainChrTypeToString(def->source->type));\n        return -1;\n    }\n\n    /* vmx:yieldOnMsrRead */\n    /* FIXME: Based on VI Client GUI default */\n    virBufferAsprintf(buffer, \"serial%d.yieldOnMsrRead = \\\"true\\\"\\n\",\n                      def->target.port);\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXFormatEthernet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "3730-3851",
    "snippet": "int\nvirVMXFormatEthernet(virDomainNetDefPtr def, int controller,\n                     virBufferPtr buffer)\n{\n    char mac_string[VIR_MAC_STRING_BUFLEN];\n    unsigned int prefix, suffix;\n\n    if (controller < 0 || controller > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Ethernet controller index %d out of [0..3] range\"),\n                       controller);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"ethernet%d.present = \\\"true\\\"\\n\", controller);\n\n    /* def:model -> vmx:virtualDev, vmx:features */\n    if (def->model) {\n        if (def->model != VIR_DOMAIN_NET_MODEL_VLANCE &&\n            def->model != VIR_DOMAIN_NET_MODEL_VMXNET &&\n            def->model != VIR_DOMAIN_NET_MODEL_VMXNET2 &&\n            def->model != VIR_DOMAIN_NET_MODEL_VMXNET3 &&\n            def->model != VIR_DOMAIN_NET_MODEL_E1000 &&\n            def->model != VIR_DOMAIN_NET_MODEL_E1000E) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML entry 'devices/interface/model' \"\n                             \"to be 'vlance' or 'vmxnet' or 'vmxnet2' or 'vmxnet3' \"\n                             \"or 'e1000' or 'e1000e' but found '%s'\"),\n                            virDomainNetModelTypeToString(def->model));\n            return -1;\n        }\n\n        if (def->model == VIR_DOMAIN_NET_MODEL_VMXNET2) {\n            virBufferAsprintf(buffer, \"ethernet%d.virtualDev = \\\"vmxnet\\\"\\n\",\n                              controller);\n            virBufferAsprintf(buffer, \"ethernet%d.features = \\\"15\\\"\\n\",\n                              controller);\n        } else {\n            virBufferAsprintf(buffer, \"ethernet%d.virtualDev = \\\"%s\\\"\\n\",\n                              controller,\n                              virDomainNetModelTypeToString(def->model));\n        }\n    }\n\n    /* def:type, def:ifname -> vmx:connectionType */\n    switch (def->type) {\n      case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        if (STRNEQ(def->data.bridge.brname, \"\"))\n            virBufferAsprintf(buffer, \"ethernet%d.networkName = \\\"%s\\\"\\n\",\n                              controller, def->data.bridge.brname);\n\n        if (def->ifname != NULL) {\n            virBufferAsprintf(buffer, \"ethernet%d.connectionType = \\\"custom\\\"\\n\",\n                              controller);\n            virBufferAsprintf(buffer, \"ethernet%d.vnet = \\\"%s\\\"\\n\",\n                              controller, def->ifname);\n        } else {\n            virBufferAsprintf(buffer, \"ethernet%d.connectionType = \\\"bridged\\\"\\n\",\n                              controller);\n        }\n\n        break;\n\n      case VIR_DOMAIN_NET_TYPE_USER:\n        virBufferAsprintf(buffer, \"ethernet%d.connectionType = \\\"nat\\\"\\n\",\n                          controller);\n        break;\n\n      case VIR_DOMAIN_NET_TYPE_ETHERNET:\n      case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n      case VIR_DOMAIN_NET_TYPE_SERVER:\n      case VIR_DOMAIN_NET_TYPE_CLIENT:\n      case VIR_DOMAIN_NET_TYPE_MCAST:\n      case VIR_DOMAIN_NET_TYPE_NETWORK:\n      case VIR_DOMAIN_NET_TYPE_INTERNAL:\n      case VIR_DOMAIN_NET_TYPE_DIRECT:\n      case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n      case VIR_DOMAIN_NET_TYPE_UDP:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, _(\"Unsupported net type '%s'\"),\n                       virDomainNetTypeToString(def->type));\n        return -1;\n\n      case VIR_DOMAIN_NET_TYPE_LAST:\n      default:\n          virReportEnumRangeError(virDomainNetType, def->type);\n          return -1;\n    }\n\n    /* def:mac -> vmx:addressType, vmx:(generated)Address, vmx:checkMACAddress */\n    virMacAddrFormat(&def->mac, mac_string);\n\n    prefix = (def->mac.addr[0] << 16) | (def->mac.addr[1] << 8) | def->mac.addr[2];\n    suffix = (def->mac.addr[3] << 16) | (def->mac.addr[4] << 8) | def->mac.addr[5];\n\n    if (prefix == 0x000c29) {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"generated\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.generatedAddress = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n        virBufferAsprintf(buffer, \"ethernet%d.generatedAddressOffset = \\\"0\\\"\\n\",\n                          controller);\n    } else if (prefix == 0x005056 && suffix <= 0x3fffff) {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"static\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.address = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n    } else if (prefix == 0x005056 && suffix >= 0x800000 && suffix <= 0xbfffff) {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"vpx\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.generatedAddress = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n    } else {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"static\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.address = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n        virBufferAsprintf(buffer, \"ethernet%d.checkMACAddress = \\\"false\\\"\\n\",\n                          controller);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buffer",
            "\"ethernet%d.checkMACAddress = \\\"false\\\"\\n\"",
            "controller"
          ],
          "line": 3846
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "&def->mac",
            "mac_string"
          ],
          "line": 3819
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virDomainNetType",
            "def->type"
          ],
          "line": 3814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported net type '%s'\")",
            "virDomainNetTypeToString(def->type)"
          ],
          "line": 3808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetTypeToString",
          "args": [
            "def->type"
          ],
          "line": 3809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported net type '%s'\""
          ],
          "line": 3808
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "def->data.bridge.brname",
            "\"\""
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetModelTypeToString",
          "args": [
            "def->model"
          ],
          "line": 3770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting domain XML entry 'devices/interface/model' \"\n                             \"to be 'vlance' or 'vmxnet' or 'vmxnet2' or 'vmxnet3' \"\n                             \"or 'e1000' or 'e1000e' but found '%s'\")",
            "virDomainNetModelTypeToString(def->model)"
          ],
          "line": 3754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetModelTypeToString",
          "args": [
            "def->model"
          ],
          "line": 3758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Ethernet controller index %d out of [0..3] range\")",
            "controller"
          ],
          "line": 3738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatEthernet(virDomainNetDefPtr def, int controller,\n                     virBufferPtr buffer)\n{\n    char mac_string[VIR_MAC_STRING_BUFLEN];\n    unsigned int prefix, suffix;\n\n    if (controller < 0 || controller > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Ethernet controller index %d out of [0..3] range\"),\n                       controller);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"ethernet%d.present = \\\"true\\\"\\n\", controller);\n\n    /* def:model -> vmx:virtualDev, vmx:features */\n    if (def->model) {\n        if (def->model != VIR_DOMAIN_NET_MODEL_VLANCE &&\n            def->model != VIR_DOMAIN_NET_MODEL_VMXNET &&\n            def->model != VIR_DOMAIN_NET_MODEL_VMXNET2 &&\n            def->model != VIR_DOMAIN_NET_MODEL_VMXNET3 &&\n            def->model != VIR_DOMAIN_NET_MODEL_E1000 &&\n            def->model != VIR_DOMAIN_NET_MODEL_E1000E) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML entry 'devices/interface/model' \"\n                             \"to be 'vlance' or 'vmxnet' or 'vmxnet2' or 'vmxnet3' \"\n                             \"or 'e1000' or 'e1000e' but found '%s'\"),\n                            virDomainNetModelTypeToString(def->model));\n            return -1;\n        }\n\n        if (def->model == VIR_DOMAIN_NET_MODEL_VMXNET2) {\n            virBufferAsprintf(buffer, \"ethernet%d.virtualDev = \\\"vmxnet\\\"\\n\",\n                              controller);\n            virBufferAsprintf(buffer, \"ethernet%d.features = \\\"15\\\"\\n\",\n                              controller);\n        } else {\n            virBufferAsprintf(buffer, \"ethernet%d.virtualDev = \\\"%s\\\"\\n\",\n                              controller,\n                              virDomainNetModelTypeToString(def->model));\n        }\n    }\n\n    /* def:type, def:ifname -> vmx:connectionType */\n    switch (def->type) {\n      case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        if (STRNEQ(def->data.bridge.brname, \"\"))\n            virBufferAsprintf(buffer, \"ethernet%d.networkName = \\\"%s\\\"\\n\",\n                              controller, def->data.bridge.brname);\n\n        if (def->ifname != NULL) {\n            virBufferAsprintf(buffer, \"ethernet%d.connectionType = \\\"custom\\\"\\n\",\n                              controller);\n            virBufferAsprintf(buffer, \"ethernet%d.vnet = \\\"%s\\\"\\n\",\n                              controller, def->ifname);\n        } else {\n            virBufferAsprintf(buffer, \"ethernet%d.connectionType = \\\"bridged\\\"\\n\",\n                              controller);\n        }\n\n        break;\n\n      case VIR_DOMAIN_NET_TYPE_USER:\n        virBufferAsprintf(buffer, \"ethernet%d.connectionType = \\\"nat\\\"\\n\",\n                          controller);\n        break;\n\n      case VIR_DOMAIN_NET_TYPE_ETHERNET:\n      case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n      case VIR_DOMAIN_NET_TYPE_SERVER:\n      case VIR_DOMAIN_NET_TYPE_CLIENT:\n      case VIR_DOMAIN_NET_TYPE_MCAST:\n      case VIR_DOMAIN_NET_TYPE_NETWORK:\n      case VIR_DOMAIN_NET_TYPE_INTERNAL:\n      case VIR_DOMAIN_NET_TYPE_DIRECT:\n      case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n      case VIR_DOMAIN_NET_TYPE_UDP:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, _(\"Unsupported net type '%s'\"),\n                       virDomainNetTypeToString(def->type));\n        return -1;\n\n      case VIR_DOMAIN_NET_TYPE_LAST:\n      default:\n          virReportEnumRangeError(virDomainNetType, def->type);\n          return -1;\n    }\n\n    /* def:mac -> vmx:addressType, vmx:(generated)Address, vmx:checkMACAddress */\n    virMacAddrFormat(&def->mac, mac_string);\n\n    prefix = (def->mac.addr[0] << 16) | (def->mac.addr[1] << 8) | def->mac.addr[2];\n    suffix = (def->mac.addr[3] << 16) | (def->mac.addr[4] << 8) | def->mac.addr[5];\n\n    if (prefix == 0x000c29) {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"generated\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.generatedAddress = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n        virBufferAsprintf(buffer, \"ethernet%d.generatedAddressOffset = \\\"0\\\"\\n\",\n                          controller);\n    } else if (prefix == 0x005056 && suffix <= 0x3fffff) {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"static\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.address = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n    } else if (prefix == 0x005056 && suffix >= 0x800000 && suffix <= 0xbfffff) {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"vpx\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.generatedAddress = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n    } else {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"static\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.address = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n        virBufferAsprintf(buffer, \"ethernet%d.checkMACAddress = \\\"false\\\"\\n\",\n                          controller);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXFormatFileSystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "3705-3726",
    "snippet": "int\nvirVMXFormatFileSystem(virDomainFSDefPtr def, int number, virBufferPtr buffer)\n{\n    if (def->type != VIR_DOMAIN_FS_TYPE_MOUNT) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Only '%s' filesystem type is supported\"),\n                       virDomainFSTypeToString(VIR_DOMAIN_FS_TYPE_MOUNT));\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"sharedFolder%d.present = \\\"true\\\"\\n\", number);\n    virBufferAsprintf(buffer, \"sharedFolder%d.enabled = \\\"true\\\"\\n\", number);\n    virBufferAsprintf(buffer, \"sharedFolder%d.readAccess = \\\"true\\\"\\n\", number);\n    virBufferAsprintf(buffer, \"sharedFolder%d.writeAccess = \\\"%s\\\"\\n\", number,\n                      def->readonly ? \"false\" : \"true\");\n    virBufferAsprintf(buffer, \"sharedFolder%d.hostPath = \\\"%s\\\"\\n\", number,\n                      def->src->path);\n    virBufferAsprintf(buffer, \"sharedFolder%d.guestName = \\\"%s\\\"\\n\", number,\n                      def->dst);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buffer",
            "\"sharedFolder%d.guestName = \\\"%s\\\"\\n\"",
            "number",
            "def->dst"
          ],
          "line": 3722
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Only '%s' filesystem type is supported\")",
            "virDomainFSTypeToString(VIR_DOMAIN_FS_TYPE_MOUNT)"
          ],
          "line": 3709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainFSTypeToString",
          "args": [
            "VIR_DOMAIN_FS_TYPE_MOUNT"
          ],
          "line": 3711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Only '%s' filesystem type is supported\""
          ],
          "line": 3710
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatFileSystem(virDomainFSDefPtr def, int number, virBufferPtr buffer)\n{\n    if (def->type != VIR_DOMAIN_FS_TYPE_MOUNT) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Only '%s' filesystem type is supported\"),\n                       virDomainFSTypeToString(VIR_DOMAIN_FS_TYPE_MOUNT));\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"sharedFolder%d.present = \\\"true\\\"\\n\", number);\n    virBufferAsprintf(buffer, \"sharedFolder%d.enabled = \\\"true\\\"\\n\", number);\n    virBufferAsprintf(buffer, \"sharedFolder%d.readAccess = \\\"true\\\"\\n\", number);\n    virBufferAsprintf(buffer, \"sharedFolder%d.writeAccess = \\\"%s\\\"\\n\", number,\n                      def->readonly ? \"false\" : \"true\");\n    virBufferAsprintf(buffer, \"sharedFolder%d.hostPath = \\\"%s\\\"\\n\", number,\n                      def->src->path);\n    virBufferAsprintf(buffer, \"sharedFolder%d.guestName = \\\"%s\\\"\\n\", number,\n                      def->dst);\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXFormatFloppy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "3648-3701",
    "snippet": "int\nvirVMXFormatFloppy(virVMXContext *ctx, virDomainDiskDefPtr def,\n                   virBufferPtr buffer, bool floppy_present[2])\n{\n    int unit;\n    char *fileName = NULL;\n    int type = virDomainDiskGetType(def);\n    const char *src = virDomainDiskGetSource(def);\n\n    if (def->device != VIR_DOMAIN_DISK_DEVICE_FLOPPY) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virVMXFloppyDiskNameToUnit(def->dst, &unit) < 0)\n        return -1;\n\n    floppy_present[unit] = true;\n\n    virBufferAsprintf(buffer, \"floppy%d.present = \\\"true\\\"\\n\", unit);\n\n    if (type == VIR_STORAGE_TYPE_FILE) {\n        virBufferAsprintf(buffer, \"floppy%d.fileType = \\\"file\\\"\\n\", unit);\n\n        if (src) {\n            fileName = ctx->formatFileName(src, ctx->opaque);\n\n            if (fileName == NULL)\n                return -1;\n\n            virBufferAsprintf(buffer, \"floppy%d.fileName = \\\"%s\\\"\\n\",\n                              unit, fileName);\n\n            VIR_FREE(fileName);\n        }\n    } else if (type == VIR_STORAGE_TYPE_BLOCK) {\n        virBufferAsprintf(buffer, \"floppy%d.fileType = \\\"device\\\"\\n\", unit);\n\n        if (src) {\n            virBufferAsprintf(buffer, \"floppy%d.fileName = \\\"%s\\\"\\n\",\n                              unit, src);\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Floppy '%s' has unsupported type '%s', expecting '%s' \"\n                         \"or '%s'\"), def->dst,\n                       virStorageTypeToString(type),\n                       virStorageTypeToString(VIR_STORAGE_TYPE_FILE),\n                       virStorageTypeToString(VIR_STORAGE_TYPE_BLOCK));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Floppy '%s' has unsupported type '%s', expecting '%s' \"\n                         \"or '%s'\")",
            "def->dst",
            "virStorageTypeToString(type)",
            "virStorageTypeToString(VIR_STORAGE_TYPE_FILE)",
            "virStorageTypeToString(VIR_STORAGE_TYPE_BLOCK)"
          ],
          "line": 3691
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageTypeToString",
          "args": [
            "VIR_STORAGE_TYPE_BLOCK"
          ],
          "line": 3696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageTypeToString",
          "args": [
            "VIR_STORAGE_TYPE_FILE"
          ],
          "line": 3695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageTypeToString",
          "args": [
            "type"
          ],
          "line": 3694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Floppy '%s' has unsupported type '%s', expecting '%s' \"\n                         \"or '%s'\""
          ],
          "line": 3692
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buffer",
            "\"floppy%d.fileName = \\\"%s\\\"\\n\"",
            "unit",
            "src"
          ],
          "line": 3687
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileName"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctx->formatFileName",
          "args": [
            "src",
            "ctx->opaque"
          ],
          "line": 3673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXFloppyDiskNameToUnit",
          "args": [
            "def->dst",
            "&unit"
          ],
          "line": 3662
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXFloppyDiskNameToUnit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "932-962",
          "snippet": "static int\nvirVMXFloppyDiskNameToUnit(const char *name, int *unit)\n{\n    int idx;\n\n    if (! STRPREFIX(name, \"fd\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'fd'\"));\n        return -1;\n    }\n\n    idx = virDiskNameToIndex(name);\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse valid disk index from '%s'\"), name);\n        return -1;\n    }\n\n    /* The FDC controller has 1 bus with 2 units for devices */\n    if (idx >= 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Floppy disk index (parsed from '%s') is too large\"), name);\n        return -1;\n    }\n\n    *unit = idx;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXFloppyDiskNameToUnit(const char *name, int *unit)\n{\n    int idx;\n\n    if (! STRPREFIX(name, \"fd\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'fd'\"));\n        return -1;\n    }\n\n    idx = virDiskNameToIndex(name);\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse valid disk index from '%s'\"), name);\n        return -1;\n    }\n\n    /* The FDC controller has 1 bus with 2 units for devices */\n    if (idx >= 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Floppy disk index (parsed from '%s') is too large\"), name);\n        return -1;\n    }\n\n    *unit = idx;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "def"
          ],
          "line": 3655
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetType",
          "args": [
            "def"
          ],
          "line": 3654
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2141-2145",
          "snippet": "int\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatFloppy(virVMXContext *ctx, virDomainDiskDefPtr def,\n                   virBufferPtr buffer, bool floppy_present[2])\n{\n    int unit;\n    char *fileName = NULL;\n    int type = virDomainDiskGetType(def);\n    const char *src = virDomainDiskGetSource(def);\n\n    if (def->device != VIR_DOMAIN_DISK_DEVICE_FLOPPY) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virVMXFloppyDiskNameToUnit(def->dst, &unit) < 0)\n        return -1;\n\n    floppy_present[unit] = true;\n\n    virBufferAsprintf(buffer, \"floppy%d.present = \\\"true\\\"\\n\", unit);\n\n    if (type == VIR_STORAGE_TYPE_FILE) {\n        virBufferAsprintf(buffer, \"floppy%d.fileType = \\\"file\\\"\\n\", unit);\n\n        if (src) {\n            fileName = ctx->formatFileName(src, ctx->opaque);\n\n            if (fileName == NULL)\n                return -1;\n\n            virBufferAsprintf(buffer, \"floppy%d.fileName = \\\"%s\\\"\\n\",\n                              unit, fileName);\n\n            VIR_FREE(fileName);\n        }\n    } else if (type == VIR_STORAGE_TYPE_BLOCK) {\n        virBufferAsprintf(buffer, \"floppy%d.fileType = \\\"device\\\"\\n\", unit);\n\n        if (src) {\n            virBufferAsprintf(buffer, \"floppy%d.fileName = \\\"%s\\\"\\n\",\n                              unit, src);\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Floppy '%s' has unsupported type '%s', expecting '%s' \"\n                         \"or '%s'\"), def->dst,\n                       virStorageTypeToString(type),\n                       virStorageTypeToString(VIR_STORAGE_TYPE_FILE),\n                       virStorageTypeToString(VIR_STORAGE_TYPE_BLOCK));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXFormatDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "3501-3646",
    "snippet": "int\nvirVMXFormatDisk(virVMXContext *ctx, virDomainDiskDefPtr def,\n                 virBufferPtr buffer)\n{\n    int controllerOrBus, unit;\n    const char *vmxDeviceType = NULL;\n    char *fileName = NULL;\n    int type = virDomainDiskGetType(def);\n\n    /* Convert a handful of types to their string values */\n    const char *busType = virDomainDiskBusTypeToString(def->bus);\n    const char *deviceType = virDomainDeviceTypeToString(def->device);\n    const char *diskType = virDomainDeviceTypeToString(type);\n\n    /* If we are dealing with a disk its a .vmdk, otherwise it must be\n     * an ISO.\n     */\n    const char *fileExt = (def->device == VIR_DOMAIN_DISK_DEVICE_DISK) ?\n                           \".vmdk\" : \".iso\";\n\n    /* Check that we got a valid device type */\n    if (def->device != VIR_DOMAIN_DISK_DEVICE_DISK &&\n        def->device != VIR_DOMAIN_DISK_DEVICE_CDROM &&\n        def->device != VIR_DOMAIN_DISK_DEVICE_LUN) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device type supplied: %s\"), deviceType);\n        return -1;\n    }\n\n    /* We only support type='file' and type='block' */\n    if (type != VIR_STORAGE_TYPE_FILE &&\n        type != VIR_STORAGE_TYPE_BLOCK) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"%s %s '%s' has unsupported type '%s', expecting \"\n                         \"'%s' or '%s'\"), busType, deviceType, def->dst,\n                       diskType,\n                       virStorageTypeToString(VIR_STORAGE_TYPE_FILE),\n                       virStorageTypeToString(VIR_STORAGE_TYPE_BLOCK));\n        return -1;\n    }\n\n    if (def->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (virVMXSCSIDiskNameToControllerAndUnit(def->dst, &controllerOrBus,\n                                                  &unit) < 0) {\n            return -1;\n        }\n    } else if (def->bus == VIR_DOMAIN_DISK_BUS_IDE) {\n        if (virVMXIDEDiskNameToBusAndUnit(def->dst, &controllerOrBus,\n                                          &unit) < 0) {\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported bus type '%s' for %s\"),\n                       busType, deviceType);\n        return -1;\n    }\n\n    if (def->device == VIR_DOMAIN_DISK_DEVICE_DISK &&\n        type == VIR_STORAGE_TYPE_FILE) {\n        vmxDeviceType = (def->bus == VIR_DOMAIN_DISK_BUS_SCSI) ?\n                        \"scsi-hardDisk\" : \"ata-hardDisk\";\n    } else if (def->device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n        if (type == VIR_STORAGE_TYPE_FILE)\n            vmxDeviceType = \"cdrom-image\";\n        else\n            vmxDeviceType = \"atapi-cdrom\";\n    } else if (def->device == VIR_DOMAIN_DISK_DEVICE_LUN) {\n        const char *src = virDomainDiskGetSource(def);\n\n        if (def->bus == VIR_DOMAIN_DISK_BUS_SCSI &&\n            src && STRPREFIX(src, \"/vmfs/devices/cdrom/\"))\n            vmxDeviceType = \"scsi-passthru\";\n        else\n            vmxDeviceType = \"cdrom-raw\";\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"%s %s '%s' has an unsupported type '%s'\"),\n                       busType, deviceType, def->dst, diskType);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"%s%d:%d.present = \\\"true\\\"\\n\",\n                      busType, controllerOrBus, unit);\n    virBufferAsprintf(buffer, \"%s%d:%d.deviceType = \\\"%s\\\"\\n\",\n                      busType, controllerOrBus, unit, vmxDeviceType);\n\n    if (type == VIR_STORAGE_TYPE_FILE) {\n        const char *src = virDomainDiskGetSource(def);\n\n        if (src) {\n            if (!virStringHasCaseSuffix(src, fileExt)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Image file for %s %s '%s' has \"\n                                 \"unsupported suffix, expecting '%s'\"),\n                               busType, deviceType, def->dst, fileExt);\n                return -1;\n            }\n\n            fileName = ctx->formatFileName(src, ctx->opaque);\n        } else if (def->device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n            fileName = g_strdup(\"emptyBackingString\");\n        }\n\n        if (fileName == NULL)\n            return -1;\n\n        virBufferAsprintf(buffer, \"%s%d:%d.fileName = \\\"%s\\\"\\n\",\n                          busType, controllerOrBus, unit, fileName);\n\n        VIR_FREE(fileName);\n    } else if (type == VIR_STORAGE_TYPE_BLOCK) {\n        const char *src = virDomainDiskGetSource(def);\n\n        if (!src &&\n            def->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_OPTIONAL) {\n            virBufferAsprintf(buffer, \"%s%d:%d.autodetect = \\\"true\\\"\\n\",\n                              busType, controllerOrBus, unit);\n            virBufferAsprintf(buffer, \"%s%d:%d.fileName = \\\"auto detect\\\"\\n\",\n                              busType, controllerOrBus, unit);\n        } else {\n            virBufferAsprintf(buffer, \"%s%d:%d.fileName = \\\"%s\\\"\\n\",\n                              busType, controllerOrBus, unit, src);\n        }\n    }\n\n    if (def->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (def->cachemode == VIR_DOMAIN_DISK_CACHE_WRITETHRU) {\n            virBufferAsprintf(buffer, \"%s%d:%d.writeThrough = \\\"true\\\"\\n\",\n                              busType, controllerOrBus, unit);\n        } else if (def->cachemode != VIR_DOMAIN_DISK_CACHE_DEFAULT) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"%s harddisk '%s' has unsupported cache mode '%s'\"),\n                           busType, def->dst,\n                           virDomainDiskCacheTypeToString(def->cachemode));\n            return -1;\n        }\n    }\n\n    if (def->transient)\n        virBufferAsprintf(buffer,\n                          \"%s%d:%d.mode = \\\"independent-nonpersistent\\\"\\n\",\n                          busType, controllerOrBus, unit);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buffer",
            "\"%s%d:%d.mode = \\\"independent-nonpersistent\\\"\\n\"",
            "busType",
            "controllerOrBus",
            "unit"
          ],
          "line": 3641
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"%s harddisk '%s' has unsupported cache mode '%s'\")",
            "busType",
            "def->dst",
            "virDomainDiskCacheTypeToString(def->cachemode)"
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskCacheTypeToString",
          "args": [
            "def->cachemode"
          ],
          "line": 3635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s harddisk '%s' has unsupported cache mode '%s'\""
          ],
          "line": 3633
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "def"
          ],
          "line": 3613
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileName"
          ],
          "line": 3611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctx->formatFileName",
          "args": [
            "src",
            "ctx->opaque"
          ],
          "line": 3600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Image file for %s %s '%s' has \"\n                                 \"unsupported suffix, expecting '%s'\")",
            "busType",
            "deviceType",
            "def->dst",
            "fileExt"
          ],
          "line": 3593
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringHasCaseSuffix",
          "args": [
            "src",
            "fileExt"
          ],
          "line": 3592
        },
        "resolved": true,
        "details": {
          "function_name": "virStringHasCaseSuffix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1110-1121",
          "snippet": "bool\nvirStringHasCaseSuffix(const char *str,\n                       const char *suffix)\n{\n    int len = strlen(str);\n    int suffixlen = strlen(suffix);\n\n    if (len < suffixlen)\n        return false;\n\n    return STRCASEEQ(str + len - suffixlen, suffix);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nbool\nvirStringHasCaseSuffix(const char *str,\n                       const char *suffix)\n{\n    int len = strlen(str);\n    int suffixlen = strlen(suffix);\n\n    if (len < suffixlen)\n        return false;\n\n    return STRCASEEQ(str + len - suffixlen, suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "src",
            "\"/vmfs/devices/cdrom/\""
          ],
          "line": 3572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported bus type '%s' for %s\")",
            "busType",
            "deviceType"
          ],
          "line": 3553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXIDEDiskNameToBusAndUnit",
          "args": [
            "def->dst",
            "&controllerOrBus",
            "&unit"
          ],
          "line": 3548
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXIDEDiskNameToBusAndUnit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "897-928",
          "snippet": "static int\nvirVMXIDEDiskNameToBusAndUnit(const char *name, int *bus, int *unit)\n{\n    int idx;\n\n    if (! STRPREFIX(name, \"hd\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'hd'\"));\n        return -1;\n    }\n\n    idx = virDiskNameToIndex(name);\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse valid disk index from '%s'\"), name);\n        return -1;\n    }\n\n    /* The IDE controller has 2 buses with 2 units each for devices */\n    if (idx >= (2 * 2)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"IDE disk index (parsed from '%s') is too large\"), name);\n        return -1;\n    }\n\n    *bus = idx / 2;\n    *unit = idx % 2;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXIDEDiskNameToBusAndUnit(const char *name, int *bus, int *unit)\n{\n    int idx;\n\n    if (! STRPREFIX(name, \"hd\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'hd'\"));\n        return -1;\n    }\n\n    idx = virDiskNameToIndex(name);\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse valid disk index from '%s'\"), name);\n        return -1;\n    }\n\n    /* The IDE controller has 2 buses with 2 units each for devices */\n    if (idx >= (2 * 2)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"IDE disk index (parsed from '%s') is too large\"), name);\n        return -1;\n    }\n\n    *bus = idx / 2;\n    *unit = idx % 2;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXSCSIDiskNameToControllerAndUnit",
          "args": [
            "def->dst",
            "&controllerOrBus",
            "&unit"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXSCSIDiskNameToControllerAndUnit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "858-893",
          "snippet": "static int\nvirVMXSCSIDiskNameToControllerAndUnit(const char *name, int *controller, int *unit)\n{\n    int idx;\n\n    if (! STRPREFIX(name, \"sd\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'sd'\"));\n        return -1;\n    }\n\n    idx = virDiskNameToIndex(name);\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse valid disk index from '%s'\"), name);\n        return -1;\n    }\n\n    /* Each of the 4 SCSI controllers has 1 bus with 15 units each for devices */\n    if (idx >= (4 * 15)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SCSI disk index (parsed from '%s') is too large\"), name);\n        return -1;\n    }\n\n    *controller = idx / 15;\n    *unit = idx % 15;\n\n    /* Skip the controller ifself at unit 7 */\n    if (*unit >= 7)\n        ++(*unit);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXSCSIDiskNameToControllerAndUnit(const char *name, int *controller, int *unit)\n{\n    int idx;\n\n    if (! STRPREFIX(name, \"sd\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'sd'\"));\n        return -1;\n    }\n\n    idx = virDiskNameToIndex(name);\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse valid disk index from '%s'\"), name);\n        return -1;\n    }\n\n    /* Each of the 4 SCSI controllers has 1 bus with 15 units each for devices */\n    if (idx >= (4 * 15)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SCSI disk index (parsed from '%s') is too large\"), name);\n        return -1;\n    }\n\n    *controller = idx / 15;\n    *unit = idx % 15;\n\n    /* Skip the controller ifself at unit 7 */\n    if (*unit >= 7)\n        ++(*unit);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageTypeToString",
          "args": [
            "VIR_STORAGE_TYPE_BLOCK"
          ],
          "line": 3538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageTypeToString",
          "args": [
            "VIR_STORAGE_TYPE_FILE"
          ],
          "line": 3537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid device type supplied: %s\")",
            "deviceType"
          ],
          "line": 3525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDeviceTypeToString",
          "args": [
            "type"
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDeviceTypeToString",
          "args": [
            "def->device"
          ],
          "line": 3512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskBusTypeToString",
          "args": [
            "def->bus"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetType",
          "args": [
            "def"
          ],
          "line": 3508
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2141-2145",
          "snippet": "int\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatDisk(virVMXContext *ctx, virDomainDiskDefPtr def,\n                 virBufferPtr buffer)\n{\n    int controllerOrBus, unit;\n    const char *vmxDeviceType = NULL;\n    char *fileName = NULL;\n    int type = virDomainDiskGetType(def);\n\n    /* Convert a handful of types to their string values */\n    const char *busType = virDomainDiskBusTypeToString(def->bus);\n    const char *deviceType = virDomainDeviceTypeToString(def->device);\n    const char *diskType = virDomainDeviceTypeToString(type);\n\n    /* If we are dealing with a disk its a .vmdk, otherwise it must be\n     * an ISO.\n     */\n    const char *fileExt = (def->device == VIR_DOMAIN_DISK_DEVICE_DISK) ?\n                           \".vmdk\" : \".iso\";\n\n    /* Check that we got a valid device type */\n    if (def->device != VIR_DOMAIN_DISK_DEVICE_DISK &&\n        def->device != VIR_DOMAIN_DISK_DEVICE_CDROM &&\n        def->device != VIR_DOMAIN_DISK_DEVICE_LUN) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device type supplied: %s\"), deviceType);\n        return -1;\n    }\n\n    /* We only support type='file' and type='block' */\n    if (type != VIR_STORAGE_TYPE_FILE &&\n        type != VIR_STORAGE_TYPE_BLOCK) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"%s %s '%s' has unsupported type '%s', expecting \"\n                         \"'%s' or '%s'\"), busType, deviceType, def->dst,\n                       diskType,\n                       virStorageTypeToString(VIR_STORAGE_TYPE_FILE),\n                       virStorageTypeToString(VIR_STORAGE_TYPE_BLOCK));\n        return -1;\n    }\n\n    if (def->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (virVMXSCSIDiskNameToControllerAndUnit(def->dst, &controllerOrBus,\n                                                  &unit) < 0) {\n            return -1;\n        }\n    } else if (def->bus == VIR_DOMAIN_DISK_BUS_IDE) {\n        if (virVMXIDEDiskNameToBusAndUnit(def->dst, &controllerOrBus,\n                                          &unit) < 0) {\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported bus type '%s' for %s\"),\n                       busType, deviceType);\n        return -1;\n    }\n\n    if (def->device == VIR_DOMAIN_DISK_DEVICE_DISK &&\n        type == VIR_STORAGE_TYPE_FILE) {\n        vmxDeviceType = (def->bus == VIR_DOMAIN_DISK_BUS_SCSI) ?\n                        \"scsi-hardDisk\" : \"ata-hardDisk\";\n    } else if (def->device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n        if (type == VIR_STORAGE_TYPE_FILE)\n            vmxDeviceType = \"cdrom-image\";\n        else\n            vmxDeviceType = \"atapi-cdrom\";\n    } else if (def->device == VIR_DOMAIN_DISK_DEVICE_LUN) {\n        const char *src = virDomainDiskGetSource(def);\n\n        if (def->bus == VIR_DOMAIN_DISK_BUS_SCSI &&\n            src && STRPREFIX(src, \"/vmfs/devices/cdrom/\"))\n            vmxDeviceType = \"scsi-passthru\";\n        else\n            vmxDeviceType = \"cdrom-raw\";\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"%s %s '%s' has an unsupported type '%s'\"),\n                       busType, deviceType, def->dst, diskType);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"%s%d:%d.present = \\\"true\\\"\\n\",\n                      busType, controllerOrBus, unit);\n    virBufferAsprintf(buffer, \"%s%d:%d.deviceType = \\\"%s\\\"\\n\",\n                      busType, controllerOrBus, unit, vmxDeviceType);\n\n    if (type == VIR_STORAGE_TYPE_FILE) {\n        const char *src = virDomainDiskGetSource(def);\n\n        if (src) {\n            if (!virStringHasCaseSuffix(src, fileExt)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Image file for %s %s '%s' has \"\n                                 \"unsupported suffix, expecting '%s'\"),\n                               busType, deviceType, def->dst, fileExt);\n                return -1;\n            }\n\n            fileName = ctx->formatFileName(src, ctx->opaque);\n        } else if (def->device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n            fileName = g_strdup(\"emptyBackingString\");\n        }\n\n        if (fileName == NULL)\n            return -1;\n\n        virBufferAsprintf(buffer, \"%s%d:%d.fileName = \\\"%s\\\"\\n\",\n                          busType, controllerOrBus, unit, fileName);\n\n        VIR_FREE(fileName);\n    } else if (type == VIR_STORAGE_TYPE_BLOCK) {\n        const char *src = virDomainDiskGetSource(def);\n\n        if (!src &&\n            def->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_OPTIONAL) {\n            virBufferAsprintf(buffer, \"%s%d:%d.autodetect = \\\"true\\\"\\n\",\n                              busType, controllerOrBus, unit);\n            virBufferAsprintf(buffer, \"%s%d:%d.fileName = \\\"auto detect\\\"\\n\",\n                              busType, controllerOrBus, unit);\n        } else {\n            virBufferAsprintf(buffer, \"%s%d:%d.fileName = \\\"%s\\\"\\n\",\n                              busType, controllerOrBus, unit, src);\n        }\n    }\n\n    if (def->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (def->cachemode == VIR_DOMAIN_DISK_CACHE_WRITETHRU) {\n            virBufferAsprintf(buffer, \"%s%d:%d.writeThrough = \\\"true\\\"\\n\",\n                              busType, controllerOrBus, unit);\n        } else if (def->cachemode != VIR_DOMAIN_DISK_CACHE_DEFAULT) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"%s harddisk '%s' has unsupported cache mode '%s'\"),\n                           busType, def->dst,\n                           virDomainDiskCacheTypeToString(def->cachemode));\n            return -1;\n        }\n    }\n\n    if (def->transient)\n        virBufferAsprintf(buffer,\n                          \"%s%d:%d.mode = \\\"independent-nonpersistent\\\"\\n\",\n                          busType, controllerOrBus, unit);\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXFormatVNC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "3457-3499",
    "snippet": "int\nvirVMXFormatVNC(virDomainGraphicsDefPtr def, virBufferPtr buffer)\n{\n    virDomainGraphicsListenDefPtr glisten;\n\n    if (def->type != VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virBufferAddLit(buffer, \"RemoteDisplay.vnc.enabled = \\\"true\\\"\\n\");\n\n    if (def->data.vnc.autoport) {\n        VIR_WARN(\"VNC autoport is enabled, but the automatically assigned \"\n                  \"VNC port cannot be read back\");\n    } else {\n        if (def->data.vnc.port < 5900 || def->data.vnc.port > 5964) {\n            VIR_WARN(\"VNC port %d it out of [5900..5964] range\",\n                     def->data.vnc.port);\n        }\n\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.port = \\\"%d\\\"\\n\",\n                          def->data.vnc.port);\n    }\n\n    if ((glisten = virDomainGraphicsGetListen(def, 0)) &&\n        glisten->address) {\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.ip = \\\"%s\\\"\\n\",\n                          glisten->address);\n    }\n\n    if (def->data.vnc.keymap != NULL) {\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.keymap = \\\"%s\\\"\\n\",\n                          def->data.vnc.keymap);\n    }\n\n    if (def->data.vnc.auth.passwd != NULL) {\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.password = \\\"%s\\\"\\n\",\n                          def->data.vnc.auth.passwd);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buffer",
            "\"RemoteDisplay.vnc.password = \\\"%s\\\"\\n\"",
            "def->data.vnc.auth.passwd"
          ],
          "line": 3494
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsGetListen",
          "args": [
            "def",
            "0"
          ],
          "line": 3482
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsGetListen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30357-30364",
          "snippet": "virDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"VNC port %d it out of [5900..5964] range\"",
            "def->data.vnc.port"
          ],
          "line": 3474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"VNC autoport is enabled, but the automatically assigned \"\n                  \"VNC port cannot be read back\""
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buffer",
            "\"RemoteDisplay.vnc.enabled = \\\"true\\\"\\n\""
          ],
          "line": 3467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 3463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid argument\""
          ],
          "line": 3463
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatVNC(virDomainGraphicsDefPtr def, virBufferPtr buffer)\n{\n    virDomainGraphicsListenDefPtr glisten;\n\n    if (def->type != VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virBufferAddLit(buffer, \"RemoteDisplay.vnc.enabled = \\\"true\\\"\\n\");\n\n    if (def->data.vnc.autoport) {\n        VIR_WARN(\"VNC autoport is enabled, but the automatically assigned \"\n                  \"VNC port cannot be read back\");\n    } else {\n        if (def->data.vnc.port < 5900 || def->data.vnc.port > 5964) {\n            VIR_WARN(\"VNC port %d it out of [5900..5964] range\",\n                     def->data.vnc.port);\n        }\n\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.port = \\\"%d\\\"\\n\",\n                          def->data.vnc.port);\n    }\n\n    if ((glisten = virDomainGraphicsGetListen(def, 0)) &&\n        glisten->address) {\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.ip = \\\"%s\\\"\\n\",\n                          glisten->address);\n    }\n\n    if (def->data.vnc.keymap != NULL) {\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.keymap = \\\"%s\\\"\\n\",\n                          def->data.vnc.keymap);\n    }\n\n    if (def->data.vnc.auth.passwd != NULL) {\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.password = \\\"%s\\\"\\n\",\n                          def->data.vnc.auth.passwd);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXFormatConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "3052-3453",
    "snippet": "char *\nvirVMXFormatConfig(virVMXContext *ctx, virDomainXMLOptionPtr xmlopt, virDomainDefPtr def,\n                   int virtualHW_version)\n{\n    char *vmx = NULL;\n    size_t i;\n    int sched_cpu_affinity_length;\n    unsigned char zero[VIR_UUID_BUFLEN];\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *preliminaryDisplayName = NULL;\n    char *displayName = NULL;\n    char *annotation = NULL;\n    unsigned long long max_balloon;\n    bool scsi_present[4] = { false, false, false, false };\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    bool floppy_present[2] = { false, false };\n    unsigned int maxvcpus;\n    bool hasSCSI = false;\n\n    if (ctx->formatFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no formatFileName function set\"));\n        return NULL;\n    }\n\n    memset(zero, 0, VIR_UUID_BUFLEN);\n\n    if (def->virtType != VIR_DOMAIN_VIRT_VMWARE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting virt type to be '%s' but found '%s'\"),\n                       virDomainVirtTypeToString(VIR_DOMAIN_VIRT_VMWARE),\n                       virDomainVirtTypeToString(def->virtType));\n        return NULL;\n    }\n\n    /* vmx:.encoding */\n    virBufferAddLit(&buffer, \".encoding = \\\"UTF-8\\\"\\n\");\n\n    /* vmx:config.version */\n    virBufferAddLit(&buffer, \"config.version = \\\"8\\\"\\n\");\n\n    /* vmx:virtualHW.version */\n    virBufferAsprintf(&buffer, \"virtualHW.version = \\\"%d\\\"\\n\",\n                      virtualHW_version);\n\n    /* def:os.arch -> vmx:guestOS */\n    if (def->os.arch == VIR_ARCH_I686) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other\\\"\\n\");\n    } else if (def->os.arch == VIR_ARCH_X86_64) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other-64\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting domain XML attribute 'arch' of entry 'os/type' \"\n                         \"to be 'i686' or 'x86_64' but found '%s'\"),\n                       virArchToString(def->os.arch));\n        goto cleanup;\n    }\n\n    /* def:os.smbios_mode -> vmx:smbios.reflecthost */\n    if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_NONE ||\n        def->os.smbios_mode == VIR_DOMAIN_SMBIOS_EMULATE) {\n        /* nothing */\n    } else if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_HOST) {\n        virBufferAddLit(&buffer, \"smbios.reflecthost = \\\"true\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported SMBIOS mode '%s'\"),\n                       virDomainSmbiosModeTypeToString(def->os.smbios_mode));\n        goto cleanup;\n    }\n\n    /* def:uuid -> vmx:uuid.action, vmx:uuid.bios */\n    if (memcmp(def->uuid, zero, VIR_UUID_BUFLEN) == 0) {\n        virBufferAddLit(&buffer, \"uuid.action = \\\"create\\\"\\n\");\n    } else {\n        virBufferAsprintf(&buffer, \"uuid.bios = \\\"%02x %02x %02x %02x %02x %02x \"\n                          \"%02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\\\"\\n\",\n                          def->uuid[0], def->uuid[1], def->uuid[2], def->uuid[3],\n                          def->uuid[4], def->uuid[5], def->uuid[6], def->uuid[7],\n                          def->uuid[8], def->uuid[9], def->uuid[10], def->uuid[11],\n                          def->uuid[12], def->uuid[13], def->uuid[14],\n                          def->uuid[15]);\n    }\n\n    /* def:name -> vmx:displayName */\n    preliminaryDisplayName = virVMXEscapeHexPipe(def->name);\n\n    if (preliminaryDisplayName == NULL)\n        goto cleanup;\n\n    displayName = virVMXEscapeHexPercent(preliminaryDisplayName);\n\n    if (displayName == NULL)\n        goto cleanup;\n\n    virBufferAsprintf(&buffer, \"displayName = \\\"%s\\\"\\n\", displayName);\n\n    /* def:description -> vmx:annotation */\n    if (def->description != NULL) {\n        if (!(annotation = virVMXEscapeHexPipe(def->description)))\n            goto cleanup;\n\n        virBufferAsprintf(&buffer, \"annotation = \\\"%s\\\"\\n\", annotation);\n    }\n\n    /* def:mem.max_balloon -> vmx:memsize */\n    /* max-memory must be a multiple of 4096 kilobyte */\n    max_balloon = VIR_DIV_UP(virDomainDefGetMemoryTotal(def), 4096) * 4096;\n\n    virBufferAsprintf(&buffer, \"memsize = \\\"%llu\\\"\\n\",\n                      max_balloon / 1024); /* Scale from kilobytes to megabytes */\n\n    /* def:mem.cur_balloon -> vmx:sched.mem.max */\n    if (def->mem.cur_balloon < max_balloon) {\n        virBufferAsprintf(&buffer, \"sched.mem.max = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.cur_balloon,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:mem.min_guarantee -> vmx:sched.mem.minsize */\n    if (def->mem.min_guarantee > 0) {\n        virBufferAsprintf(&buffer, \"sched.mem.minsize = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.min_guarantee,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:maxvcpus -> vmx:numvcpus */\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"No support for domain XML entry 'vcpu' attribute \"\n                         \"'current'\"));\n        goto cleanup;\n    }\n    maxvcpus = virDomainDefGetVcpusMax(def);\n    if (maxvcpus == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML entry 'vcpu' to be greater \"\n                         \"than 0\"));\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"numvcpus = \\\"%d\\\"\\n\", maxvcpus);\n\n    if (def->cpu) {\n        unsigned int calculated_vcpus;\n\n        if (def->cpu->mode != VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU mode 'custom' but \"\n                             \"found '%s'\"),\n                           virCPUModeTypeToString(def->cpu->mode));\n            goto cleanup;\n        }\n\n        if (def->cpu->threads != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 thread per core is supported\"));\n            goto cleanup;\n        }\n\n        if (def->cpu->dies != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 die per socket is supported\"));\n            goto cleanup;\n        }\n\n        calculated_vcpus = def->cpu->sockets * def->cpu->cores;\n        if (calculated_vcpus != maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU sockets per core as %d \"\n                             \"but found %d\"),\n                           maxvcpus, calculated_vcpus);\n            goto cleanup;\n        }\n\n        virBufferAsprintf(&buffer, \"cpuid.coresPerSocket = \\\"%d\\\"\\n\", def->cpu->cores);\n    }\n\n    /* def:cpumask -> vmx:sched.cpu.affinity */\n    if (def->cpumask && virBitmapSize(def->cpumask) > 0) {\n        int bit;\n        virBufferAddLit(&buffer, \"sched.cpu.affinity = \\\"\");\n\n        sched_cpu_affinity_length = 0;\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0)\n            ++sched_cpu_affinity_length;\n\n        if (sched_cpu_affinity_length < maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML attribute 'cpuset' of entry \"\n                             \"'vcpu' to contain at least %d CPU(s)\"),\n                           maxvcpus);\n            goto cleanup;\n        }\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0) {\n            virBufferAsprintf(&buffer, \"%d\", bit);\n\n            if (sched_cpu_affinity_length > 1)\n                virBufferAddChar(&buffer, ',');\n\n            --sched_cpu_affinity_length;\n        }\n\n        virBufferAddLit(&buffer, \"\\\"\\n\");\n    }\n\n    /* def:cputune.shares -> vmx:sched.cpu.shares */\n    if (def->cputune.sharesSpecified) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (def->cputune.shares == vcpus * 500) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"low\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 1000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"normal\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 2000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"high\\\"\\n\");\n        } else {\n            virBufferAsprintf(&buffer, \"sched.cpu.shares = \\\"%llu\\\"\\n\",\n                              def->cputune.shares);\n        }\n    }\n\n    /* def:graphics */\n    for (i = 0; i < def->ngraphics; ++i) {\n        switch (def->graphics[i]->type) {\n          case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n            if (virVMXFormatVNC(def->graphics[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n          case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n          case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported graphics type '%s'\"),\n                           virDomainGraphicsTypeToString(def->graphics[i]->type));\n            goto cleanup;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n          default:\n              virReportEnumRangeError(virDomainGraphicsType, def->graphics[i]->type);\n              goto cleanup;\n        }\n    }\n\n    /* def:disks */\n    for (i = 0; i < def->ndisks; ++i) {\n        if (virVMXVerifyDiskAddress(xmlopt, def->disks[i], def) < 0 ||\n            virVMXHandleLegacySCSIDiskDriverName(def, def->disks[i]) < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (virVMXGatherSCSIControllers(ctx, def, scsi_virtualDev,\n                                    scsi_present) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < 4; ++i) {\n        if (scsi_present[i]) {\n            hasSCSI = true;\n\n            virBufferAsprintf(&buffer, \"scsi%zu.present = \\\"true\\\"\\n\", i);\n\n            if (scsi_virtualDev[i] != -1) {\n                virBufferAsprintf(&buffer, \"scsi%zu.virtualDev = \\\"%s\\\"\\n\", i,\n                                  virVMXControllerModelSCSITypeToString\n                                    (scsi_virtualDev[i]));\n            }\n        }\n    }\n\n    for (i = 0; i < def->ndisks; ++i) {\n        switch (def->disks[i]->device) {\n          case VIR_DOMAIN_DISK_DEVICE_DISK:\n          case VIR_DOMAIN_DISK_DEVICE_CDROM:\n          case VIR_DOMAIN_DISK_DEVICE_LUN:\n            if (virVMXFormatDisk(ctx, def->disks[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_DISK_DEVICE_FLOPPY:\n            if (virVMXFormatFloppy(ctx, def->disks[i], &buffer,\n                                   floppy_present) < 0) {\n                goto cleanup;\n            }\n\n            break;\n\n          default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported disk device type '%s'\"),\n                           virDomainDiskDeviceTypeToString(def->disks[i]->device));\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < 2; ++i) {\n        /* floppy[0..1].present defaults to true, disable it explicitly */\n        if (! floppy_present[i])\n            virBufferAsprintf(&buffer, \"floppy%zu.present = \\\"false\\\"\\n\", i);\n    }\n\n    /* def:fss */\n    if (def->nfss > 0) {\n        virBufferAddLit(&buffer, \"isolation.tools.hgfs.disable = \\\"false\\\"\\n\");\n        virBufferAsprintf(&buffer, \"sharedFolder.maxNum = \\\"%zu\\\"\\n\", def->nfss);\n    }\n\n    for (i = 0; i < def->nfss; ++i) {\n        if (virVMXFormatFileSystem(def->fss[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:nets */\n    for (i = 0; i < def->nnets; ++i) {\n        if (virVMXFormatEthernet(def->nets[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:videos */\n    if (def->nvideos > 0) {\n        if (def->nvideos > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No support for multiple video devices\"));\n            goto cleanup;\n        }\n\n        if (virVMXFormatSVGA(def->videos[0], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    for (i = 0; i < def->nserials; ++i) {\n        if (virVMXFormatSerial(ctx, def->serials[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:parallels */\n    for (i = 0; i < def->nparallels; ++i) {\n        if (virVMXFormatParallel(ctx, def->parallels[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* vmx:firmware */\n    if (def->os.firmware == VIR_DOMAIN_OS_DEF_FIRMWARE_EFI)\n        virBufferAddLit(&buffer, \"firmware = \\\"efi\\\"\\n\");\n\n    if (virtualHW_version >= 7) {\n        if (hasSCSI) {\n            virBufferAddLit(&buffer, \"pciBridge0.present = \\\"true\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge4.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge5.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge6.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge7.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.functions = \\\"8\\\"\\n\");\n        }\n\n        virBufferAddLit(&buffer, \"vmci0.present = \\\"true\\\"\\n\");\n    }\n\n    /* Get final VMX output */\n    vmx = virBufferContentAndReset(&buffer);\n\n cleanup:\n    if (vmx == NULL)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(preliminaryDisplayName);\n    VIR_FREE(displayName);\n    VIR_FREE(annotation);\n\n    return vmx;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "annotation"
          ],
          "line": 3450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "displayName"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "preliminaryDisplayName"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buffer"
          ],
          "line": 3446
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buffer"
          ],
          "line": 3442
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"vmci0.present = \\\"true\\\"\\n\""
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"pciBridge7.functions = \\\"8\\\"\\n\""
          ],
          "line": 3435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"pciBridge7.virtualDev = \\\"pcieRootPort\\\"\\n\""
          ],
          "line": 3434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"pciBridge7.present = \\\"true\\\"\\n\""
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"pciBridge6.functions = \\\"8\\\"\\n\""
          ],
          "line": 3431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"pciBridge6.virtualDev = \\\"pcieRootPort\\\"\\n\""
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"pciBridge6.present = \\\"true\\\"\\n\""
          ],
          "line": 3429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"pciBridge5.functions = \\\"8\\\"\\n\""
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"pciBridge5.virtualDev = \\\"pcieRootPort\\\"\\n\""
          ],
          "line": 3426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"pciBridge5.present = \\\"true\\\"\\n\""
          ],
          "line": 3425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"pciBridge4.functions = \\\"8\\\"\\n\""
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"pciBridge4.virtualDev = \\\"pcieRootPort\\\"\\n\""
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"pciBridge4.present = \\\"true\\\"\\n\""
          ],
          "line": 3421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"pciBridge0.present = \\\"true\\\"\\n\""
          ],
          "line": 3419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"firmware = \\\"efi\\\"\\n\""
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXFormatParallel",
          "args": [
            "ctx",
            "def->parallels[i]",
            "&buffer"
          ],
          "line": 3409
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXFormatParallel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "3961-4009",
          "snippet": "int\nvirVMXFormatParallel(virVMXContext *ctx, virDomainChrDefPtr def,\n                     virBufferPtr buffer)\n{\n    char *fileName = NULL;\n\n    if (def->target.port < 0 || def->target.port > 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Parallel port index %d out of [0..2] range\"),\n                       def->target.port);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"parallel%d.present = \\\"true\\\"\\n\",\n                      def->target.port);\n\n    /* def:type -> vmx:fileType and def:data.file.path -> vmx:fileName */\n    switch (def->source->type) {\n      case VIR_DOMAIN_CHR_TYPE_DEV:\n        virBufferAsprintf(buffer, \"parallel%d.fileType = \\\"device\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"parallel%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, def->source->data.file.path);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_FILE:\n        virBufferAsprintf(buffer, \"parallel%d.fileType = \\\"file\\\"\\n\",\n                          def->target.port);\n\n        fileName = ctx->formatFileName(def->source->data.file.path, ctx->opaque);\n\n        if (fileName == NULL)\n            return -1;\n\n        virBufferAsprintf(buffer, \"parallel%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, fileName);\n\n        VIR_FREE(fileName);\n        break;\n\n      default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported character device type '%s'\"),\n                       virDomainChrTypeToString(def->source->type));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatParallel(virVMXContext *ctx, virDomainChrDefPtr def,\n                     virBufferPtr buffer)\n{\n    char *fileName = NULL;\n\n    if (def->target.port < 0 || def->target.port > 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Parallel port index %d out of [0..2] range\"),\n                       def->target.port);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"parallel%d.present = \\\"true\\\"\\n\",\n                      def->target.port);\n\n    /* def:type -> vmx:fileType and def:data.file.path -> vmx:fileName */\n    switch (def->source->type) {\n      case VIR_DOMAIN_CHR_TYPE_DEV:\n        virBufferAsprintf(buffer, \"parallel%d.fileType = \\\"device\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"parallel%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, def->source->data.file.path);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_FILE:\n        virBufferAsprintf(buffer, \"parallel%d.fileType = \\\"file\\\"\\n\",\n                          def->target.port);\n\n        fileName = ctx->formatFileName(def->source->data.file.path, ctx->opaque);\n\n        if (fileName == NULL)\n            return -1;\n\n        virBufferAsprintf(buffer, \"parallel%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, fileName);\n\n        VIR_FREE(fileName);\n        break;\n\n      default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported character device type '%s'\"),\n                       virDomainChrTypeToString(def->source->type));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXFormatSerial",
          "args": [
            "ctx",
            "def->serials[i]",
            "&buffer"
          ],
          "line": 3403
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXFormatSerial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "3855-3957",
          "snippet": "int\nvirVMXFormatSerial(virVMXContext *ctx, virDomainChrDefPtr def,\n                   virBufferPtr buffer)\n{\n    char *fileName = NULL;\n    const char *protocol;\n\n    if (def->target.port < 0 || def->target.port > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Serial port index %d out of [0..3] range\"),\n                       def->target.port);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"serial%d.present = \\\"true\\\"\\n\", def->target.port);\n\n    /* def:type -> vmx:fileType and def:data.file.path -> vmx:fileName */\n    switch (def->source->type) {\n      case VIR_DOMAIN_CHR_TYPE_DEV:\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"device\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, def->source->data.file.path);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_FILE:\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"file\\\"\\n\",\n                          def->target.port);\n\n        fileName = ctx->formatFileName(def->source->data.file.path, ctx->opaque);\n\n        if (fileName == NULL)\n            return -1;\n\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, fileName);\n\n        VIR_FREE(fileName);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_PIPE:\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"pipe\\\"\\n\",\n                          def->target.port);\n        /* FIXME: Based on VI Client GUI default */\n        virBufferAsprintf(buffer, \"serial%d.pipe.endPoint = \\\"client\\\"\\n\",\n                          def->target.port);\n        /* FIXME: Based on VI Client GUI default */\n        virBufferAsprintf(buffer, \"serial%d.tryNoRxLoss = \\\"false\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, def->source->data.file.path);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_TCP:\n        switch (def->source->data.tcp.protocol) {\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW:\n            protocol = \"tcp\";\n            break;\n\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET:\n            protocol = \"telnet\";\n            break;\n\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNETS:\n            protocol = \"telnets\";\n            break;\n\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_TLS:\n            protocol = \"ssl\";\n            break;\n\n          default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported character device TCP protocol '%s'\"),\n                           virDomainChrTcpProtocolTypeToString(\n                               def->source->data.tcp.protocol));\n            return -1;\n        }\n\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"network\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s://%s:%s\\\"\\n\",\n                          def->target.port, protocol, def->source->data.tcp.host,\n                          def->source->data.tcp.service);\n        virBufferAsprintf(buffer, \"serial%d.network.endPoint = \\\"%s\\\"\\n\",\n                          def->target.port,\n                          def->source->data.tcp.listen ? \"server\" : \"client\");\n        break;\n\n      default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported character device type '%s'\"),\n                       virDomainChrTypeToString(def->source->type));\n        return -1;\n    }\n\n    /* vmx:yieldOnMsrRead */\n    /* FIXME: Based on VI Client GUI default */\n    virBufferAsprintf(buffer, \"serial%d.yieldOnMsrRead = \\\"true\\\"\\n\",\n                      def->target.port);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatSerial(virVMXContext *ctx, virDomainChrDefPtr def,\n                   virBufferPtr buffer)\n{\n    char *fileName = NULL;\n    const char *protocol;\n\n    if (def->target.port < 0 || def->target.port > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Serial port index %d out of [0..3] range\"),\n                       def->target.port);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"serial%d.present = \\\"true\\\"\\n\", def->target.port);\n\n    /* def:type -> vmx:fileType and def:data.file.path -> vmx:fileName */\n    switch (def->source->type) {\n      case VIR_DOMAIN_CHR_TYPE_DEV:\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"device\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, def->source->data.file.path);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_FILE:\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"file\\\"\\n\",\n                          def->target.port);\n\n        fileName = ctx->formatFileName(def->source->data.file.path, ctx->opaque);\n\n        if (fileName == NULL)\n            return -1;\n\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, fileName);\n\n        VIR_FREE(fileName);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_PIPE:\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"pipe\\\"\\n\",\n                          def->target.port);\n        /* FIXME: Based on VI Client GUI default */\n        virBufferAsprintf(buffer, \"serial%d.pipe.endPoint = \\\"client\\\"\\n\",\n                          def->target.port);\n        /* FIXME: Based on VI Client GUI default */\n        virBufferAsprintf(buffer, \"serial%d.tryNoRxLoss = \\\"false\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s\\\"\\n\",\n                          def->target.port, def->source->data.file.path);\n        break;\n\n      case VIR_DOMAIN_CHR_TYPE_TCP:\n        switch (def->source->data.tcp.protocol) {\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW:\n            protocol = \"tcp\";\n            break;\n\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET:\n            protocol = \"telnet\";\n            break;\n\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNETS:\n            protocol = \"telnets\";\n            break;\n\n          case VIR_DOMAIN_CHR_TCP_PROTOCOL_TLS:\n            protocol = \"ssl\";\n            break;\n\n          default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported character device TCP protocol '%s'\"),\n                           virDomainChrTcpProtocolTypeToString(\n                               def->source->data.tcp.protocol));\n            return -1;\n        }\n\n        virBufferAsprintf(buffer, \"serial%d.fileType = \\\"network\\\"\\n\",\n                          def->target.port);\n        virBufferAsprintf(buffer, \"serial%d.fileName = \\\"%s://%s:%s\\\"\\n\",\n                          def->target.port, protocol, def->source->data.tcp.host,\n                          def->source->data.tcp.service);\n        virBufferAsprintf(buffer, \"serial%d.network.endPoint = \\\"%s\\\"\\n\",\n                          def->target.port,\n                          def->source->data.tcp.listen ? \"server\" : \"client\");\n        break;\n\n      default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported character device type '%s'\"),\n                       virDomainChrTypeToString(def->source->type));\n        return -1;\n    }\n\n    /* vmx:yieldOnMsrRead */\n    /* FIXME: Based on VI Client GUI default */\n    virBufferAsprintf(buffer, \"serial%d.yieldOnMsrRead = \\\"true\\\"\\n\",\n                      def->target.port);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXFormatSVGA",
          "args": [
            "def->videos[0]",
            "&buffer"
          ],
          "line": 3394
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXFormatSVGA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "4013-4041",
          "snippet": "int\nvirVMXFormatSVGA(virDomainVideoDefPtr def, virBufferPtr buffer)\n{\n    unsigned long long vram;\n\n    if (def->type != VIR_DOMAIN_VIDEO_TYPE_VMVGA) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported video device type '%s'\"),\n                       virDomainVideoTypeToString(def->type));\n        return -1;\n    }\n\n    /*\n     * For Windows guests the VRAM size should be a multiple of 64 kilobyte.\n     * See http://kb.vmware.com/kb/1003 and http://kb.vmware.com/kb/1001558\n     */\n    vram = VIR_DIV_UP(def->vram, 64) * 64;\n\n    if (def->heads > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Multi-head video devices are unsupported\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"svga.vramSize = \\\"%lld\\\"\\n\",\n                      vram * 1024); /* kilobyte to byte */\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatSVGA(virDomainVideoDefPtr def, virBufferPtr buffer)\n{\n    unsigned long long vram;\n\n    if (def->type != VIR_DOMAIN_VIDEO_TYPE_VMVGA) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported video device type '%s'\"),\n                       virDomainVideoTypeToString(def->type));\n        return -1;\n    }\n\n    /*\n     * For Windows guests the VRAM size should be a multiple of 64 kilobyte.\n     * See http://kb.vmware.com/kb/1003 and http://kb.vmware.com/kb/1001558\n     */\n    vram = VIR_DIV_UP(def->vram, 64) * 64;\n\n    if (def->heads > 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Multi-head video devices are unsupported\"));\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"svga.vramSize = \\\"%lld\\\"\\n\",\n                      vram * 1024); /* kilobyte to byte */\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"No support for multiple video devices\")"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No support for multiple video devices\""
          ],
          "line": 3390
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXFormatEthernet",
          "args": [
            "def->nets[i]",
            "i",
            "&buffer"
          ],
          "line": 3376
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXFormatEthernet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "3730-3851",
          "snippet": "int\nvirVMXFormatEthernet(virDomainNetDefPtr def, int controller,\n                     virBufferPtr buffer)\n{\n    char mac_string[VIR_MAC_STRING_BUFLEN];\n    unsigned int prefix, suffix;\n\n    if (controller < 0 || controller > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Ethernet controller index %d out of [0..3] range\"),\n                       controller);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"ethernet%d.present = \\\"true\\\"\\n\", controller);\n\n    /* def:model -> vmx:virtualDev, vmx:features */\n    if (def->model) {\n        if (def->model != VIR_DOMAIN_NET_MODEL_VLANCE &&\n            def->model != VIR_DOMAIN_NET_MODEL_VMXNET &&\n            def->model != VIR_DOMAIN_NET_MODEL_VMXNET2 &&\n            def->model != VIR_DOMAIN_NET_MODEL_VMXNET3 &&\n            def->model != VIR_DOMAIN_NET_MODEL_E1000 &&\n            def->model != VIR_DOMAIN_NET_MODEL_E1000E) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML entry 'devices/interface/model' \"\n                             \"to be 'vlance' or 'vmxnet' or 'vmxnet2' or 'vmxnet3' \"\n                             \"or 'e1000' or 'e1000e' but found '%s'\"),\n                            virDomainNetModelTypeToString(def->model));\n            return -1;\n        }\n\n        if (def->model == VIR_DOMAIN_NET_MODEL_VMXNET2) {\n            virBufferAsprintf(buffer, \"ethernet%d.virtualDev = \\\"vmxnet\\\"\\n\",\n                              controller);\n            virBufferAsprintf(buffer, \"ethernet%d.features = \\\"15\\\"\\n\",\n                              controller);\n        } else {\n            virBufferAsprintf(buffer, \"ethernet%d.virtualDev = \\\"%s\\\"\\n\",\n                              controller,\n                              virDomainNetModelTypeToString(def->model));\n        }\n    }\n\n    /* def:type, def:ifname -> vmx:connectionType */\n    switch (def->type) {\n      case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        if (STRNEQ(def->data.bridge.brname, \"\"))\n            virBufferAsprintf(buffer, \"ethernet%d.networkName = \\\"%s\\\"\\n\",\n                              controller, def->data.bridge.brname);\n\n        if (def->ifname != NULL) {\n            virBufferAsprintf(buffer, \"ethernet%d.connectionType = \\\"custom\\\"\\n\",\n                              controller);\n            virBufferAsprintf(buffer, \"ethernet%d.vnet = \\\"%s\\\"\\n\",\n                              controller, def->ifname);\n        } else {\n            virBufferAsprintf(buffer, \"ethernet%d.connectionType = \\\"bridged\\\"\\n\",\n                              controller);\n        }\n\n        break;\n\n      case VIR_DOMAIN_NET_TYPE_USER:\n        virBufferAsprintf(buffer, \"ethernet%d.connectionType = \\\"nat\\\"\\n\",\n                          controller);\n        break;\n\n      case VIR_DOMAIN_NET_TYPE_ETHERNET:\n      case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n      case VIR_DOMAIN_NET_TYPE_SERVER:\n      case VIR_DOMAIN_NET_TYPE_CLIENT:\n      case VIR_DOMAIN_NET_TYPE_MCAST:\n      case VIR_DOMAIN_NET_TYPE_NETWORK:\n      case VIR_DOMAIN_NET_TYPE_INTERNAL:\n      case VIR_DOMAIN_NET_TYPE_DIRECT:\n      case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n      case VIR_DOMAIN_NET_TYPE_UDP:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, _(\"Unsupported net type '%s'\"),\n                       virDomainNetTypeToString(def->type));\n        return -1;\n\n      case VIR_DOMAIN_NET_TYPE_LAST:\n      default:\n          virReportEnumRangeError(virDomainNetType, def->type);\n          return -1;\n    }\n\n    /* def:mac -> vmx:addressType, vmx:(generated)Address, vmx:checkMACAddress */\n    virMacAddrFormat(&def->mac, mac_string);\n\n    prefix = (def->mac.addr[0] << 16) | (def->mac.addr[1] << 8) | def->mac.addr[2];\n    suffix = (def->mac.addr[3] << 16) | (def->mac.addr[4] << 8) | def->mac.addr[5];\n\n    if (prefix == 0x000c29) {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"generated\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.generatedAddress = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n        virBufferAsprintf(buffer, \"ethernet%d.generatedAddressOffset = \\\"0\\\"\\n\",\n                          controller);\n    } else if (prefix == 0x005056 && suffix <= 0x3fffff) {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"static\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.address = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n    } else if (prefix == 0x005056 && suffix >= 0x800000 && suffix <= 0xbfffff) {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"vpx\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.generatedAddress = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n    } else {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"static\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.address = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n        virBufferAsprintf(buffer, \"ethernet%d.checkMACAddress = \\\"false\\\"\\n\",\n                          controller);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatEthernet(virDomainNetDefPtr def, int controller,\n                     virBufferPtr buffer)\n{\n    char mac_string[VIR_MAC_STRING_BUFLEN];\n    unsigned int prefix, suffix;\n\n    if (controller < 0 || controller > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Ethernet controller index %d out of [0..3] range\"),\n                       controller);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"ethernet%d.present = \\\"true\\\"\\n\", controller);\n\n    /* def:model -> vmx:virtualDev, vmx:features */\n    if (def->model) {\n        if (def->model != VIR_DOMAIN_NET_MODEL_VLANCE &&\n            def->model != VIR_DOMAIN_NET_MODEL_VMXNET &&\n            def->model != VIR_DOMAIN_NET_MODEL_VMXNET2 &&\n            def->model != VIR_DOMAIN_NET_MODEL_VMXNET3 &&\n            def->model != VIR_DOMAIN_NET_MODEL_E1000 &&\n            def->model != VIR_DOMAIN_NET_MODEL_E1000E) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML entry 'devices/interface/model' \"\n                             \"to be 'vlance' or 'vmxnet' or 'vmxnet2' or 'vmxnet3' \"\n                             \"or 'e1000' or 'e1000e' but found '%s'\"),\n                            virDomainNetModelTypeToString(def->model));\n            return -1;\n        }\n\n        if (def->model == VIR_DOMAIN_NET_MODEL_VMXNET2) {\n            virBufferAsprintf(buffer, \"ethernet%d.virtualDev = \\\"vmxnet\\\"\\n\",\n                              controller);\n            virBufferAsprintf(buffer, \"ethernet%d.features = \\\"15\\\"\\n\",\n                              controller);\n        } else {\n            virBufferAsprintf(buffer, \"ethernet%d.virtualDev = \\\"%s\\\"\\n\",\n                              controller,\n                              virDomainNetModelTypeToString(def->model));\n        }\n    }\n\n    /* def:type, def:ifname -> vmx:connectionType */\n    switch (def->type) {\n      case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        if (STRNEQ(def->data.bridge.brname, \"\"))\n            virBufferAsprintf(buffer, \"ethernet%d.networkName = \\\"%s\\\"\\n\",\n                              controller, def->data.bridge.brname);\n\n        if (def->ifname != NULL) {\n            virBufferAsprintf(buffer, \"ethernet%d.connectionType = \\\"custom\\\"\\n\",\n                              controller);\n            virBufferAsprintf(buffer, \"ethernet%d.vnet = \\\"%s\\\"\\n\",\n                              controller, def->ifname);\n        } else {\n            virBufferAsprintf(buffer, \"ethernet%d.connectionType = \\\"bridged\\\"\\n\",\n                              controller);\n        }\n\n        break;\n\n      case VIR_DOMAIN_NET_TYPE_USER:\n        virBufferAsprintf(buffer, \"ethernet%d.connectionType = \\\"nat\\\"\\n\",\n                          controller);\n        break;\n\n      case VIR_DOMAIN_NET_TYPE_ETHERNET:\n      case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n      case VIR_DOMAIN_NET_TYPE_SERVER:\n      case VIR_DOMAIN_NET_TYPE_CLIENT:\n      case VIR_DOMAIN_NET_TYPE_MCAST:\n      case VIR_DOMAIN_NET_TYPE_NETWORK:\n      case VIR_DOMAIN_NET_TYPE_INTERNAL:\n      case VIR_DOMAIN_NET_TYPE_DIRECT:\n      case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n      case VIR_DOMAIN_NET_TYPE_UDP:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, _(\"Unsupported net type '%s'\"),\n                       virDomainNetTypeToString(def->type));\n        return -1;\n\n      case VIR_DOMAIN_NET_TYPE_LAST:\n      default:\n          virReportEnumRangeError(virDomainNetType, def->type);\n          return -1;\n    }\n\n    /* def:mac -> vmx:addressType, vmx:(generated)Address, vmx:checkMACAddress */\n    virMacAddrFormat(&def->mac, mac_string);\n\n    prefix = (def->mac.addr[0] << 16) | (def->mac.addr[1] << 8) | def->mac.addr[2];\n    suffix = (def->mac.addr[3] << 16) | (def->mac.addr[4] << 8) | def->mac.addr[5];\n\n    if (prefix == 0x000c29) {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"generated\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.generatedAddress = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n        virBufferAsprintf(buffer, \"ethernet%d.generatedAddressOffset = \\\"0\\\"\\n\",\n                          controller);\n    } else if (prefix == 0x005056 && suffix <= 0x3fffff) {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"static\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.address = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n    } else if (prefix == 0x005056 && suffix >= 0x800000 && suffix <= 0xbfffff) {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"vpx\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.generatedAddress = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n    } else {\n        virBufferAsprintf(buffer, \"ethernet%d.addressType = \\\"static\\\"\\n\",\n                          controller);\n        virBufferAsprintf(buffer, \"ethernet%d.address = \\\"%s\\\"\\n\",\n                          controller, mac_string);\n        virBufferAsprintf(buffer, \"ethernet%d.checkMACAddress = \\\"false\\\"\\n\",\n                          controller);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXFormatFileSystem",
          "args": [
            "def->fss[i]",
            "i",
            "&buffer"
          ],
          "line": 3370
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXFormatFileSystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "3705-3726",
          "snippet": "int\nvirVMXFormatFileSystem(virDomainFSDefPtr def, int number, virBufferPtr buffer)\n{\n    if (def->type != VIR_DOMAIN_FS_TYPE_MOUNT) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Only '%s' filesystem type is supported\"),\n                       virDomainFSTypeToString(VIR_DOMAIN_FS_TYPE_MOUNT));\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"sharedFolder%d.present = \\\"true\\\"\\n\", number);\n    virBufferAsprintf(buffer, \"sharedFolder%d.enabled = \\\"true\\\"\\n\", number);\n    virBufferAsprintf(buffer, \"sharedFolder%d.readAccess = \\\"true\\\"\\n\", number);\n    virBufferAsprintf(buffer, \"sharedFolder%d.writeAccess = \\\"%s\\\"\\n\", number,\n                      def->readonly ? \"false\" : \"true\");\n    virBufferAsprintf(buffer, \"sharedFolder%d.hostPath = \\\"%s\\\"\\n\", number,\n                      def->src->path);\n    virBufferAsprintf(buffer, \"sharedFolder%d.guestName = \\\"%s\\\"\\n\", number,\n                      def->dst);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatFileSystem(virDomainFSDefPtr def, int number, virBufferPtr buffer)\n{\n    if (def->type != VIR_DOMAIN_FS_TYPE_MOUNT) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Only '%s' filesystem type is supported\"),\n                       virDomainFSTypeToString(VIR_DOMAIN_FS_TYPE_MOUNT));\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"sharedFolder%d.present = \\\"true\\\"\\n\", number);\n    virBufferAsprintf(buffer, \"sharedFolder%d.enabled = \\\"true\\\"\\n\", number);\n    virBufferAsprintf(buffer, \"sharedFolder%d.readAccess = \\\"true\\\"\\n\", number);\n    virBufferAsprintf(buffer, \"sharedFolder%d.writeAccess = \\\"%s\\\"\\n\", number,\n                      def->readonly ? \"false\" : \"true\");\n    virBufferAsprintf(buffer, \"sharedFolder%d.hostPath = \\\"%s\\\"\\n\", number,\n                      def->src->path);\n    virBufferAsprintf(buffer, \"sharedFolder%d.guestName = \\\"%s\\\"\\n\", number,\n                      def->dst);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buffer",
            "\"sharedFolder.maxNum = \\\"%zu\\\"\\n\"",
            "def->nfss"
          ],
          "line": 3366
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"isolation.tools.hgfs.disable = \\\"false\\\"\\n\""
          ],
          "line": 3365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported disk device type '%s'\")",
            "virDomainDiskDeviceTypeToString(def->disks[i]->device)"
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDeviceTypeToString",
          "args": [
            "def->disks[i]->device"
          ],
          "line": 3352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXFormatFloppy",
          "args": [
            "ctx",
            "def->disks[i]",
            "&buffer",
            "floppy_present"
          ],
          "line": 3342
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXFormatFloppy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "3648-3701",
          "snippet": "int\nvirVMXFormatFloppy(virVMXContext *ctx, virDomainDiskDefPtr def,\n                   virBufferPtr buffer, bool floppy_present[2])\n{\n    int unit;\n    char *fileName = NULL;\n    int type = virDomainDiskGetType(def);\n    const char *src = virDomainDiskGetSource(def);\n\n    if (def->device != VIR_DOMAIN_DISK_DEVICE_FLOPPY) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virVMXFloppyDiskNameToUnit(def->dst, &unit) < 0)\n        return -1;\n\n    floppy_present[unit] = true;\n\n    virBufferAsprintf(buffer, \"floppy%d.present = \\\"true\\\"\\n\", unit);\n\n    if (type == VIR_STORAGE_TYPE_FILE) {\n        virBufferAsprintf(buffer, \"floppy%d.fileType = \\\"file\\\"\\n\", unit);\n\n        if (src) {\n            fileName = ctx->formatFileName(src, ctx->opaque);\n\n            if (fileName == NULL)\n                return -1;\n\n            virBufferAsprintf(buffer, \"floppy%d.fileName = \\\"%s\\\"\\n\",\n                              unit, fileName);\n\n            VIR_FREE(fileName);\n        }\n    } else if (type == VIR_STORAGE_TYPE_BLOCK) {\n        virBufferAsprintf(buffer, \"floppy%d.fileType = \\\"device\\\"\\n\", unit);\n\n        if (src) {\n            virBufferAsprintf(buffer, \"floppy%d.fileName = \\\"%s\\\"\\n\",\n                              unit, src);\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Floppy '%s' has unsupported type '%s', expecting '%s' \"\n                         \"or '%s'\"), def->dst,\n                       virStorageTypeToString(type),\n                       virStorageTypeToString(VIR_STORAGE_TYPE_FILE),\n                       virStorageTypeToString(VIR_STORAGE_TYPE_BLOCK));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatFloppy(virVMXContext *ctx, virDomainDiskDefPtr def,\n                   virBufferPtr buffer, bool floppy_present[2])\n{\n    int unit;\n    char *fileName = NULL;\n    int type = virDomainDiskGetType(def);\n    const char *src = virDomainDiskGetSource(def);\n\n    if (def->device != VIR_DOMAIN_DISK_DEVICE_FLOPPY) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virVMXFloppyDiskNameToUnit(def->dst, &unit) < 0)\n        return -1;\n\n    floppy_present[unit] = true;\n\n    virBufferAsprintf(buffer, \"floppy%d.present = \\\"true\\\"\\n\", unit);\n\n    if (type == VIR_STORAGE_TYPE_FILE) {\n        virBufferAsprintf(buffer, \"floppy%d.fileType = \\\"file\\\"\\n\", unit);\n\n        if (src) {\n            fileName = ctx->formatFileName(src, ctx->opaque);\n\n            if (fileName == NULL)\n                return -1;\n\n            virBufferAsprintf(buffer, \"floppy%d.fileName = \\\"%s\\\"\\n\",\n                              unit, fileName);\n\n            VIR_FREE(fileName);\n        }\n    } else if (type == VIR_STORAGE_TYPE_BLOCK) {\n        virBufferAsprintf(buffer, \"floppy%d.fileType = \\\"device\\\"\\n\", unit);\n\n        if (src) {\n            virBufferAsprintf(buffer, \"floppy%d.fileName = \\\"%s\\\"\\n\",\n                              unit, src);\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Floppy '%s' has unsupported type '%s', expecting '%s' \"\n                         \"or '%s'\"), def->dst,\n                       virStorageTypeToString(type),\n                       virStorageTypeToString(VIR_STORAGE_TYPE_FILE),\n                       virStorageTypeToString(VIR_STORAGE_TYPE_BLOCK));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXFormatDisk",
          "args": [
            "ctx",
            "def->disks[i]",
            "&buffer"
          ],
          "line": 3336
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXFormatDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "3501-3646",
          "snippet": "int\nvirVMXFormatDisk(virVMXContext *ctx, virDomainDiskDefPtr def,\n                 virBufferPtr buffer)\n{\n    int controllerOrBus, unit;\n    const char *vmxDeviceType = NULL;\n    char *fileName = NULL;\n    int type = virDomainDiskGetType(def);\n\n    /* Convert a handful of types to their string values */\n    const char *busType = virDomainDiskBusTypeToString(def->bus);\n    const char *deviceType = virDomainDeviceTypeToString(def->device);\n    const char *diskType = virDomainDeviceTypeToString(type);\n\n    /* If we are dealing with a disk its a .vmdk, otherwise it must be\n     * an ISO.\n     */\n    const char *fileExt = (def->device == VIR_DOMAIN_DISK_DEVICE_DISK) ?\n                           \".vmdk\" : \".iso\";\n\n    /* Check that we got a valid device type */\n    if (def->device != VIR_DOMAIN_DISK_DEVICE_DISK &&\n        def->device != VIR_DOMAIN_DISK_DEVICE_CDROM &&\n        def->device != VIR_DOMAIN_DISK_DEVICE_LUN) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device type supplied: %s\"), deviceType);\n        return -1;\n    }\n\n    /* We only support type='file' and type='block' */\n    if (type != VIR_STORAGE_TYPE_FILE &&\n        type != VIR_STORAGE_TYPE_BLOCK) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"%s %s '%s' has unsupported type '%s', expecting \"\n                         \"'%s' or '%s'\"), busType, deviceType, def->dst,\n                       diskType,\n                       virStorageTypeToString(VIR_STORAGE_TYPE_FILE),\n                       virStorageTypeToString(VIR_STORAGE_TYPE_BLOCK));\n        return -1;\n    }\n\n    if (def->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (virVMXSCSIDiskNameToControllerAndUnit(def->dst, &controllerOrBus,\n                                                  &unit) < 0) {\n            return -1;\n        }\n    } else if (def->bus == VIR_DOMAIN_DISK_BUS_IDE) {\n        if (virVMXIDEDiskNameToBusAndUnit(def->dst, &controllerOrBus,\n                                          &unit) < 0) {\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported bus type '%s' for %s\"),\n                       busType, deviceType);\n        return -1;\n    }\n\n    if (def->device == VIR_DOMAIN_DISK_DEVICE_DISK &&\n        type == VIR_STORAGE_TYPE_FILE) {\n        vmxDeviceType = (def->bus == VIR_DOMAIN_DISK_BUS_SCSI) ?\n                        \"scsi-hardDisk\" : \"ata-hardDisk\";\n    } else if (def->device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n        if (type == VIR_STORAGE_TYPE_FILE)\n            vmxDeviceType = \"cdrom-image\";\n        else\n            vmxDeviceType = \"atapi-cdrom\";\n    } else if (def->device == VIR_DOMAIN_DISK_DEVICE_LUN) {\n        const char *src = virDomainDiskGetSource(def);\n\n        if (def->bus == VIR_DOMAIN_DISK_BUS_SCSI &&\n            src && STRPREFIX(src, \"/vmfs/devices/cdrom/\"))\n            vmxDeviceType = \"scsi-passthru\";\n        else\n            vmxDeviceType = \"cdrom-raw\";\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"%s %s '%s' has an unsupported type '%s'\"),\n                       busType, deviceType, def->dst, diskType);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"%s%d:%d.present = \\\"true\\\"\\n\",\n                      busType, controllerOrBus, unit);\n    virBufferAsprintf(buffer, \"%s%d:%d.deviceType = \\\"%s\\\"\\n\",\n                      busType, controllerOrBus, unit, vmxDeviceType);\n\n    if (type == VIR_STORAGE_TYPE_FILE) {\n        const char *src = virDomainDiskGetSource(def);\n\n        if (src) {\n            if (!virStringHasCaseSuffix(src, fileExt)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Image file for %s %s '%s' has \"\n                                 \"unsupported suffix, expecting '%s'\"),\n                               busType, deviceType, def->dst, fileExt);\n                return -1;\n            }\n\n            fileName = ctx->formatFileName(src, ctx->opaque);\n        } else if (def->device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n            fileName = g_strdup(\"emptyBackingString\");\n        }\n\n        if (fileName == NULL)\n            return -1;\n\n        virBufferAsprintf(buffer, \"%s%d:%d.fileName = \\\"%s\\\"\\n\",\n                          busType, controllerOrBus, unit, fileName);\n\n        VIR_FREE(fileName);\n    } else if (type == VIR_STORAGE_TYPE_BLOCK) {\n        const char *src = virDomainDiskGetSource(def);\n\n        if (!src &&\n            def->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_OPTIONAL) {\n            virBufferAsprintf(buffer, \"%s%d:%d.autodetect = \\\"true\\\"\\n\",\n                              busType, controllerOrBus, unit);\n            virBufferAsprintf(buffer, \"%s%d:%d.fileName = \\\"auto detect\\\"\\n\",\n                              busType, controllerOrBus, unit);\n        } else {\n            virBufferAsprintf(buffer, \"%s%d:%d.fileName = \\\"%s\\\"\\n\",\n                              busType, controllerOrBus, unit, src);\n        }\n    }\n\n    if (def->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (def->cachemode == VIR_DOMAIN_DISK_CACHE_WRITETHRU) {\n            virBufferAsprintf(buffer, \"%s%d:%d.writeThrough = \\\"true\\\"\\n\",\n                              busType, controllerOrBus, unit);\n        } else if (def->cachemode != VIR_DOMAIN_DISK_CACHE_DEFAULT) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"%s harddisk '%s' has unsupported cache mode '%s'\"),\n                           busType, def->dst,\n                           virDomainDiskCacheTypeToString(def->cachemode));\n            return -1;\n        }\n    }\n\n    if (def->transient)\n        virBufferAsprintf(buffer,\n                          \"%s%d:%d.mode = \\\"independent-nonpersistent\\\"\\n\",\n                          busType, controllerOrBus, unit);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatDisk(virVMXContext *ctx, virDomainDiskDefPtr def,\n                 virBufferPtr buffer)\n{\n    int controllerOrBus, unit;\n    const char *vmxDeviceType = NULL;\n    char *fileName = NULL;\n    int type = virDomainDiskGetType(def);\n\n    /* Convert a handful of types to their string values */\n    const char *busType = virDomainDiskBusTypeToString(def->bus);\n    const char *deviceType = virDomainDeviceTypeToString(def->device);\n    const char *diskType = virDomainDeviceTypeToString(type);\n\n    /* If we are dealing with a disk its a .vmdk, otherwise it must be\n     * an ISO.\n     */\n    const char *fileExt = (def->device == VIR_DOMAIN_DISK_DEVICE_DISK) ?\n                           \".vmdk\" : \".iso\";\n\n    /* Check that we got a valid device type */\n    if (def->device != VIR_DOMAIN_DISK_DEVICE_DISK &&\n        def->device != VIR_DOMAIN_DISK_DEVICE_CDROM &&\n        def->device != VIR_DOMAIN_DISK_DEVICE_LUN) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device type supplied: %s\"), deviceType);\n        return -1;\n    }\n\n    /* We only support type='file' and type='block' */\n    if (type != VIR_STORAGE_TYPE_FILE &&\n        type != VIR_STORAGE_TYPE_BLOCK) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"%s %s '%s' has unsupported type '%s', expecting \"\n                         \"'%s' or '%s'\"), busType, deviceType, def->dst,\n                       diskType,\n                       virStorageTypeToString(VIR_STORAGE_TYPE_FILE),\n                       virStorageTypeToString(VIR_STORAGE_TYPE_BLOCK));\n        return -1;\n    }\n\n    if (def->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (virVMXSCSIDiskNameToControllerAndUnit(def->dst, &controllerOrBus,\n                                                  &unit) < 0) {\n            return -1;\n        }\n    } else if (def->bus == VIR_DOMAIN_DISK_BUS_IDE) {\n        if (virVMXIDEDiskNameToBusAndUnit(def->dst, &controllerOrBus,\n                                          &unit) < 0) {\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported bus type '%s' for %s\"),\n                       busType, deviceType);\n        return -1;\n    }\n\n    if (def->device == VIR_DOMAIN_DISK_DEVICE_DISK &&\n        type == VIR_STORAGE_TYPE_FILE) {\n        vmxDeviceType = (def->bus == VIR_DOMAIN_DISK_BUS_SCSI) ?\n                        \"scsi-hardDisk\" : \"ata-hardDisk\";\n    } else if (def->device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n        if (type == VIR_STORAGE_TYPE_FILE)\n            vmxDeviceType = \"cdrom-image\";\n        else\n            vmxDeviceType = \"atapi-cdrom\";\n    } else if (def->device == VIR_DOMAIN_DISK_DEVICE_LUN) {\n        const char *src = virDomainDiskGetSource(def);\n\n        if (def->bus == VIR_DOMAIN_DISK_BUS_SCSI &&\n            src && STRPREFIX(src, \"/vmfs/devices/cdrom/\"))\n            vmxDeviceType = \"scsi-passthru\";\n        else\n            vmxDeviceType = \"cdrom-raw\";\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"%s %s '%s' has an unsupported type '%s'\"),\n                       busType, deviceType, def->dst, diskType);\n        return -1;\n    }\n\n    virBufferAsprintf(buffer, \"%s%d:%d.present = \\\"true\\\"\\n\",\n                      busType, controllerOrBus, unit);\n    virBufferAsprintf(buffer, \"%s%d:%d.deviceType = \\\"%s\\\"\\n\",\n                      busType, controllerOrBus, unit, vmxDeviceType);\n\n    if (type == VIR_STORAGE_TYPE_FILE) {\n        const char *src = virDomainDiskGetSource(def);\n\n        if (src) {\n            if (!virStringHasCaseSuffix(src, fileExt)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Image file for %s %s '%s' has \"\n                                 \"unsupported suffix, expecting '%s'\"),\n                               busType, deviceType, def->dst, fileExt);\n                return -1;\n            }\n\n            fileName = ctx->formatFileName(src, ctx->opaque);\n        } else if (def->device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n            fileName = g_strdup(\"emptyBackingString\");\n        }\n\n        if (fileName == NULL)\n            return -1;\n\n        virBufferAsprintf(buffer, \"%s%d:%d.fileName = \\\"%s\\\"\\n\",\n                          busType, controllerOrBus, unit, fileName);\n\n        VIR_FREE(fileName);\n    } else if (type == VIR_STORAGE_TYPE_BLOCK) {\n        const char *src = virDomainDiskGetSource(def);\n\n        if (!src &&\n            def->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_OPTIONAL) {\n            virBufferAsprintf(buffer, \"%s%d:%d.autodetect = \\\"true\\\"\\n\",\n                              busType, controllerOrBus, unit);\n            virBufferAsprintf(buffer, \"%s%d:%d.fileName = \\\"auto detect\\\"\\n\",\n                              busType, controllerOrBus, unit);\n        } else {\n            virBufferAsprintf(buffer, \"%s%d:%d.fileName = \\\"%s\\\"\\n\",\n                              busType, controllerOrBus, unit, src);\n        }\n    }\n\n    if (def->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (def->cachemode == VIR_DOMAIN_DISK_CACHE_WRITETHRU) {\n            virBufferAsprintf(buffer, \"%s%d:%d.writeThrough = \\\"true\\\"\\n\",\n                              busType, controllerOrBus, unit);\n        } else if (def->cachemode != VIR_DOMAIN_DISK_CACHE_DEFAULT) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"%s harddisk '%s' has unsupported cache mode '%s'\"),\n                           busType, def->dst,\n                           virDomainDiskCacheTypeToString(def->cachemode));\n            return -1;\n        }\n    }\n\n    if (def->transient)\n        virBufferAsprintf(buffer,\n                          \"%s%d:%d.mode = \\\"independent-nonpersistent\\\"\\n\",\n                          busType, controllerOrBus, unit);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXControllerModelSCSITypeToString",
          "args": [
            "scsi_virtualDev[i]"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGatherSCSIControllers",
          "args": [
            "ctx",
            "def",
            "scsi_virtualDev",
            "scsi_present"
          ],
          "line": 3312
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGatherSCSIControllers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "1138-1237",
          "snippet": "static int\nvirVMXGatherSCSIControllers(virVMXContext *ctx, virDomainDefPtr def,\n                            int virtualDev[4], bool present[4])\n{\n    int result = -1;\n    size_t i, k;\n    virDomainDiskDefPtr disk;\n    virDomainControllerDefPtr controller;\n    bool controllerHasDisksAttached;\n    int count = 0;\n    int *autodetectedModels;\n\n    if (VIR_ALLOC_N(autodetectedModels, def->ndisks) < 0)\n        return -1;\n\n    for (i = 0; i < def->ncontrollers; ++i) {\n        controller = def->controllers[i];\n\n        if (controller->type != VIR_DOMAIN_CONTROLLER_TYPE_SCSI) {\n            /* skip non-SCSI controllers */\n            continue;\n        }\n\n        controllerHasDisksAttached = false;\n\n        for (k = 0; k < def->ndisks; ++k) {\n            disk = def->disks[k];\n\n            if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI &&\n                disk->info.addr.drive.controller == controller->idx) {\n                controllerHasDisksAttached = true;\n                break;\n            }\n        }\n\n        if (! controllerHasDisksAttached) {\n            /* skip SCSI controllers without attached disks */\n            continue;\n        }\n\n        if (controller->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO &&\n            ctx->autodetectSCSIControllerModel != NULL) {\n            count = 0;\n\n            /* try to autodetect the SCSI controller model by collecting\n             * SCSI controller model of all disks attached to this controller */\n            for (k = 0; k < def->ndisks; ++k) {\n                disk = def->disks[k];\n\n                if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI &&\n                    disk->info.addr.drive.controller == controller->idx) {\n                    if (ctx->autodetectSCSIControllerModel\n                               (disk, &autodetectedModels[count],\n                                ctx->opaque) < 0) {\n                        goto cleanup;\n                    }\n\n                    ++count;\n                }\n            }\n\n            /* autodetection fails when the disks attached to one controller\n             * have inconsistent SCSI controller models */\n            for (k = 0; k < count; ++k) {\n                if (autodetectedModels[k] != autodetectedModels[0]) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Disks on SCSI controller %d have inconsistent \"\n                                     \"controller models, cannot autodetect model\"),\n                                   controller->idx);\n                    goto cleanup;\n                }\n            }\n\n            controller->model = autodetectedModels[0];\n        }\n\n        if (controller->model != -1 &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068 &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML attribute 'model' of entry \"\n                             \"'controller' to be 'buslogic' or 'lsilogic' or \"\n                             \"'lsisas1068' or 'vmpvscsi' but found '%s'\"),\n                           virDomainControllerModelSCSITypeToString(controller->model));\n            goto cleanup;\n        }\n\n        present[controller->idx] = true;\n        virtualDev[controller->idx] = controller->model;\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(autodetectedModels);\n\n    return result;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGatherSCSIControllers(virVMXContext *ctx, virDomainDefPtr def,\n                            int virtualDev[4], bool present[4])\n{\n    int result = -1;\n    size_t i, k;\n    virDomainDiskDefPtr disk;\n    virDomainControllerDefPtr controller;\n    bool controllerHasDisksAttached;\n    int count = 0;\n    int *autodetectedModels;\n\n    if (VIR_ALLOC_N(autodetectedModels, def->ndisks) < 0)\n        return -1;\n\n    for (i = 0; i < def->ncontrollers; ++i) {\n        controller = def->controllers[i];\n\n        if (controller->type != VIR_DOMAIN_CONTROLLER_TYPE_SCSI) {\n            /* skip non-SCSI controllers */\n            continue;\n        }\n\n        controllerHasDisksAttached = false;\n\n        for (k = 0; k < def->ndisks; ++k) {\n            disk = def->disks[k];\n\n            if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI &&\n                disk->info.addr.drive.controller == controller->idx) {\n                controllerHasDisksAttached = true;\n                break;\n            }\n        }\n\n        if (! controllerHasDisksAttached) {\n            /* skip SCSI controllers without attached disks */\n            continue;\n        }\n\n        if (controller->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO &&\n            ctx->autodetectSCSIControllerModel != NULL) {\n            count = 0;\n\n            /* try to autodetect the SCSI controller model by collecting\n             * SCSI controller model of all disks attached to this controller */\n            for (k = 0; k < def->ndisks; ++k) {\n                disk = def->disks[k];\n\n                if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI &&\n                    disk->info.addr.drive.controller == controller->idx) {\n                    if (ctx->autodetectSCSIControllerModel\n                               (disk, &autodetectedModels[count],\n                                ctx->opaque) < 0) {\n                        goto cleanup;\n                    }\n\n                    ++count;\n                }\n            }\n\n            /* autodetection fails when the disks attached to one controller\n             * have inconsistent SCSI controller models */\n            for (k = 0; k < count; ++k) {\n                if (autodetectedModels[k] != autodetectedModels[0]) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Disks on SCSI controller %d have inconsistent \"\n                                     \"controller models, cannot autodetect model\"),\n                                   controller->idx);\n                    goto cleanup;\n                }\n            }\n\n            controller->model = autodetectedModels[0];\n        }\n\n        if (controller->model != -1 &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068 &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML attribute 'model' of entry \"\n                             \"'controller' to be 'buslogic' or 'lsilogic' or \"\n                             \"'lsisas1068' or 'vmpvscsi' but found '%s'\"),\n                           virDomainControllerModelSCSITypeToString(controller->model));\n            goto cleanup;\n        }\n\n        present[controller->idx] = true;\n        virtualDev[controller->idx] = controller->model;\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(autodetectedModels);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXHandleLegacySCSIDiskDriverName",
          "args": [
            "def",
            "def->disks[i]"
          ],
          "line": 3307
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXHandleLegacySCSIDiskDriverName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "1079-1134",
          "snippet": "static int\nvirVMXHandleLegacySCSIDiskDriverName(virDomainDefPtr def,\n                                     virDomainDiskDefPtr disk)\n{\n    char *tmp;\n    int model;\n    size_t i;\n    virDomainControllerDefPtr controller = NULL;\n    const char *driver = virDomainDiskGetDriver(disk);\n    char *copy;\n\n    if (disk->bus != VIR_DOMAIN_DISK_BUS_SCSI || !driver)\n        return 0;\n\n    copy = g_strdup(driver);\n    tmp = copy;\n\n    for (; *tmp != '\\0'; ++tmp)\n        *tmp = g_ascii_tolower(*tmp);\n\n    model = virDomainControllerModelSCSITypeFromString(copy);\n    VIR_FREE(copy);\n\n    if (model < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown driver name '%s'\"), driver);\n        return -1;\n    }\n\n    for (i = 0; i < def->ncontrollers; ++i) {\n        if (def->controllers[i]->idx == disk->info.addr.drive.controller) {\n            controller = def->controllers[i];\n            break;\n        }\n    }\n\n    if (controller == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing SCSI controller for index %d\"),\n                       disk->info.addr.drive.controller);\n        return -1;\n    }\n\n    if (controller->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT) {\n        controller->model = model;\n    } else if (controller->model != model) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Inconsistent SCSI controller model ('%s' is not '%s') \"\n                         \"for SCSI controller index %d\"), driver,\n                       virDomainControllerModelSCSITypeToString(controller->model),\n                       controller->idx);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXHandleLegacySCSIDiskDriverName(virDomainDefPtr def,\n                                     virDomainDiskDefPtr disk)\n{\n    char *tmp;\n    int model;\n    size_t i;\n    virDomainControllerDefPtr controller = NULL;\n    const char *driver = virDomainDiskGetDriver(disk);\n    char *copy;\n\n    if (disk->bus != VIR_DOMAIN_DISK_BUS_SCSI || !driver)\n        return 0;\n\n    copy = g_strdup(driver);\n    tmp = copy;\n\n    for (; *tmp != '\\0'; ++tmp)\n        *tmp = g_ascii_tolower(*tmp);\n\n    model = virDomainControllerModelSCSITypeFromString(copy);\n    VIR_FREE(copy);\n\n    if (model < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown driver name '%s'\"), driver);\n        return -1;\n    }\n\n    for (i = 0; i < def->ncontrollers; ++i) {\n        if (def->controllers[i]->idx == disk->info.addr.drive.controller) {\n            controller = def->controllers[i];\n            break;\n        }\n    }\n\n    if (controller == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing SCSI controller for index %d\"),\n                       disk->info.addr.drive.controller);\n        return -1;\n    }\n\n    if (controller->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT) {\n        controller->model = model;\n    } else if (controller->model != model) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Inconsistent SCSI controller model ('%s' is not '%s') \"\n                         \"for SCSI controller index %d\"), driver,\n                       virDomainControllerModelSCSITypeToString(controller->model),\n                       controller->idx);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXVerifyDiskAddress",
          "args": [
            "xmlopt",
            "def->disks[i]",
            "def"
          ],
          "line": 3306
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXVerifyDiskAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "966-1075",
          "snippet": "static int\nvirVMXVerifyDiskAddress(virDomainXMLOptionPtr xmlopt,\n                        virDomainDiskDefPtr disk,\n                        virDomainDefPtr vmdef)\n{\n    virDomainDiskDef def;\n    virDomainDeviceDriveAddressPtr drive;\n\n    memset(&def, 0, sizeof(def));\n\n    if (disk->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported disk address type '%s'\"),\n                       virDomainDeviceAddressTypeToString(disk->info.type));\n        return -1;\n    }\n\n    drive = &disk->info.addr.drive;\n\n    def.dst = disk->dst;\n    def.bus = disk->bus;\n\n    if (virDomainDiskDefAssignAddress(xmlopt, &def, vmdef) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not verify disk address\"));\n        return -1;\n    }\n\n    if (def.info.addr.drive.controller != drive->controller ||\n        def.info.addr.drive.bus != drive->bus ||\n        def.info.addr.drive.unit != drive->unit) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Disk address %d:%d:%d doesn't match target device '%s'\"),\n                       drive->controller, drive->bus, drive->unit, disk->dst);\n        return -1;\n    }\n\n    /* drive->{controller|bus|unit} is unsigned, no >= 0 checks are necessary */\n    if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (drive->controller > 3) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"SCSI controller index %d out of [0..3] range\"),\n                           drive->controller);\n            return -1;\n        }\n\n        if (drive->bus != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"SCSI bus index %d out of [0] range\"),\n                           drive->bus);\n            return -1;\n        }\n\n        if (drive->unit > 15 || drive->unit == 7) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"SCSI unit index %d out of [0..6,8..15] range\"),\n                           drive->unit);\n            return -1;\n        }\n    } else if (disk->bus == VIR_DOMAIN_DISK_BUS_IDE) {\n        if (drive->controller != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"IDE controller index %d out of [0] range\"),\n                           drive->controller);\n            return -1;\n        }\n\n        if (drive->bus > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"IDE bus index %d out of [0..1] range\"),\n                           drive->bus);\n            return -1;\n        }\n\n        if (drive->unit > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"IDE unit index %d out of [0..1] range\"),\n                           drive->unit);\n            return -1;\n        }\n    } else if (disk->bus == VIR_DOMAIN_DISK_BUS_FDC) {\n        if (drive->controller != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"FDC controller index %d out of [0] range\"),\n                           drive->controller);\n            return -1;\n        }\n\n        if (drive->bus != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"FDC bus index %d out of [0] range\"),\n                           drive->bus);\n            return -1;\n        }\n\n        if (drive->unit > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"FDC unit index %d out of [0..1] range\"),\n                           drive->unit);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported bus type '%s'\"),\n                       virDomainDiskBusTypeToString(disk->bus));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXVerifyDiskAddress(virDomainXMLOptionPtr xmlopt,\n                        virDomainDiskDefPtr disk,\n                        virDomainDefPtr vmdef)\n{\n    virDomainDiskDef def;\n    virDomainDeviceDriveAddressPtr drive;\n\n    memset(&def, 0, sizeof(def));\n\n    if (disk->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported disk address type '%s'\"),\n                       virDomainDeviceAddressTypeToString(disk->info.type));\n        return -1;\n    }\n\n    drive = &disk->info.addr.drive;\n\n    def.dst = disk->dst;\n    def.bus = disk->bus;\n\n    if (virDomainDiskDefAssignAddress(xmlopt, &def, vmdef) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not verify disk address\"));\n        return -1;\n    }\n\n    if (def.info.addr.drive.controller != drive->controller ||\n        def.info.addr.drive.bus != drive->bus ||\n        def.info.addr.drive.unit != drive->unit) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Disk address %d:%d:%d doesn't match target device '%s'\"),\n                       drive->controller, drive->bus, drive->unit, disk->dst);\n        return -1;\n    }\n\n    /* drive->{controller|bus|unit} is unsigned, no >= 0 checks are necessary */\n    if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (drive->controller > 3) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"SCSI controller index %d out of [0..3] range\"),\n                           drive->controller);\n            return -1;\n        }\n\n        if (drive->bus != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"SCSI bus index %d out of [0] range\"),\n                           drive->bus);\n            return -1;\n        }\n\n        if (drive->unit > 15 || drive->unit == 7) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"SCSI unit index %d out of [0..6,8..15] range\"),\n                           drive->unit);\n            return -1;\n        }\n    } else if (disk->bus == VIR_DOMAIN_DISK_BUS_IDE) {\n        if (drive->controller != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"IDE controller index %d out of [0] range\"),\n                           drive->controller);\n            return -1;\n        }\n\n        if (drive->bus > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"IDE bus index %d out of [0..1] range\"),\n                           drive->bus);\n            return -1;\n        }\n\n        if (drive->unit > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"IDE unit index %d out of [0..1] range\"),\n                           drive->unit);\n            return -1;\n        }\n    } else if (disk->bus == VIR_DOMAIN_DISK_BUS_FDC) {\n        if (drive->controller != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"FDC controller index %d out of [0] range\"),\n                           drive->controller);\n            return -1;\n        }\n\n        if (drive->bus != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"FDC bus index %d out of [0] range\"),\n                           drive->bus);\n            return -1;\n        }\n\n        if (drive->unit > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"FDC unit index %d out of [0..1] range\"),\n                           drive->unit);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported bus type '%s'\"),\n                       virDomainDiskBusTypeToString(disk->bus));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virDomainGraphicsType",
            "def->graphics[i]->type"
          ],
          "line": 3299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported graphics type '%s'\")",
            "virDomainGraphicsTypeToString(def->graphics[i]->type)"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsTypeToString",
          "args": [
            "def->graphics[i]->type"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXFormatVNC",
          "args": [
            "def->graphics[i]",
            "&buffer"
          ],
          "line": 3282
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXFormatVNC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "3457-3499",
          "snippet": "int\nvirVMXFormatVNC(virDomainGraphicsDefPtr def, virBufferPtr buffer)\n{\n    virDomainGraphicsListenDefPtr glisten;\n\n    if (def->type != VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virBufferAddLit(buffer, \"RemoteDisplay.vnc.enabled = \\\"true\\\"\\n\");\n\n    if (def->data.vnc.autoport) {\n        VIR_WARN(\"VNC autoport is enabled, but the automatically assigned \"\n                  \"VNC port cannot be read back\");\n    } else {\n        if (def->data.vnc.port < 5900 || def->data.vnc.port > 5964) {\n            VIR_WARN(\"VNC port %d it out of [5900..5964] range\",\n                     def->data.vnc.port);\n        }\n\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.port = \\\"%d\\\"\\n\",\n                          def->data.vnc.port);\n    }\n\n    if ((glisten = virDomainGraphicsGetListen(def, 0)) &&\n        glisten->address) {\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.ip = \\\"%s\\\"\\n\",\n                          glisten->address);\n    }\n\n    if (def->data.vnc.keymap != NULL) {\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.keymap = \\\"%s\\\"\\n\",\n                          def->data.vnc.keymap);\n    }\n\n    if (def->data.vnc.auth.passwd != NULL) {\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.password = \\\"%s\\\"\\n\",\n                          def->data.vnc.auth.passwd);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXFormatVNC(virDomainGraphicsDefPtr def, virBufferPtr buffer)\n{\n    virDomainGraphicsListenDefPtr glisten;\n\n    if (def->type != VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virBufferAddLit(buffer, \"RemoteDisplay.vnc.enabled = \\\"true\\\"\\n\");\n\n    if (def->data.vnc.autoport) {\n        VIR_WARN(\"VNC autoport is enabled, but the automatically assigned \"\n                  \"VNC port cannot be read back\");\n    } else {\n        if (def->data.vnc.port < 5900 || def->data.vnc.port > 5964) {\n            VIR_WARN(\"VNC port %d it out of [5900..5964] range\",\n                     def->data.vnc.port);\n        }\n\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.port = \\\"%d\\\"\\n\",\n                          def->data.vnc.port);\n    }\n\n    if ((glisten = virDomainGraphicsGetListen(def, 0)) &&\n        glisten->address) {\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.ip = \\\"%s\\\"\\n\",\n                          glisten->address);\n    }\n\n    if (def->data.vnc.keymap != NULL) {\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.keymap = \\\"%s\\\"\\n\",\n                          def->data.vnc.keymap);\n    }\n\n    if (def->data.vnc.auth.passwd != NULL) {\n        virBufferAsprintf(buffer, \"RemoteDisplay.vnc.password = \\\"%s\\\"\\n\",\n                          def->data.vnc.auth.passwd);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"sched.cpu.shares = \\\"high\\\"\\n\""
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"sched.cpu.shares = \\\"normal\\\"\\n\""
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"sched.cpu.shares = \\\"low\\\"\\n\""
          ],
          "line": 3267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpus",
          "args": [
            "def"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1912-1924",
          "snippet": "unsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"\\\"\\n\""
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddChar",
          "args": [
            "&buffer",
            "','"
          ],
          "line": 3254
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "206-210",
          "snippet": "void\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNextSetBit",
          "args": [
            "def->cpumask",
            "bit"
          ],
          "line": 3250
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextSetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "986-1014",
          "snippet": "ssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting domain XML attribute 'cpuset' of entry \"\n                             \"'vcpu' to contain at least %d CPU(s)\")",
            "maxvcpus"
          ],
          "line": 3242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"sched.cpu.affinity = \\\"\""
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSize",
          "args": [
            "def->cpumask"
          ],
          "line": 3231
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "882-886",
          "snippet": "size_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nsize_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting domain XML CPU sockets per core as %d \"\n                             \"but found %d\")",
            "maxvcpus",
            "calculated_vcpus"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Only 1 die per socket is supported\")"
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Only 1 thread per core is supported\")"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting domain XML CPU mode 'custom' but \"\n                             \"found '%s'\")",
            "virCPUModeTypeToString(def->cpu->mode)"
          ],
          "line": 3199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUModeTypeToString",
          "args": [
            "def->cpu->mode"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Expecting domain XML entry 'vcpu' to be greater \"\n                         \"than 0\")"
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpusMax",
          "args": [
            "def"
          ],
          "line": 3185
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpusMax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1882-1886",
          "snippet": "unsigned int\nvirDomainDefGetVcpusMax(const virDomainDef *def)\n{\n    return def->maxvcpus;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int\nvirDomainDefGetVcpusMax(const virDomainDef *def)\n{\n    return def->maxvcpus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"No support for domain XML entry 'vcpu' attribute \"\n                         \"'current'\")"
          ],
          "line": 3180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefHasVcpusOffline",
          "args": [
            "def"
          ],
          "line": 3179
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefHasVcpusOffline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1868-1879",
          "snippet": "bool\nvirDomainDefHasVcpusOffline(const virDomainDef *def)\n{\n    size_t i;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (!def->vcpus[i]->online)\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainDefHasVcpusOffline(const virDomainDef *def)\n{\n    size_t i;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (!def->vcpus[i]->online)\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "def->mem.min_guarantee",
            "1024"
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "def->mem.cur_balloon",
            "1024"
          ],
          "line": 3167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "virDomainDefGetMemoryTotal(def)",
            "4096"
          ],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetMemoryTotal",
          "args": [
            "def"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10946-10950",
          "snippet": "unsigned long long\nvirDomainDefGetMemoryTotal(const virDomainDef *def)\n{\n    return def->mem.total_memory;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned long long\nvirDomainDefGetMemoryTotal(const virDomainDef *def)\n{\n    return def->mem.total_memory;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXEscapeHexPipe",
          "args": [
            "def->description"
          ],
          "line": 3151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXEscapeHexPercent",
          "args": [
            "preliminaryDisplayName"
          ],
          "line": 3142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXEscapeHexPipe",
          "args": [
            "def->name"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"uuid.action = \\\"create\\\"\\n\""
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "def->uuid",
            "zero",
            "VIR_UUID_BUFLEN"
          ],
          "line": 3124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported SMBIOS mode '%s'\")",
            "virDomainSmbiosModeTypeToString(def->os.smbios_mode)"
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSmbiosModeTypeToString",
          "args": [
            "def->os.smbios_mode"
          ],
          "line": 3119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"smbios.reflecthost = \\\"true\\\"\\n\""
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting domain XML attribute 'arch' of entry 'os/type' \"\n                         \"to be 'i686' or 'x86_64' but found '%s'\")",
            "virArchToString(def->os.arch)"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "def->os.arch"
          ],
          "line": 3106
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"guestOS = \\\"other-64\\\"\\n\""
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"guestOS = \\\"other\\\"\\n\""
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"config.version = \\\"8\\\"\\n\""
          ],
          "line": 3091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\".encoding = \\\"UTF-8\\\"\\n\""
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting virt type to be '%s' but found '%s'\")",
            "virDomainVirtTypeToString(VIR_DOMAIN_VIRT_VMWARE)",
            "virDomainVirtTypeToString(def->virtType)"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtTypeToString",
          "args": [
            "def->virtType"
          ],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtTypeToString",
          "args": [
            "VIR_DOMAIN_VIRT_VMWARE"
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "zero",
            "0",
            "VIR_UUID_BUFLEN"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"virVMXContext has no formatFileName function set\")"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirVMXFormatConfig(virVMXContext *ctx, virDomainXMLOptionPtr xmlopt, virDomainDefPtr def,\n                   int virtualHW_version)\n{\n    char *vmx = NULL;\n    size_t i;\n    int sched_cpu_affinity_length;\n    unsigned char zero[VIR_UUID_BUFLEN];\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *preliminaryDisplayName = NULL;\n    char *displayName = NULL;\n    char *annotation = NULL;\n    unsigned long long max_balloon;\n    bool scsi_present[4] = { false, false, false, false };\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    bool floppy_present[2] = { false, false };\n    unsigned int maxvcpus;\n    bool hasSCSI = false;\n\n    if (ctx->formatFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no formatFileName function set\"));\n        return NULL;\n    }\n\n    memset(zero, 0, VIR_UUID_BUFLEN);\n\n    if (def->virtType != VIR_DOMAIN_VIRT_VMWARE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting virt type to be '%s' but found '%s'\"),\n                       virDomainVirtTypeToString(VIR_DOMAIN_VIRT_VMWARE),\n                       virDomainVirtTypeToString(def->virtType));\n        return NULL;\n    }\n\n    /* vmx:.encoding */\n    virBufferAddLit(&buffer, \".encoding = \\\"UTF-8\\\"\\n\");\n\n    /* vmx:config.version */\n    virBufferAddLit(&buffer, \"config.version = \\\"8\\\"\\n\");\n\n    /* vmx:virtualHW.version */\n    virBufferAsprintf(&buffer, \"virtualHW.version = \\\"%d\\\"\\n\",\n                      virtualHW_version);\n\n    /* def:os.arch -> vmx:guestOS */\n    if (def->os.arch == VIR_ARCH_I686) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other\\\"\\n\");\n    } else if (def->os.arch == VIR_ARCH_X86_64) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other-64\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting domain XML attribute 'arch' of entry 'os/type' \"\n                         \"to be 'i686' or 'x86_64' but found '%s'\"),\n                       virArchToString(def->os.arch));\n        goto cleanup;\n    }\n\n    /* def:os.smbios_mode -> vmx:smbios.reflecthost */\n    if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_NONE ||\n        def->os.smbios_mode == VIR_DOMAIN_SMBIOS_EMULATE) {\n        /* nothing */\n    } else if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_HOST) {\n        virBufferAddLit(&buffer, \"smbios.reflecthost = \\\"true\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported SMBIOS mode '%s'\"),\n                       virDomainSmbiosModeTypeToString(def->os.smbios_mode));\n        goto cleanup;\n    }\n\n    /* def:uuid -> vmx:uuid.action, vmx:uuid.bios */\n    if (memcmp(def->uuid, zero, VIR_UUID_BUFLEN) == 0) {\n        virBufferAddLit(&buffer, \"uuid.action = \\\"create\\\"\\n\");\n    } else {\n        virBufferAsprintf(&buffer, \"uuid.bios = \\\"%02x %02x %02x %02x %02x %02x \"\n                          \"%02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\\\"\\n\",\n                          def->uuid[0], def->uuid[1], def->uuid[2], def->uuid[3],\n                          def->uuid[4], def->uuid[5], def->uuid[6], def->uuid[7],\n                          def->uuid[8], def->uuid[9], def->uuid[10], def->uuid[11],\n                          def->uuid[12], def->uuid[13], def->uuid[14],\n                          def->uuid[15]);\n    }\n\n    /* def:name -> vmx:displayName */\n    preliminaryDisplayName = virVMXEscapeHexPipe(def->name);\n\n    if (preliminaryDisplayName == NULL)\n        goto cleanup;\n\n    displayName = virVMXEscapeHexPercent(preliminaryDisplayName);\n\n    if (displayName == NULL)\n        goto cleanup;\n\n    virBufferAsprintf(&buffer, \"displayName = \\\"%s\\\"\\n\", displayName);\n\n    /* def:description -> vmx:annotation */\n    if (def->description != NULL) {\n        if (!(annotation = virVMXEscapeHexPipe(def->description)))\n            goto cleanup;\n\n        virBufferAsprintf(&buffer, \"annotation = \\\"%s\\\"\\n\", annotation);\n    }\n\n    /* def:mem.max_balloon -> vmx:memsize */\n    /* max-memory must be a multiple of 4096 kilobyte */\n    max_balloon = VIR_DIV_UP(virDomainDefGetMemoryTotal(def), 4096) * 4096;\n\n    virBufferAsprintf(&buffer, \"memsize = \\\"%llu\\\"\\n\",\n                      max_balloon / 1024); /* Scale from kilobytes to megabytes */\n\n    /* def:mem.cur_balloon -> vmx:sched.mem.max */\n    if (def->mem.cur_balloon < max_balloon) {\n        virBufferAsprintf(&buffer, \"sched.mem.max = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.cur_balloon,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:mem.min_guarantee -> vmx:sched.mem.minsize */\n    if (def->mem.min_guarantee > 0) {\n        virBufferAsprintf(&buffer, \"sched.mem.minsize = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.min_guarantee,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:maxvcpus -> vmx:numvcpus */\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"No support for domain XML entry 'vcpu' attribute \"\n                         \"'current'\"));\n        goto cleanup;\n    }\n    maxvcpus = virDomainDefGetVcpusMax(def);\n    if (maxvcpus == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML entry 'vcpu' to be greater \"\n                         \"than 0\"));\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"numvcpus = \\\"%d\\\"\\n\", maxvcpus);\n\n    if (def->cpu) {\n        unsigned int calculated_vcpus;\n\n        if (def->cpu->mode != VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU mode 'custom' but \"\n                             \"found '%s'\"),\n                           virCPUModeTypeToString(def->cpu->mode));\n            goto cleanup;\n        }\n\n        if (def->cpu->threads != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 thread per core is supported\"));\n            goto cleanup;\n        }\n\n        if (def->cpu->dies != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 die per socket is supported\"));\n            goto cleanup;\n        }\n\n        calculated_vcpus = def->cpu->sockets * def->cpu->cores;\n        if (calculated_vcpus != maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU sockets per core as %d \"\n                             \"but found %d\"),\n                           maxvcpus, calculated_vcpus);\n            goto cleanup;\n        }\n\n        virBufferAsprintf(&buffer, \"cpuid.coresPerSocket = \\\"%d\\\"\\n\", def->cpu->cores);\n    }\n\n    /* def:cpumask -> vmx:sched.cpu.affinity */\n    if (def->cpumask && virBitmapSize(def->cpumask) > 0) {\n        int bit;\n        virBufferAddLit(&buffer, \"sched.cpu.affinity = \\\"\");\n\n        sched_cpu_affinity_length = 0;\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0)\n            ++sched_cpu_affinity_length;\n\n        if (sched_cpu_affinity_length < maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML attribute 'cpuset' of entry \"\n                             \"'vcpu' to contain at least %d CPU(s)\"),\n                           maxvcpus);\n            goto cleanup;\n        }\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0) {\n            virBufferAsprintf(&buffer, \"%d\", bit);\n\n            if (sched_cpu_affinity_length > 1)\n                virBufferAddChar(&buffer, ',');\n\n            --sched_cpu_affinity_length;\n        }\n\n        virBufferAddLit(&buffer, \"\\\"\\n\");\n    }\n\n    /* def:cputune.shares -> vmx:sched.cpu.shares */\n    if (def->cputune.sharesSpecified) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (def->cputune.shares == vcpus * 500) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"low\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 1000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"normal\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 2000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"high\\\"\\n\");\n        } else {\n            virBufferAsprintf(&buffer, \"sched.cpu.shares = \\\"%llu\\\"\\n\",\n                              def->cputune.shares);\n        }\n    }\n\n    /* def:graphics */\n    for (i = 0; i < def->ngraphics; ++i) {\n        switch (def->graphics[i]->type) {\n          case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n            if (virVMXFormatVNC(def->graphics[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n          case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n          case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported graphics type '%s'\"),\n                           virDomainGraphicsTypeToString(def->graphics[i]->type));\n            goto cleanup;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n          default:\n              virReportEnumRangeError(virDomainGraphicsType, def->graphics[i]->type);\n              goto cleanup;\n        }\n    }\n\n    /* def:disks */\n    for (i = 0; i < def->ndisks; ++i) {\n        if (virVMXVerifyDiskAddress(xmlopt, def->disks[i], def) < 0 ||\n            virVMXHandleLegacySCSIDiskDriverName(def, def->disks[i]) < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (virVMXGatherSCSIControllers(ctx, def, scsi_virtualDev,\n                                    scsi_present) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < 4; ++i) {\n        if (scsi_present[i]) {\n            hasSCSI = true;\n\n            virBufferAsprintf(&buffer, \"scsi%zu.present = \\\"true\\\"\\n\", i);\n\n            if (scsi_virtualDev[i] != -1) {\n                virBufferAsprintf(&buffer, \"scsi%zu.virtualDev = \\\"%s\\\"\\n\", i,\n                                  virVMXControllerModelSCSITypeToString\n                                    (scsi_virtualDev[i]));\n            }\n        }\n    }\n\n    for (i = 0; i < def->ndisks; ++i) {\n        switch (def->disks[i]->device) {\n          case VIR_DOMAIN_DISK_DEVICE_DISK:\n          case VIR_DOMAIN_DISK_DEVICE_CDROM:\n          case VIR_DOMAIN_DISK_DEVICE_LUN:\n            if (virVMXFormatDisk(ctx, def->disks[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_DISK_DEVICE_FLOPPY:\n            if (virVMXFormatFloppy(ctx, def->disks[i], &buffer,\n                                   floppy_present) < 0) {\n                goto cleanup;\n            }\n\n            break;\n\n          default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported disk device type '%s'\"),\n                           virDomainDiskDeviceTypeToString(def->disks[i]->device));\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < 2; ++i) {\n        /* floppy[0..1].present defaults to true, disable it explicitly */\n        if (! floppy_present[i])\n            virBufferAsprintf(&buffer, \"floppy%zu.present = \\\"false\\\"\\n\", i);\n    }\n\n    /* def:fss */\n    if (def->nfss > 0) {\n        virBufferAddLit(&buffer, \"isolation.tools.hgfs.disable = \\\"false\\\"\\n\");\n        virBufferAsprintf(&buffer, \"sharedFolder.maxNum = \\\"%zu\\\"\\n\", def->nfss);\n    }\n\n    for (i = 0; i < def->nfss; ++i) {\n        if (virVMXFormatFileSystem(def->fss[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:nets */\n    for (i = 0; i < def->nnets; ++i) {\n        if (virVMXFormatEthernet(def->nets[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:videos */\n    if (def->nvideos > 0) {\n        if (def->nvideos > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No support for multiple video devices\"));\n            goto cleanup;\n        }\n\n        if (virVMXFormatSVGA(def->videos[0], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    for (i = 0; i < def->nserials; ++i) {\n        if (virVMXFormatSerial(ctx, def->serials[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:parallels */\n    for (i = 0; i < def->nparallels; ++i) {\n        if (virVMXFormatParallel(ctx, def->parallels[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* vmx:firmware */\n    if (def->os.firmware == VIR_DOMAIN_OS_DEF_FIRMWARE_EFI)\n        virBufferAddLit(&buffer, \"firmware = \\\"efi\\\"\\n\");\n\n    if (virtualHW_version >= 7) {\n        if (hasSCSI) {\n            virBufferAddLit(&buffer, \"pciBridge0.present = \\\"true\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge4.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge5.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge6.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge7.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.functions = \\\"8\\\"\\n\");\n        }\n\n        virBufferAddLit(&buffer, \"vmci0.present = \\\"true\\\"\\n\");\n    }\n\n    /* Get final VMX output */\n    vmx = virBufferContentAndReset(&buffer);\n\n cleanup:\n    if (vmx == NULL)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(preliminaryDisplayName);\n    VIR_FREE(displayName);\n    VIR_FREE(annotation);\n\n    return vmx;\n}"
  },
  {
    "function_name": "virVMXParseSVGA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "3011-3044",
    "snippet": "int\nvirVMXParseSVGA(virConfPtr conf, virDomainVideoDefPtr *def)\n{\n    int result = -1;\n    long long svga_vramSize = 0;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(*def) < 0)\n        return -1;\n\n    (*def)->type = VIR_DOMAIN_VIDEO_TYPE_VMVGA;\n\n    /* vmx:vramSize */\n    if (virVMXGetConfigLong(conf, \"svga.vramSize\", &svga_vramSize,\n                            4 * 1024 * 1024, true) < 0) {\n        goto cleanup;\n    }\n\n    (*def)->vram = VIR_DIV_UP(svga_vramSize, 1024); /* Scale from bytes to kilobytes */\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainVideoDefFree(*def);\n        *def = NULL;\n    }\n\n    return result;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainVideoDefFree",
          "args": [
            "*def"
          ],
          "line": 3039
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainVideoDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2879-2886",
          "snippet": "void virDomainVideoDefFree(virDomainVideoDefPtr def)\n{\n    if (!def)\n        return;\n\n    virDomainVideoDefClear(def);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def)\n{\n    if (!def)\n        return;\n\n    virDomainVideoDefClear(def);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "svga_vramSize",
            "1024"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigLong",
          "args": [
            "conf",
            "\"svga.vramSize\"",
            "&svga_vramSize",
            "4 * 1024 * 1024",
            "true"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "792-820",
          "snippet": "static int\nvirVMXGetConfigLong(virConfPtr conf, const char *name, long long *number,\n                    long long default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *number = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"unlimited\")) {\n        *number = -1;\n    } else if (virStrToLong_ll(string, NULL, 10, number) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Config entry '%s' must represent an integer value\"),\n                name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigLong(virConfPtr conf, const char *name, long long *number,\n                    long long default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *number = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"unlimited\")) {\n        *number = -1;\n    } else if (virStrToLong_ll(string, NULL, 10, number) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Config entry '%s' must represent an integer value\"),\n                name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "*def"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid argument\""
          ],
          "line": 3018
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXParseSVGA(virConfPtr conf, virDomainVideoDefPtr *def)\n{\n    int result = -1;\n    long long svga_vramSize = 0;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(*def) < 0)\n        return -1;\n\n    (*def)->type = VIR_DOMAIN_VIDEO_TYPE_VMVGA;\n\n    /* vmx:vramSize */\n    if (virVMXGetConfigLong(conf, \"svga.vramSize\", &svga_vramSize,\n                            4 * 1024 * 1024, true) < 0) {\n        goto cleanup;\n    }\n\n    (*def)->vram = VIR_DIV_UP(svga_vramSize, 1024); /* Scale from bytes to kilobytes */\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainVideoDefFree(*def);\n        *def = NULL;\n    }\n\n    return result;\n}"
  },
  {
    "function_name": "virVMXParseParallel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "2909-3007",
    "snippet": "int\nvirVMXParseParallel(virVMXContext *ctx, virConfPtr conf, int port,\n                    virDomainChrDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char startConnected_name[48] = \"\";\n    bool startConnected = false;\n\n    char fileType_name[48] = \"\";\n    char *fileType = NULL;\n\n    char fileName_name[48] = \"\";\n    char *fileName = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (port < 0 || port > 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Parallel port index %d out of [0..2] range\"), port);\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"parallel%d\", port);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(fileType);\n    VMX_BUILD_NAME(fileName);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        return -1;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        return 0;\n\n    if (!(*def = virDomainChrDefNew(NULL)))\n        return -1;\n\n    (*def)->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_PARALLEL;\n\n    /* vmx:fileType -> def:type */\n    if (virVMXGetConfigString(conf, fileType_name, &fileType, false) < 0)\n        goto cleanup;\n\n    /* vmx:fileName -> def:data.file.path */\n    if (virVMXGetConfigString(conf, fileName_name, &fileName, false) < 0)\n        goto cleanup;\n\n    /* Setup virDomainChrDef */\n    if (STRCASEEQ(fileType, \"device\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        (*def)->source->data.file.path = fileName;\n\n        fileName = NULL;\n    } else if (STRCASEEQ(fileType, \"file\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n        (*def)->source->data.file.path = ctx->parseFileName(fileName,\n                                                            ctx->opaque);\n\n        if ((*def)->source->data.file.path == NULL)\n            goto cleanup;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry '%s' to be 'device' or 'file' but \"\n                         \"found '%s'\"), fileType_name, fileType);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainChrDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(fileType);\n    VIR_FREE(fileName);\n\n    return result;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileName"
          ],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileType"
          ],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrDefFree",
          "args": [
            "*def"
          ],
          "line": 2999
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2706-2733",
          "snippet": "void virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry '%s' to be 'device' or 'file' but \"\n                         \"found '%s'\")",
            "fileType_name",
            "fileType"
          ],
          "line": 2989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Expecting VMX entry '%s' to be 'device' or 'file' but \"\n                         \"found '%s'\""
          ],
          "line": 2990
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctx->parseFileName",
          "args": [
            "fileName",
            "ctx->opaque"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "fileType",
            "\"file\""
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "fileType",
            "\"device\""
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigString",
          "args": [
            "conf",
            "fileName_name",
            "&fileName",
            "false"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "750-760",
          "snippet": "static int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainChrDefNew",
          "args": [
            "NULL"
          ],
          "line": 2960
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "13232-13246",
          "snippet": "virDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigBoolean",
          "args": [
            "conf",
            "startConnected_name",
            "&startConnected",
            "true",
            "true"
          ],
          "line": 2951
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "824-854",
          "snippet": "static int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "fileName"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "fileType"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "startConnected"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "present"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "prefix",
            "sizeof(prefix)",
            "\"parallel%d\"",
            "port"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Parallel port index %d out of [0..2] range\")",
            "port"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXParseParallel(virVMXContext *ctx, virConfPtr conf, int port,\n                    virDomainChrDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char startConnected_name[48] = \"\";\n    bool startConnected = false;\n\n    char fileType_name[48] = \"\";\n    char *fileType = NULL;\n\n    char fileName_name[48] = \"\";\n    char *fileName = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (port < 0 || port > 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Parallel port index %d out of [0..2] range\"), port);\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"parallel%d\", port);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(fileType);\n    VMX_BUILD_NAME(fileName);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        return -1;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        return 0;\n\n    if (!(*def = virDomainChrDefNew(NULL)))\n        return -1;\n\n    (*def)->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_PARALLEL;\n\n    /* vmx:fileType -> def:type */\n    if (virVMXGetConfigString(conf, fileType_name, &fileType, false) < 0)\n        goto cleanup;\n\n    /* vmx:fileName -> def:data.file.path */\n    if (virVMXGetConfigString(conf, fileName_name, &fileName, false) < 0)\n        goto cleanup;\n\n    /* Setup virDomainChrDef */\n    if (STRCASEEQ(fileType, \"device\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        (*def)->source->data.file.path = fileName;\n\n        fileName = NULL;\n    } else if (STRCASEEQ(fileType, \"file\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n        (*def)->source->data.file.path = ctx->parseFileName(fileName,\n                                                            ctx->opaque);\n\n        if ((*def)->source->data.file.path == NULL)\n            goto cleanup;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry '%s' to be 'device' or 'file' but \"\n                         \"found '%s'\"), fileType_name, fileType);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainChrDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(fileType);\n    VIR_FREE(fileName);\n\n    return result;\n}"
  },
  {
    "function_name": "virVMXParseSerial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "2727-2905",
    "snippet": "int\nvirVMXParseSerial(virVMXContext *ctx, virConfPtr conf, int port,\n                  virDomainChrDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char startConnected_name[48] = \"\";\n    bool startConnected = false;\n\n    char fileType_name[48] = \"\";\n    char *fileType = NULL;\n\n    char fileName_name[48] = \"\";\n    char *fileName = NULL;\n\n    char network_endPoint_name[48] = \"\";\n    char *network_endPoint = NULL;\n\n    virURIPtr parsedUri = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (port < 0 || port > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Serial port index %d out of [0..3] range\"), port);\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"serial%d\", port);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(fileType);\n    VMX_BUILD_NAME(fileName);\n    VMX_BUILD_NAME_EXTRA(network_endPoint, \"network.endPoint\");\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        return -1;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        return 0;\n\n    if (!(*def = virDomainChrDefNew(NULL)))\n        return -1;\n\n    (*def)->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n\n    /* vmx:fileType -> def:type */\n    if (virVMXGetConfigString(conf, fileType_name, &fileType, true) < 0)\n        goto cleanup;\n\n    /* vmx:fileName -> def:data.file.path */\n    if (virVMXGetConfigString(conf, fileName_name, &fileName, true) < 0)\n        goto cleanup;\n\n    /* vmx:network.endPoint -> def:data.tcp.listen */\n    if (virVMXGetConfigString(conf, network_endPoint_name, &network_endPoint,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    /*\n     * Setup virDomainChrDef. The default fileType is \"device\", and vmware\n     * will sometimes omit this tag when adding a new serial port of this\n     * type.\n     */\n    if (!fileType || STRCASEEQ(fileType, \"device\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        (*def)->source->data.file.path = fileName;\n\n        fileName = NULL;\n    } else if (STRCASEEQ(fileType, \"file\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n        (*def)->source->data.file.path = ctx->parseFileName(fileName,\n                                                            ctx->opaque);\n\n        if ((*def)->source->data.file.path == NULL)\n            goto cleanup;\n    } else if (STRCASEEQ(fileType, \"pipe\")) {\n        /*\n         * FIXME: Differences between client/server and VM/application pipes\n         *        not representable in domain XML form\n         */\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_PIPE;\n        (*def)->source->data.file.path = fileName;\n\n        fileName = NULL;\n    } else if (STRCASEEQ(fileType, \"network\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_TCP;\n\n        if (!(parsedUri = virURIParse(fileName)))\n            goto cleanup;\n\n        if (parsedUri->port == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry '%s' doesn't contain a port part\"),\n                           fileName_name);\n            goto cleanup;\n        }\n\n        (*def)->source->data.tcp.host = g_strdup(parsedUri->server);\n\n        (*def)->source->data.tcp.service = g_strdup_printf(\"%d\", parsedUri->port);\n\n        /* See vSphere API documentation about VirtualSerialPortURIBackingInfo */\n        if (parsedUri->scheme == NULL ||\n            STRCASEEQ(parsedUri->scheme, \"tcp\") ||\n            STRCASEEQ(parsedUri->scheme, \"tcp4\") ||\n            STRCASEEQ(parsedUri->scheme, \"tcp6\")) {\n            (*def)->source->data.tcp.protocol = VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW;\n        } else if (STRCASEEQ(parsedUri->scheme, \"telnet\")) {\n            (*def)->source->data.tcp.protocol\n                = VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET;\n        } else if (STRCASEEQ(parsedUri->scheme, \"telnets\")) {\n            (*def)->source->data.tcp.protocol\n                = VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNETS;\n        } else if (STRCASEEQ(parsedUri->scheme, \"ssl\") ||\n                   STRCASEEQ(parsedUri->scheme, \"tcp+ssl\") ||\n                   STRCASEEQ(parsedUri->scheme, \"tcp4+ssl\") ||\n                   STRCASEEQ(parsedUri->scheme, \"tcp6+ssl\")) {\n            (*def)->source->data.tcp.protocol = VIR_DOMAIN_CHR_TCP_PROTOCOL_TLS;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry '%s' contains unsupported scheme '%s'\"),\n                           fileName_name, parsedUri->scheme);\n            goto cleanup;\n        }\n\n        if (network_endPoint == NULL || STRCASEEQ(network_endPoint, \"server\")) {\n            (*def)->source->data.tcp.listen = true;\n        } else if (STRCASEEQ(network_endPoint, \"client\")) {\n            (*def)->source->data.tcp.listen = false;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry '%s' to be 'server' or 'client' \"\n                             \"but found '%s'\"), network_endPoint_name, network_endPoint);\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry '%s' to be 'device', 'file' or 'pipe' \"\n                         \"or 'network' but found '%s'\"), fileType_name, fileType);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainChrDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(fileType);\n    VIR_FREE(fileName);\n    VIR_FREE(network_endPoint);\n    virURIFree(parsedUri);\n\n    return result;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virURIFree",
          "args": [
            "parsedUri"
          ],
          "line": 2902
        },
        "resolved": true,
        "details": {
          "function_name": "virURIFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "277-298",
          "snippet": "void virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvoid virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "network_endPoint"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileName"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileType"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrDefFree",
          "args": [
            "*def"
          ],
          "line": 2895
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2706-2733",
          "snippet": "void virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry '%s' to be 'device', 'file' or 'pipe' \"\n                         \"or 'network' but found '%s'\")",
            "fileType_name",
            "fileType"
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Expecting VMX entry '%s' to be 'device', 'file' or 'pipe' \"\n                         \"or 'network' but found '%s'\""
          ],
          "line": 2886
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry '%s' to be 'server' or 'client' \"\n                             \"but found '%s'\")",
            "network_endPoint_name",
            "network_endPoint"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "network_endPoint",
            "\"client\""
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "network_endPoint",
            "\"server\""
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"VMX entry '%s' contains unsupported scheme '%s'\")",
            "fileName_name",
            "parsedUri->scheme"
          ],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "parsedUri->scheme",
            "\"tcp6+ssl\""
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "parsedUri->scheme",
            "\"tcp4+ssl\""
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "parsedUri->scheme",
            "\"tcp+ssl\""
          ],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "parsedUri->scheme",
            "\"ssl\""
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "parsedUri->scheme",
            "\"telnets\""
          ],
          "line": 2859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "parsedUri->scheme",
            "\"telnet\""
          ],
          "line": 2856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "parsedUri->scheme",
            "\"tcp6\""
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "parsedUri->scheme",
            "\"tcp4\""
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "parsedUri->scheme",
            "\"tcp\""
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"VMX entry '%s' doesn't contain a port part\")",
            "fileName_name"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIParse",
          "args": [
            "fileName"
          ],
          "line": 2836
        },
        "resolved": true,
        "details": {
          "function_name": "virURIParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "143-194",
          "snippet": "virURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvirURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "fileType",
            "\"network\""
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "fileType",
            "\"pipe\""
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctx->parseFileName",
          "args": [
            "fileName",
            "ctx->opaque"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "fileType",
            "\"file\""
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "fileType",
            "\"device\""
          ],
          "line": 2808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigString",
          "args": [
            "conf",
            "network_endPoint_name",
            "&network_endPoint",
            "true"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "750-760",
          "snippet": "static int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainChrDefNew",
          "args": [
            "NULL"
          ],
          "line": 2784
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "13232-13246",
          "snippet": "virDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigBoolean",
          "args": [
            "conf",
            "startConnected_name",
            "&startConnected",
            "true",
            "true"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "824-854",
          "snippet": "static int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME_EXTRA",
          "args": [
            "network_endPoint",
            "\"network.endPoint\""
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "fileName"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "fileType"
          ],
          "line": 2766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "startConnected"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "present"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "prefix",
            "sizeof(prefix)",
            "\"serial%d\"",
            "port"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Serial port index %d out of [0..3] range\")",
            "port"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXParseSerial(virVMXContext *ctx, virConfPtr conf, int port,\n                  virDomainChrDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char startConnected_name[48] = \"\";\n    bool startConnected = false;\n\n    char fileType_name[48] = \"\";\n    char *fileType = NULL;\n\n    char fileName_name[48] = \"\";\n    char *fileName = NULL;\n\n    char network_endPoint_name[48] = \"\";\n    char *network_endPoint = NULL;\n\n    virURIPtr parsedUri = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (port < 0 || port > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Serial port index %d out of [0..3] range\"), port);\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"serial%d\", port);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(fileType);\n    VMX_BUILD_NAME(fileName);\n    VMX_BUILD_NAME_EXTRA(network_endPoint, \"network.endPoint\");\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        return -1;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        return 0;\n\n    if (!(*def = virDomainChrDefNew(NULL)))\n        return -1;\n\n    (*def)->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n\n    /* vmx:fileType -> def:type */\n    if (virVMXGetConfigString(conf, fileType_name, &fileType, true) < 0)\n        goto cleanup;\n\n    /* vmx:fileName -> def:data.file.path */\n    if (virVMXGetConfigString(conf, fileName_name, &fileName, true) < 0)\n        goto cleanup;\n\n    /* vmx:network.endPoint -> def:data.tcp.listen */\n    if (virVMXGetConfigString(conf, network_endPoint_name, &network_endPoint,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    /*\n     * Setup virDomainChrDef. The default fileType is \"device\", and vmware\n     * will sometimes omit this tag when adding a new serial port of this\n     * type.\n     */\n    if (!fileType || STRCASEEQ(fileType, \"device\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        (*def)->source->data.file.path = fileName;\n\n        fileName = NULL;\n    } else if (STRCASEEQ(fileType, \"file\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n        (*def)->source->data.file.path = ctx->parseFileName(fileName,\n                                                            ctx->opaque);\n\n        if ((*def)->source->data.file.path == NULL)\n            goto cleanup;\n    } else if (STRCASEEQ(fileType, \"pipe\")) {\n        /*\n         * FIXME: Differences between client/server and VM/application pipes\n         *        not representable in domain XML form\n         */\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_PIPE;\n        (*def)->source->data.file.path = fileName;\n\n        fileName = NULL;\n    } else if (STRCASEEQ(fileType, \"network\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_TCP;\n\n        if (!(parsedUri = virURIParse(fileName)))\n            goto cleanup;\n\n        if (parsedUri->port == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry '%s' doesn't contain a port part\"),\n                           fileName_name);\n            goto cleanup;\n        }\n\n        (*def)->source->data.tcp.host = g_strdup(parsedUri->server);\n\n        (*def)->source->data.tcp.service = g_strdup_printf(\"%d\", parsedUri->port);\n\n        /* See vSphere API documentation about VirtualSerialPortURIBackingInfo */\n        if (parsedUri->scheme == NULL ||\n            STRCASEEQ(parsedUri->scheme, \"tcp\") ||\n            STRCASEEQ(parsedUri->scheme, \"tcp4\") ||\n            STRCASEEQ(parsedUri->scheme, \"tcp6\")) {\n            (*def)->source->data.tcp.protocol = VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW;\n        } else if (STRCASEEQ(parsedUri->scheme, \"telnet\")) {\n            (*def)->source->data.tcp.protocol\n                = VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET;\n        } else if (STRCASEEQ(parsedUri->scheme, \"telnets\")) {\n            (*def)->source->data.tcp.protocol\n                = VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNETS;\n        } else if (STRCASEEQ(parsedUri->scheme, \"ssl\") ||\n                   STRCASEEQ(parsedUri->scheme, \"tcp+ssl\") ||\n                   STRCASEEQ(parsedUri->scheme, \"tcp4+ssl\") ||\n                   STRCASEEQ(parsedUri->scheme, \"tcp6+ssl\")) {\n            (*def)->source->data.tcp.protocol = VIR_DOMAIN_CHR_TCP_PROTOCOL_TLS;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry '%s' contains unsupported scheme '%s'\"),\n                           fileName_name, parsedUri->scheme);\n            goto cleanup;\n        }\n\n        if (network_endPoint == NULL || STRCASEEQ(network_endPoint, \"server\")) {\n            (*def)->source->data.tcp.listen = true;\n        } else if (STRCASEEQ(network_endPoint, \"client\")) {\n            (*def)->source->data.tcp.listen = false;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry '%s' to be 'server' or 'client' \"\n                             \"but found '%s'\"), network_endPoint_name, network_endPoint);\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry '%s' to be 'device', 'file' or 'pipe' \"\n                         \"or 'network' but found '%s'\"), fileType_name, fileType);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainChrDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(fileType);\n    VIR_FREE(fileName);\n    VIR_FREE(network_endPoint);\n    virURIFree(parsedUri);\n\n    return result;\n}"
  },
  {
    "function_name": "virVMXParseEthernet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "2514-2723",
    "snippet": "int\nvirVMXParseEthernet(virConfPtr conf, int controller, virDomainNetDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char startConnected_name[48] = \"\";\n    bool startConnected = false;\n\n    char connectionType_name[48] = \"\";\n    char *connectionType = NULL;\n\n    char addressType_name[48] = \"\";\n    char *addressType = NULL;\n\n    char generatedAddress_name[48] = \"\";\n    char *generatedAddress = NULL;\n\n    char address_name[48] = \"\";\n    char *address = NULL;\n\n    char virtualDev_name[48] = \"\";\n    char *virtualDev = NULL;\n\n    char features_name[48] = \"\";\n    long long features = 0;\n\n    char vnet_name[48] = \"\";\n    char *vnet = NULL;\n\n    char networkName_name[48] = \"\";\n    char *networkName = NULL;\n\n    int netmodel = VIR_DOMAIN_NET_MODEL_UNKNOWN;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"ethernet%d\", controller);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(connectionType);\n    VMX_BUILD_NAME(addressType);\n    VMX_BUILD_NAME(generatedAddress);\n    VMX_BUILD_NAME(address);\n    VMX_BUILD_NAME(virtualDev);\n    VMX_BUILD_NAME(features);\n    VMX_BUILD_NAME(networkName);\n    VMX_BUILD_NAME(vnet);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        return -1;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        return 0;\n\n    if (VIR_ALLOC(*def) < 0)\n        return -1;\n\n    /* vmx:connectionType -> def:type */\n    if (virVMXGetConfigString(conf, connectionType_name, &connectionType,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    /* vmx:addressType, vmx:generatedAddress, vmx:address -> def:mac */\n    if (virVMXGetConfigString(conf, addressType_name, &addressType,\n                              true) < 0 ||\n        virVMXGetConfigString(conf, generatedAddress_name, &generatedAddress,\n                              true) < 0 ||\n        virVMXGetConfigString(conf, address_name, &address, true) < 0) {\n        goto cleanup;\n    }\n\n    if (addressType == NULL || STRCASEEQ(addressType, \"generated\") ||\n        STRCASEEQ(addressType, \"vpx\")) {\n        if (generatedAddress != NULL) {\n            if (virMacAddrParse(generatedAddress, &(*def)->mac) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be MAC address but \"\n                                 \"found '%s'\"), generatedAddress_name,\n                               generatedAddress);\n                goto cleanup;\n            }\n        }\n    } else if (STRCASEEQ(addressType, \"static\")) {\n        if (address != NULL) {\n            if (virMacAddrParse(address, &(*def)->mac) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be MAC address but \"\n                                 \"found '%s'\"), address_name, address);\n                goto cleanup;\n            }\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry '%s' to be 'generated' or 'static' or \"\n                         \"'vpx' but found '%s'\"), addressType_name, addressType);\n        goto cleanup;\n    }\n\n    /* vmx:virtualDev, vmx:features -> def:model */\n    if (virVMXGetConfigString(conf, virtualDev_name, &virtualDev, true) < 0 ||\n        virVMXGetConfigLong(conf, features_name, &features, 0, true) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualDev != NULL) {\n        if (STRCASEEQ(virtualDev, \"vlance\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_VLANCE;\n        } else if (STRCASEEQ(virtualDev, \"vmxnet\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_VMXNET;\n        } else if (STRCASEEQ(virtualDev, \"vmxnet3\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_VMXNET3;\n        } else if (STRCASEEQ(virtualDev, \"e1000\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_E1000;\n        } else if (STRCASEEQ(virtualDev, \"e1000e\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_E1000E;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry '%s' to be 'vlance' or 'vmxnet' or \"\n                             \"'vmxnet3' or 'e1000' or 'e1000e' but found '%s'\"),\n                           virtualDev_name, virtualDev);\n            goto cleanup;\n        }\n\n        if (netmodel == VIR_DOMAIN_NET_MODEL_VMXNET && features == 15)\n            netmodel = VIR_DOMAIN_NET_MODEL_VMXNET2;\n    }\n\n    /* vmx:networkName -> def:data.bridge.brname */\n    if (connectionType == NULL ||\n        STRCASEEQ(connectionType, \"bridged\") ||\n        STRCASEEQ(connectionType, \"custom\")) {\n        if (virVMXGetConfigString(conf, networkName_name, &networkName,\n                                  true) < 0)\n            goto cleanup;\n\n        if (!networkName)\n            networkName = g_strdup(\"\");\n    }\n\n    /* vmx:vnet -> def:data.ifname */\n    if (connectionType != NULL && STRCASEEQ(connectionType, \"custom\") &&\n        virVMXGetConfigString(conf, vnet_name, &vnet, false) < 0) {\n        goto cleanup;\n    }\n\n    /* Setup virDomainNetDef */\n    if (connectionType == NULL || STRCASEEQ(connectionType, \"bridged\")) {\n        (*def)->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n        (*def)->data.bridge.brname = networkName;\n\n        networkName = NULL;\n    } else if (STRCASEEQ(connectionType, \"hostonly\")) {\n        /* FIXME */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No yet handled value '%s' for VMX entry '%s'\"),\n                       connectionType, connectionType_name);\n        goto cleanup;\n    } else if (STRCASEEQ(connectionType, \"nat\")) {\n        (*def)->type = VIR_DOMAIN_NET_TYPE_USER;\n\n    } else if (STRCASEEQ(connectionType, \"custom\")) {\n        (*def)->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n        (*def)->data.bridge.brname = networkName;\n        (*def)->ifname = vnet;\n\n        networkName = NULL;\n        vnet = NULL;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid value '%s' for VMX entry '%s'\"), connectionType,\n                       connectionType_name);\n        goto cleanup;\n    }\n\n    (*def)->model = netmodel;\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainNetDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(networkName);\n    VIR_FREE(connectionType);\n    VIR_FREE(addressType);\n    VIR_FREE(generatedAddress);\n    VIR_FREE(address);\n    VIR_FREE(virtualDev);\n    VIR_FREE(vnet);\n\n    return result;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vnet"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "virtualDev"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "address"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "generatedAddress"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addressType"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "connectionType"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "networkName"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetDefFree",
          "args": [
            "*def"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2481-2489",
          "snippet": "void\nvirDomainNetDefFree(virDomainNetDefPtr def)\n{\n    if (!def)\n        return;\n    virDomainNetDefClear(def);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainNetDefFree(virDomainNetDefPtr def)\n{\n    if (!def)\n        return;\n    virDomainNetDefClear(def);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid value '%s' for VMX entry '%s'\")",
            "connectionType",
            "connectionType_name"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid value '%s' for VMX entry '%s'\""
          ],
          "line": 2700
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "connectionType",
            "\"custom\""
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "connectionType",
            "\"nat\""
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"No yet handled value '%s' for VMX entry '%s'\")",
            "connectionType",
            "connectionType_name"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "connectionType",
            "\"hostonly\""
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "connectionType",
            "\"bridged\""
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigString",
          "args": [
            "conf",
            "vnet_name",
            "&vnet",
            "false"
          ],
          "line": 2672
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "750-760",
          "snippet": "static int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "connectionType",
            "\"custom\""
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "connectionType",
            "\"custom\""
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "connectionType",
            "\"bridged\""
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry '%s' to be 'vlance' or 'vmxnet' or \"\n                             \"'vmxnet3' or 'e1000' or 'e1000e' but found '%s'\")",
            "virtualDev_name",
            "virtualDev"
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "virtualDev",
            "\"e1000e\""
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "virtualDev",
            "\"e1000\""
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "virtualDev",
            "\"vmxnet3\""
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "virtualDev",
            "\"vmxnet\""
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "virtualDev",
            "\"vlance\""
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigLong",
          "args": [
            "conf",
            "features_name",
            "&features",
            "0",
            "true"
          ],
          "line": 2631
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "792-820",
          "snippet": "static int\nvirVMXGetConfigLong(virConfPtr conf, const char *name, long long *number,\n                    long long default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *number = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"unlimited\")) {\n        *number = -1;\n    } else if (virStrToLong_ll(string, NULL, 10, number) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Config entry '%s' must represent an integer value\"),\n                name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigLong(virConfPtr conf, const char *name, long long *number,\n                    long long default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *number = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"unlimited\")) {\n        *number = -1;\n    } else if (virStrToLong_ll(string, NULL, 10, number) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Config entry '%s' must represent an integer value\"),\n                name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry '%s' to be 'generated' or 'static' or \"\n                         \"'vpx' but found '%s'\")",
            "addressType_name",
            "addressType"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry '%s' to be MAC address but \"\n                                 \"found '%s'\")",
            "address_name",
            "address"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrParse",
          "args": [
            "address",
            "&(*def)->mac"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "205-218",
          "snippet": "int\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "addressType",
            "\"static\""
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry '%s' to be MAC address but \"\n                                 \"found '%s'\")",
            "generatedAddress_name",
            "generatedAddress"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "addressType",
            "\"vpx\""
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "addressType",
            "\"generated\""
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "*def"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigBoolean",
          "args": [
            "conf",
            "startConnected_name",
            "&startConnected",
            "true",
            "true"
          ],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "824-854",
          "snippet": "static int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "vnet"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "networkName"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "features"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "virtualDev"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "address"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "generatedAddress"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "addressType"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "connectionType"
          ],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "startConnected"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "present"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "prefix",
            "sizeof(prefix)",
            "\"ethernet%d\"",
            "controller"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXParseEthernet(virConfPtr conf, int controller, virDomainNetDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char startConnected_name[48] = \"\";\n    bool startConnected = false;\n\n    char connectionType_name[48] = \"\";\n    char *connectionType = NULL;\n\n    char addressType_name[48] = \"\";\n    char *addressType = NULL;\n\n    char generatedAddress_name[48] = \"\";\n    char *generatedAddress = NULL;\n\n    char address_name[48] = \"\";\n    char *address = NULL;\n\n    char virtualDev_name[48] = \"\";\n    char *virtualDev = NULL;\n\n    char features_name[48] = \"\";\n    long long features = 0;\n\n    char vnet_name[48] = \"\";\n    char *vnet = NULL;\n\n    char networkName_name[48] = \"\";\n    char *networkName = NULL;\n\n    int netmodel = VIR_DOMAIN_NET_MODEL_UNKNOWN;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"ethernet%d\", controller);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(connectionType);\n    VMX_BUILD_NAME(addressType);\n    VMX_BUILD_NAME(generatedAddress);\n    VMX_BUILD_NAME(address);\n    VMX_BUILD_NAME(virtualDev);\n    VMX_BUILD_NAME(features);\n    VMX_BUILD_NAME(networkName);\n    VMX_BUILD_NAME(vnet);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        return -1;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        return 0;\n\n    if (VIR_ALLOC(*def) < 0)\n        return -1;\n\n    /* vmx:connectionType -> def:type */\n    if (virVMXGetConfigString(conf, connectionType_name, &connectionType,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    /* vmx:addressType, vmx:generatedAddress, vmx:address -> def:mac */\n    if (virVMXGetConfigString(conf, addressType_name, &addressType,\n                              true) < 0 ||\n        virVMXGetConfigString(conf, generatedAddress_name, &generatedAddress,\n                              true) < 0 ||\n        virVMXGetConfigString(conf, address_name, &address, true) < 0) {\n        goto cleanup;\n    }\n\n    if (addressType == NULL || STRCASEEQ(addressType, \"generated\") ||\n        STRCASEEQ(addressType, \"vpx\")) {\n        if (generatedAddress != NULL) {\n            if (virMacAddrParse(generatedAddress, &(*def)->mac) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be MAC address but \"\n                                 \"found '%s'\"), generatedAddress_name,\n                               generatedAddress);\n                goto cleanup;\n            }\n        }\n    } else if (STRCASEEQ(addressType, \"static\")) {\n        if (address != NULL) {\n            if (virMacAddrParse(address, &(*def)->mac) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be MAC address but \"\n                                 \"found '%s'\"), address_name, address);\n                goto cleanup;\n            }\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry '%s' to be 'generated' or 'static' or \"\n                         \"'vpx' but found '%s'\"), addressType_name, addressType);\n        goto cleanup;\n    }\n\n    /* vmx:virtualDev, vmx:features -> def:model */\n    if (virVMXGetConfigString(conf, virtualDev_name, &virtualDev, true) < 0 ||\n        virVMXGetConfigLong(conf, features_name, &features, 0, true) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualDev != NULL) {\n        if (STRCASEEQ(virtualDev, \"vlance\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_VLANCE;\n        } else if (STRCASEEQ(virtualDev, \"vmxnet\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_VMXNET;\n        } else if (STRCASEEQ(virtualDev, \"vmxnet3\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_VMXNET3;\n        } else if (STRCASEEQ(virtualDev, \"e1000\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_E1000;\n        } else if (STRCASEEQ(virtualDev, \"e1000e\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_E1000E;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry '%s' to be 'vlance' or 'vmxnet' or \"\n                             \"'vmxnet3' or 'e1000' or 'e1000e' but found '%s'\"),\n                           virtualDev_name, virtualDev);\n            goto cleanup;\n        }\n\n        if (netmodel == VIR_DOMAIN_NET_MODEL_VMXNET && features == 15)\n            netmodel = VIR_DOMAIN_NET_MODEL_VMXNET2;\n    }\n\n    /* vmx:networkName -> def:data.bridge.brname */\n    if (connectionType == NULL ||\n        STRCASEEQ(connectionType, \"bridged\") ||\n        STRCASEEQ(connectionType, \"custom\")) {\n        if (virVMXGetConfigString(conf, networkName_name, &networkName,\n                                  true) < 0)\n            goto cleanup;\n\n        if (!networkName)\n            networkName = g_strdup(\"\");\n    }\n\n    /* vmx:vnet -> def:data.ifname */\n    if (connectionType != NULL && STRCASEEQ(connectionType, \"custom\") &&\n        virVMXGetConfigString(conf, vnet_name, &vnet, false) < 0) {\n        goto cleanup;\n    }\n\n    /* Setup virDomainNetDef */\n    if (connectionType == NULL || STRCASEEQ(connectionType, \"bridged\")) {\n        (*def)->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n        (*def)->data.bridge.brname = networkName;\n\n        networkName = NULL;\n    } else if (STRCASEEQ(connectionType, \"hostonly\")) {\n        /* FIXME */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No yet handled value '%s' for VMX entry '%s'\"),\n                       connectionType, connectionType_name);\n        goto cleanup;\n    } else if (STRCASEEQ(connectionType, \"nat\")) {\n        (*def)->type = VIR_DOMAIN_NET_TYPE_USER;\n\n    } else if (STRCASEEQ(connectionType, \"custom\")) {\n        (*def)->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n        (*def)->data.bridge.brname = networkName;\n        (*def)->ifname = vnet;\n\n        networkName = NULL;\n        vnet = NULL;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid value '%s' for VMX entry '%s'\"), connectionType,\n                       connectionType_name);\n        goto cleanup;\n    }\n\n    (*def)->model = netmodel;\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainNetDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(networkName);\n    VIR_FREE(connectionType);\n    VIR_FREE(addressType);\n    VIR_FREE(generatedAddress);\n    VIR_FREE(address);\n    VIR_FREE(virtualDev);\n    VIR_FREE(vnet);\n\n    return result;\n}"
  },
  {
    "function_name": "virVMXParseFileSystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "2427-2510",
    "snippet": "int virVMXParseFileSystem(virConfPtr conf, int number, virDomainFSDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char enabled_name[48] = \"\";\n    bool enabled = false;\n\n    char hostPath_name[48] = \"\";\n    char *hostPath = NULL;\n\n    char guestName_name[48] = \"\";\n    char *guestName = NULL;\n\n    char writeAccess_name[48] = \"\";\n    bool writeAccess = false;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"sharedFolder%d\", number);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(enabled);\n    VMX_BUILD_NAME(hostPath);\n    VMX_BUILD_NAME(guestName);\n    VMX_BUILD_NAME(writeAccess);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:enabled */\n    if (virVMXGetConfigBoolean(conf, enabled_name, &enabled, false, true) < 0)\n        return -1;\n\n    if (!(present && enabled))\n        return 0;\n\n    if (!(*def = virDomainFSDefNew(NULL)))\n        return -1;\n\n    (*def)->type = VIR_DOMAIN_FS_TYPE_MOUNT;\n\n    /* vmx:hostPath */\n    if (virVMXGetConfigString(conf, hostPath_name, &hostPath, false) < 0)\n        goto cleanup;\n\n    (*def)->src->path = hostPath;\n    hostPath = NULL;\n\n    /* vmx:guestName */\n    if (virVMXGetConfigString(conf, guestName_name, &guestName, false) < 0)\n        goto cleanup;\n\n    (*def)->dst = guestName;\n    guestName = NULL;\n\n    /* vmx:writeAccess */\n    if (virVMXGetConfigBoolean(conf, writeAccess_name, &writeAccess, false,\n                               true) < 0) {\n        goto cleanup;\n    }\n\n    (*def)->readonly = !writeAccess;\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainFSDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(hostPath);\n    VIR_FREE(guestName);\n\n    return result;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "guestName"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hostPath"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainFSDefFree",
          "args": [
            "*def"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainFSDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2328-2341",
          "snippet": "void virDomainFSDefFree(virDomainFSDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->dst);\n    virDomainDeviceInfoClear(&def->info);\n    VIR_FREE(def->virtio);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def->binary);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainFSDefFree(virDomainFSDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->dst);\n    virDomainDeviceInfoClear(&def->info);\n    VIR_FREE(def->virtio);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def->binary);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigBoolean",
          "args": [
            "conf",
            "writeAccess_name",
            "&writeAccess",
            "false",
            "true"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "824-854",
          "snippet": "static int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigString",
          "args": [
            "conf",
            "guestName_name",
            "&guestName",
            "false"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "750-760",
          "snippet": "static int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainFSDefNew",
          "args": [
            "NULL"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainFSDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2304-2326",
          "snippet": "virDomainFSDefPtr\nvirDomainFSDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainFSDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto cleanup;\n\n    if (xmlopt &&\n        xmlopt->privateData.fsNew &&\n        !(ret->privateData = xmlopt->privateData.fsNew()))\n        goto cleanup;\n\n    return ret;\n\n cleanup:\n    virDomainFSDefFree(ret);\n    return NULL;\n\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainFSDefPtr\nvirDomainFSDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainFSDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto cleanup;\n\n    if (xmlopt &&\n        xmlopt->privateData.fsNew &&\n        !(ret->privateData = xmlopt->privateData.fsNew()))\n        goto cleanup;\n\n    return ret;\n\n cleanup:\n    virDomainFSDefFree(ret);\n    return NULL;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "writeAccess"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "guestName"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "hostPath"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "enabled"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "present"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "prefix",
            "sizeof(prefix)",
            "\"sharedFolder%d\"",
            "number"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid argument\""
          ],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint virVMXParseFileSystem(virConfPtr conf, int number, virDomainFSDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char enabled_name[48] = \"\";\n    bool enabled = false;\n\n    char hostPath_name[48] = \"\";\n    char *hostPath = NULL;\n\n    char guestName_name[48] = \"\";\n    char *guestName = NULL;\n\n    char writeAccess_name[48] = \"\";\n    bool writeAccess = false;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"sharedFolder%d\", number);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(enabled);\n    VMX_BUILD_NAME(hostPath);\n    VMX_BUILD_NAME(guestName);\n    VMX_BUILD_NAME(writeAccess);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:enabled */\n    if (virVMXGetConfigBoolean(conf, enabled_name, &enabled, false, true) < 0)\n        return -1;\n\n    if (!(present && enabled))\n        return 0;\n\n    if (!(*def = virDomainFSDefNew(NULL)))\n        return -1;\n\n    (*def)->type = VIR_DOMAIN_FS_TYPE_MOUNT;\n\n    /* vmx:hostPath */\n    if (virVMXGetConfigString(conf, hostPath_name, &hostPath, false) < 0)\n        goto cleanup;\n\n    (*def)->src->path = hostPath;\n    hostPath = NULL;\n\n    /* vmx:guestName */\n    if (virVMXGetConfigString(conf, guestName_name, &guestName, false) < 0)\n        goto cleanup;\n\n    (*def)->dst = guestName;\n    guestName = NULL;\n\n    /* vmx:writeAccess */\n    if (virVMXGetConfigBoolean(conf, writeAccess_name, &writeAccess, false,\n                               true) < 0) {\n        goto cleanup;\n    }\n\n    (*def)->readonly = !writeAccess;\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainFSDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(hostPath);\n    VIR_FREE(guestName);\n\n    return result;\n}"
  },
  {
    "function_name": "virVMXParseDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "2007-2423",
    "snippet": "int\nvirVMXParseDisk(virVMXContext *ctx, virDomainXMLOptionPtr xmlopt, virConfPtr conf,\n                int device, int busType, int controllerOrBus, int unit,\n                virDomainDiskDefPtr *def, virDomainDefPtr vmdef)\n{\n    /*\n     *          device = {VIR_DOMAIN_DISK_DEVICE_DISK,\n     *                    VIR_DOMAIN_DISK_DEVICE_CDROM,\n     *                    VIR_DOMAIN_DISK_DEVICE_LUN}\n     *         busType = VIR_DOMAIN_DISK_BUS_SCSI\n     * controllerOrBus = [0..3] -> controller\n     *            unit = [0..6,8..15]\n     *\n     *          device = {VIR_DOMAIN_DISK_DEVICE_DISK,\n     *                    VIR_DOMAIN_DISK_DEVICE_CDROM,\n     *                    VIR_DOMAIN_DISK_DEVICE_LUN}\n     *         busType = VIR_DOMAIN_DISK_BUS_IDE\n     * controllerOrBus = [0..1] -> bus\n     *            unit = [0..1]\n     *\n     *          device = VIR_DOMAIN_DISK_DEVICE_FLOPPY\n     *         busType = VIR_DOMAIN_DISK_BUS_FDC\n     * controllerOrBus = [0]\n     *            unit = [0..1]\n     */\n\n    int result = -1;\n    char *prefix = NULL;\n\n    char present_name[32] = \"\";\n    bool present = false;\n\n    char startConnected_name[32] = \"\";\n    bool startConnected = false;\n\n    char deviceType_name[32] = \"\";\n    char *deviceType = NULL;\n\n    char clientDevice_name[32] = \"\";\n    bool clientDevice = false;\n\n    char fileType_name[32] = \"\";\n    char *fileType = NULL;\n\n    char fileName_name[32] = \"\";\n    char *fileName = NULL;\n\n    char writeThrough_name[32] = \"\";\n    bool writeThrough = false;\n\n    char mode_name[32] = \"\";\n    char *mode = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!(*def = virDomainDiskDefNew(xmlopt)))\n        return -1;\n\n    (*def)->device = device;\n    (*def)->bus = busType;\n\n    /* def:dst, def:driverName */\n    if (device == VIR_DOMAIN_DISK_DEVICE_DISK ||\n        device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n        if (busType == VIR_DOMAIN_DISK_BUS_SCSI) {\n            if (controllerOrBus < 0 || controllerOrBus > 3) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"SCSI controller index %d out of [0..3] range\"),\n                               controllerOrBus);\n                goto cleanup;\n            }\n\n            if (unit < 0 || unit > 15 || unit == 7) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"SCSI unit index %d out of [0..6,8..15] range\"),\n                               unit);\n                goto cleanup;\n            }\n\n            prefix = g_strdup_printf(\"scsi%d:%d\", controllerOrBus, unit);\n\n            (*def)->dst =\n               virIndexToDiskName\n                 (controllerOrBus * 15 + (unit < 7 ? unit : unit - 1), \"sd\");\n\n            if ((*def)->dst == NULL)\n                goto cleanup;\n        } else if (busType == VIR_DOMAIN_DISK_BUS_IDE) {\n            if (controllerOrBus < 0 || controllerOrBus > 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"IDE bus index %d out of [0..1] range\"),\n                               controllerOrBus);\n                goto cleanup;\n            }\n\n            if (unit < 0 || unit > 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"IDE unit index %d out of [0..1] range\"), unit);\n                goto cleanup;\n            }\n\n            prefix = g_strdup_printf(\"ide%d:%d\", controllerOrBus, unit);\n\n            (*def)->dst = virIndexToDiskName(controllerOrBus * 2 + unit, \"hd\");\n\n            if ((*def)->dst == NULL)\n                goto cleanup;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported bus type '%s' for device type '%s'\"),\n                           virDomainDiskBusTypeToString(busType),\n                           virDomainDiskDeviceTypeToString(device));\n            goto cleanup;\n        }\n    } else if (device == VIR_DOMAIN_DISK_DEVICE_FLOPPY) {\n        if (busType == VIR_DOMAIN_DISK_BUS_FDC) {\n            if (controllerOrBus != 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"FDC controller index %d out of [0] range\"),\n                               controllerOrBus);\n                goto cleanup;\n            }\n\n            if (unit < 0 || unit > 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"FDC unit index %d out of [0..1] range\"),\n                               unit);\n                goto cleanup;\n            }\n\n            prefix = g_strdup_printf(\"floppy%d\", unit);\n\n            (*def)->dst = virIndexToDiskName(unit, \"fd\");\n\n            if ((*def)->dst == NULL)\n                goto cleanup;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported bus type '%s' for device type '%s'\"),\n                           virDomainDiskBusTypeToString(busType),\n                           virDomainDiskDeviceTypeToString(device));\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported device type '%s'\"),\n                       virDomainDiskDeviceTypeToString(device));\n        goto cleanup;\n    }\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(deviceType);\n    VMX_BUILD_NAME(clientDevice);\n    VMX_BUILD_NAME(fileType);\n    VMX_BUILD_NAME(fileName);\n    VMX_BUILD_NAME(writeThrough);\n    VMX_BUILD_NAME(mode);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        goto cleanup;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        goto cleanup;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        goto ignore;\n\n    /* vmx:deviceType -> def:type */\n    if (virVMXGetConfigString(conf, deviceType_name, &deviceType, true) < 0)\n        goto cleanup;\n\n    /* vmx:clientDevice */\n    if (virVMXGetConfigBoolean(conf, clientDevice_name, &clientDevice, false,\n                               true) < 0) {\n        goto cleanup;\n    }\n\n    /* vmx:mode -> def:transient */\n    if (virVMXGetConfigString(conf, mode_name, &mode, true) < 0)\n        goto cleanup;\n\n    if (clientDevice) {\n        /*\n         * Just ignore devices in client mode, because I have no clue how to\n         * handle them (e.g. assign an image) without the VI Client GUI.\n         */\n        goto ignore;\n    }\n\n    /* vmx:fileType -> def:type */\n    if (virVMXGetConfigString(conf, fileType_name, &fileType, true) < 0)\n        goto cleanup;\n\n    /* vmx:fileName -> def:src, def:type */\n    if (virVMXGetConfigString(conf, fileName_name, &fileName, true) < 0)\n        goto cleanup;\n\n    /* vmx:writeThrough -> def:cachemode */\n    if (virVMXGetConfigBoolean(conf, writeThrough_name, &writeThrough, false,\n                               true) < 0) {\n        goto cleanup;\n    }\n\n    /* Setup virDomainDiskDef */\n    if (device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n        if (fileName == NULL ||\n            virStringHasCaseSuffix(fileName, \".iso\") ||\n            STREQ(fileName, \"emptyBackingString\") ||\n            (deviceType &&\n             (STRCASEEQ(deviceType, \"atapi-cdrom\") ||\n              STRCASEEQ(deviceType, \"cdrom-raw\") ||\n              (STRCASEEQ(deviceType, \"scsi-passthru\") &&\n               STRPREFIX(fileName, \"/vmfs/devices/cdrom/\"))))) {\n            /*\n             * This function was called in order to parse a harddisk device,\n             * but .iso files, 'atapi-cdrom', 'cdrom-raw', and 'scsi-passthru'\n             * CDROM devices are for CDROM devices only. Just ignore it, another\n             * call to this function to parse a CDROM device may handle it.\n             */\n            goto ignore;\n        } else if (virStringHasCaseSuffix(fileName, \".vmdk\")) {\n            char *tmp;\n\n            if (deviceType != NULL) {\n                if (busType == VIR_DOMAIN_DISK_BUS_SCSI &&\n                    STRCASENEQ(deviceType, \"scsi-hardDisk\") &&\n                    STRCASENEQ(deviceType, \"disk\")) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Expecting VMX entry '%s' to be 'scsi-hardDisk' \"\n                                     \"or 'disk' but found '%s'\"), deviceType_name,\n                                   deviceType);\n                    goto cleanup;\n                } else if (busType == VIR_DOMAIN_DISK_BUS_IDE &&\n                           STRCASENEQ(deviceType, \"ata-hardDisk\") &&\n                           STRCASENEQ(deviceType, \"disk\")) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Expecting VMX entry '%s' to be 'ata-hardDisk' \"\n                                     \"or 'disk' but found '%s'\"), deviceType_name,\n                                   deviceType);\n                    goto cleanup;\n                }\n            }\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            if (!(tmp = ctx->parseFileName(fileName, ctx->opaque)))\n                goto cleanup;\n            if (virDomainDiskSetSource(*def, tmp) < 0) {\n                VIR_FREE(tmp);\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n            (*def)->cachemode = writeThrough ? VIR_DOMAIN_DISK_CACHE_WRITETHRU\n                                             : VIR_DOMAIN_DISK_CACHE_DEFAULT;\n            if (mode)\n                (*def)->transient = STRCASEEQ(mode,\n                                              \"independent-nonpersistent\");\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\"),\n                           fileName, fileName_name,\n                           deviceType ? deviceType : \"unknown\");\n            goto cleanup;\n        }\n    } else if (device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n        if (fileName && virStringHasCaseSuffix(fileName, \".vmdk\")) {\n            /*\n             * This function was called in order to parse a CDROM device, but\n             * .vmdk files are for harddisk devices only. Just ignore it,\n             * another call to this function to parse a harddisk device may\n             * handle it.\n             */\n            goto ignore;\n        } else if (fileName && virStringHasCaseSuffix(fileName, \".iso\")) {\n            char *tmp;\n\n            if (deviceType && STRCASENEQ(deviceType, \"cdrom-image\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be 'cdrom-image' \"\n                                 \"but found '%s'\"), deviceType_name, deviceType);\n                goto cleanup;\n            }\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            if (!(tmp = ctx->parseFileName(fileName, ctx->opaque)))\n                goto cleanup;\n            if (virDomainDiskSetSource(*def, tmp) < 0) {\n                VIR_FREE(tmp);\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n        } else if (deviceType && STRCASEEQ(deviceType, \"atapi-cdrom\")) {\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n\n            if (fileName && STRCASEEQ(fileName, \"auto detect\")) {\n                ignore_value(virDomainDiskSetSource(*def, NULL));\n                (*def)->startupPolicy = VIR_DOMAIN_STARTUP_POLICY_OPTIONAL;\n            } else if (virDomainDiskSetSource(*def, fileName) < 0) {\n                goto cleanup;\n            }\n        } else if (deviceType && STRCASEEQ(deviceType, \"cdrom-raw\")) {\n            /* Raw access CD-ROMs actually are device='lun' */\n            (*def)->device = VIR_DOMAIN_DISK_DEVICE_LUN;\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n\n            if (fileName && STRCASEEQ(fileName, \"auto detect\")) {\n                ignore_value(virDomainDiskSetSource(*def, NULL));\n                (*def)->startupPolicy = VIR_DOMAIN_STARTUP_POLICY_OPTIONAL;\n            } else if (virDomainDiskSetSource(*def, fileName) < 0) {\n                goto cleanup;\n            }\n        } else if (busType == VIR_DOMAIN_DISK_BUS_SCSI &&\n                   deviceType && STRCASEEQ(deviceType, \"scsi-passthru\")) {\n            if (fileName && STRPREFIX(fileName, \"/vmfs/devices/cdrom/\")) {\n                /* SCSI-passthru CD-ROMs actually are device='lun' */\n                (*def)->device = VIR_DOMAIN_DISK_DEVICE_LUN;\n                virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n\n                if (virDomainDiskSetSource(*def, fileName) < 0)\n                    goto cleanup;\n            } else {\n                /*\n                 * This function was called in order to parse a CDROM device,\n                 * but the filename does not indicate a CDROM device. Just ignore\n                 * it, another call to this function to parse a harddisk device\n                 * may handle it.\n                 */\n                goto ignore;\n            }\n        } else if (fileName && STREQ(fileName, \"emptyBackingString\")) {\n            if (deviceType && STRCASENEQ(deviceType, \"cdrom-image\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be 'cdrom-image' \"\n                                 \"but found '%s'\"), deviceType_name, deviceType);\n                goto cleanup;\n            }\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            ignore_value(virDomainDiskSetSource(*def, NULL));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\"),\n                           NULLSTR(fileName), fileName_name,\n                           deviceType ? deviceType : \"unknown\");\n            goto cleanup;\n        }\n    } else if (device == VIR_DOMAIN_DISK_DEVICE_FLOPPY) {\n        if (fileType != NULL && STRCASEEQ(fileType, \"device\")) {\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n            if (virDomainDiskSetSource(*def, fileName) < 0)\n                goto cleanup;\n        } else if (fileType != NULL && STRCASEEQ(fileType, \"file\")) {\n            char *tmp = NULL;\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            if (fileName && !(tmp = ctx->parseFileName(fileName, ctx->opaque)))\n                goto cleanup;\n            if (virDomainDiskSetSource(*def, tmp) < 0) {\n                VIR_FREE(tmp);\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\"),\n                           NULLSTR(fileName), fileName_name,\n                           deviceType ? deviceType : \"unknown\");\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, _(\"Unsupported device type '%s'\"),\n                       virDomainDiskDeviceTypeToString(device));\n        goto cleanup;\n    }\n\n    if (virDomainDiskDefAssignAddress(xmlopt, *def, vmdef) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not assign address to disk '%s'\"),\n                       virDomainDiskGetSource(*def));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainDiskDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(prefix);\n    VIR_FREE(deviceType);\n    VIR_FREE(fileType);\n    VIR_FREE(fileName);\n    VIR_FREE(mode);\n\n    return result;\n\n ignore:\n    virDomainDiskDefFree(*def);\n    *def = NULL;\n\n    result = 0;\n\n    goto cleanup;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDiskDefFree",
          "args": [
            "*def"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2117-2138",
          "snippet": "void\nvirDomainDiskDefFree(virDomainDiskDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->serial);\n    VIR_FREE(def->dst);\n    virObjectUnref(def->mirror);\n    VIR_FREE(def->wwn);\n    VIR_FREE(def->driverName);\n    VIR_FREE(def->vendor);\n    VIR_FREE(def->product);\n    VIR_FREE(def->domain_name);\n    VIR_FREE(def->blkdeviotune.group_name);\n    VIR_FREE(def->virtio);\n    virDomainDeviceInfoClear(&def->info);\n    virObjectUnref(def->privateData);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDiskDefFree(virDomainDiskDefPtr def)\n{\n    if (!def)\n        return;\n\n    virObjectUnref(def->src);\n    VIR_FREE(def->serial);\n    VIR_FREE(def->dst);\n    virObjectUnref(def->mirror);\n    VIR_FREE(def->wwn);\n    VIR_FREE(def->driverName);\n    VIR_FREE(def->vendor);\n    VIR_FREE(def->product);\n    VIR_FREE(def->domain_name);\n    VIR_FREE(def->blkdeviotune.group_name);\n    VIR_FREE(def->virtio);\n    virDomainDeviceInfoClear(&def->info);\n    virObjectUnref(def->privateData);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mode"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileName"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileType"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "deviceType"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "prefix"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not assign address to disk '%s'\")",
            "virDomainDiskGetSource(*def)"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "*def"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not assign address to disk '%s'\""
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskDefAssignAddress",
          "args": [
            "xmlopt",
            "*def",
            "vmdef"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskDefAssignAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "8831-8922",
          "snippet": "int\nvirDomainDiskDefAssignAddress(virDomainXMLOptionPtr xmlopt,\n                              virDomainDiskDefPtr def,\n                              const virDomainDef *vmdef)\n{\n    int idx = virDiskNameToIndex(def->dst);\n    if (idx < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unknown disk name '%s' and no address specified\"),\n                       def->dst);\n        return -1;\n    }\n\n    switch (def->bus) {\n    case VIR_DOMAIN_DISK_BUS_SCSI: {\n        virDomainDeviceDriveAddress addr = {0, 0, 0, 0};\n        unsigned int controller;\n        unsigned int unit;\n\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n\n        if (xmlopt->config.features & VIR_DOMAIN_DEF_FEATURE_WIDE_SCSI) {\n            /* For a wide SCSI bus we define the default mapping to be\n             * 16 units per bus, 1 bus per controller, many controllers.\n             * Unit 7 is the SCSI controller itself. Therefore unit 7\n             * cannot be assigned to disks and is skipped.\n             */\n            controller = idx / 15;\n            unit = idx % 15;\n\n            /* Skip the SCSI controller at unit 7 */\n            if (unit >= 7)\n                ++unit;\n        } else {\n            /* For a narrow SCSI bus we define the default mapping to be\n             * 7 units per bus, 1 bus per controller, many controllers */\n            controller = idx / 7;\n            unit = idx % 7;\n        }\n\n        addr.controller = controller;\n        addr.unit = unit;\n\n        if (virDomainDriveAddressIsUsedByHostdev(vmdef,\n                                                 VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI,\n                                                 &addr)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"using disk target name '%s' conflicts with \"\n                             \"SCSI host device address controller='%u' \"\n                             \"bus='%u' target='%u' unit='%u\"),\n                           def->dst, controller, 0, 0, unit);\n            return -1;\n        }\n\n        memcpy(&def->info.addr.drive, &addr, sizeof(addr));\n        break;\n    }\n\n    case VIR_DOMAIN_DISK_BUS_IDE:\n        /* For IDE we define the default mapping to be 2 units\n         * per bus, 2 bus per controller, many controllers */\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        def->info.addr.drive.controller = idx / 4;\n        def->info.addr.drive.bus = (idx % 4) / 2;\n        def->info.addr.drive.unit = (idx % 2);\n        break;\n\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        /* For SATA we define the default mapping to be 6 units\n         * per bus, 1 bus per controller, many controllers */\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        def->info.addr.drive.controller = idx / 6;\n        def->info.addr.drive.bus = 0;\n        def->info.addr.drive.unit = idx % 6;\n        break;\n\n    case VIR_DOMAIN_DISK_BUS_FDC:\n        /* For FDC we define the default mapping to be 2 units\n         * per bus, 1 bus per controller, many controllers */\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        def->info.addr.drive.controller = idx / 2;\n        def->info.addr.drive.bus = 0;\n        def->info.addr.drive.unit = idx % 2;\n        break;\n\n    default:\n        /* Other disk bus's aren't controller based */\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskDefAssignAddress(virDomainXMLOptionPtr xmlopt,\n                              virDomainDiskDefPtr def,\n                              const virDomainDef *vmdef)\n{\n    int idx = virDiskNameToIndex(def->dst);\n    if (idx < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unknown disk name '%s' and no address specified\"),\n                       def->dst);\n        return -1;\n    }\n\n    switch (def->bus) {\n    case VIR_DOMAIN_DISK_BUS_SCSI: {\n        virDomainDeviceDriveAddress addr = {0, 0, 0, 0};\n        unsigned int controller;\n        unsigned int unit;\n\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n\n        if (xmlopt->config.features & VIR_DOMAIN_DEF_FEATURE_WIDE_SCSI) {\n            /* For a wide SCSI bus we define the default mapping to be\n             * 16 units per bus, 1 bus per controller, many controllers.\n             * Unit 7 is the SCSI controller itself. Therefore unit 7\n             * cannot be assigned to disks and is skipped.\n             */\n            controller = idx / 15;\n            unit = idx % 15;\n\n            /* Skip the SCSI controller at unit 7 */\n            if (unit >= 7)\n                ++unit;\n        } else {\n            /* For a narrow SCSI bus we define the default mapping to be\n             * 7 units per bus, 1 bus per controller, many controllers */\n            controller = idx / 7;\n            unit = idx % 7;\n        }\n\n        addr.controller = controller;\n        addr.unit = unit;\n\n        if (virDomainDriveAddressIsUsedByHostdev(vmdef,\n                                                 VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI,\n                                                 &addr)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"using disk target name '%s' conflicts with \"\n                             \"SCSI host device address controller='%u' \"\n                             \"bus='%u' target='%u' unit='%u\"),\n                           def->dst, controller, 0, 0, unit);\n            return -1;\n        }\n\n        memcpy(&def->info.addr.drive, &addr, sizeof(addr));\n        break;\n    }\n\n    case VIR_DOMAIN_DISK_BUS_IDE:\n        /* For IDE we define the default mapping to be 2 units\n         * per bus, 2 bus per controller, many controllers */\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        def->info.addr.drive.controller = idx / 4;\n        def->info.addr.drive.bus = (idx % 4) / 2;\n        def->info.addr.drive.unit = (idx % 2);\n        break;\n\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        /* For SATA we define the default mapping to be 6 units\n         * per bus, 1 bus per controller, many controllers */\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        def->info.addr.drive.controller = idx / 6;\n        def->info.addr.drive.bus = 0;\n        def->info.addr.drive.unit = idx % 6;\n        break;\n\n    case VIR_DOMAIN_DISK_BUS_FDC:\n        /* For FDC we define the default mapping to be 2 units\n         * per bus, 1 bus per controller, many controllers */\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        def->info.addr.drive.controller = idx / 2;\n        def->info.addr.drive.bus = 0;\n        def->info.addr.drive.unit = idx % 2;\n        break;\n\n    default:\n        /* Other disk bus's aren't controller based */\n        break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported device type '%s'\")",
            "virDomainDiskDeviceTypeToString(device)"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDeviceTypeToString",
          "args": [
            "device"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\")",
            "NULLSTR(fileName)",
            "fileName_name",
            "deviceType ? deviceType : \"unknown\""
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "fileName"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskSetSource",
          "args": [
            "*def",
            "tmp"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2162-2169",
          "snippet": "int\nvirDomainDiskSetSource(virDomainDiskDefPtr def, const char *src)\n{\n    char *tmp = g_strdup(src);\n    g_free(def->src->path);\n    def->src->path = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskSetSource(virDomainDiskDefPtr def, const char *src)\n{\n    char *tmp = g_strdup(src);\n    g_free(def->src->path);\n    def->src->path = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctx->parseFileName",
          "args": [
            "fileName",
            "ctx->opaque"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskSetType",
          "args": [
            "*def",
            "VIR_STORAGE_TYPE_FILE"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2148-2152",
          "snippet": "void\nvirDomainDiskSetType(virDomainDiskDefPtr def, int type)\n{\n    def->src->type = type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDiskSetType(virDomainDiskDefPtr def, int type)\n{\n    def->src->type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "fileType",
            "\"file\""
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "fileType",
            "\"device\""
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\")",
            "NULLSTR(fileName)",
            "fileName_name",
            "deviceType ? deviceType : \"unknown\""
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "fileName"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virDomainDiskSetSource(*def, NULL)"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry '%s' to be 'cdrom-image' \"\n                                 \"but found '%s'\")",
            "deviceType_name",
            "deviceType"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASENEQ",
          "args": [
            "deviceType",
            "\"cdrom-image\""
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "fileName",
            "\"emptyBackingString\""
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "fileName",
            "\"/vmfs/devices/cdrom/\""
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "deviceType",
            "\"scsi-passthru\""
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virDomainDiskSetSource(*def, NULL)"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "fileName",
            "\"auto detect\""
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "deviceType",
            "\"cdrom-raw\""
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virDomainDiskSetSource(*def, NULL)"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "fileName",
            "\"auto detect\""
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "deviceType",
            "\"atapi-cdrom\""
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctx->parseFileName",
          "args": [
            "fileName",
            "ctx->opaque"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry '%s' to be 'cdrom-image' \"\n                                 \"but found '%s'\")",
            "deviceType_name",
            "deviceType"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASENEQ",
          "args": [
            "deviceType",
            "\"cdrom-image\""
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringHasCaseSuffix",
          "args": [
            "fileName",
            "\".iso\""
          ],
          "line": 2289
        },
        "resolved": true,
        "details": {
          "function_name": "virStringHasCaseSuffix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1110-1121",
          "snippet": "bool\nvirStringHasCaseSuffix(const char *str,\n                       const char *suffix)\n{\n    int len = strlen(str);\n    int suffixlen = strlen(suffix);\n\n    if (len < suffixlen)\n        return false;\n\n    return STRCASEEQ(str + len - suffixlen, suffix);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nbool\nvirStringHasCaseSuffix(const char *str,\n                       const char *suffix)\n{\n    int len = strlen(str);\n    int suffixlen = strlen(suffix);\n\n    if (len < suffixlen)\n        return false;\n\n    return STRCASEEQ(str + len - suffixlen, suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\")",
            "fileName",
            "fileName_name",
            "deviceType ? deviceType : \"unknown\""
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "mode",
            "\"independent-nonpersistent\""
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctx->parseFileName",
          "args": [
            "fileName",
            "ctx->opaque"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry '%s' to be 'ata-hardDisk' \"\n                                     \"or 'disk' but found '%s'\")",
            "deviceType_name",
            "deviceType"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASENEQ",
          "args": [
            "deviceType",
            "\"disk\""
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASENEQ",
          "args": [
            "deviceType",
            "\"ata-hardDisk\""
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry '%s' to be 'scsi-hardDisk' \"\n                                     \"or 'disk' but found '%s'\")",
            "deviceType_name",
            "deviceType"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASENEQ",
          "args": [
            "deviceType",
            "\"disk\""
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASENEQ",
          "args": [
            "deviceType",
            "\"scsi-hardDisk\""
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "fileName",
            "\"/vmfs/devices/cdrom/\""
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "deviceType",
            "\"scsi-passthru\""
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "deviceType",
            "\"cdrom-raw\""
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "deviceType",
            "\"atapi-cdrom\""
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "fileName",
            "\"emptyBackingString\""
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigBoolean",
          "args": [
            "conf",
            "writeThrough_name",
            "&writeThrough",
            "false",
            "true"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "824-854",
          "snippet": "static int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigString",
          "args": [
            "conf",
            "fileName_name",
            "&fileName",
            "true"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "750-760",
          "snippet": "static int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "mode"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "writeThrough"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "fileName"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "fileType"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "clientDevice"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "deviceType"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "startConnected"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMX_BUILD_NAME",
          "args": [
            "present"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported device type '%s'\")",
            "virDomainDiskDeviceTypeToString(device)"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDeviceTypeToString",
          "args": [
            "device"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported bus type '%s' for device type '%s'\")",
            "virDomainDiskBusTypeToString(busType)",
            "virDomainDiskDeviceTypeToString(device)"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDeviceTypeToString",
          "args": [
            "device"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskBusTypeToString",
          "args": [
            "busType"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virIndexToDiskName",
          "args": [
            "unit",
            "\"fd\""
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "virIndexToDiskName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "436-463",
          "snippet": "char *virIndexToDiskName(int idx, const char *prefix)\n{\n    char *name = NULL;\n    size_t i;\n    int ctr;\n    int offset;\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Disk index %d is negative\"), idx);\n        return NULL;\n    }\n\n    for (i = 0, ctr = idx; ctr >= 0; ++i, ctr = ctr / 26 - 1) { }\n\n    offset = strlen(prefix);\n\n    if (VIR_ALLOC_N(name, offset + i + 1))\n        return NULL;\n\n    strcpy(name, prefix);\n    name[offset + i] = '\\0';\n\n    for (i = i - 1, ctr = idx; ctr >= 0; --i, ctr = ctr / 26 - 1)\n        name[offset + i] = 'a' + (ctr % 26);\n\n    return name;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virIndexToDiskName(int idx, const char *prefix)\n{\n    char *name = NULL;\n    size_t i;\n    int ctr;\n    int offset;\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Disk index %d is negative\"), idx);\n        return NULL;\n    }\n\n    for (i = 0, ctr = idx; ctr >= 0; ++i, ctr = ctr / 26 - 1) { }\n\n    offset = strlen(prefix);\n\n    if (VIR_ALLOC_N(name, offset + i + 1))\n        return NULL;\n\n    strcpy(name, prefix);\n    name[offset + i] = '\\0';\n\n    for (i = i - 1, ctr = idx; ctr >= 0; --i, ctr = ctr / 26 - 1)\n        name[offset + i] = 'a' + (ctr % 26);\n\n    return name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"FDC unit index %d out of [0..1] range\")",
            "unit"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"FDC controller index %d out of [0] range\")",
            "controllerOrBus"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported bus type '%s' for device type '%s'\")",
            "virDomainDiskBusTypeToString(busType)",
            "virDomainDiskDeviceTypeToString(device)"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDeviceTypeToString",
          "args": [
            "device"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskBusTypeToString",
          "args": [
            "busType"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"IDE unit index %d out of [0..1] range\")",
            "unit"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"IDE bus index %d out of [0..1] range\")",
            "controllerOrBus"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"SCSI unit index %d out of [0..6,8..15] range\")",
            "unit"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"SCSI controller index %d out of [0..3] range\")",
            "controllerOrBus"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDefNew",
          "args": [
            "xmlopt"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2093-2114",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDiskDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto error;\n\n    if (xmlopt &&\n        xmlopt->privateData.diskNew &&\n        !(ret->privateData = xmlopt->privateData.diskNew()))\n        goto error;\n\n    return ret;\n\n error:\n    virDomainDiskDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDiskDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto error;\n\n    if (xmlopt &&\n        xmlopt->privateData.diskNew &&\n        !(ret->privateData = xmlopt->privateData.diskNew()))\n        goto error;\n\n    return ret;\n\n error:\n    virDomainDiskDefFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXParseDisk(virVMXContext *ctx, virDomainXMLOptionPtr xmlopt, virConfPtr conf,\n                int device, int busType, int controllerOrBus, int unit,\n                virDomainDiskDefPtr *def, virDomainDefPtr vmdef)\n{\n    /*\n     *          device = {VIR_DOMAIN_DISK_DEVICE_DISK,\n     *                    VIR_DOMAIN_DISK_DEVICE_CDROM,\n     *                    VIR_DOMAIN_DISK_DEVICE_LUN}\n     *         busType = VIR_DOMAIN_DISK_BUS_SCSI\n     * controllerOrBus = [0..3] -> controller\n     *            unit = [0..6,8..15]\n     *\n     *          device = {VIR_DOMAIN_DISK_DEVICE_DISK,\n     *                    VIR_DOMAIN_DISK_DEVICE_CDROM,\n     *                    VIR_DOMAIN_DISK_DEVICE_LUN}\n     *         busType = VIR_DOMAIN_DISK_BUS_IDE\n     * controllerOrBus = [0..1] -> bus\n     *            unit = [0..1]\n     *\n     *          device = VIR_DOMAIN_DISK_DEVICE_FLOPPY\n     *         busType = VIR_DOMAIN_DISK_BUS_FDC\n     * controllerOrBus = [0]\n     *            unit = [0..1]\n     */\n\n    int result = -1;\n    char *prefix = NULL;\n\n    char present_name[32] = \"\";\n    bool present = false;\n\n    char startConnected_name[32] = \"\";\n    bool startConnected = false;\n\n    char deviceType_name[32] = \"\";\n    char *deviceType = NULL;\n\n    char clientDevice_name[32] = \"\";\n    bool clientDevice = false;\n\n    char fileType_name[32] = \"\";\n    char *fileType = NULL;\n\n    char fileName_name[32] = \"\";\n    char *fileName = NULL;\n\n    char writeThrough_name[32] = \"\";\n    bool writeThrough = false;\n\n    char mode_name[32] = \"\";\n    char *mode = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!(*def = virDomainDiskDefNew(xmlopt)))\n        return -1;\n\n    (*def)->device = device;\n    (*def)->bus = busType;\n\n    /* def:dst, def:driverName */\n    if (device == VIR_DOMAIN_DISK_DEVICE_DISK ||\n        device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n        if (busType == VIR_DOMAIN_DISK_BUS_SCSI) {\n            if (controllerOrBus < 0 || controllerOrBus > 3) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"SCSI controller index %d out of [0..3] range\"),\n                               controllerOrBus);\n                goto cleanup;\n            }\n\n            if (unit < 0 || unit > 15 || unit == 7) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"SCSI unit index %d out of [0..6,8..15] range\"),\n                               unit);\n                goto cleanup;\n            }\n\n            prefix = g_strdup_printf(\"scsi%d:%d\", controllerOrBus, unit);\n\n            (*def)->dst =\n               virIndexToDiskName\n                 (controllerOrBus * 15 + (unit < 7 ? unit : unit - 1), \"sd\");\n\n            if ((*def)->dst == NULL)\n                goto cleanup;\n        } else if (busType == VIR_DOMAIN_DISK_BUS_IDE) {\n            if (controllerOrBus < 0 || controllerOrBus > 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"IDE bus index %d out of [0..1] range\"),\n                               controllerOrBus);\n                goto cleanup;\n            }\n\n            if (unit < 0 || unit > 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"IDE unit index %d out of [0..1] range\"), unit);\n                goto cleanup;\n            }\n\n            prefix = g_strdup_printf(\"ide%d:%d\", controllerOrBus, unit);\n\n            (*def)->dst = virIndexToDiskName(controllerOrBus * 2 + unit, \"hd\");\n\n            if ((*def)->dst == NULL)\n                goto cleanup;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported bus type '%s' for device type '%s'\"),\n                           virDomainDiskBusTypeToString(busType),\n                           virDomainDiskDeviceTypeToString(device));\n            goto cleanup;\n        }\n    } else if (device == VIR_DOMAIN_DISK_DEVICE_FLOPPY) {\n        if (busType == VIR_DOMAIN_DISK_BUS_FDC) {\n            if (controllerOrBus != 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"FDC controller index %d out of [0] range\"),\n                               controllerOrBus);\n                goto cleanup;\n            }\n\n            if (unit < 0 || unit > 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"FDC unit index %d out of [0..1] range\"),\n                               unit);\n                goto cleanup;\n            }\n\n            prefix = g_strdup_printf(\"floppy%d\", unit);\n\n            (*def)->dst = virIndexToDiskName(unit, \"fd\");\n\n            if ((*def)->dst == NULL)\n                goto cleanup;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported bus type '%s' for device type '%s'\"),\n                           virDomainDiskBusTypeToString(busType),\n                           virDomainDiskDeviceTypeToString(device));\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported device type '%s'\"),\n                       virDomainDiskDeviceTypeToString(device));\n        goto cleanup;\n    }\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(deviceType);\n    VMX_BUILD_NAME(clientDevice);\n    VMX_BUILD_NAME(fileType);\n    VMX_BUILD_NAME(fileName);\n    VMX_BUILD_NAME(writeThrough);\n    VMX_BUILD_NAME(mode);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        goto cleanup;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        goto cleanup;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        goto ignore;\n\n    /* vmx:deviceType -> def:type */\n    if (virVMXGetConfigString(conf, deviceType_name, &deviceType, true) < 0)\n        goto cleanup;\n\n    /* vmx:clientDevice */\n    if (virVMXGetConfigBoolean(conf, clientDevice_name, &clientDevice, false,\n                               true) < 0) {\n        goto cleanup;\n    }\n\n    /* vmx:mode -> def:transient */\n    if (virVMXGetConfigString(conf, mode_name, &mode, true) < 0)\n        goto cleanup;\n\n    if (clientDevice) {\n        /*\n         * Just ignore devices in client mode, because I have no clue how to\n         * handle them (e.g. assign an image) without the VI Client GUI.\n         */\n        goto ignore;\n    }\n\n    /* vmx:fileType -> def:type */\n    if (virVMXGetConfigString(conf, fileType_name, &fileType, true) < 0)\n        goto cleanup;\n\n    /* vmx:fileName -> def:src, def:type */\n    if (virVMXGetConfigString(conf, fileName_name, &fileName, true) < 0)\n        goto cleanup;\n\n    /* vmx:writeThrough -> def:cachemode */\n    if (virVMXGetConfigBoolean(conf, writeThrough_name, &writeThrough, false,\n                               true) < 0) {\n        goto cleanup;\n    }\n\n    /* Setup virDomainDiskDef */\n    if (device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n        if (fileName == NULL ||\n            virStringHasCaseSuffix(fileName, \".iso\") ||\n            STREQ(fileName, \"emptyBackingString\") ||\n            (deviceType &&\n             (STRCASEEQ(deviceType, \"atapi-cdrom\") ||\n              STRCASEEQ(deviceType, \"cdrom-raw\") ||\n              (STRCASEEQ(deviceType, \"scsi-passthru\") &&\n               STRPREFIX(fileName, \"/vmfs/devices/cdrom/\"))))) {\n            /*\n             * This function was called in order to parse a harddisk device,\n             * but .iso files, 'atapi-cdrom', 'cdrom-raw', and 'scsi-passthru'\n             * CDROM devices are for CDROM devices only. Just ignore it, another\n             * call to this function to parse a CDROM device may handle it.\n             */\n            goto ignore;\n        } else if (virStringHasCaseSuffix(fileName, \".vmdk\")) {\n            char *tmp;\n\n            if (deviceType != NULL) {\n                if (busType == VIR_DOMAIN_DISK_BUS_SCSI &&\n                    STRCASENEQ(deviceType, \"scsi-hardDisk\") &&\n                    STRCASENEQ(deviceType, \"disk\")) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Expecting VMX entry '%s' to be 'scsi-hardDisk' \"\n                                     \"or 'disk' but found '%s'\"), deviceType_name,\n                                   deviceType);\n                    goto cleanup;\n                } else if (busType == VIR_DOMAIN_DISK_BUS_IDE &&\n                           STRCASENEQ(deviceType, \"ata-hardDisk\") &&\n                           STRCASENEQ(deviceType, \"disk\")) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Expecting VMX entry '%s' to be 'ata-hardDisk' \"\n                                     \"or 'disk' but found '%s'\"), deviceType_name,\n                                   deviceType);\n                    goto cleanup;\n                }\n            }\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            if (!(tmp = ctx->parseFileName(fileName, ctx->opaque)))\n                goto cleanup;\n            if (virDomainDiskSetSource(*def, tmp) < 0) {\n                VIR_FREE(tmp);\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n            (*def)->cachemode = writeThrough ? VIR_DOMAIN_DISK_CACHE_WRITETHRU\n                                             : VIR_DOMAIN_DISK_CACHE_DEFAULT;\n            if (mode)\n                (*def)->transient = STRCASEEQ(mode,\n                                              \"independent-nonpersistent\");\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\"),\n                           fileName, fileName_name,\n                           deviceType ? deviceType : \"unknown\");\n            goto cleanup;\n        }\n    } else if (device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n        if (fileName && virStringHasCaseSuffix(fileName, \".vmdk\")) {\n            /*\n             * This function was called in order to parse a CDROM device, but\n             * .vmdk files are for harddisk devices only. Just ignore it,\n             * another call to this function to parse a harddisk device may\n             * handle it.\n             */\n            goto ignore;\n        } else if (fileName && virStringHasCaseSuffix(fileName, \".iso\")) {\n            char *tmp;\n\n            if (deviceType && STRCASENEQ(deviceType, \"cdrom-image\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be 'cdrom-image' \"\n                                 \"but found '%s'\"), deviceType_name, deviceType);\n                goto cleanup;\n            }\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            if (!(tmp = ctx->parseFileName(fileName, ctx->opaque)))\n                goto cleanup;\n            if (virDomainDiskSetSource(*def, tmp) < 0) {\n                VIR_FREE(tmp);\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n        } else if (deviceType && STRCASEEQ(deviceType, \"atapi-cdrom\")) {\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n\n            if (fileName && STRCASEEQ(fileName, \"auto detect\")) {\n                ignore_value(virDomainDiskSetSource(*def, NULL));\n                (*def)->startupPolicy = VIR_DOMAIN_STARTUP_POLICY_OPTIONAL;\n            } else if (virDomainDiskSetSource(*def, fileName) < 0) {\n                goto cleanup;\n            }\n        } else if (deviceType && STRCASEEQ(deviceType, \"cdrom-raw\")) {\n            /* Raw access CD-ROMs actually are device='lun' */\n            (*def)->device = VIR_DOMAIN_DISK_DEVICE_LUN;\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n\n            if (fileName && STRCASEEQ(fileName, \"auto detect\")) {\n                ignore_value(virDomainDiskSetSource(*def, NULL));\n                (*def)->startupPolicy = VIR_DOMAIN_STARTUP_POLICY_OPTIONAL;\n            } else if (virDomainDiskSetSource(*def, fileName) < 0) {\n                goto cleanup;\n            }\n        } else if (busType == VIR_DOMAIN_DISK_BUS_SCSI &&\n                   deviceType && STRCASEEQ(deviceType, \"scsi-passthru\")) {\n            if (fileName && STRPREFIX(fileName, \"/vmfs/devices/cdrom/\")) {\n                /* SCSI-passthru CD-ROMs actually are device='lun' */\n                (*def)->device = VIR_DOMAIN_DISK_DEVICE_LUN;\n                virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n\n                if (virDomainDiskSetSource(*def, fileName) < 0)\n                    goto cleanup;\n            } else {\n                /*\n                 * This function was called in order to parse a CDROM device,\n                 * but the filename does not indicate a CDROM device. Just ignore\n                 * it, another call to this function to parse a harddisk device\n                 * may handle it.\n                 */\n                goto ignore;\n            }\n        } else if (fileName && STREQ(fileName, \"emptyBackingString\")) {\n            if (deviceType && STRCASENEQ(deviceType, \"cdrom-image\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be 'cdrom-image' \"\n                                 \"but found '%s'\"), deviceType_name, deviceType);\n                goto cleanup;\n            }\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            ignore_value(virDomainDiskSetSource(*def, NULL));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\"),\n                           NULLSTR(fileName), fileName_name,\n                           deviceType ? deviceType : \"unknown\");\n            goto cleanup;\n        }\n    } else if (device == VIR_DOMAIN_DISK_DEVICE_FLOPPY) {\n        if (fileType != NULL && STRCASEEQ(fileType, \"device\")) {\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n            if (virDomainDiskSetSource(*def, fileName) < 0)\n                goto cleanup;\n        } else if (fileType != NULL && STRCASEEQ(fileType, \"file\")) {\n            char *tmp = NULL;\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            if (fileName && !(tmp = ctx->parseFileName(fileName, ctx->opaque)))\n                goto cleanup;\n            if (virDomainDiskSetSource(*def, tmp) < 0) {\n                VIR_FREE(tmp);\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\"),\n                           NULLSTR(fileName), fileName_name,\n                           deviceType ? deviceType : \"unknown\");\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, _(\"Unsupported device type '%s'\"),\n                       virDomainDiskDeviceTypeToString(device));\n        goto cleanup;\n    }\n\n    if (virDomainDiskDefAssignAddress(xmlopt, *def, vmdef) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not assign address to disk '%s'\"),\n                       virDomainDiskGetSource(*def));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainDiskDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(prefix);\n    VIR_FREE(deviceType);\n    VIR_FREE(fileType);\n    VIR_FREE(fileName);\n    VIR_FREE(mode);\n\n    return result;\n\n ignore:\n    virDomainDiskDefFree(*def);\n    *def = NULL;\n\n    result = 0;\n\n    goto cleanup;\n}"
  },
  {
    "function_name": "virVMXParseSCSIController",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "1937-2003",
    "snippet": "int\nvirVMXParseSCSIController(virConfPtr conf, int controller, bool *present,\n                          int *virtualDev)\n{\n    int result = -1;\n    char present_name[32];\n    char virtualDev_name[32];\n    char *virtualDev_string = NULL;\n    char *tmp;\n\n    if (virtualDev == NULL || *virtualDev != -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (controller < 0 || controller > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SCSI controller index %d out of [0..3] range\"),\n                       controller);\n        return -1;\n    }\n\n    g_snprintf(present_name, sizeof(present_name), \"scsi%d.present\", controller);\n    g_snprintf(virtualDev_name, sizeof(virtualDev_name), \"scsi%d.virtualDev\",\n               controller);\n\n    if (virVMXGetConfigBoolean(conf, present_name, present, false, true) < 0)\n        goto cleanup;\n\n    if (! *present) {\n        result = 0;\n        goto cleanup;\n    }\n\n    if (virVMXGetConfigString(conf, virtualDev_name, &virtualDev_string,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualDev_string != NULL) {\n        tmp = virtualDev_string;\n\n        for (; *tmp != '\\0'; ++tmp)\n            *tmp = g_ascii_tolower(*tmp);\n\n        *virtualDev = virVMXControllerModelSCSITypeFromString(virtualDev_string);\n\n        if (*virtualDev == -1 ||\n            (*virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC &&\n             *virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC &&\n             *virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068 &&\n             *virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry '%s' to be 'buslogic' or 'lsilogic' \"\n                             \"or 'lsisas1068' or 'pvscsi' but found '%s'\"),\n                           virtualDev_name, virtualDev_string);\n            goto cleanup;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(virtualDev_string);\n\n    return result;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "virtualDev_string"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry '%s' to be 'buslogic' or 'lsilogic' \"\n                             \"or 'lsisas1068' or 'pvscsi' but found '%s'\")",
            "virtualDev_name",
            "virtualDev_string"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Expecting VMX entry '%s' to be 'buslogic' or 'lsilogic' \"\n                             \"or 'lsisas1068' or 'pvscsi' but found '%s'\""
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXControllerModelSCSITypeFromString",
          "args": [
            "virtualDev_string"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_tolower",
          "args": [
            "*tmp"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigString",
          "args": [
            "conf",
            "virtualDev_name",
            "&virtualDev_string",
            "true"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "750-760",
          "snippet": "static int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigBoolean",
          "args": [
            "conf",
            "present_name",
            "present",
            "false",
            "true"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "824-854",
          "snippet": "static int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "virtualDev_name",
            "sizeof(virtualDev_name)",
            "\"scsi%d.virtualDev\"",
            "controller"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "present_name",
            "sizeof(present_name)",
            "\"scsi%d.present\"",
            "controller"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"SCSI controller index %d out of [0..3] range\")",
            "controller"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXParseSCSIController(virConfPtr conf, int controller, bool *present,\n                          int *virtualDev)\n{\n    int result = -1;\n    char present_name[32];\n    char virtualDev_name[32];\n    char *virtualDev_string = NULL;\n    char *tmp;\n\n    if (virtualDev == NULL || *virtualDev != -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (controller < 0 || controller > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SCSI controller index %d out of [0..3] range\"),\n                       controller);\n        return -1;\n    }\n\n    g_snprintf(present_name, sizeof(present_name), \"scsi%d.present\", controller);\n    g_snprintf(virtualDev_name, sizeof(virtualDev_name), \"scsi%d.virtualDev\",\n               controller);\n\n    if (virVMXGetConfigBoolean(conf, present_name, present, false, true) < 0)\n        goto cleanup;\n\n    if (! *present) {\n        result = 0;\n        goto cleanup;\n    }\n\n    if (virVMXGetConfigString(conf, virtualDev_name, &virtualDev_string,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualDev_string != NULL) {\n        tmp = virtualDev_string;\n\n        for (; *tmp != '\\0'; ++tmp)\n            *tmp = g_ascii_tolower(*tmp);\n\n        *virtualDev = virVMXControllerModelSCSITypeFromString(virtualDev_string);\n\n        if (*virtualDev == -1 ||\n            (*virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC &&\n             *virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC &&\n             *virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068 &&\n             *virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry '%s' to be 'buslogic' or 'lsilogic' \"\n                             \"or 'lsisas1068' or 'pvscsi' but found '%s'\"),\n                           virtualDev_name, virtualDev_string);\n            goto cleanup;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(virtualDev_string);\n\n    return result;\n}"
  },
  {
    "function_name": "virVMXParseVNC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "1871-1933",
    "snippet": "int\nvirVMXParseVNC(virConfPtr conf, virDomainGraphicsDefPtr *def)\n{\n    bool enabled = false;\n    long long port = 0;\n    char *listenAddr = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virVMXGetConfigBoolean(conf, \"RemoteDisplay.vnc.enabled\", &enabled,\n                               false, true) < 0) {\n        return -1;\n    }\n\n    if (! enabled)\n        return 0;\n\n    if (VIR_ALLOC(*def) < 0)\n        goto failure;\n\n    (*def)->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n\n    if (virVMXGetConfigLong(conf, \"RemoteDisplay.vnc.port\", &port, -1,\n                            true) < 0 ||\n        virVMXGetConfigString(conf, \"RemoteDisplay.vnc.ip\",\n                              &listenAddr, true) < 0 ||\n        virVMXGetConfigString(conf, \"RemoteDisplay.vnc.keymap\",\n                              &(*def)->data.vnc.keymap, true) < 0 ||\n        virVMXGetConfigString(conf, \"RemoteDisplay.vnc.password\",\n                              &(*def)->data.vnc.auth.passwd, true) < 0) {\n        goto failure;\n    }\n\n    if (virDomainGraphicsListenAppendAddress(*def, listenAddr) < 0)\n        goto failure;\n    VIR_FREE(listenAddr);\n\n    if (port < 0) {\n        VIR_WARN(\"VNC is enabled but VMX entry 'RemoteDisplay.vnc.port' \"\n                  \"is missing, the VNC port is unknown\");\n\n        (*def)->data.vnc.port = 0;\n        (*def)->data.vnc.autoport = true;\n    } else {\n        if (port < 5900 || port > 5964)\n            VIR_WARN(\"VNC port %lld it out of [5900..5964] range\", port);\n\n        (*def)->data.vnc.port = port;\n        (*def)->data.vnc.autoport = false;\n    }\n\n    return 0;\n\n failure:\n    VIR_FREE(listenAddr);\n    virDomainGraphicsDefFree(*def);\n    *def = NULL;\n\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainGraphicsDefFree",
          "args": [
            "*def"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1719-1764",
          "snippet": "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    switch (def->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        VIR_FREE(def->data.vnc.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.vnc.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n        VIR_FREE(def->data.sdl.display);\n        VIR_FREE(def->data.sdl.xauth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n        VIR_FREE(def->data.desktop.display);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        VIR_FREE(def->data.spice.rendernode);\n        VIR_FREE(def->data.spice.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.spice.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        VIR_FREE(def->data.egl_headless.rendernode);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    for (i = 0; i < def->nListens; i++)\n        virDomainGraphicsListenDefClear(&def->listens[i]);\n    VIR_FREE(def->listens);\n\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    switch (def->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        VIR_FREE(def->data.vnc.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.vnc.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n        VIR_FREE(def->data.sdl.display);\n        VIR_FREE(def->data.sdl.xauth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n        VIR_FREE(def->data.desktop.display);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        VIR_FREE(def->data.spice.rendernode);\n        VIR_FREE(def->data.spice.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.spice.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        VIR_FREE(def->data.egl_headless.rendernode);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    for (i = 0; i < def->nListens; i++)\n        virDomainGraphicsListenDefClear(&def->listens[i]);\n    VIR_FREE(def->listens);\n\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "listenAddr"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"VNC port %lld it out of [5900..5964] range\"",
            "port"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"VNC is enabled but VMX entry 'RemoteDisplay.vnc.port' \"\n                  \"is missing, the VNC port is unknown\""
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "listenAddr"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsListenAppendAddress",
          "args": [
            "*def",
            "listenAddr"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsListenAppendAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30367-30386",
          "snippet": "int\nvirDomainGraphicsListenAppendAddress(virDomainGraphicsDefPtr def,\n                                     const char *address)\n{\n    virDomainGraphicsListenDef glisten;\n\n    memset(&glisten, 0, sizeof(glisten));\n\n    glisten.type = VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS;\n\n    glisten.address = g_strdup(address);\n\n    if (VIR_APPEND_ELEMENT_COPY(def->listens, def->nListens, glisten) < 0)\n        goto error;\n\n    return 0;\n error:\n    VIR_FREE(glisten.address);\n    return -1;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainGraphicsListenAppendAddress(virDomainGraphicsDefPtr def,\n                                     const char *address)\n{\n    virDomainGraphicsListenDef glisten;\n\n    memset(&glisten, 0, sizeof(glisten));\n\n    glisten.type = VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS;\n\n    glisten.address = g_strdup(address);\n\n    if (VIR_APPEND_ELEMENT_COPY(def->listens, def->nListens, glisten) < 0)\n        goto error;\n\n    return 0;\n error:\n    VIR_FREE(glisten.address);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigString",
          "args": [
            "conf",
            "\"RemoteDisplay.vnc.password\"",
            "&(*def)->data.vnc.auth.passwd",
            "true"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "750-760",
          "snippet": "static int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigLong",
          "args": [
            "conf",
            "\"RemoteDisplay.vnc.port\"",
            "&port",
            "-1",
            "true"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "792-820",
          "snippet": "static int\nvirVMXGetConfigLong(virConfPtr conf, const char *name, long long *number,\n                    long long default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *number = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"unlimited\")) {\n        *number = -1;\n    } else if (virStrToLong_ll(string, NULL, 10, number) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Config entry '%s' must represent an integer value\"),\n                name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigLong(virConfPtr conf, const char *name, long long *number,\n                    long long default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *number = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"unlimited\")) {\n        *number = -1;\n    } else if (virStrToLong_ll(string, NULL, 10, number) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Config entry '%s' must represent an integer value\"),\n                name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "*def"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigBoolean",
          "args": [
            "conf",
            "\"RemoteDisplay.vnc.enabled\"",
            "&enabled",
            "false",
            "true"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "824-854",
          "snippet": "static int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid argument\""
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXParseVNC(virConfPtr conf, virDomainGraphicsDefPtr *def)\n{\n    bool enabled = false;\n    long long port = 0;\n    char *listenAddr = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virVMXGetConfigBoolean(conf, \"RemoteDisplay.vnc.enabled\", &enabled,\n                               false, true) < 0) {\n        return -1;\n    }\n\n    if (! enabled)\n        return 0;\n\n    if (VIR_ALLOC(*def) < 0)\n        goto failure;\n\n    (*def)->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n\n    if (virVMXGetConfigLong(conf, \"RemoteDisplay.vnc.port\", &port, -1,\n                            true) < 0 ||\n        virVMXGetConfigString(conf, \"RemoteDisplay.vnc.ip\",\n                              &listenAddr, true) < 0 ||\n        virVMXGetConfigString(conf, \"RemoteDisplay.vnc.keymap\",\n                              &(*def)->data.vnc.keymap, true) < 0 ||\n        virVMXGetConfigString(conf, \"RemoteDisplay.vnc.password\",\n                              &(*def)->data.vnc.auth.passwd, true) < 0) {\n        goto failure;\n    }\n\n    if (virDomainGraphicsListenAppendAddress(*def, listenAddr) < 0)\n        goto failure;\n    VIR_FREE(listenAddr);\n\n    if (port < 0) {\n        VIR_WARN(\"VNC is enabled but VMX entry 'RemoteDisplay.vnc.port' \"\n                  \"is missing, the VNC port is unknown\");\n\n        (*def)->data.vnc.port = 0;\n        (*def)->data.vnc.autoport = true;\n    } else {\n        if (port < 5900 || port > 5964)\n            VIR_WARN(\"VNC port %lld it out of [5900..5964] range\", port);\n\n        (*def)->data.vnc.port = port;\n        (*def)->data.vnc.autoport = false;\n    }\n\n    return 0;\n\n failure:\n    VIR_FREE(listenAddr);\n    virDomainGraphicsDefFree(*def);\n    *def = NULL;\n\n    return -1;\n}"
  },
  {
    "function_name": "virVMXParseConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "1275-1867",
    "snippet": "virDomainDefPtr\nvirVMXParseConfig(virVMXContext *ctx,\n                  virDomainXMLOptionPtr xmlopt,\n                  virCapsPtr caps G_GNUC_UNUSED,\n                  const char *vmx)\n{\n    bool success = false;\n    g_autoptr(virConf) conf = NULL;\n    char *encoding = NULL;\n    char *utf8;\n    virDomainDefPtr def = NULL;\n    long long config_version = 0;\n    long long virtualHW_version = 0;\n    long long memsize = 0;\n    long long sched_mem_max = 0;\n    long long sched_mem_minsize = 0;\n    long long numvcpus = 0;\n    char *sched_cpu_affinity = NULL;\n    char *sched_cpu_shares = NULL;\n    char *guestOS = NULL;\n    bool smbios_reflecthost = false;\n    int controller;\n    int bus;\n    int port;\n    bool present;\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    int unit;\n    bool hgfs_disabled = true;\n    long long sharedFolder_maxNum = 0;\n    struct virVMXConfigScanResults results = { -1 };\n    long long coresPerSocket = 0;\n    virCPUDefPtr cpu = NULL;\n    char *firmware = NULL;\n\n    if (ctx->parseFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no parseFileName function set\"));\n        return NULL;\n    }\n\n    conf = virConfReadString(vmx, VIR_CONF_FLAG_VMX_FORMAT);\n\n    if (conf == NULL)\n        return NULL;\n\n    /* vmx:.encoding */\n    if (virVMXGetConfigString(conf, \".encoding\", &encoding, true) < 0)\n        goto cleanup;\n\n    if (encoding == NULL || STRCASEEQ(encoding, \"UTF-8\")) {\n        /* nothing */\n    } else {\n        virConfFree(conf);\n        conf = NULL;\n\n        utf8 = virVMXConvertToUTF8(encoding, vmx);\n\n        if (utf8 == NULL)\n            goto cleanup;\n\n        conf = virConfReadString(utf8, VIR_CONF_FLAG_VMX_FORMAT);\n\n        VIR_FREE(utf8);\n\n        if (conf == NULL)\n            goto cleanup;\n    }\n\n    if (virConfWalk(conf, virVMXConfigScanResultsCollector, &results) < 0)\n        goto cleanup;\n\n    /* Allocate domain def */\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    def->virtType = VIR_DOMAIN_VIRT_VMWARE;\n    def->id = -1;\n\n    /* vmx:config.version */\n    if (virVMXGetConfigLong(conf, \"config.version\", &config_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (config_version != 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'config.version' to be 8 but found \"\n                         \"%lld\"), config_version);\n        goto cleanup;\n    }\n\n    /* vmx:virtualHW.version */\n    if (virVMXGetConfigLong(conf, \"virtualHW.version\", &virtualHW_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualHW_version < 4) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'virtualHW.version' to be \"\n                         \"4 or higher but found %lld\"),\n                       virtualHW_version);\n        goto cleanup;\n    }\n\n    /* vmx:uuid.bios -> def:uuid */\n    /* FIXME: Need to handle 'uuid.action = \"create\"' */\n    if (virVMXGetConfigUUID(conf, \"uuid.bios\", def->uuid, true) < 0)\n        goto cleanup;\n\n    /* vmx:displayName -> def:name */\n    if (virVMXGetConfigString(conf, \"displayName\", &def->name, true) < 0)\n        goto cleanup;\n\n    if (def->name != NULL) {\n        if (virVMXUnescapeHexPercent(def->name) < 0 ||\n            virVMXUnescapeHexPipe(def->name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'name' contains invalid escape sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:annotation -> def:description */\n    if (virVMXGetConfigString(conf, \"annotation\", &def->description,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (def->description != NULL) {\n        if (virVMXUnescapeHexPipe(def->description) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'annotation' contains invalid escape \"\n                             \"sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:memsize -> def:mem.max_balloon */\n    if (virVMXGetConfigLong(conf, \"memsize\", &memsize, 32, true) < 0)\n        goto cleanup;\n\n    if (memsize <= 0 || memsize % 4 != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'memsize' to be an unsigned \"\n                         \"integer (multiple of 4) but found %lld\"), memsize);\n        goto cleanup;\n    }\n\n    virDomainDefSetMemoryTotal(def, memsize * 1024); /* Scale from megabytes to kilobytes */\n\n    /* vmx:sched.mem.max -> def:mem.cur_balloon */\n    if (virVMXGetConfigLong(conf, \"sched.mem.max\", &sched_mem_max, memsize,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_max < 0)\n        sched_mem_max = memsize;\n\n    def->mem.cur_balloon = sched_mem_max * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.cur_balloon > virDomainDefGetMemoryTotal(def))\n        def->mem.cur_balloon = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:sched.mem.minsize -> def:mem.min_guarantee */\n    if (virVMXGetConfigLong(conf, \"sched.mem.minsize\", &sched_mem_minsize, 0,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_minsize < 0)\n        sched_mem_minsize = 0;\n\n    def->mem.min_guarantee = sched_mem_minsize * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.min_guarantee > virDomainDefGetMemoryTotal(def))\n        def->mem.min_guarantee = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:numvcpus -> def:vcpus */\n    if (virVMXGetConfigLong(conf, \"numvcpus\", &numvcpus, 1, true) < 0)\n        goto cleanup;\n\n    if (numvcpus <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'numvcpus' to be an unsigned \"\n                         \"integer greater than 0 but found %lld\"), numvcpus);\n        goto cleanup;\n    }\n\n    if (virDomainDefSetVcpusMax(def, numvcpus, xmlopt) < 0)\n        goto cleanup;\n\n    if (virDomainDefSetVcpus(def, numvcpus) < 0)\n        goto cleanup;\n\n    /* vmx:cpuid.coresPerSocket -> def:cpu */\n    if (virVMXGetConfigLong(conf, \"cpuid.coresPerSocket\", &coresPerSocket, 1,\n                            true) < 0)\n        goto cleanup;\n\n    if (coresPerSocket > 1) {\n        cpu = virCPUDefNew();\n\n        cpu->type = VIR_CPU_TYPE_GUEST;\n        cpu->mode = VIR_CPU_MODE_CUSTOM;\n\n        cpu->sockets = numvcpus / coresPerSocket;\n        if (cpu->sockets <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'cpuid.coresPerSocket' smaller than \"\n                             \"'numvcpus'\"));\n            goto cleanup;\n        }\n        cpu->dies = 1;\n        cpu->cores = coresPerSocket;\n        cpu->threads = 1;\n\n        def->cpu = g_steal_pointer(&cpu);\n    }\n\n    /* vmx:sched.cpu.affinity -> def:cpumask */\n    /* NOTE: maps to VirtualMachine:config.cpuAffinity.affinitySet */\n    if (virVMXGetConfigString(conf, \"sched.cpu.affinity\", &sched_cpu_affinity,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_affinity != NULL && STRCASENEQ(sched_cpu_affinity, \"all\")) {\n        VIR_AUTOSTRINGLIST afflist = NULL;\n        char **aff;\n        size_t naffs;\n\n        def->cpumask = virBitmapNew(VIR_DOMAIN_CPUMASK_LEN);\n        if (!def->cpumask)\n            goto cleanup;\n\n        if (!(afflist = virStringSplitCount(sched_cpu_affinity, \",\", 0, &naffs)))\n            goto cleanup;\n\n        if (naffs < numvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.affinity' to contain \"\n                             \"at least as many values as 'numvcpus' (%lld) but \"\n                             \"found only %zu value(s)\"), numvcpus, naffs);\n            goto cleanup;\n        }\n\n        for (aff = afflist; *aff; aff++) {\n            const char *current = *aff;\n            unsigned int number;\n            int rc;\n\n            virSkipSpaces(&current);\n            rc = virStrToLong_uip(current, (char **) &current, 10, &number);\n            virSkipSpaces(&current);\n\n            if (rc < 0 || *current != '\\0') {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry 'sched.cpu.affinity' to be \"\n                                 \"a comma separated list of unsigned integers but \"\n                                 \"found '%s'\"), sched_cpu_affinity);\n                goto cleanup;\n            }\n\n            if (number >= VIR_DOMAIN_CPUMASK_LEN) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"VMX entry 'sched.cpu.affinity' contains a %d, \"\n                                 \"this value is too large\"), number);\n                goto cleanup;\n            }\n\n            ignore_value(virBitmapSetBit(def->cpumask, number));\n        }\n    }\n\n    /* vmx:sched.cpu.shares -> def:cputune.shares */\n    if (virVMXGetConfigString(conf, \"sched.cpu.shares\", &sched_cpu_shares,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_shares != NULL) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (STRCASEEQ(sched_cpu_shares, \"low\")) {\n            def->cputune.shares = vcpus * 500;\n        } else if (STRCASEEQ(sched_cpu_shares, \"normal\")) {\n            def->cputune.shares = vcpus * 1000;\n        } else if (STRCASEEQ(sched_cpu_shares, \"high\")) {\n            def->cputune.shares = vcpus * 2000;\n        } else if (virStrToLong_ull(sched_cpu_shares, NULL, 10,\n                                    &def->cputune.shares) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.shares' to be an \"\n                             \"unsigned integer or 'low', 'normal' or 'high' but \"\n                             \"found '%s'\"), sched_cpu_shares);\n            goto cleanup;\n        }\n        def->cputune.sharesSpecified = true;\n    }\n\n    /* def:lifecycle */\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* def:os */\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    /* vmx:guestOS -> def:os.arch */\n    if (virVMXGetConfigString(conf, \"guestOS\", &guestOS, true) < 0)\n        goto cleanup;\n\n    if (guestOS != NULL && virStringHasSuffix(guestOS, \"-64\")) {\n        def->os.arch = VIR_ARCH_X86_64;\n    } else {\n        def->os.arch = VIR_ARCH_I686;\n    }\n\n    /* vmx:smbios.reflecthost -> def:os.smbios_mode */\n    if (virVMXGetConfigBoolean(conf, \"smbios.reflecthost\",\n                               &smbios_reflecthost, false, true) < 0) {\n        goto cleanup;\n    }\n\n    if (smbios_reflecthost)\n        def->os.smbios_mode = VIR_DOMAIN_SMBIOS_HOST;\n\n    /* def:features */\n    /* FIXME */\n\n    /* def:clock */\n    /* FIXME */\n\n    /* def:graphics */\n    if (VIR_ALLOC_N(def->graphics, 1) < 0)\n        goto cleanup;\n\n    def->ngraphics = 0;\n\n    if (virVMXParseVNC(conf, &def->graphics[def->ngraphics]) < 0)\n        goto cleanup;\n\n    if (def->graphics[def->ngraphics] != NULL)\n        ++def->ngraphics;\n\n    /* def:disks: 4 * 15 scsi + 2 * 2 ide + 2 floppy = 66 */\n    if (VIR_ALLOC_N(def->disks, 66) < 0)\n        goto cleanup;\n\n    def->ndisks = 0;\n\n    /* def:disks (scsi) */\n    for (controller = 0; controller < 4; ++controller) {\n        if (virVMXParseSCSIController(conf, controller, &present,\n                                      &scsi_virtualDev[controller]) < 0) {\n            goto cleanup;\n        }\n\n        if (! present)\n            continue;\n\n        for (unit = 0; unit < 16; ++unit) {\n            if (unit == 7) {\n                /*\n                 * SCSI unit 7 is assigned to the SCSI controller and cannot be\n                 * used for disk devices.\n                 */\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                 VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                 &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n\n    }\n\n    /* add all the SCSI controllers we've seen, up until the last one that is\n     * currently used by a disk */\n    if (def->ndisks != 0) {\n        virDomainDeviceInfoPtr info = &def->disks[def->ndisks - 1]->info;\n        for (controller = 0; controller <= info->addr.drive.controller; controller++) {\n            if (!virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_SCSI,\n                                           controller, scsi_virtualDev[controller]))\n                goto cleanup;\n        }\n    }\n\n    /* def:disks (ide) */\n    for (bus = 0; bus < 2; ++bus) {\n        for (unit = 0; unit < 2; ++unit) {\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n    }\n\n    /* def:disks (floppy) */\n    for (unit = 0; unit < 2; ++unit) {\n        if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_FLOPPY,\n                            VIR_DOMAIN_DISK_BUS_FDC, 0, unit,\n                            &def->disks[def->ndisks], def) < 0) {\n            goto cleanup;\n        }\n\n        if (def->disks[def->ndisks] != NULL)\n            ++def->ndisks;\n    }\n\n    /* def:fss */\n    if (virVMXGetConfigBoolean(conf, \"isolation.tools.hgfs.disable\",\n                               &hgfs_disabled, true, true) < 0) {\n        goto cleanup;\n    }\n\n    if (!hgfs_disabled) {\n        if (virVMXGetConfigLong(conf, \"sharedFolder.maxNum\", &sharedFolder_maxNum,\n                                0, true) < 0) {\n            goto cleanup;\n        }\n\n        if (sharedFolder_maxNum > 0) {\n            int number;\n\n            if (VIR_ALLOC_N(def->fss, sharedFolder_maxNum) < 0)\n                goto cleanup;\n\n            def->nfss = 0;\n\n            for (number = 0; number < sharedFolder_maxNum; ++number) {\n                if (virVMXParseFileSystem(conf, number,\n                                          &def->fss[def->nfss]) < 0) {\n                    goto cleanup;\n                }\n\n                if (def->fss[def->nfss] != NULL)\n                    ++def->nfss;\n            }\n        }\n    }\n\n    /* def:nets */\n    for (controller = 0; controller <= results.networks_max_index; ++controller) {\n        virDomainNetDefPtr net = NULL;\n        if (virVMXParseEthernet(conf, controller, &net) < 0)\n            goto cleanup;\n\n        if (!net)\n            continue;\n\n        if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:videos */\n    if (VIR_ALLOC_N(def->videos, 1) < 0)\n        goto cleanup;\n\n    def->nvideos = 0;\n\n    if (virVMXParseSVGA(conf, &def->videos[def->nvideos]) < 0)\n        goto cleanup;\n\n    def->nvideos = 1;\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    if (VIR_ALLOC_N(def->serials, 4) < 0)\n        goto cleanup;\n\n    def->nserials = 0;\n\n    for (port = 0; port < 4; ++port) {\n        if (virVMXParseSerial(ctx, conf, port,\n                              &def->serials[def->nserials]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->serials[def->nserials] != NULL)\n            ++def->nserials;\n    }\n\n    /* def:parallels */\n    if (VIR_ALLOC_N(def->parallels, 3) < 0)\n        goto cleanup;\n\n    def->nparallels = 0;\n\n    for (port = 0; port < 3; ++port) {\n        if (virVMXParseParallel(ctx, conf, port,\n                                &def->parallels[def->nparallels]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->parallels[def->nparallels] != NULL)\n            ++def->nparallels;\n    }\n\n    /* ctx:datacenterPath -> def:namespaceData */\n    if (ctx->datacenterPath || ctx->moref) {\n        struct virVMXDomainDefNamespaceData *nsdata = NULL;\n\n        if (VIR_ALLOC(nsdata) < 0) {\n            virVMXDomainDefNamespaceFree(nsdata);\n            goto cleanup;\n        }\n\n        nsdata->datacenterPath = g_strdup(ctx->datacenterPath);\n\n        nsdata->moref = g_strdup(ctx->moref);\n\n        def->ns = *virDomainXMLOptionGetNamespace(xmlopt);\n        def->namespaceData = nsdata;\n    }\n\n    /* vmx:firmware */\n    if (virVMXGetConfigString(conf, \"firmware\", &firmware, true) < 0)\n        goto cleanup;\n\n    if (firmware != NULL) {\n        if (STREQ(firmware, \"efi\")) {\n            def->os.firmware = VIR_DOMAIN_OS_DEF_FIRMWARE_EFI;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry 'firmware' has unknown value '%s'\"),\n                           firmware);\n            goto cleanup;\n        }\n    }\n\n    if (virDomainDefPostParse(def, VIR_DOMAIN_DEF_PARSE_ABI_UPDATE,\n                              xmlopt, NULL) < 0)\n        goto cleanup;\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        virDomainDefFree(def);\n        def = NULL;\n    }\n\n    VIR_FREE(encoding);\n    VIR_FREE(sched_cpu_affinity);\n    VIR_FREE(sched_cpu_shares);\n    VIR_FREE(guestOS);\n    virCPUDefFree(cpu);\n    VIR_FREE(firmware);\n\n    return def;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "firmware"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "cpu"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "guestOS"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sched_cpu_shares"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sched_cpu_affinity"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "encoding"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefPostParse",
          "args": [
            "def",
            "VIR_DOMAIN_DEF_PARSE_ABI_UPDATE",
            "xmlopt",
            "NULL"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefPostParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "5869-5953",
          "snippet": "int\nvirDomainDefPostParse(virDomainDefPtr def,\n                      unsigned int parseFlags,\n                      virDomainXMLOptionPtr xmlopt,\n                      void *parseOpaque)\n{\n    int ret = -1;\n    bool localParseOpaque = false;\n    struct virDomainDefPostParseDeviceIteratorData data = {\n        .xmlopt = xmlopt,\n        .parseFlags = parseFlags,\n        .parseOpaque = parseOpaque,\n    };\n\n    def->postParseFailed = false;\n\n    /* call the basic post parse callback */\n    if (xmlopt->config.domainPostParseBasicCallback) {\n        ret = xmlopt->config.domainPostParseBasicCallback(def,\n                                                          xmlopt->config.priv);\n\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n    }\n\n    if (!data.parseOpaque &&\n        xmlopt->config.domainPostParseDataAlloc) {\n        ret = xmlopt->config.domainPostParseDataAlloc(def, parseFlags,\n                                                      xmlopt->config.priv,\n                                                      &data.parseOpaque);\n\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n        localParseOpaque = true;\n    }\n\n    /* this must be done before the hypervisor-specific callback,\n     * in case presence of a controller at a specific index is checked\n     */\n    virDomainAssignControllerIndexes(def);\n\n    /* call the domain config callback */\n    if (xmlopt->config.domainPostParseCallback) {\n        ret = xmlopt->config.domainPostParseCallback(def, parseFlags,\n                                                     xmlopt->config.priv,\n                                                     data.parseOpaque);\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n    }\n\n    /* iterate the devices */\n    ret = virDomainDeviceInfoIterateInternal(def,\n                                             virDomainDefPostParseDeviceIterator,\n                                             DOMAIN_DEVICE_ITERATE_ALL_CONSOLES |\n                                             DOMAIN_DEVICE_ITERATE_MISSING_INFO,\n                                             &data);\n\n    if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n        goto cleanup;\n\n    if ((ret = virDomainDefPostParseCommon(def, &data, xmlopt)) < 0)\n        goto cleanup;\n\n    if (xmlopt->config.assignAddressesCallback) {\n        ret = xmlopt->config.assignAddressesCallback(def, parseFlags,\n                                                     xmlopt->config.priv,\n                                                     data.parseOpaque);\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n    }\n\n    if ((ret = virDomainDefPostParseCheckFeatures(def, xmlopt)) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (localParseOpaque && xmlopt->config.domainPostParseDataFree)\n        xmlopt->config.domainPostParseDataFree(data.parseOpaque);\n\n    if (ret == 1)\n        ret = -1;\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum {\n    DOMAIN_DEVICE_ITERATE_ALL_CONSOLES = 1 << 0,\n    DOMAIN_DEVICE_ITERATE_MISSING_INFO = 1 << 1,\n} virDomainDeviceIterateFlags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nenum {\n    DOMAIN_DEVICE_ITERATE_ALL_CONSOLES = 1 << 0,\n    DOMAIN_DEVICE_ITERATE_MISSING_INFO = 1 << 1,\n} virDomainDeviceIterateFlags;\n\nint\nvirDomainDefPostParse(virDomainDefPtr def,\n                      unsigned int parseFlags,\n                      virDomainXMLOptionPtr xmlopt,\n                      void *parseOpaque)\n{\n    int ret = -1;\n    bool localParseOpaque = false;\n    struct virDomainDefPostParseDeviceIteratorData data = {\n        .xmlopt = xmlopt,\n        .parseFlags = parseFlags,\n        .parseOpaque = parseOpaque,\n    };\n\n    def->postParseFailed = false;\n\n    /* call the basic post parse callback */\n    if (xmlopt->config.domainPostParseBasicCallback) {\n        ret = xmlopt->config.domainPostParseBasicCallback(def,\n                                                          xmlopt->config.priv);\n\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n    }\n\n    if (!data.parseOpaque &&\n        xmlopt->config.domainPostParseDataAlloc) {\n        ret = xmlopt->config.domainPostParseDataAlloc(def, parseFlags,\n                                                      xmlopt->config.priv,\n                                                      &data.parseOpaque);\n\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n        localParseOpaque = true;\n    }\n\n    /* this must be done before the hypervisor-specific callback,\n     * in case presence of a controller at a specific index is checked\n     */\n    virDomainAssignControllerIndexes(def);\n\n    /* call the domain config callback */\n    if (xmlopt->config.domainPostParseCallback) {\n        ret = xmlopt->config.domainPostParseCallback(def, parseFlags,\n                                                     xmlopt->config.priv,\n                                                     data.parseOpaque);\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n    }\n\n    /* iterate the devices */\n    ret = virDomainDeviceInfoIterateInternal(def,\n                                             virDomainDefPostParseDeviceIterator,\n                                             DOMAIN_DEVICE_ITERATE_ALL_CONSOLES |\n                                             DOMAIN_DEVICE_ITERATE_MISSING_INFO,\n                                             &data);\n\n    if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n        goto cleanup;\n\n    if ((ret = virDomainDefPostParseCommon(def, &data, xmlopt)) < 0)\n        goto cleanup;\n\n    if (xmlopt->config.assignAddressesCallback) {\n        ret = xmlopt->config.assignAddressesCallback(def, parseFlags,\n                                                     xmlopt->config.priv,\n                                                     data.parseOpaque);\n        if (virDomainDefPostParseCheckFailure(def, parseFlags, ret) < 0)\n            goto cleanup;\n    }\n\n    if ((ret = virDomainDefPostParseCheckFeatures(def, xmlopt)) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (localParseOpaque && xmlopt->config.domainPostParseDataFree)\n        xmlopt->config.domainPostParseDataFree(data.parseOpaque);\n\n    if (ret == 1)\n        ret = -1;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"VMX entry 'firmware' has unknown value '%s'\")",
            "firmware"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"VMX entry 'firmware' has unknown value '%s'\""
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "firmware",
            "\"efi\""
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigString",
          "args": [
            "conf",
            "\"firmware\"",
            "&firmware",
            "true"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "750-760",
          "snippet": "static int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainXMLOptionGetNamespace",
          "args": [
            "xmlopt"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainXMLOptionGetNamespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1468-1472",
          "snippet": "virXMLNamespacePtr\nvirDomainXMLOptionGetNamespace(virDomainXMLOptionPtr xmlopt)\n{\n    return &xmlopt->ns;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirXMLNamespacePtr\nvirDomainXMLOptionGetNamespace(virDomainXMLOptionPtr xmlopt)\n{\n    return &xmlopt->ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXDomainDefNamespaceFree",
          "args": [
            "nsdata"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXDomainDefNamespaceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "569-579",
          "snippet": "static void\nvirVMXDomainDefNamespaceFree(void *nsdata)\n{\n    struct virVMXDomainDefNamespaceData *data = nsdata;\n\n    if (data) {\n        VIR_FREE(data->datacenterPath);\n        VIR_FREE(data->moref);\n    }\n    VIR_FREE(data);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nvirVMXDomainDefNamespaceFree(void *nsdata)\n{\n    struct virVMXDomainDefNamespaceData *data = nsdata;\n\n    if (data) {\n        VIR_FREE(data->datacenterPath);\n        VIR_FREE(data->moref);\n    }\n    VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "nsdata"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXParseParallel",
          "args": [
            "ctx",
            "conf",
            "port",
            "&def->parallels[def->nparallels]"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXParseParallel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "2909-3007",
          "snippet": "int\nvirVMXParseParallel(virVMXContext *ctx, virConfPtr conf, int port,\n                    virDomainChrDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char startConnected_name[48] = \"\";\n    bool startConnected = false;\n\n    char fileType_name[48] = \"\";\n    char *fileType = NULL;\n\n    char fileName_name[48] = \"\";\n    char *fileName = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (port < 0 || port > 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Parallel port index %d out of [0..2] range\"), port);\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"parallel%d\", port);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(fileType);\n    VMX_BUILD_NAME(fileName);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        return -1;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        return 0;\n\n    if (!(*def = virDomainChrDefNew(NULL)))\n        return -1;\n\n    (*def)->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_PARALLEL;\n\n    /* vmx:fileType -> def:type */\n    if (virVMXGetConfigString(conf, fileType_name, &fileType, false) < 0)\n        goto cleanup;\n\n    /* vmx:fileName -> def:data.file.path */\n    if (virVMXGetConfigString(conf, fileName_name, &fileName, false) < 0)\n        goto cleanup;\n\n    /* Setup virDomainChrDef */\n    if (STRCASEEQ(fileType, \"device\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        (*def)->source->data.file.path = fileName;\n\n        fileName = NULL;\n    } else if (STRCASEEQ(fileType, \"file\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n        (*def)->source->data.file.path = ctx->parseFileName(fileName,\n                                                            ctx->opaque);\n\n        if ((*def)->source->data.file.path == NULL)\n            goto cleanup;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry '%s' to be 'device' or 'file' but \"\n                         \"found '%s'\"), fileType_name, fileType);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainChrDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(fileType);\n    VIR_FREE(fileName);\n\n    return result;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXParseParallel(virVMXContext *ctx, virConfPtr conf, int port,\n                    virDomainChrDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char startConnected_name[48] = \"\";\n    bool startConnected = false;\n\n    char fileType_name[48] = \"\";\n    char *fileType = NULL;\n\n    char fileName_name[48] = \"\";\n    char *fileName = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (port < 0 || port > 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Parallel port index %d out of [0..2] range\"), port);\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"parallel%d\", port);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(fileType);\n    VMX_BUILD_NAME(fileName);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        return -1;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        return 0;\n\n    if (!(*def = virDomainChrDefNew(NULL)))\n        return -1;\n\n    (*def)->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_PARALLEL;\n\n    /* vmx:fileType -> def:type */\n    if (virVMXGetConfigString(conf, fileType_name, &fileType, false) < 0)\n        goto cleanup;\n\n    /* vmx:fileName -> def:data.file.path */\n    if (virVMXGetConfigString(conf, fileName_name, &fileName, false) < 0)\n        goto cleanup;\n\n    /* Setup virDomainChrDef */\n    if (STRCASEEQ(fileType, \"device\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        (*def)->source->data.file.path = fileName;\n\n        fileName = NULL;\n    } else if (STRCASEEQ(fileType, \"file\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n        (*def)->source->data.file.path = ctx->parseFileName(fileName,\n                                                            ctx->opaque);\n\n        if ((*def)->source->data.file.path == NULL)\n            goto cleanup;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry '%s' to be 'device' or 'file' but \"\n                         \"found '%s'\"), fileType_name, fileType);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainChrDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(fileType);\n    VIR_FREE(fileName);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->parallels",
            "3"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXParseSerial",
          "args": [
            "ctx",
            "conf",
            "port",
            "&def->serials[def->nserials]"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXParseSerial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "2727-2905",
          "snippet": "int\nvirVMXParseSerial(virVMXContext *ctx, virConfPtr conf, int port,\n                  virDomainChrDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char startConnected_name[48] = \"\";\n    bool startConnected = false;\n\n    char fileType_name[48] = \"\";\n    char *fileType = NULL;\n\n    char fileName_name[48] = \"\";\n    char *fileName = NULL;\n\n    char network_endPoint_name[48] = \"\";\n    char *network_endPoint = NULL;\n\n    virURIPtr parsedUri = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (port < 0 || port > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Serial port index %d out of [0..3] range\"), port);\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"serial%d\", port);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(fileType);\n    VMX_BUILD_NAME(fileName);\n    VMX_BUILD_NAME_EXTRA(network_endPoint, \"network.endPoint\");\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        return -1;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        return 0;\n\n    if (!(*def = virDomainChrDefNew(NULL)))\n        return -1;\n\n    (*def)->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n\n    /* vmx:fileType -> def:type */\n    if (virVMXGetConfigString(conf, fileType_name, &fileType, true) < 0)\n        goto cleanup;\n\n    /* vmx:fileName -> def:data.file.path */\n    if (virVMXGetConfigString(conf, fileName_name, &fileName, true) < 0)\n        goto cleanup;\n\n    /* vmx:network.endPoint -> def:data.tcp.listen */\n    if (virVMXGetConfigString(conf, network_endPoint_name, &network_endPoint,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    /*\n     * Setup virDomainChrDef. The default fileType is \"device\", and vmware\n     * will sometimes omit this tag when adding a new serial port of this\n     * type.\n     */\n    if (!fileType || STRCASEEQ(fileType, \"device\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        (*def)->source->data.file.path = fileName;\n\n        fileName = NULL;\n    } else if (STRCASEEQ(fileType, \"file\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n        (*def)->source->data.file.path = ctx->parseFileName(fileName,\n                                                            ctx->opaque);\n\n        if ((*def)->source->data.file.path == NULL)\n            goto cleanup;\n    } else if (STRCASEEQ(fileType, \"pipe\")) {\n        /*\n         * FIXME: Differences between client/server and VM/application pipes\n         *        not representable in domain XML form\n         */\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_PIPE;\n        (*def)->source->data.file.path = fileName;\n\n        fileName = NULL;\n    } else if (STRCASEEQ(fileType, \"network\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_TCP;\n\n        if (!(parsedUri = virURIParse(fileName)))\n            goto cleanup;\n\n        if (parsedUri->port == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry '%s' doesn't contain a port part\"),\n                           fileName_name);\n            goto cleanup;\n        }\n\n        (*def)->source->data.tcp.host = g_strdup(parsedUri->server);\n\n        (*def)->source->data.tcp.service = g_strdup_printf(\"%d\", parsedUri->port);\n\n        /* See vSphere API documentation about VirtualSerialPortURIBackingInfo */\n        if (parsedUri->scheme == NULL ||\n            STRCASEEQ(parsedUri->scheme, \"tcp\") ||\n            STRCASEEQ(parsedUri->scheme, \"tcp4\") ||\n            STRCASEEQ(parsedUri->scheme, \"tcp6\")) {\n            (*def)->source->data.tcp.protocol = VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW;\n        } else if (STRCASEEQ(parsedUri->scheme, \"telnet\")) {\n            (*def)->source->data.tcp.protocol\n                = VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET;\n        } else if (STRCASEEQ(parsedUri->scheme, \"telnets\")) {\n            (*def)->source->data.tcp.protocol\n                = VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNETS;\n        } else if (STRCASEEQ(parsedUri->scheme, \"ssl\") ||\n                   STRCASEEQ(parsedUri->scheme, \"tcp+ssl\") ||\n                   STRCASEEQ(parsedUri->scheme, \"tcp4+ssl\") ||\n                   STRCASEEQ(parsedUri->scheme, \"tcp6+ssl\")) {\n            (*def)->source->data.tcp.protocol = VIR_DOMAIN_CHR_TCP_PROTOCOL_TLS;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry '%s' contains unsupported scheme '%s'\"),\n                           fileName_name, parsedUri->scheme);\n            goto cleanup;\n        }\n\n        if (network_endPoint == NULL || STRCASEEQ(network_endPoint, \"server\")) {\n            (*def)->source->data.tcp.listen = true;\n        } else if (STRCASEEQ(network_endPoint, \"client\")) {\n            (*def)->source->data.tcp.listen = false;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry '%s' to be 'server' or 'client' \"\n                             \"but found '%s'\"), network_endPoint_name, network_endPoint);\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry '%s' to be 'device', 'file' or 'pipe' \"\n                         \"or 'network' but found '%s'\"), fileType_name, fileType);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainChrDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(fileType);\n    VIR_FREE(fileName);\n    VIR_FREE(network_endPoint);\n    virURIFree(parsedUri);\n\n    return result;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXParseSerial(virVMXContext *ctx, virConfPtr conf, int port,\n                  virDomainChrDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char startConnected_name[48] = \"\";\n    bool startConnected = false;\n\n    char fileType_name[48] = \"\";\n    char *fileType = NULL;\n\n    char fileName_name[48] = \"\";\n    char *fileName = NULL;\n\n    char network_endPoint_name[48] = \"\";\n    char *network_endPoint = NULL;\n\n    virURIPtr parsedUri = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (port < 0 || port > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Serial port index %d out of [0..3] range\"), port);\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"serial%d\", port);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(fileType);\n    VMX_BUILD_NAME(fileName);\n    VMX_BUILD_NAME_EXTRA(network_endPoint, \"network.endPoint\");\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        return -1;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        return 0;\n\n    if (!(*def = virDomainChrDefNew(NULL)))\n        return -1;\n\n    (*def)->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n\n    /* vmx:fileType -> def:type */\n    if (virVMXGetConfigString(conf, fileType_name, &fileType, true) < 0)\n        goto cleanup;\n\n    /* vmx:fileName -> def:data.file.path */\n    if (virVMXGetConfigString(conf, fileName_name, &fileName, true) < 0)\n        goto cleanup;\n\n    /* vmx:network.endPoint -> def:data.tcp.listen */\n    if (virVMXGetConfigString(conf, network_endPoint_name, &network_endPoint,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    /*\n     * Setup virDomainChrDef. The default fileType is \"device\", and vmware\n     * will sometimes omit this tag when adding a new serial port of this\n     * type.\n     */\n    if (!fileType || STRCASEEQ(fileType, \"device\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        (*def)->source->data.file.path = fileName;\n\n        fileName = NULL;\n    } else if (STRCASEEQ(fileType, \"file\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n        (*def)->source->data.file.path = ctx->parseFileName(fileName,\n                                                            ctx->opaque);\n\n        if ((*def)->source->data.file.path == NULL)\n            goto cleanup;\n    } else if (STRCASEEQ(fileType, \"pipe\")) {\n        /*\n         * FIXME: Differences between client/server and VM/application pipes\n         *        not representable in domain XML form\n         */\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_PIPE;\n        (*def)->source->data.file.path = fileName;\n\n        fileName = NULL;\n    } else if (STRCASEEQ(fileType, \"network\")) {\n        (*def)->target.port = port;\n        (*def)->source->type = VIR_DOMAIN_CHR_TYPE_TCP;\n\n        if (!(parsedUri = virURIParse(fileName)))\n            goto cleanup;\n\n        if (parsedUri->port == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry '%s' doesn't contain a port part\"),\n                           fileName_name);\n            goto cleanup;\n        }\n\n        (*def)->source->data.tcp.host = g_strdup(parsedUri->server);\n\n        (*def)->source->data.tcp.service = g_strdup_printf(\"%d\", parsedUri->port);\n\n        /* See vSphere API documentation about VirtualSerialPortURIBackingInfo */\n        if (parsedUri->scheme == NULL ||\n            STRCASEEQ(parsedUri->scheme, \"tcp\") ||\n            STRCASEEQ(parsedUri->scheme, \"tcp4\") ||\n            STRCASEEQ(parsedUri->scheme, \"tcp6\")) {\n            (*def)->source->data.tcp.protocol = VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW;\n        } else if (STRCASEEQ(parsedUri->scheme, \"telnet\")) {\n            (*def)->source->data.tcp.protocol\n                = VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET;\n        } else if (STRCASEEQ(parsedUri->scheme, \"telnets\")) {\n            (*def)->source->data.tcp.protocol\n                = VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNETS;\n        } else if (STRCASEEQ(parsedUri->scheme, \"ssl\") ||\n                   STRCASEEQ(parsedUri->scheme, \"tcp+ssl\") ||\n                   STRCASEEQ(parsedUri->scheme, \"tcp4+ssl\") ||\n                   STRCASEEQ(parsedUri->scheme, \"tcp6+ssl\")) {\n            (*def)->source->data.tcp.protocol = VIR_DOMAIN_CHR_TCP_PROTOCOL_TLS;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry '%s' contains unsupported scheme '%s'\"),\n                           fileName_name, parsedUri->scheme);\n            goto cleanup;\n        }\n\n        if (network_endPoint == NULL || STRCASEEQ(network_endPoint, \"server\")) {\n            (*def)->source->data.tcp.listen = true;\n        } else if (STRCASEEQ(network_endPoint, \"client\")) {\n            (*def)->source->data.tcp.listen = false;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry '%s' to be 'server' or 'client' \"\n                             \"but found '%s'\"), network_endPoint_name, network_endPoint);\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry '%s' to be 'device', 'file' or 'pipe' \"\n                         \"or 'network' but found '%s'\"), fileType_name, fileType);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainChrDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(fileType);\n    VIR_FREE(fileName);\n    VIR_FREE(network_endPoint);\n    virURIFree(parsedUri);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->serials",
            "4"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXParseSVGA",
          "args": [
            "conf",
            "&def->videos[def->nvideos]"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXParseSVGA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "3011-3044",
          "snippet": "int\nvirVMXParseSVGA(virConfPtr conf, virDomainVideoDefPtr *def)\n{\n    int result = -1;\n    long long svga_vramSize = 0;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(*def) < 0)\n        return -1;\n\n    (*def)->type = VIR_DOMAIN_VIDEO_TYPE_VMVGA;\n\n    /* vmx:vramSize */\n    if (virVMXGetConfigLong(conf, \"svga.vramSize\", &svga_vramSize,\n                            4 * 1024 * 1024, true) < 0) {\n        goto cleanup;\n    }\n\n    (*def)->vram = VIR_DIV_UP(svga_vramSize, 1024); /* Scale from bytes to kilobytes */\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainVideoDefFree(*def);\n        *def = NULL;\n    }\n\n    return result;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXParseSVGA(virConfPtr conf, virDomainVideoDefPtr *def)\n{\n    int result = -1;\n    long long svga_vramSize = 0;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(*def) < 0)\n        return -1;\n\n    (*def)->type = VIR_DOMAIN_VIDEO_TYPE_VMVGA;\n\n    /* vmx:vramSize */\n    if (virVMXGetConfigLong(conf, \"svga.vramSize\", &svga_vramSize,\n                            4 * 1024 * 1024, true) < 0) {\n        goto cleanup;\n    }\n\n    (*def)->vram = VIR_DIV_UP(svga_vramSize, 1024); /* Scale from bytes to kilobytes */\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainVideoDefFree(*def);\n        *def = NULL;\n    }\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->videos",
            "1"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->nets",
            "def->nnets",
            "net"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXParseEthernet",
          "args": [
            "conf",
            "controller",
            "&net"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXParseEthernet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "2514-2723",
          "snippet": "int\nvirVMXParseEthernet(virConfPtr conf, int controller, virDomainNetDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char startConnected_name[48] = \"\";\n    bool startConnected = false;\n\n    char connectionType_name[48] = \"\";\n    char *connectionType = NULL;\n\n    char addressType_name[48] = \"\";\n    char *addressType = NULL;\n\n    char generatedAddress_name[48] = \"\";\n    char *generatedAddress = NULL;\n\n    char address_name[48] = \"\";\n    char *address = NULL;\n\n    char virtualDev_name[48] = \"\";\n    char *virtualDev = NULL;\n\n    char features_name[48] = \"\";\n    long long features = 0;\n\n    char vnet_name[48] = \"\";\n    char *vnet = NULL;\n\n    char networkName_name[48] = \"\";\n    char *networkName = NULL;\n\n    int netmodel = VIR_DOMAIN_NET_MODEL_UNKNOWN;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"ethernet%d\", controller);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(connectionType);\n    VMX_BUILD_NAME(addressType);\n    VMX_BUILD_NAME(generatedAddress);\n    VMX_BUILD_NAME(address);\n    VMX_BUILD_NAME(virtualDev);\n    VMX_BUILD_NAME(features);\n    VMX_BUILD_NAME(networkName);\n    VMX_BUILD_NAME(vnet);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        return -1;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        return 0;\n\n    if (VIR_ALLOC(*def) < 0)\n        return -1;\n\n    /* vmx:connectionType -> def:type */\n    if (virVMXGetConfigString(conf, connectionType_name, &connectionType,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    /* vmx:addressType, vmx:generatedAddress, vmx:address -> def:mac */\n    if (virVMXGetConfigString(conf, addressType_name, &addressType,\n                              true) < 0 ||\n        virVMXGetConfigString(conf, generatedAddress_name, &generatedAddress,\n                              true) < 0 ||\n        virVMXGetConfigString(conf, address_name, &address, true) < 0) {\n        goto cleanup;\n    }\n\n    if (addressType == NULL || STRCASEEQ(addressType, \"generated\") ||\n        STRCASEEQ(addressType, \"vpx\")) {\n        if (generatedAddress != NULL) {\n            if (virMacAddrParse(generatedAddress, &(*def)->mac) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be MAC address but \"\n                                 \"found '%s'\"), generatedAddress_name,\n                               generatedAddress);\n                goto cleanup;\n            }\n        }\n    } else if (STRCASEEQ(addressType, \"static\")) {\n        if (address != NULL) {\n            if (virMacAddrParse(address, &(*def)->mac) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be MAC address but \"\n                                 \"found '%s'\"), address_name, address);\n                goto cleanup;\n            }\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry '%s' to be 'generated' or 'static' or \"\n                         \"'vpx' but found '%s'\"), addressType_name, addressType);\n        goto cleanup;\n    }\n\n    /* vmx:virtualDev, vmx:features -> def:model */\n    if (virVMXGetConfigString(conf, virtualDev_name, &virtualDev, true) < 0 ||\n        virVMXGetConfigLong(conf, features_name, &features, 0, true) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualDev != NULL) {\n        if (STRCASEEQ(virtualDev, \"vlance\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_VLANCE;\n        } else if (STRCASEEQ(virtualDev, \"vmxnet\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_VMXNET;\n        } else if (STRCASEEQ(virtualDev, \"vmxnet3\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_VMXNET3;\n        } else if (STRCASEEQ(virtualDev, \"e1000\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_E1000;\n        } else if (STRCASEEQ(virtualDev, \"e1000e\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_E1000E;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry '%s' to be 'vlance' or 'vmxnet' or \"\n                             \"'vmxnet3' or 'e1000' or 'e1000e' but found '%s'\"),\n                           virtualDev_name, virtualDev);\n            goto cleanup;\n        }\n\n        if (netmodel == VIR_DOMAIN_NET_MODEL_VMXNET && features == 15)\n            netmodel = VIR_DOMAIN_NET_MODEL_VMXNET2;\n    }\n\n    /* vmx:networkName -> def:data.bridge.brname */\n    if (connectionType == NULL ||\n        STRCASEEQ(connectionType, \"bridged\") ||\n        STRCASEEQ(connectionType, \"custom\")) {\n        if (virVMXGetConfigString(conf, networkName_name, &networkName,\n                                  true) < 0)\n            goto cleanup;\n\n        if (!networkName)\n            networkName = g_strdup(\"\");\n    }\n\n    /* vmx:vnet -> def:data.ifname */\n    if (connectionType != NULL && STRCASEEQ(connectionType, \"custom\") &&\n        virVMXGetConfigString(conf, vnet_name, &vnet, false) < 0) {\n        goto cleanup;\n    }\n\n    /* Setup virDomainNetDef */\n    if (connectionType == NULL || STRCASEEQ(connectionType, \"bridged\")) {\n        (*def)->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n        (*def)->data.bridge.brname = networkName;\n\n        networkName = NULL;\n    } else if (STRCASEEQ(connectionType, \"hostonly\")) {\n        /* FIXME */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No yet handled value '%s' for VMX entry '%s'\"),\n                       connectionType, connectionType_name);\n        goto cleanup;\n    } else if (STRCASEEQ(connectionType, \"nat\")) {\n        (*def)->type = VIR_DOMAIN_NET_TYPE_USER;\n\n    } else if (STRCASEEQ(connectionType, \"custom\")) {\n        (*def)->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n        (*def)->data.bridge.brname = networkName;\n        (*def)->ifname = vnet;\n\n        networkName = NULL;\n        vnet = NULL;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid value '%s' for VMX entry '%s'\"), connectionType,\n                       connectionType_name);\n        goto cleanup;\n    }\n\n    (*def)->model = netmodel;\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainNetDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(networkName);\n    VIR_FREE(connectionType);\n    VIR_FREE(addressType);\n    VIR_FREE(generatedAddress);\n    VIR_FREE(address);\n    VIR_FREE(virtualDev);\n    VIR_FREE(vnet);\n\n    return result;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXParseEthernet(virConfPtr conf, int controller, virDomainNetDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char startConnected_name[48] = \"\";\n    bool startConnected = false;\n\n    char connectionType_name[48] = \"\";\n    char *connectionType = NULL;\n\n    char addressType_name[48] = \"\";\n    char *addressType = NULL;\n\n    char generatedAddress_name[48] = \"\";\n    char *generatedAddress = NULL;\n\n    char address_name[48] = \"\";\n    char *address = NULL;\n\n    char virtualDev_name[48] = \"\";\n    char *virtualDev = NULL;\n\n    char features_name[48] = \"\";\n    long long features = 0;\n\n    char vnet_name[48] = \"\";\n    char *vnet = NULL;\n\n    char networkName_name[48] = \"\";\n    char *networkName = NULL;\n\n    int netmodel = VIR_DOMAIN_NET_MODEL_UNKNOWN;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"ethernet%d\", controller);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(connectionType);\n    VMX_BUILD_NAME(addressType);\n    VMX_BUILD_NAME(generatedAddress);\n    VMX_BUILD_NAME(address);\n    VMX_BUILD_NAME(virtualDev);\n    VMX_BUILD_NAME(features);\n    VMX_BUILD_NAME(networkName);\n    VMX_BUILD_NAME(vnet);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        return -1;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        return 0;\n\n    if (VIR_ALLOC(*def) < 0)\n        return -1;\n\n    /* vmx:connectionType -> def:type */\n    if (virVMXGetConfigString(conf, connectionType_name, &connectionType,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    /* vmx:addressType, vmx:generatedAddress, vmx:address -> def:mac */\n    if (virVMXGetConfigString(conf, addressType_name, &addressType,\n                              true) < 0 ||\n        virVMXGetConfigString(conf, generatedAddress_name, &generatedAddress,\n                              true) < 0 ||\n        virVMXGetConfigString(conf, address_name, &address, true) < 0) {\n        goto cleanup;\n    }\n\n    if (addressType == NULL || STRCASEEQ(addressType, \"generated\") ||\n        STRCASEEQ(addressType, \"vpx\")) {\n        if (generatedAddress != NULL) {\n            if (virMacAddrParse(generatedAddress, &(*def)->mac) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be MAC address but \"\n                                 \"found '%s'\"), generatedAddress_name,\n                               generatedAddress);\n                goto cleanup;\n            }\n        }\n    } else if (STRCASEEQ(addressType, \"static\")) {\n        if (address != NULL) {\n            if (virMacAddrParse(address, &(*def)->mac) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be MAC address but \"\n                                 \"found '%s'\"), address_name, address);\n                goto cleanup;\n            }\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry '%s' to be 'generated' or 'static' or \"\n                         \"'vpx' but found '%s'\"), addressType_name, addressType);\n        goto cleanup;\n    }\n\n    /* vmx:virtualDev, vmx:features -> def:model */\n    if (virVMXGetConfigString(conf, virtualDev_name, &virtualDev, true) < 0 ||\n        virVMXGetConfigLong(conf, features_name, &features, 0, true) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualDev != NULL) {\n        if (STRCASEEQ(virtualDev, \"vlance\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_VLANCE;\n        } else if (STRCASEEQ(virtualDev, \"vmxnet\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_VMXNET;\n        } else if (STRCASEEQ(virtualDev, \"vmxnet3\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_VMXNET3;\n        } else if (STRCASEEQ(virtualDev, \"e1000\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_E1000;\n        } else if (STRCASEEQ(virtualDev, \"e1000e\")) {\n            netmodel = VIR_DOMAIN_NET_MODEL_E1000E;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry '%s' to be 'vlance' or 'vmxnet' or \"\n                             \"'vmxnet3' or 'e1000' or 'e1000e' but found '%s'\"),\n                           virtualDev_name, virtualDev);\n            goto cleanup;\n        }\n\n        if (netmodel == VIR_DOMAIN_NET_MODEL_VMXNET && features == 15)\n            netmodel = VIR_DOMAIN_NET_MODEL_VMXNET2;\n    }\n\n    /* vmx:networkName -> def:data.bridge.brname */\n    if (connectionType == NULL ||\n        STRCASEEQ(connectionType, \"bridged\") ||\n        STRCASEEQ(connectionType, \"custom\")) {\n        if (virVMXGetConfigString(conf, networkName_name, &networkName,\n                                  true) < 0)\n            goto cleanup;\n\n        if (!networkName)\n            networkName = g_strdup(\"\");\n    }\n\n    /* vmx:vnet -> def:data.ifname */\n    if (connectionType != NULL && STRCASEEQ(connectionType, \"custom\") &&\n        virVMXGetConfigString(conf, vnet_name, &vnet, false) < 0) {\n        goto cleanup;\n    }\n\n    /* Setup virDomainNetDef */\n    if (connectionType == NULL || STRCASEEQ(connectionType, \"bridged\")) {\n        (*def)->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n        (*def)->data.bridge.brname = networkName;\n\n        networkName = NULL;\n    } else if (STRCASEEQ(connectionType, \"hostonly\")) {\n        /* FIXME */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No yet handled value '%s' for VMX entry '%s'\"),\n                       connectionType, connectionType_name);\n        goto cleanup;\n    } else if (STRCASEEQ(connectionType, \"nat\")) {\n        (*def)->type = VIR_DOMAIN_NET_TYPE_USER;\n\n    } else if (STRCASEEQ(connectionType, \"custom\")) {\n        (*def)->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n        (*def)->data.bridge.brname = networkName;\n        (*def)->ifname = vnet;\n\n        networkName = NULL;\n        vnet = NULL;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid value '%s' for VMX entry '%s'\"), connectionType,\n                       connectionType_name);\n        goto cleanup;\n    }\n\n    (*def)->model = netmodel;\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainNetDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(networkName);\n    VIR_FREE(connectionType);\n    VIR_FREE(addressType);\n    VIR_FREE(generatedAddress);\n    VIR_FREE(address);\n    VIR_FREE(virtualDev);\n    VIR_FREE(vnet);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXParseFileSystem",
          "args": [
            "conf",
            "number",
            "&def->fss[def->nfss]"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXParseFileSystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "2427-2510",
          "snippet": "int virVMXParseFileSystem(virConfPtr conf, int number, virDomainFSDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char enabled_name[48] = \"\";\n    bool enabled = false;\n\n    char hostPath_name[48] = \"\";\n    char *hostPath = NULL;\n\n    char guestName_name[48] = \"\";\n    char *guestName = NULL;\n\n    char writeAccess_name[48] = \"\";\n    bool writeAccess = false;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"sharedFolder%d\", number);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(enabled);\n    VMX_BUILD_NAME(hostPath);\n    VMX_BUILD_NAME(guestName);\n    VMX_BUILD_NAME(writeAccess);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:enabled */\n    if (virVMXGetConfigBoolean(conf, enabled_name, &enabled, false, true) < 0)\n        return -1;\n\n    if (!(present && enabled))\n        return 0;\n\n    if (!(*def = virDomainFSDefNew(NULL)))\n        return -1;\n\n    (*def)->type = VIR_DOMAIN_FS_TYPE_MOUNT;\n\n    /* vmx:hostPath */\n    if (virVMXGetConfigString(conf, hostPath_name, &hostPath, false) < 0)\n        goto cleanup;\n\n    (*def)->src->path = hostPath;\n    hostPath = NULL;\n\n    /* vmx:guestName */\n    if (virVMXGetConfigString(conf, guestName_name, &guestName, false) < 0)\n        goto cleanup;\n\n    (*def)->dst = guestName;\n    guestName = NULL;\n\n    /* vmx:writeAccess */\n    if (virVMXGetConfigBoolean(conf, writeAccess_name, &writeAccess, false,\n                               true) < 0) {\n        goto cleanup;\n    }\n\n    (*def)->readonly = !writeAccess;\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainFSDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(hostPath);\n    VIR_FREE(guestName);\n\n    return result;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint virVMXParseFileSystem(virConfPtr conf, int number, virDomainFSDefPtr *def)\n{\n    int result = -1;\n    char prefix[48] = \"\";\n\n    char present_name[48] = \"\";\n    bool present = false;\n\n    char enabled_name[48] = \"\";\n    bool enabled = false;\n\n    char hostPath_name[48] = \"\";\n    char *hostPath = NULL;\n\n    char guestName_name[48] = \"\";\n    char *guestName = NULL;\n\n    char writeAccess_name[48] = \"\";\n    bool writeAccess = false;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    g_snprintf(prefix, sizeof(prefix), \"sharedFolder%d\", number);\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(enabled);\n    VMX_BUILD_NAME(hostPath);\n    VMX_BUILD_NAME(guestName);\n    VMX_BUILD_NAME(writeAccess);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        return -1;\n\n    /* vmx:enabled */\n    if (virVMXGetConfigBoolean(conf, enabled_name, &enabled, false, true) < 0)\n        return -1;\n\n    if (!(present && enabled))\n        return 0;\n\n    if (!(*def = virDomainFSDefNew(NULL)))\n        return -1;\n\n    (*def)->type = VIR_DOMAIN_FS_TYPE_MOUNT;\n\n    /* vmx:hostPath */\n    if (virVMXGetConfigString(conf, hostPath_name, &hostPath, false) < 0)\n        goto cleanup;\n\n    (*def)->src->path = hostPath;\n    hostPath = NULL;\n\n    /* vmx:guestName */\n    if (virVMXGetConfigString(conf, guestName_name, &guestName, false) < 0)\n        goto cleanup;\n\n    (*def)->dst = guestName;\n    guestName = NULL;\n\n    /* vmx:writeAccess */\n    if (virVMXGetConfigBoolean(conf, writeAccess_name, &writeAccess, false,\n                               true) < 0) {\n        goto cleanup;\n    }\n\n    (*def)->readonly = !writeAccess;\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainFSDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(hostPath);\n    VIR_FREE(guestName);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->fss",
            "sharedFolder_maxNum"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigLong",
          "args": [
            "conf",
            "\"sharedFolder.maxNum\"",
            "&sharedFolder_maxNum",
            "0",
            "true"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "792-820",
          "snippet": "static int\nvirVMXGetConfigLong(virConfPtr conf, const char *name, long long *number,\n                    long long default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *number = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"unlimited\")) {\n        *number = -1;\n    } else if (virStrToLong_ll(string, NULL, 10, number) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Config entry '%s' must represent an integer value\"),\n                name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigLong(virConfPtr conf, const char *name, long long *number,\n                    long long default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *number = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"unlimited\")) {\n        *number = -1;\n    } else if (virStrToLong_ll(string, NULL, 10, number) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Config entry '%s' must represent an integer value\"),\n                name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigBoolean",
          "args": [
            "conf",
            "\"isolation.tools.hgfs.disable\"",
            "&hgfs_disabled",
            "true",
            "true"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "824-854",
          "snippet": "static int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXParseDisk",
          "args": [
            "ctx",
            "xmlopt",
            "conf",
            "VIR_DOMAIN_DISK_DEVICE_FLOPPY",
            "VIR_DOMAIN_DISK_BUS_FDC",
            "0",
            "unit",
            "&def->disks[def->ndisks]",
            "def"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXParseDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "2007-2423",
          "snippet": "int\nvirVMXParseDisk(virVMXContext *ctx, virDomainXMLOptionPtr xmlopt, virConfPtr conf,\n                int device, int busType, int controllerOrBus, int unit,\n                virDomainDiskDefPtr *def, virDomainDefPtr vmdef)\n{\n    /*\n     *          device = {VIR_DOMAIN_DISK_DEVICE_DISK,\n     *                    VIR_DOMAIN_DISK_DEVICE_CDROM,\n     *                    VIR_DOMAIN_DISK_DEVICE_LUN}\n     *         busType = VIR_DOMAIN_DISK_BUS_SCSI\n     * controllerOrBus = [0..3] -> controller\n     *            unit = [0..6,8..15]\n     *\n     *          device = {VIR_DOMAIN_DISK_DEVICE_DISK,\n     *                    VIR_DOMAIN_DISK_DEVICE_CDROM,\n     *                    VIR_DOMAIN_DISK_DEVICE_LUN}\n     *         busType = VIR_DOMAIN_DISK_BUS_IDE\n     * controllerOrBus = [0..1] -> bus\n     *            unit = [0..1]\n     *\n     *          device = VIR_DOMAIN_DISK_DEVICE_FLOPPY\n     *         busType = VIR_DOMAIN_DISK_BUS_FDC\n     * controllerOrBus = [0]\n     *            unit = [0..1]\n     */\n\n    int result = -1;\n    char *prefix = NULL;\n\n    char present_name[32] = \"\";\n    bool present = false;\n\n    char startConnected_name[32] = \"\";\n    bool startConnected = false;\n\n    char deviceType_name[32] = \"\";\n    char *deviceType = NULL;\n\n    char clientDevice_name[32] = \"\";\n    bool clientDevice = false;\n\n    char fileType_name[32] = \"\";\n    char *fileType = NULL;\n\n    char fileName_name[32] = \"\";\n    char *fileName = NULL;\n\n    char writeThrough_name[32] = \"\";\n    bool writeThrough = false;\n\n    char mode_name[32] = \"\";\n    char *mode = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!(*def = virDomainDiskDefNew(xmlopt)))\n        return -1;\n\n    (*def)->device = device;\n    (*def)->bus = busType;\n\n    /* def:dst, def:driverName */\n    if (device == VIR_DOMAIN_DISK_DEVICE_DISK ||\n        device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n        if (busType == VIR_DOMAIN_DISK_BUS_SCSI) {\n            if (controllerOrBus < 0 || controllerOrBus > 3) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"SCSI controller index %d out of [0..3] range\"),\n                               controllerOrBus);\n                goto cleanup;\n            }\n\n            if (unit < 0 || unit > 15 || unit == 7) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"SCSI unit index %d out of [0..6,8..15] range\"),\n                               unit);\n                goto cleanup;\n            }\n\n            prefix = g_strdup_printf(\"scsi%d:%d\", controllerOrBus, unit);\n\n            (*def)->dst =\n               virIndexToDiskName\n                 (controllerOrBus * 15 + (unit < 7 ? unit : unit - 1), \"sd\");\n\n            if ((*def)->dst == NULL)\n                goto cleanup;\n        } else if (busType == VIR_DOMAIN_DISK_BUS_IDE) {\n            if (controllerOrBus < 0 || controllerOrBus > 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"IDE bus index %d out of [0..1] range\"),\n                               controllerOrBus);\n                goto cleanup;\n            }\n\n            if (unit < 0 || unit > 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"IDE unit index %d out of [0..1] range\"), unit);\n                goto cleanup;\n            }\n\n            prefix = g_strdup_printf(\"ide%d:%d\", controllerOrBus, unit);\n\n            (*def)->dst = virIndexToDiskName(controllerOrBus * 2 + unit, \"hd\");\n\n            if ((*def)->dst == NULL)\n                goto cleanup;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported bus type '%s' for device type '%s'\"),\n                           virDomainDiskBusTypeToString(busType),\n                           virDomainDiskDeviceTypeToString(device));\n            goto cleanup;\n        }\n    } else if (device == VIR_DOMAIN_DISK_DEVICE_FLOPPY) {\n        if (busType == VIR_DOMAIN_DISK_BUS_FDC) {\n            if (controllerOrBus != 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"FDC controller index %d out of [0] range\"),\n                               controllerOrBus);\n                goto cleanup;\n            }\n\n            if (unit < 0 || unit > 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"FDC unit index %d out of [0..1] range\"),\n                               unit);\n                goto cleanup;\n            }\n\n            prefix = g_strdup_printf(\"floppy%d\", unit);\n\n            (*def)->dst = virIndexToDiskName(unit, \"fd\");\n\n            if ((*def)->dst == NULL)\n                goto cleanup;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported bus type '%s' for device type '%s'\"),\n                           virDomainDiskBusTypeToString(busType),\n                           virDomainDiskDeviceTypeToString(device));\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported device type '%s'\"),\n                       virDomainDiskDeviceTypeToString(device));\n        goto cleanup;\n    }\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(deviceType);\n    VMX_BUILD_NAME(clientDevice);\n    VMX_BUILD_NAME(fileType);\n    VMX_BUILD_NAME(fileName);\n    VMX_BUILD_NAME(writeThrough);\n    VMX_BUILD_NAME(mode);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        goto cleanup;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        goto cleanup;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        goto ignore;\n\n    /* vmx:deviceType -> def:type */\n    if (virVMXGetConfigString(conf, deviceType_name, &deviceType, true) < 0)\n        goto cleanup;\n\n    /* vmx:clientDevice */\n    if (virVMXGetConfigBoolean(conf, clientDevice_name, &clientDevice, false,\n                               true) < 0) {\n        goto cleanup;\n    }\n\n    /* vmx:mode -> def:transient */\n    if (virVMXGetConfigString(conf, mode_name, &mode, true) < 0)\n        goto cleanup;\n\n    if (clientDevice) {\n        /*\n         * Just ignore devices in client mode, because I have no clue how to\n         * handle them (e.g. assign an image) without the VI Client GUI.\n         */\n        goto ignore;\n    }\n\n    /* vmx:fileType -> def:type */\n    if (virVMXGetConfigString(conf, fileType_name, &fileType, true) < 0)\n        goto cleanup;\n\n    /* vmx:fileName -> def:src, def:type */\n    if (virVMXGetConfigString(conf, fileName_name, &fileName, true) < 0)\n        goto cleanup;\n\n    /* vmx:writeThrough -> def:cachemode */\n    if (virVMXGetConfigBoolean(conf, writeThrough_name, &writeThrough, false,\n                               true) < 0) {\n        goto cleanup;\n    }\n\n    /* Setup virDomainDiskDef */\n    if (device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n        if (fileName == NULL ||\n            virStringHasCaseSuffix(fileName, \".iso\") ||\n            STREQ(fileName, \"emptyBackingString\") ||\n            (deviceType &&\n             (STRCASEEQ(deviceType, \"atapi-cdrom\") ||\n              STRCASEEQ(deviceType, \"cdrom-raw\") ||\n              (STRCASEEQ(deviceType, \"scsi-passthru\") &&\n               STRPREFIX(fileName, \"/vmfs/devices/cdrom/\"))))) {\n            /*\n             * This function was called in order to parse a harddisk device,\n             * but .iso files, 'atapi-cdrom', 'cdrom-raw', and 'scsi-passthru'\n             * CDROM devices are for CDROM devices only. Just ignore it, another\n             * call to this function to parse a CDROM device may handle it.\n             */\n            goto ignore;\n        } else if (virStringHasCaseSuffix(fileName, \".vmdk\")) {\n            char *tmp;\n\n            if (deviceType != NULL) {\n                if (busType == VIR_DOMAIN_DISK_BUS_SCSI &&\n                    STRCASENEQ(deviceType, \"scsi-hardDisk\") &&\n                    STRCASENEQ(deviceType, \"disk\")) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Expecting VMX entry '%s' to be 'scsi-hardDisk' \"\n                                     \"or 'disk' but found '%s'\"), deviceType_name,\n                                   deviceType);\n                    goto cleanup;\n                } else if (busType == VIR_DOMAIN_DISK_BUS_IDE &&\n                           STRCASENEQ(deviceType, \"ata-hardDisk\") &&\n                           STRCASENEQ(deviceType, \"disk\")) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Expecting VMX entry '%s' to be 'ata-hardDisk' \"\n                                     \"or 'disk' but found '%s'\"), deviceType_name,\n                                   deviceType);\n                    goto cleanup;\n                }\n            }\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            if (!(tmp = ctx->parseFileName(fileName, ctx->opaque)))\n                goto cleanup;\n            if (virDomainDiskSetSource(*def, tmp) < 0) {\n                VIR_FREE(tmp);\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n            (*def)->cachemode = writeThrough ? VIR_DOMAIN_DISK_CACHE_WRITETHRU\n                                             : VIR_DOMAIN_DISK_CACHE_DEFAULT;\n            if (mode)\n                (*def)->transient = STRCASEEQ(mode,\n                                              \"independent-nonpersistent\");\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\"),\n                           fileName, fileName_name,\n                           deviceType ? deviceType : \"unknown\");\n            goto cleanup;\n        }\n    } else if (device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n        if (fileName && virStringHasCaseSuffix(fileName, \".vmdk\")) {\n            /*\n             * This function was called in order to parse a CDROM device, but\n             * .vmdk files are for harddisk devices only. Just ignore it,\n             * another call to this function to parse a harddisk device may\n             * handle it.\n             */\n            goto ignore;\n        } else if (fileName && virStringHasCaseSuffix(fileName, \".iso\")) {\n            char *tmp;\n\n            if (deviceType && STRCASENEQ(deviceType, \"cdrom-image\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be 'cdrom-image' \"\n                                 \"but found '%s'\"), deviceType_name, deviceType);\n                goto cleanup;\n            }\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            if (!(tmp = ctx->parseFileName(fileName, ctx->opaque)))\n                goto cleanup;\n            if (virDomainDiskSetSource(*def, tmp) < 0) {\n                VIR_FREE(tmp);\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n        } else if (deviceType && STRCASEEQ(deviceType, \"atapi-cdrom\")) {\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n\n            if (fileName && STRCASEEQ(fileName, \"auto detect\")) {\n                ignore_value(virDomainDiskSetSource(*def, NULL));\n                (*def)->startupPolicy = VIR_DOMAIN_STARTUP_POLICY_OPTIONAL;\n            } else if (virDomainDiskSetSource(*def, fileName) < 0) {\n                goto cleanup;\n            }\n        } else if (deviceType && STRCASEEQ(deviceType, \"cdrom-raw\")) {\n            /* Raw access CD-ROMs actually are device='lun' */\n            (*def)->device = VIR_DOMAIN_DISK_DEVICE_LUN;\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n\n            if (fileName && STRCASEEQ(fileName, \"auto detect\")) {\n                ignore_value(virDomainDiskSetSource(*def, NULL));\n                (*def)->startupPolicy = VIR_DOMAIN_STARTUP_POLICY_OPTIONAL;\n            } else if (virDomainDiskSetSource(*def, fileName) < 0) {\n                goto cleanup;\n            }\n        } else if (busType == VIR_DOMAIN_DISK_BUS_SCSI &&\n                   deviceType && STRCASEEQ(deviceType, \"scsi-passthru\")) {\n            if (fileName && STRPREFIX(fileName, \"/vmfs/devices/cdrom/\")) {\n                /* SCSI-passthru CD-ROMs actually are device='lun' */\n                (*def)->device = VIR_DOMAIN_DISK_DEVICE_LUN;\n                virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n\n                if (virDomainDiskSetSource(*def, fileName) < 0)\n                    goto cleanup;\n            } else {\n                /*\n                 * This function was called in order to parse a CDROM device,\n                 * but the filename does not indicate a CDROM device. Just ignore\n                 * it, another call to this function to parse a harddisk device\n                 * may handle it.\n                 */\n                goto ignore;\n            }\n        } else if (fileName && STREQ(fileName, \"emptyBackingString\")) {\n            if (deviceType && STRCASENEQ(deviceType, \"cdrom-image\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be 'cdrom-image' \"\n                                 \"but found '%s'\"), deviceType_name, deviceType);\n                goto cleanup;\n            }\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            ignore_value(virDomainDiskSetSource(*def, NULL));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\"),\n                           NULLSTR(fileName), fileName_name,\n                           deviceType ? deviceType : \"unknown\");\n            goto cleanup;\n        }\n    } else if (device == VIR_DOMAIN_DISK_DEVICE_FLOPPY) {\n        if (fileType != NULL && STRCASEEQ(fileType, \"device\")) {\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n            if (virDomainDiskSetSource(*def, fileName) < 0)\n                goto cleanup;\n        } else if (fileType != NULL && STRCASEEQ(fileType, \"file\")) {\n            char *tmp = NULL;\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            if (fileName && !(tmp = ctx->parseFileName(fileName, ctx->opaque)))\n                goto cleanup;\n            if (virDomainDiskSetSource(*def, tmp) < 0) {\n                VIR_FREE(tmp);\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\"),\n                           NULLSTR(fileName), fileName_name,\n                           deviceType ? deviceType : \"unknown\");\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, _(\"Unsupported device type '%s'\"),\n                       virDomainDiskDeviceTypeToString(device));\n        goto cleanup;\n    }\n\n    if (virDomainDiskDefAssignAddress(xmlopt, *def, vmdef) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not assign address to disk '%s'\"),\n                       virDomainDiskGetSource(*def));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainDiskDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(prefix);\n    VIR_FREE(deviceType);\n    VIR_FREE(fileType);\n    VIR_FREE(fileName);\n    VIR_FREE(mode);\n\n    return result;\n\n ignore:\n    virDomainDiskDefFree(*def);\n    *def = NULL;\n\n    result = 0;\n\n    goto cleanup;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXParseDisk(virVMXContext *ctx, virDomainXMLOptionPtr xmlopt, virConfPtr conf,\n                int device, int busType, int controllerOrBus, int unit,\n                virDomainDiskDefPtr *def, virDomainDefPtr vmdef)\n{\n    /*\n     *          device = {VIR_DOMAIN_DISK_DEVICE_DISK,\n     *                    VIR_DOMAIN_DISK_DEVICE_CDROM,\n     *                    VIR_DOMAIN_DISK_DEVICE_LUN}\n     *         busType = VIR_DOMAIN_DISK_BUS_SCSI\n     * controllerOrBus = [0..3] -> controller\n     *            unit = [0..6,8..15]\n     *\n     *          device = {VIR_DOMAIN_DISK_DEVICE_DISK,\n     *                    VIR_DOMAIN_DISK_DEVICE_CDROM,\n     *                    VIR_DOMAIN_DISK_DEVICE_LUN}\n     *         busType = VIR_DOMAIN_DISK_BUS_IDE\n     * controllerOrBus = [0..1] -> bus\n     *            unit = [0..1]\n     *\n     *          device = VIR_DOMAIN_DISK_DEVICE_FLOPPY\n     *         busType = VIR_DOMAIN_DISK_BUS_FDC\n     * controllerOrBus = [0]\n     *            unit = [0..1]\n     */\n\n    int result = -1;\n    char *prefix = NULL;\n\n    char present_name[32] = \"\";\n    bool present = false;\n\n    char startConnected_name[32] = \"\";\n    bool startConnected = false;\n\n    char deviceType_name[32] = \"\";\n    char *deviceType = NULL;\n\n    char clientDevice_name[32] = \"\";\n    bool clientDevice = false;\n\n    char fileType_name[32] = \"\";\n    char *fileType = NULL;\n\n    char fileName_name[32] = \"\";\n    char *fileName = NULL;\n\n    char writeThrough_name[32] = \"\";\n    bool writeThrough = false;\n\n    char mode_name[32] = \"\";\n    char *mode = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!(*def = virDomainDiskDefNew(xmlopt)))\n        return -1;\n\n    (*def)->device = device;\n    (*def)->bus = busType;\n\n    /* def:dst, def:driverName */\n    if (device == VIR_DOMAIN_DISK_DEVICE_DISK ||\n        device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n        if (busType == VIR_DOMAIN_DISK_BUS_SCSI) {\n            if (controllerOrBus < 0 || controllerOrBus > 3) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"SCSI controller index %d out of [0..3] range\"),\n                               controllerOrBus);\n                goto cleanup;\n            }\n\n            if (unit < 0 || unit > 15 || unit == 7) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"SCSI unit index %d out of [0..6,8..15] range\"),\n                               unit);\n                goto cleanup;\n            }\n\n            prefix = g_strdup_printf(\"scsi%d:%d\", controllerOrBus, unit);\n\n            (*def)->dst =\n               virIndexToDiskName\n                 (controllerOrBus * 15 + (unit < 7 ? unit : unit - 1), \"sd\");\n\n            if ((*def)->dst == NULL)\n                goto cleanup;\n        } else if (busType == VIR_DOMAIN_DISK_BUS_IDE) {\n            if (controllerOrBus < 0 || controllerOrBus > 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"IDE bus index %d out of [0..1] range\"),\n                               controllerOrBus);\n                goto cleanup;\n            }\n\n            if (unit < 0 || unit > 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"IDE unit index %d out of [0..1] range\"), unit);\n                goto cleanup;\n            }\n\n            prefix = g_strdup_printf(\"ide%d:%d\", controllerOrBus, unit);\n\n            (*def)->dst = virIndexToDiskName(controllerOrBus * 2 + unit, \"hd\");\n\n            if ((*def)->dst == NULL)\n                goto cleanup;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported bus type '%s' for device type '%s'\"),\n                           virDomainDiskBusTypeToString(busType),\n                           virDomainDiskDeviceTypeToString(device));\n            goto cleanup;\n        }\n    } else if (device == VIR_DOMAIN_DISK_DEVICE_FLOPPY) {\n        if (busType == VIR_DOMAIN_DISK_BUS_FDC) {\n            if (controllerOrBus != 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"FDC controller index %d out of [0] range\"),\n                               controllerOrBus);\n                goto cleanup;\n            }\n\n            if (unit < 0 || unit > 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"FDC unit index %d out of [0..1] range\"),\n                               unit);\n                goto cleanup;\n            }\n\n            prefix = g_strdup_printf(\"floppy%d\", unit);\n\n            (*def)->dst = virIndexToDiskName(unit, \"fd\");\n\n            if ((*def)->dst == NULL)\n                goto cleanup;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported bus type '%s' for device type '%s'\"),\n                           virDomainDiskBusTypeToString(busType),\n                           virDomainDiskDeviceTypeToString(device));\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported device type '%s'\"),\n                       virDomainDiskDeviceTypeToString(device));\n        goto cleanup;\n    }\n\n    VMX_BUILD_NAME(present);\n    VMX_BUILD_NAME(startConnected);\n    VMX_BUILD_NAME(deviceType);\n    VMX_BUILD_NAME(clientDevice);\n    VMX_BUILD_NAME(fileType);\n    VMX_BUILD_NAME(fileName);\n    VMX_BUILD_NAME(writeThrough);\n    VMX_BUILD_NAME(mode);\n\n    /* vmx:present */\n    if (virVMXGetConfigBoolean(conf, present_name, &present, false, true) < 0)\n        goto cleanup;\n\n    /* vmx:startConnected */\n    if (virVMXGetConfigBoolean(conf, startConnected_name, &startConnected,\n                               true, true) < 0) {\n        goto cleanup;\n    }\n\n    /* FIXME: Need to distinguish between active and inactive domains here */\n    if (! present/* && ! startConnected*/)\n        goto ignore;\n\n    /* vmx:deviceType -> def:type */\n    if (virVMXGetConfigString(conf, deviceType_name, &deviceType, true) < 0)\n        goto cleanup;\n\n    /* vmx:clientDevice */\n    if (virVMXGetConfigBoolean(conf, clientDevice_name, &clientDevice, false,\n                               true) < 0) {\n        goto cleanup;\n    }\n\n    /* vmx:mode -> def:transient */\n    if (virVMXGetConfigString(conf, mode_name, &mode, true) < 0)\n        goto cleanup;\n\n    if (clientDevice) {\n        /*\n         * Just ignore devices in client mode, because I have no clue how to\n         * handle them (e.g. assign an image) without the VI Client GUI.\n         */\n        goto ignore;\n    }\n\n    /* vmx:fileType -> def:type */\n    if (virVMXGetConfigString(conf, fileType_name, &fileType, true) < 0)\n        goto cleanup;\n\n    /* vmx:fileName -> def:src, def:type */\n    if (virVMXGetConfigString(conf, fileName_name, &fileName, true) < 0)\n        goto cleanup;\n\n    /* vmx:writeThrough -> def:cachemode */\n    if (virVMXGetConfigBoolean(conf, writeThrough_name, &writeThrough, false,\n                               true) < 0) {\n        goto cleanup;\n    }\n\n    /* Setup virDomainDiskDef */\n    if (device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n        if (fileName == NULL ||\n            virStringHasCaseSuffix(fileName, \".iso\") ||\n            STREQ(fileName, \"emptyBackingString\") ||\n            (deviceType &&\n             (STRCASEEQ(deviceType, \"atapi-cdrom\") ||\n              STRCASEEQ(deviceType, \"cdrom-raw\") ||\n              (STRCASEEQ(deviceType, \"scsi-passthru\") &&\n               STRPREFIX(fileName, \"/vmfs/devices/cdrom/\"))))) {\n            /*\n             * This function was called in order to parse a harddisk device,\n             * but .iso files, 'atapi-cdrom', 'cdrom-raw', and 'scsi-passthru'\n             * CDROM devices are for CDROM devices only. Just ignore it, another\n             * call to this function to parse a CDROM device may handle it.\n             */\n            goto ignore;\n        } else if (virStringHasCaseSuffix(fileName, \".vmdk\")) {\n            char *tmp;\n\n            if (deviceType != NULL) {\n                if (busType == VIR_DOMAIN_DISK_BUS_SCSI &&\n                    STRCASENEQ(deviceType, \"scsi-hardDisk\") &&\n                    STRCASENEQ(deviceType, \"disk\")) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Expecting VMX entry '%s' to be 'scsi-hardDisk' \"\n                                     \"or 'disk' but found '%s'\"), deviceType_name,\n                                   deviceType);\n                    goto cleanup;\n                } else if (busType == VIR_DOMAIN_DISK_BUS_IDE &&\n                           STRCASENEQ(deviceType, \"ata-hardDisk\") &&\n                           STRCASENEQ(deviceType, \"disk\")) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Expecting VMX entry '%s' to be 'ata-hardDisk' \"\n                                     \"or 'disk' but found '%s'\"), deviceType_name,\n                                   deviceType);\n                    goto cleanup;\n                }\n            }\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            if (!(tmp = ctx->parseFileName(fileName, ctx->opaque)))\n                goto cleanup;\n            if (virDomainDiskSetSource(*def, tmp) < 0) {\n                VIR_FREE(tmp);\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n            (*def)->cachemode = writeThrough ? VIR_DOMAIN_DISK_CACHE_WRITETHRU\n                                             : VIR_DOMAIN_DISK_CACHE_DEFAULT;\n            if (mode)\n                (*def)->transient = STRCASEEQ(mode,\n                                              \"independent-nonpersistent\");\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\"),\n                           fileName, fileName_name,\n                           deviceType ? deviceType : \"unknown\");\n            goto cleanup;\n        }\n    } else if (device == VIR_DOMAIN_DISK_DEVICE_CDROM) {\n        if (fileName && virStringHasCaseSuffix(fileName, \".vmdk\")) {\n            /*\n             * This function was called in order to parse a CDROM device, but\n             * .vmdk files are for harddisk devices only. Just ignore it,\n             * another call to this function to parse a harddisk device may\n             * handle it.\n             */\n            goto ignore;\n        } else if (fileName && virStringHasCaseSuffix(fileName, \".iso\")) {\n            char *tmp;\n\n            if (deviceType && STRCASENEQ(deviceType, \"cdrom-image\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be 'cdrom-image' \"\n                                 \"but found '%s'\"), deviceType_name, deviceType);\n                goto cleanup;\n            }\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            if (!(tmp = ctx->parseFileName(fileName, ctx->opaque)))\n                goto cleanup;\n            if (virDomainDiskSetSource(*def, tmp) < 0) {\n                VIR_FREE(tmp);\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n        } else if (deviceType && STRCASEEQ(deviceType, \"atapi-cdrom\")) {\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n\n            if (fileName && STRCASEEQ(fileName, \"auto detect\")) {\n                ignore_value(virDomainDiskSetSource(*def, NULL));\n                (*def)->startupPolicy = VIR_DOMAIN_STARTUP_POLICY_OPTIONAL;\n            } else if (virDomainDiskSetSource(*def, fileName) < 0) {\n                goto cleanup;\n            }\n        } else if (deviceType && STRCASEEQ(deviceType, \"cdrom-raw\")) {\n            /* Raw access CD-ROMs actually are device='lun' */\n            (*def)->device = VIR_DOMAIN_DISK_DEVICE_LUN;\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n\n            if (fileName && STRCASEEQ(fileName, \"auto detect\")) {\n                ignore_value(virDomainDiskSetSource(*def, NULL));\n                (*def)->startupPolicy = VIR_DOMAIN_STARTUP_POLICY_OPTIONAL;\n            } else if (virDomainDiskSetSource(*def, fileName) < 0) {\n                goto cleanup;\n            }\n        } else if (busType == VIR_DOMAIN_DISK_BUS_SCSI &&\n                   deviceType && STRCASEEQ(deviceType, \"scsi-passthru\")) {\n            if (fileName && STRPREFIX(fileName, \"/vmfs/devices/cdrom/\")) {\n                /* SCSI-passthru CD-ROMs actually are device='lun' */\n                (*def)->device = VIR_DOMAIN_DISK_DEVICE_LUN;\n                virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n\n                if (virDomainDiskSetSource(*def, fileName) < 0)\n                    goto cleanup;\n            } else {\n                /*\n                 * This function was called in order to parse a CDROM device,\n                 * but the filename does not indicate a CDROM device. Just ignore\n                 * it, another call to this function to parse a harddisk device\n                 * may handle it.\n                 */\n                goto ignore;\n            }\n        } else if (fileName && STREQ(fileName, \"emptyBackingString\")) {\n            if (deviceType && STRCASENEQ(deviceType, \"cdrom-image\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry '%s' to be 'cdrom-image' \"\n                                 \"but found '%s'\"), deviceType_name, deviceType);\n                goto cleanup;\n            }\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            ignore_value(virDomainDiskSetSource(*def, NULL));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\"),\n                           NULLSTR(fileName), fileName_name,\n                           deviceType ? deviceType : \"unknown\");\n            goto cleanup;\n        }\n    } else if (device == VIR_DOMAIN_DISK_DEVICE_FLOPPY) {\n        if (fileType != NULL && STRCASEEQ(fileType, \"device\")) {\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_BLOCK);\n            if (virDomainDiskSetSource(*def, fileName) < 0)\n                goto cleanup;\n        } else if (fileType != NULL && STRCASEEQ(fileType, \"file\")) {\n            char *tmp = NULL;\n\n            virDomainDiskSetType(*def, VIR_STORAGE_TYPE_FILE);\n            if (fileName && !(tmp = ctx->parseFileName(fileName, ctx->opaque)))\n                goto cleanup;\n            if (virDomainDiskSetSource(*def, tmp) < 0) {\n                VIR_FREE(tmp);\n                goto cleanup;\n            }\n            VIR_FREE(tmp);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid or not yet handled value '%s' \"\n                             \"for VMX entry '%s' for device type '%s'\"),\n                           NULLSTR(fileName), fileName_name,\n                           deviceType ? deviceType : \"unknown\");\n            goto cleanup;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, _(\"Unsupported device type '%s'\"),\n                       virDomainDiskDeviceTypeToString(device));\n        goto cleanup;\n    }\n\n    if (virDomainDiskDefAssignAddress(xmlopt, *def, vmdef) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not assign address to disk '%s'\"),\n                       virDomainDiskGetSource(*def));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virDomainDiskDefFree(*def);\n        *def = NULL;\n    }\n\n    VIR_FREE(prefix);\n    VIR_FREE(deviceType);\n    VIR_FREE(fileType);\n    VIR_FREE(fileName);\n    VIR_FREE(mode);\n\n    return result;\n\n ignore:\n    virDomainDiskDefFree(*def);\n    *def = NULL;\n\n    result = 0;\n\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefAddController",
          "args": [
            "def",
            "VIR_DOMAIN_CONTROLLER_TYPE_SCSI",
            "controller",
            "scsi_virtualDev[controller]"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefAddController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "18932-18952",
          "snippet": "virDomainControllerDefPtr\nvirDomainDefAddController(virDomainDefPtr def, int type, int idx, int model)\n{\n    virDomainControllerDefPtr cont;\n\n    if (!(cont = virDomainControllerDefNew(type)))\n        return NULL;\n\n    if (idx < 0)\n        idx = virDomainControllerFindUnusedIndex(def, type);\n\n    cont->idx = idx;\n    cont->model = model;\n\n    if (VIR_APPEND_ELEMENT_COPY(def->controllers, def->ncontrollers, cont) < 0) {\n        VIR_FREE(cont);\n        return NULL;\n    }\n\n    return cont;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainControllerDefPtr\nvirDomainDefAddController(virDomainDefPtr def, int type, int idx, int model)\n{\n    virDomainControllerDefPtr cont;\n\n    if (!(cont = virDomainControllerDefNew(type)))\n        return NULL;\n\n    if (idx < 0)\n        idx = virDomainControllerFindUnusedIndex(def, type);\n\n    cont->idx = idx;\n    cont->model = model;\n\n    if (VIR_APPEND_ELEMENT_COPY(def->controllers, def->ncontrollers, cont) < 0) {\n        VIR_FREE(cont);\n        return NULL;\n    }\n\n    return cont;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXParseSCSIController",
          "args": [
            "conf",
            "controller",
            "&present",
            "&scsi_virtualDev[controller]"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXParseSCSIController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "1937-2003",
          "snippet": "int\nvirVMXParseSCSIController(virConfPtr conf, int controller, bool *present,\n                          int *virtualDev)\n{\n    int result = -1;\n    char present_name[32];\n    char virtualDev_name[32];\n    char *virtualDev_string = NULL;\n    char *tmp;\n\n    if (virtualDev == NULL || *virtualDev != -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (controller < 0 || controller > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SCSI controller index %d out of [0..3] range\"),\n                       controller);\n        return -1;\n    }\n\n    g_snprintf(present_name, sizeof(present_name), \"scsi%d.present\", controller);\n    g_snprintf(virtualDev_name, sizeof(virtualDev_name), \"scsi%d.virtualDev\",\n               controller);\n\n    if (virVMXGetConfigBoolean(conf, present_name, present, false, true) < 0)\n        goto cleanup;\n\n    if (! *present) {\n        result = 0;\n        goto cleanup;\n    }\n\n    if (virVMXGetConfigString(conf, virtualDev_name, &virtualDev_string,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualDev_string != NULL) {\n        tmp = virtualDev_string;\n\n        for (; *tmp != '\\0'; ++tmp)\n            *tmp = g_ascii_tolower(*tmp);\n\n        *virtualDev = virVMXControllerModelSCSITypeFromString(virtualDev_string);\n\n        if (*virtualDev == -1 ||\n            (*virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC &&\n             *virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC &&\n             *virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068 &&\n             *virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry '%s' to be 'buslogic' or 'lsilogic' \"\n                             \"or 'lsisas1068' or 'pvscsi' but found '%s'\"),\n                           virtualDev_name, virtualDev_string);\n            goto cleanup;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(virtualDev_string);\n\n    return result;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXParseSCSIController(virConfPtr conf, int controller, bool *present,\n                          int *virtualDev)\n{\n    int result = -1;\n    char present_name[32];\n    char virtualDev_name[32];\n    char *virtualDev_string = NULL;\n    char *tmp;\n\n    if (virtualDev == NULL || *virtualDev != -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (controller < 0 || controller > 3) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SCSI controller index %d out of [0..3] range\"),\n                       controller);\n        return -1;\n    }\n\n    g_snprintf(present_name, sizeof(present_name), \"scsi%d.present\", controller);\n    g_snprintf(virtualDev_name, sizeof(virtualDev_name), \"scsi%d.virtualDev\",\n               controller);\n\n    if (virVMXGetConfigBoolean(conf, present_name, present, false, true) < 0)\n        goto cleanup;\n\n    if (! *present) {\n        result = 0;\n        goto cleanup;\n    }\n\n    if (virVMXGetConfigString(conf, virtualDev_name, &virtualDev_string,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualDev_string != NULL) {\n        tmp = virtualDev_string;\n\n        for (; *tmp != '\\0'; ++tmp)\n            *tmp = g_ascii_tolower(*tmp);\n\n        *virtualDev = virVMXControllerModelSCSITypeFromString(virtualDev_string);\n\n        if (*virtualDev == -1 ||\n            (*virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC &&\n             *virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC &&\n             *virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068 &&\n             *virtualDev != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry '%s' to be 'buslogic' or 'lsilogic' \"\n                             \"or 'lsisas1068' or 'pvscsi' but found '%s'\"),\n                           virtualDev_name, virtualDev_string);\n            goto cleanup;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(virtualDev_string);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->disks",
            "66"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXParseVNC",
          "args": [
            "conf",
            "&def->graphics[def->ngraphics]"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXParseVNC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "1871-1933",
          "snippet": "int\nvirVMXParseVNC(virConfPtr conf, virDomainGraphicsDefPtr *def)\n{\n    bool enabled = false;\n    long long port = 0;\n    char *listenAddr = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virVMXGetConfigBoolean(conf, \"RemoteDisplay.vnc.enabled\", &enabled,\n                               false, true) < 0) {\n        return -1;\n    }\n\n    if (! enabled)\n        return 0;\n\n    if (VIR_ALLOC(*def) < 0)\n        goto failure;\n\n    (*def)->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n\n    if (virVMXGetConfigLong(conf, \"RemoteDisplay.vnc.port\", &port, -1,\n                            true) < 0 ||\n        virVMXGetConfigString(conf, \"RemoteDisplay.vnc.ip\",\n                              &listenAddr, true) < 0 ||\n        virVMXGetConfigString(conf, \"RemoteDisplay.vnc.keymap\",\n                              &(*def)->data.vnc.keymap, true) < 0 ||\n        virVMXGetConfigString(conf, \"RemoteDisplay.vnc.password\",\n                              &(*def)->data.vnc.auth.passwd, true) < 0) {\n        goto failure;\n    }\n\n    if (virDomainGraphicsListenAppendAddress(*def, listenAddr) < 0)\n        goto failure;\n    VIR_FREE(listenAddr);\n\n    if (port < 0) {\n        VIR_WARN(\"VNC is enabled but VMX entry 'RemoteDisplay.vnc.port' \"\n                  \"is missing, the VNC port is unknown\");\n\n        (*def)->data.vnc.port = 0;\n        (*def)->data.vnc.autoport = true;\n    } else {\n        if (port < 5900 || port > 5964)\n            VIR_WARN(\"VNC port %lld it out of [5900..5964] range\", port);\n\n        (*def)->data.vnc.port = port;\n        (*def)->data.vnc.autoport = false;\n    }\n\n    return 0;\n\n failure:\n    VIR_FREE(listenAddr);\n    virDomainGraphicsDefFree(*def);\n    *def = NULL;\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXParseVNC(virConfPtr conf, virDomainGraphicsDefPtr *def)\n{\n    bool enabled = false;\n    long long port = 0;\n    char *listenAddr = NULL;\n\n    if (def == NULL || *def != NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (virVMXGetConfigBoolean(conf, \"RemoteDisplay.vnc.enabled\", &enabled,\n                               false, true) < 0) {\n        return -1;\n    }\n\n    if (! enabled)\n        return 0;\n\n    if (VIR_ALLOC(*def) < 0)\n        goto failure;\n\n    (*def)->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n\n    if (virVMXGetConfigLong(conf, \"RemoteDisplay.vnc.port\", &port, -1,\n                            true) < 0 ||\n        virVMXGetConfigString(conf, \"RemoteDisplay.vnc.ip\",\n                              &listenAddr, true) < 0 ||\n        virVMXGetConfigString(conf, \"RemoteDisplay.vnc.keymap\",\n                              &(*def)->data.vnc.keymap, true) < 0 ||\n        virVMXGetConfigString(conf, \"RemoteDisplay.vnc.password\",\n                              &(*def)->data.vnc.auth.passwd, true) < 0) {\n        goto failure;\n    }\n\n    if (virDomainGraphicsListenAppendAddress(*def, listenAddr) < 0)\n        goto failure;\n    VIR_FREE(listenAddr);\n\n    if (port < 0) {\n        VIR_WARN(\"VNC is enabled but VMX entry 'RemoteDisplay.vnc.port' \"\n                  \"is missing, the VNC port is unknown\");\n\n        (*def)->data.vnc.port = 0;\n        (*def)->data.vnc.autoport = true;\n    } else {\n        if (port < 5900 || port > 5964)\n            VIR_WARN(\"VNC port %lld it out of [5900..5964] range\", port);\n\n        (*def)->data.vnc.port = port;\n        (*def)->data.vnc.autoport = false;\n    }\n\n    return 0;\n\n failure:\n    VIR_FREE(listenAddr);\n    virDomainGraphicsDefFree(*def);\n    *def = NULL;\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->graphics",
            "1"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringHasSuffix",
          "args": [
            "guestOS",
            "\"-64\""
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "virStringHasSuffix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1097-1108",
          "snippet": "bool\nvirStringHasSuffix(const char *str,\n                   const char *suffix)\n{\n    int len = strlen(str);\n    int suffixlen = strlen(suffix);\n\n    if (len < suffixlen)\n        return false;\n\n    return STREQ(str + len - suffixlen, suffix);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nbool\nvirStringHasSuffix(const char *str,\n                   const char *suffix)\n{\n    int len = strlen(str);\n    int suffixlen = strlen(suffix);\n\n    if (len < suffixlen)\n        return false;\n\n    return STREQ(str + len - suffixlen, suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry 'sched.cpu.shares' to be an \"\n                             \"unsigned integer or 'low', 'normal' or 'high' but \"\n                             \"found '%s'\")",
            "sched_cpu_shares"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "sched_cpu_shares",
            "NULL",
            "10",
            "&def->cputune.shares"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "sched_cpu_shares",
            "\"high\""
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "sched_cpu_shares",
            "\"normal\""
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "sched_cpu_shares",
            "\"low\""
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpus",
          "args": [
            "def"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1912-1924",
          "snippet": "unsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(def->cpumask, number)"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "def->cpumask",
            "number"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"VMX entry 'sched.cpu.affinity' contains a %d, \"\n                                 \"this value is too large\")",
            "number"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry 'sched.cpu.affinity' to be \"\n                                 \"a comma separated list of unsigned integers but \"\n                                 \"found '%s'\")",
            "sched_cpu_affinity"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSkipSpaces",
          "args": [
            "&current"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "virSkipSpacesAndBackslash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "810-818",
          "snippet": "void\nvirSkipSpacesAndBackslash(const char **str)\n{\n    const char *cur = *str;\n\n    while (g_ascii_isspace(*cur) || *cur == '\\\\')\n        cur++;\n    *str = cur;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirSkipSpacesAndBackslash(const char **str)\n{\n    const char *cur = *str;\n\n    while (g_ascii_isspace(*cur) || *cur == '\\\\')\n        cur++;\n    *str = cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_uip",
          "args": [
            "current",
            "(char **) &current",
            "10",
            "&number"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry 'sched.cpu.affinity' to contain \"\n                             \"at least as many values as 'numvcpus' (%lld) but \"\n                             \"found only %zu value(s)\")",
            "numvcpus",
            "naffs"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplitCount",
          "args": [
            "sched_cpu_affinity",
            "\",\"",
            "0",
            "&naffs"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplitCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "69-123",
          "snippet": "char **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplitCount(const char *string,\n                    const char *delim,\n                    size_t max_tokens,\n                    size_t *tokcount)\n{\n    char **tokens = NULL;\n    size_t ntokens = 0;\n    size_t maxtokens = 0;\n    const char *remainder = string;\n    char *tmp;\n    size_t i;\n\n    if (max_tokens == 0)\n        max_tokens = INT_MAX;\n\n    tmp = strstr(remainder, delim);\n    if (tmp) {\n        size_t delimlen = strlen(delim);\n\n        while (--max_tokens && tmp) {\n            size_t len = tmp - remainder;\n\n            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n                goto error;\n\n            tokens[ntokens] = g_strndup(remainder, len);\n            ntokens++;\n            remainder = tmp + delimlen;\n            tmp = strstr(remainder, delim);\n        }\n    }\n    if (*string) {\n        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n            goto error;\n\n        tokens[ntokens] = g_strdup(remainder);\n        ntokens++;\n    }\n\n    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)\n        goto error;\n    tokens[ntokens++] = NULL;\n\n    if (tokcount)\n        *tokcount = ntokens - 1;\n\n    return tokens;\n\n error:\n    for (i = 0; i < ntokens; i++)\n        VIR_FREE(tokens[i]);\n    VIR_FREE(tokens);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "VIR_DOMAIN_CPUMASK_LEN"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASENEQ",
          "args": [
            "sched_cpu_affinity",
            "\"all\""
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&cpu"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"VMX entry 'cpuid.coresPerSocket' smaller than \"\n                             \"'numvcpus'\")"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefNew",
          "args": [],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "85-90",
          "snippet": "virCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetVcpus",
          "args": [
            "def",
            "numvcpus"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1889-1909",
          "snippet": "int\nvirDomainDefSetVcpus(virDomainDefPtr def,\n                     unsigned int vcpus)\n{\n    size_t i;\n\n    if (vcpus > def->maxvcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"maximum vCPU count must not be less than current \"\n                         \"vCPU count\"));\n        return -1;\n    }\n\n    for (i = 0; i < vcpus; i++)\n        def->vcpus[i]->online = true;\n\n    for (i = vcpus; i < def->maxvcpus; i++)\n        def->vcpus[i]->online = false;\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSetVcpus(virDomainDefPtr def,\n                     unsigned int vcpus)\n{\n    size_t i;\n\n    if (vcpus > def->maxvcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"maximum vCPU count must not be less than current \"\n                         \"vCPU count\"));\n        return -1;\n    }\n\n    for (i = 0; i < vcpus; i++)\n        def->vcpus[i]->online = true;\n\n    for (i = vcpus; i < def->maxvcpus; i++)\n        def->vcpus[i]->online = false;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetVcpusMax",
          "args": [
            "def",
            "numvcpus",
            "xmlopt"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetVcpusMax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1838-1865",
          "snippet": "int\nvirDomainDefSetVcpusMax(virDomainDefPtr def,\n                        unsigned int maxvcpus,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    size_t oldmax = def->maxvcpus;\n    size_t i;\n\n    if (def->maxvcpus == maxvcpus)\n        return 0;\n\n    if (def->maxvcpus < maxvcpus) {\n        if (VIR_EXPAND_N(def->vcpus, def->maxvcpus, maxvcpus - def->maxvcpus) < 0)\n            return -1;\n\n        for (i = oldmax; i < def->maxvcpus; i++) {\n            if (!(def->vcpus[i] = virDomainVcpuDefNew(xmlopt)))\n                return -1;\n        }\n    } else {\n        for (i = maxvcpus; i < def->maxvcpus; i++)\n            virDomainVcpuDefFree(def->vcpus[i]);\n\n        VIR_SHRINK_N(def->vcpus, def->maxvcpus, def->maxvcpus - maxvcpus);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSetVcpusMax(virDomainDefPtr def,\n                        unsigned int maxvcpus,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    size_t oldmax = def->maxvcpus;\n    size_t i;\n\n    if (def->maxvcpus == maxvcpus)\n        return 0;\n\n    if (def->maxvcpus < maxvcpus) {\n        if (VIR_EXPAND_N(def->vcpus, def->maxvcpus, maxvcpus - def->maxvcpus) < 0)\n            return -1;\n\n        for (i = oldmax; i < def->maxvcpus; i++) {\n            if (!(def->vcpus[i] = virDomainVcpuDefNew(xmlopt)))\n                return -1;\n        }\n    } else {\n        for (i = maxvcpus; i < def->maxvcpus; i++)\n            virDomainVcpuDefFree(def->vcpus[i]);\n\n        VIR_SHRINK_N(def->vcpus, def->maxvcpus, def->maxvcpus - maxvcpus);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry 'numvcpus' to be an unsigned \"\n                         \"integer greater than 0 but found %lld\")",
            "numvcpus"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetMemoryTotal",
          "args": [
            "def"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10946-10950",
          "snippet": "unsigned long long\nvirDomainDefGetMemoryTotal(const virDomainDef *def)\n{\n    return def->mem.total_memory;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned long long\nvirDomainDefGetMemoryTotal(const virDomainDef *def)\n{\n    return def->mem.total_memory;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetMemoryTotal",
          "args": [
            "def",
            "memsize * 1024"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10931-10936",
          "snippet": "void\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry 'memsize' to be an unsigned \"\n                         \"integer (multiple of 4) but found %lld\")",
            "memsize"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"VMX entry 'annotation' contains invalid escape \"\n                             \"sequence\")"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXUnescapeHexPipe",
          "args": [
            "def->description"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"VMX entry 'name' contains invalid escape sequence\")"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXUnescapeHexPipe",
          "args": [
            "def->name"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXUnescapeHexPercent",
          "args": [
            "def->name"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigUUID",
          "args": [
            "conf",
            "\"uuid.bios\"",
            "def->uuid",
            "true"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "764-788",
          "snippet": "static int\nvirVMXGetConfigUUID(virConfPtr conf, const char *name, unsigned char *uuid,\n                    bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    rc = virUUIDParse(string, uuid);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"), string);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigUUID(virConfPtr conf, const char *name, unsigned char *uuid,\n                    bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    rc = virUUIDParse(string, uuid);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"), string);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry 'virtualHW.version' to be \"\n                         \"4 or higher but found %lld\")",
            "virtualHW_version"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VMX entry 'config.version' to be 8 but found \"\n                         \"%lld\")",
            "config_version"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefNew",
          "args": [],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3574-3594",
          "snippet": "virDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfWalk",
          "args": [
            "conf",
            "virVMXConfigScanResultsCollector",
            "&results"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "virConfWalk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1391-1408",
          "snippet": "int virConfWalk(virConfPtr conf,\n                virConfWalkCallback callback,\n                void *opaque)\n{\n    virConfEntryPtr cur;\n\n    if (!conf)\n        return 0;\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (cur->name && cur->value &&\n            callback(cur->name, cur->value, opaque) < 0)\n            return -1;\n        cur = cur->next;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfWalk(virConfPtr conf,\n                virConfWalkCallback callback,\n                void *opaque)\n{\n    virConfEntryPtr cur;\n\n    if (!conf)\n        return 0;\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (cur->name && cur->value &&\n            callback(cur->name, cur->value, opaque) < 0)\n            return -1;\n        cur = cur->next;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "utf8"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfReadString",
          "args": [
            "utf8",
            "VIR_CONF_FLAG_VMX_FORMAT"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "virConfReadString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "765-777",
          "snippet": "virConfPtr\nvirConfReadString(const char *memory, unsigned int flags)\n{\n    size_t len;\n\n    if (memory == NULL) {\n        virConfError(NULL, VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return NULL;\n    }\n\n    len = strlen(memory);\n    return virConfParse(\"memory conf\", memory, len, flags);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvirConfPtr\nvirConfReadString(const char *memory, unsigned int flags)\n{\n    size_t len;\n\n    if (memory == NULL) {\n        virConfError(NULL, VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return NULL;\n    }\n\n    len = strlen(memory);\n    return virConfParse(\"memory conf\", memory, len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXConvertToUTF8",
          "args": [
            "encoding",
            "vmx"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXConvertToUTF8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "691-725",
          "snippet": "char *\nvirVMXConvertToUTF8(const char *encoding, const char *string)\n{\n    char *result = NULL;\n    xmlCharEncodingHandlerPtr handler;\n    xmlBufferPtr input;\n    xmlBufferPtr utf8;\n\n    handler = xmlFindCharEncodingHandler(encoding);\n\n    if (handler == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"libxml2 doesn't handle %s encoding\"), encoding);\n        return NULL;\n    }\n\n    input = xmlBufferCreateStatic((char *)string, strlen(string));\n    utf8 = xmlBufferCreate();\n\n    if (xmlCharEncInFunc(handler, utf8, input) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not convert from %s to UTF-8 encoding\"), encoding);\n        goto cleanup;\n    }\n\n    result = (char *)utf8->content;\n    utf8->content = NULL;\n\n cleanup:\n    xmlCharEncCloseFunc(handler);\n    xmlBufferFree(input);\n    xmlBufferFree(utf8);\n\n    return result;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirVMXConvertToUTF8(const char *encoding, const char *string)\n{\n    char *result = NULL;\n    xmlCharEncodingHandlerPtr handler;\n    xmlBufferPtr input;\n    xmlBufferPtr utf8;\n\n    handler = xmlFindCharEncodingHandler(encoding);\n\n    if (handler == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"libxml2 doesn't handle %s encoding\"), encoding);\n        return NULL;\n    }\n\n    input = xmlBufferCreateStatic((char *)string, strlen(string));\n    utf8 = xmlBufferCreate();\n\n    if (xmlCharEncInFunc(handler, utf8, input) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not convert from %s to UTF-8 encoding\"), encoding);\n        goto cleanup;\n    }\n\n    result = (char *)utf8->content;\n    utf8->content = NULL;\n\n cleanup:\n    xmlCharEncCloseFunc(handler);\n    xmlBufferFree(input);\n    xmlBufferFree(utf8);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfFree",
          "args": [
            "conf"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "virConfFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "787-807",
          "snippet": "int\nvirConfFree(virConfPtr conf)\n{\n    virConfEntryPtr tmp;\n    if (conf == NULL)\n        return 0;\n\n    tmp = conf->entries;\n    while (tmp) {\n        virConfEntryPtr next;\n        VIR_FREE(tmp->name);\n        virConfFreeValue(tmp->value);\n        VIR_FREE(tmp->comment);\n        next = tmp->next;\n        VIR_FREE(tmp);\n        tmp = next;\n    }\n    VIR_FREE(conf->filename);\n    VIR_FREE(conf);\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirConfFree(virConfPtr conf)\n{\n    virConfEntryPtr tmp;\n    if (conf == NULL)\n        return 0;\n\n    tmp = conf->entries;\n    while (tmp) {\n        virConfEntryPtr next;\n        VIR_FREE(tmp->name);\n        virConfFreeValue(tmp->value);\n        VIR_FREE(tmp->comment);\n        next = tmp->next;\n        VIR_FREE(tmp);\n        tmp = next;\n    }\n    VIR_FREE(conf->filename);\n    VIR_FREE(conf);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "encoding",
            "\"UTF-8\""
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"virVMXContext has no parseFileName function set\")"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainDefPtr\nvirVMXParseConfig(virVMXContext *ctx,\n                  virDomainXMLOptionPtr xmlopt,\n                  virCapsPtr caps G_GNUC_UNUSED,\n                  const char *vmx)\n{\n    bool success = false;\n    g_autoptr(virConf) conf = NULL;\n    char *encoding = NULL;\n    char *utf8;\n    virDomainDefPtr def = NULL;\n    long long config_version = 0;\n    long long virtualHW_version = 0;\n    long long memsize = 0;\n    long long sched_mem_max = 0;\n    long long sched_mem_minsize = 0;\n    long long numvcpus = 0;\n    char *sched_cpu_affinity = NULL;\n    char *sched_cpu_shares = NULL;\n    char *guestOS = NULL;\n    bool smbios_reflecthost = false;\n    int controller;\n    int bus;\n    int port;\n    bool present;\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    int unit;\n    bool hgfs_disabled = true;\n    long long sharedFolder_maxNum = 0;\n    struct virVMXConfigScanResults results = { -1 };\n    long long coresPerSocket = 0;\n    virCPUDefPtr cpu = NULL;\n    char *firmware = NULL;\n\n    if (ctx->parseFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no parseFileName function set\"));\n        return NULL;\n    }\n\n    conf = virConfReadString(vmx, VIR_CONF_FLAG_VMX_FORMAT);\n\n    if (conf == NULL)\n        return NULL;\n\n    /* vmx:.encoding */\n    if (virVMXGetConfigString(conf, \".encoding\", &encoding, true) < 0)\n        goto cleanup;\n\n    if (encoding == NULL || STRCASEEQ(encoding, \"UTF-8\")) {\n        /* nothing */\n    } else {\n        virConfFree(conf);\n        conf = NULL;\n\n        utf8 = virVMXConvertToUTF8(encoding, vmx);\n\n        if (utf8 == NULL)\n            goto cleanup;\n\n        conf = virConfReadString(utf8, VIR_CONF_FLAG_VMX_FORMAT);\n\n        VIR_FREE(utf8);\n\n        if (conf == NULL)\n            goto cleanup;\n    }\n\n    if (virConfWalk(conf, virVMXConfigScanResultsCollector, &results) < 0)\n        goto cleanup;\n\n    /* Allocate domain def */\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    def->virtType = VIR_DOMAIN_VIRT_VMWARE;\n    def->id = -1;\n\n    /* vmx:config.version */\n    if (virVMXGetConfigLong(conf, \"config.version\", &config_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (config_version != 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'config.version' to be 8 but found \"\n                         \"%lld\"), config_version);\n        goto cleanup;\n    }\n\n    /* vmx:virtualHW.version */\n    if (virVMXGetConfigLong(conf, \"virtualHW.version\", &virtualHW_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualHW_version < 4) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'virtualHW.version' to be \"\n                         \"4 or higher but found %lld\"),\n                       virtualHW_version);\n        goto cleanup;\n    }\n\n    /* vmx:uuid.bios -> def:uuid */\n    /* FIXME: Need to handle 'uuid.action = \"create\"' */\n    if (virVMXGetConfigUUID(conf, \"uuid.bios\", def->uuid, true) < 0)\n        goto cleanup;\n\n    /* vmx:displayName -> def:name */\n    if (virVMXGetConfigString(conf, \"displayName\", &def->name, true) < 0)\n        goto cleanup;\n\n    if (def->name != NULL) {\n        if (virVMXUnescapeHexPercent(def->name) < 0 ||\n            virVMXUnescapeHexPipe(def->name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'name' contains invalid escape sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:annotation -> def:description */\n    if (virVMXGetConfigString(conf, \"annotation\", &def->description,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (def->description != NULL) {\n        if (virVMXUnescapeHexPipe(def->description) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'annotation' contains invalid escape \"\n                             \"sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:memsize -> def:mem.max_balloon */\n    if (virVMXGetConfigLong(conf, \"memsize\", &memsize, 32, true) < 0)\n        goto cleanup;\n\n    if (memsize <= 0 || memsize % 4 != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'memsize' to be an unsigned \"\n                         \"integer (multiple of 4) but found %lld\"), memsize);\n        goto cleanup;\n    }\n\n    virDomainDefSetMemoryTotal(def, memsize * 1024); /* Scale from megabytes to kilobytes */\n\n    /* vmx:sched.mem.max -> def:mem.cur_balloon */\n    if (virVMXGetConfigLong(conf, \"sched.mem.max\", &sched_mem_max, memsize,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_max < 0)\n        sched_mem_max = memsize;\n\n    def->mem.cur_balloon = sched_mem_max * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.cur_balloon > virDomainDefGetMemoryTotal(def))\n        def->mem.cur_balloon = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:sched.mem.minsize -> def:mem.min_guarantee */\n    if (virVMXGetConfigLong(conf, \"sched.mem.minsize\", &sched_mem_minsize, 0,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_minsize < 0)\n        sched_mem_minsize = 0;\n\n    def->mem.min_guarantee = sched_mem_minsize * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.min_guarantee > virDomainDefGetMemoryTotal(def))\n        def->mem.min_guarantee = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:numvcpus -> def:vcpus */\n    if (virVMXGetConfigLong(conf, \"numvcpus\", &numvcpus, 1, true) < 0)\n        goto cleanup;\n\n    if (numvcpus <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'numvcpus' to be an unsigned \"\n                         \"integer greater than 0 but found %lld\"), numvcpus);\n        goto cleanup;\n    }\n\n    if (virDomainDefSetVcpusMax(def, numvcpus, xmlopt) < 0)\n        goto cleanup;\n\n    if (virDomainDefSetVcpus(def, numvcpus) < 0)\n        goto cleanup;\n\n    /* vmx:cpuid.coresPerSocket -> def:cpu */\n    if (virVMXGetConfigLong(conf, \"cpuid.coresPerSocket\", &coresPerSocket, 1,\n                            true) < 0)\n        goto cleanup;\n\n    if (coresPerSocket > 1) {\n        cpu = virCPUDefNew();\n\n        cpu->type = VIR_CPU_TYPE_GUEST;\n        cpu->mode = VIR_CPU_MODE_CUSTOM;\n\n        cpu->sockets = numvcpus / coresPerSocket;\n        if (cpu->sockets <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'cpuid.coresPerSocket' smaller than \"\n                             \"'numvcpus'\"));\n            goto cleanup;\n        }\n        cpu->dies = 1;\n        cpu->cores = coresPerSocket;\n        cpu->threads = 1;\n\n        def->cpu = g_steal_pointer(&cpu);\n    }\n\n    /* vmx:sched.cpu.affinity -> def:cpumask */\n    /* NOTE: maps to VirtualMachine:config.cpuAffinity.affinitySet */\n    if (virVMXGetConfigString(conf, \"sched.cpu.affinity\", &sched_cpu_affinity,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_affinity != NULL && STRCASENEQ(sched_cpu_affinity, \"all\")) {\n        VIR_AUTOSTRINGLIST afflist = NULL;\n        char **aff;\n        size_t naffs;\n\n        def->cpumask = virBitmapNew(VIR_DOMAIN_CPUMASK_LEN);\n        if (!def->cpumask)\n            goto cleanup;\n\n        if (!(afflist = virStringSplitCount(sched_cpu_affinity, \",\", 0, &naffs)))\n            goto cleanup;\n\n        if (naffs < numvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.affinity' to contain \"\n                             \"at least as many values as 'numvcpus' (%lld) but \"\n                             \"found only %zu value(s)\"), numvcpus, naffs);\n            goto cleanup;\n        }\n\n        for (aff = afflist; *aff; aff++) {\n            const char *current = *aff;\n            unsigned int number;\n            int rc;\n\n            virSkipSpaces(&current);\n            rc = virStrToLong_uip(current, (char **) &current, 10, &number);\n            virSkipSpaces(&current);\n\n            if (rc < 0 || *current != '\\0') {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry 'sched.cpu.affinity' to be \"\n                                 \"a comma separated list of unsigned integers but \"\n                                 \"found '%s'\"), sched_cpu_affinity);\n                goto cleanup;\n            }\n\n            if (number >= VIR_DOMAIN_CPUMASK_LEN) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"VMX entry 'sched.cpu.affinity' contains a %d, \"\n                                 \"this value is too large\"), number);\n                goto cleanup;\n            }\n\n            ignore_value(virBitmapSetBit(def->cpumask, number));\n        }\n    }\n\n    /* vmx:sched.cpu.shares -> def:cputune.shares */\n    if (virVMXGetConfigString(conf, \"sched.cpu.shares\", &sched_cpu_shares,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_shares != NULL) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (STRCASEEQ(sched_cpu_shares, \"low\")) {\n            def->cputune.shares = vcpus * 500;\n        } else if (STRCASEEQ(sched_cpu_shares, \"normal\")) {\n            def->cputune.shares = vcpus * 1000;\n        } else if (STRCASEEQ(sched_cpu_shares, \"high\")) {\n            def->cputune.shares = vcpus * 2000;\n        } else if (virStrToLong_ull(sched_cpu_shares, NULL, 10,\n                                    &def->cputune.shares) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.shares' to be an \"\n                             \"unsigned integer or 'low', 'normal' or 'high' but \"\n                             \"found '%s'\"), sched_cpu_shares);\n            goto cleanup;\n        }\n        def->cputune.sharesSpecified = true;\n    }\n\n    /* def:lifecycle */\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* def:os */\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    /* vmx:guestOS -> def:os.arch */\n    if (virVMXGetConfigString(conf, \"guestOS\", &guestOS, true) < 0)\n        goto cleanup;\n\n    if (guestOS != NULL && virStringHasSuffix(guestOS, \"-64\")) {\n        def->os.arch = VIR_ARCH_X86_64;\n    } else {\n        def->os.arch = VIR_ARCH_I686;\n    }\n\n    /* vmx:smbios.reflecthost -> def:os.smbios_mode */\n    if (virVMXGetConfigBoolean(conf, \"smbios.reflecthost\",\n                               &smbios_reflecthost, false, true) < 0) {\n        goto cleanup;\n    }\n\n    if (smbios_reflecthost)\n        def->os.smbios_mode = VIR_DOMAIN_SMBIOS_HOST;\n\n    /* def:features */\n    /* FIXME */\n\n    /* def:clock */\n    /* FIXME */\n\n    /* def:graphics */\n    if (VIR_ALLOC_N(def->graphics, 1) < 0)\n        goto cleanup;\n\n    def->ngraphics = 0;\n\n    if (virVMXParseVNC(conf, &def->graphics[def->ngraphics]) < 0)\n        goto cleanup;\n\n    if (def->graphics[def->ngraphics] != NULL)\n        ++def->ngraphics;\n\n    /* def:disks: 4 * 15 scsi + 2 * 2 ide + 2 floppy = 66 */\n    if (VIR_ALLOC_N(def->disks, 66) < 0)\n        goto cleanup;\n\n    def->ndisks = 0;\n\n    /* def:disks (scsi) */\n    for (controller = 0; controller < 4; ++controller) {\n        if (virVMXParseSCSIController(conf, controller, &present,\n                                      &scsi_virtualDev[controller]) < 0) {\n            goto cleanup;\n        }\n\n        if (! present)\n            continue;\n\n        for (unit = 0; unit < 16; ++unit) {\n            if (unit == 7) {\n                /*\n                 * SCSI unit 7 is assigned to the SCSI controller and cannot be\n                 * used for disk devices.\n                 */\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                 VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                 &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n\n    }\n\n    /* add all the SCSI controllers we've seen, up until the last one that is\n     * currently used by a disk */\n    if (def->ndisks != 0) {\n        virDomainDeviceInfoPtr info = &def->disks[def->ndisks - 1]->info;\n        for (controller = 0; controller <= info->addr.drive.controller; controller++) {\n            if (!virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_SCSI,\n                                           controller, scsi_virtualDev[controller]))\n                goto cleanup;\n        }\n    }\n\n    /* def:disks (ide) */\n    for (bus = 0; bus < 2; ++bus) {\n        for (unit = 0; unit < 2; ++unit) {\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n    }\n\n    /* def:disks (floppy) */\n    for (unit = 0; unit < 2; ++unit) {\n        if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_FLOPPY,\n                            VIR_DOMAIN_DISK_BUS_FDC, 0, unit,\n                            &def->disks[def->ndisks], def) < 0) {\n            goto cleanup;\n        }\n\n        if (def->disks[def->ndisks] != NULL)\n            ++def->ndisks;\n    }\n\n    /* def:fss */\n    if (virVMXGetConfigBoolean(conf, \"isolation.tools.hgfs.disable\",\n                               &hgfs_disabled, true, true) < 0) {\n        goto cleanup;\n    }\n\n    if (!hgfs_disabled) {\n        if (virVMXGetConfigLong(conf, \"sharedFolder.maxNum\", &sharedFolder_maxNum,\n                                0, true) < 0) {\n            goto cleanup;\n        }\n\n        if (sharedFolder_maxNum > 0) {\n            int number;\n\n            if (VIR_ALLOC_N(def->fss, sharedFolder_maxNum) < 0)\n                goto cleanup;\n\n            def->nfss = 0;\n\n            for (number = 0; number < sharedFolder_maxNum; ++number) {\n                if (virVMXParseFileSystem(conf, number,\n                                          &def->fss[def->nfss]) < 0) {\n                    goto cleanup;\n                }\n\n                if (def->fss[def->nfss] != NULL)\n                    ++def->nfss;\n            }\n        }\n    }\n\n    /* def:nets */\n    for (controller = 0; controller <= results.networks_max_index; ++controller) {\n        virDomainNetDefPtr net = NULL;\n        if (virVMXParseEthernet(conf, controller, &net) < 0)\n            goto cleanup;\n\n        if (!net)\n            continue;\n\n        if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:videos */\n    if (VIR_ALLOC_N(def->videos, 1) < 0)\n        goto cleanup;\n\n    def->nvideos = 0;\n\n    if (virVMXParseSVGA(conf, &def->videos[def->nvideos]) < 0)\n        goto cleanup;\n\n    def->nvideos = 1;\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    if (VIR_ALLOC_N(def->serials, 4) < 0)\n        goto cleanup;\n\n    def->nserials = 0;\n\n    for (port = 0; port < 4; ++port) {\n        if (virVMXParseSerial(ctx, conf, port,\n                              &def->serials[def->nserials]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->serials[def->nserials] != NULL)\n            ++def->nserials;\n    }\n\n    /* def:parallels */\n    if (VIR_ALLOC_N(def->parallels, 3) < 0)\n        goto cleanup;\n\n    def->nparallels = 0;\n\n    for (port = 0; port < 3; ++port) {\n        if (virVMXParseParallel(ctx, conf, port,\n                                &def->parallels[def->nparallels]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->parallels[def->nparallels] != NULL)\n            ++def->nparallels;\n    }\n\n    /* ctx:datacenterPath -> def:namespaceData */\n    if (ctx->datacenterPath || ctx->moref) {\n        struct virVMXDomainDefNamespaceData *nsdata = NULL;\n\n        if (VIR_ALLOC(nsdata) < 0) {\n            virVMXDomainDefNamespaceFree(nsdata);\n            goto cleanup;\n        }\n\n        nsdata->datacenterPath = g_strdup(ctx->datacenterPath);\n\n        nsdata->moref = g_strdup(ctx->moref);\n\n        def->ns = *virDomainXMLOptionGetNamespace(xmlopt);\n        def->namespaceData = nsdata;\n    }\n\n    /* vmx:firmware */\n    if (virVMXGetConfigString(conf, \"firmware\", &firmware, true) < 0)\n        goto cleanup;\n\n    if (firmware != NULL) {\n        if (STREQ(firmware, \"efi\")) {\n            def->os.firmware = VIR_DOMAIN_OS_DEF_FIRMWARE_EFI;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry 'firmware' has unknown value '%s'\"),\n                           firmware);\n            goto cleanup;\n        }\n    }\n\n    if (virDomainDefPostParse(def, VIR_DOMAIN_DEF_PARSE_ABI_UPDATE,\n                              xmlopt, NULL) < 0)\n        goto cleanup;\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        virDomainDefFree(def);\n        def = NULL;\n    }\n\n    VIR_FREE(encoding);\n    VIR_FREE(sched_cpu_affinity);\n    VIR_FREE(sched_cpu_shares);\n    VIR_FREE(guestOS);\n    virCPUDefFree(cpu);\n    VIR_FREE(firmware);\n\n    return def;\n}"
  },
  {
    "function_name": "virVMXConfigScanResultsCollector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "1243-1267",
    "snippet": "static int\nvirVMXConfigScanResultsCollector(const char* name,\n                                 virConfValuePtr value G_GNUC_UNUSED,\n                                 void *opaque)\n{\n    struct virVMXConfigScanResults *results = opaque;\n\n    if (STRCASEPREFIX(name, \"ethernet\")) {\n        unsigned int idx;\n        char *p;\n\n        if (virStrToLong_uip(name + 8, &p, 10, &idx) < 0 ||\n            *p != '.') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to parse the index of the VMX key '%s'\"),\n                           name);\n            return -1;\n        }\n\n        if ((int)idx > results->networks_max_index)\n            results->networks_max_index = (int)idx;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to parse the index of the VMX key '%s'\")",
            "name"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to parse the index of the VMX key '%s'\""
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_uip",
          "args": [
            "name + 8",
            "&p",
            "10",
            "&idx"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEPREFIX",
          "args": [
            "name",
            "\"ethernet\""
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXConfigScanResultsCollector(const char* name,\n                                 virConfValuePtr value G_GNUC_UNUSED,\n                                 void *opaque)\n{\n    struct virVMXConfigScanResults *results = opaque;\n\n    if (STRCASEPREFIX(name, \"ethernet\")) {\n        unsigned int idx;\n        char *p;\n\n        if (virStrToLong_uip(name + 8, &p, 10, &idx) < 0 ||\n            *p != '.') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to parse the index of the VMX key '%s'\"),\n                           name);\n            return -1;\n        }\n\n        if ((int)idx > results->networks_max_index)\n            results->networks_max_index = (int)idx;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXGatherSCSIControllers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "1138-1237",
    "snippet": "static int\nvirVMXGatherSCSIControllers(virVMXContext *ctx, virDomainDefPtr def,\n                            int virtualDev[4], bool present[4])\n{\n    int result = -1;\n    size_t i, k;\n    virDomainDiskDefPtr disk;\n    virDomainControllerDefPtr controller;\n    bool controllerHasDisksAttached;\n    int count = 0;\n    int *autodetectedModels;\n\n    if (VIR_ALLOC_N(autodetectedModels, def->ndisks) < 0)\n        return -1;\n\n    for (i = 0; i < def->ncontrollers; ++i) {\n        controller = def->controllers[i];\n\n        if (controller->type != VIR_DOMAIN_CONTROLLER_TYPE_SCSI) {\n            /* skip non-SCSI controllers */\n            continue;\n        }\n\n        controllerHasDisksAttached = false;\n\n        for (k = 0; k < def->ndisks; ++k) {\n            disk = def->disks[k];\n\n            if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI &&\n                disk->info.addr.drive.controller == controller->idx) {\n                controllerHasDisksAttached = true;\n                break;\n            }\n        }\n\n        if (! controllerHasDisksAttached) {\n            /* skip SCSI controllers without attached disks */\n            continue;\n        }\n\n        if (controller->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO &&\n            ctx->autodetectSCSIControllerModel != NULL) {\n            count = 0;\n\n            /* try to autodetect the SCSI controller model by collecting\n             * SCSI controller model of all disks attached to this controller */\n            for (k = 0; k < def->ndisks; ++k) {\n                disk = def->disks[k];\n\n                if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI &&\n                    disk->info.addr.drive.controller == controller->idx) {\n                    if (ctx->autodetectSCSIControllerModel\n                               (disk, &autodetectedModels[count],\n                                ctx->opaque) < 0) {\n                        goto cleanup;\n                    }\n\n                    ++count;\n                }\n            }\n\n            /* autodetection fails when the disks attached to one controller\n             * have inconsistent SCSI controller models */\n            for (k = 0; k < count; ++k) {\n                if (autodetectedModels[k] != autodetectedModels[0]) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Disks on SCSI controller %d have inconsistent \"\n                                     \"controller models, cannot autodetect model\"),\n                                   controller->idx);\n                    goto cleanup;\n                }\n            }\n\n            controller->model = autodetectedModels[0];\n        }\n\n        if (controller->model != -1 &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068 &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML attribute 'model' of entry \"\n                             \"'controller' to be 'buslogic' or 'lsilogic' or \"\n                             \"'lsisas1068' or 'vmpvscsi' but found '%s'\"),\n                           virDomainControllerModelSCSITypeToString(controller->model));\n            goto cleanup;\n        }\n\n        present[controller->idx] = true;\n        virtualDev[controller->idx] = controller->model;\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(autodetectedModels);\n\n    return result;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "autodetectedModels"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting domain XML attribute 'model' of entry \"\n                             \"'controller' to be 'buslogic' or 'lsilogic' or \"\n                             \"'lsisas1068' or 'vmpvscsi' but found '%s'\")",
            "virDomainControllerModelSCSITypeToString(controller->model)"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainControllerModelSCSITypeToString",
          "args": [
            "controller->model"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Expecting domain XML attribute 'model' of entry \"\n                             \"'controller' to be 'buslogic' or 'lsilogic' or \"\n                             \"'lsisas1068' or 'vmpvscsi' but found '%s'\""
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Disks on SCSI controller %d have inconsistent \"\n                                     \"controller models, cannot autodetect model\")",
            "controller->idx"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctx->autodetectSCSIControllerModel",
          "args": [
            "disk",
            "&autodetectedModels[count]",
            "ctx->opaque"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "autodetectedModels",
            "def->ndisks"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGatherSCSIControllers(virVMXContext *ctx, virDomainDefPtr def,\n                            int virtualDev[4], bool present[4])\n{\n    int result = -1;\n    size_t i, k;\n    virDomainDiskDefPtr disk;\n    virDomainControllerDefPtr controller;\n    bool controllerHasDisksAttached;\n    int count = 0;\n    int *autodetectedModels;\n\n    if (VIR_ALLOC_N(autodetectedModels, def->ndisks) < 0)\n        return -1;\n\n    for (i = 0; i < def->ncontrollers; ++i) {\n        controller = def->controllers[i];\n\n        if (controller->type != VIR_DOMAIN_CONTROLLER_TYPE_SCSI) {\n            /* skip non-SCSI controllers */\n            continue;\n        }\n\n        controllerHasDisksAttached = false;\n\n        for (k = 0; k < def->ndisks; ++k) {\n            disk = def->disks[k];\n\n            if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI &&\n                disk->info.addr.drive.controller == controller->idx) {\n                controllerHasDisksAttached = true;\n                break;\n            }\n        }\n\n        if (! controllerHasDisksAttached) {\n            /* skip SCSI controllers without attached disks */\n            continue;\n        }\n\n        if (controller->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO &&\n            ctx->autodetectSCSIControllerModel != NULL) {\n            count = 0;\n\n            /* try to autodetect the SCSI controller model by collecting\n             * SCSI controller model of all disks attached to this controller */\n            for (k = 0; k < def->ndisks; ++k) {\n                disk = def->disks[k];\n\n                if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI &&\n                    disk->info.addr.drive.controller == controller->idx) {\n                    if (ctx->autodetectSCSIControllerModel\n                               (disk, &autodetectedModels[count],\n                                ctx->opaque) < 0) {\n                        goto cleanup;\n                    }\n\n                    ++count;\n                }\n            }\n\n            /* autodetection fails when the disks attached to one controller\n             * have inconsistent SCSI controller models */\n            for (k = 0; k < count; ++k) {\n                if (autodetectedModels[k] != autodetectedModels[0]) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Disks on SCSI controller %d have inconsistent \"\n                                     \"controller models, cannot autodetect model\"),\n                                   controller->idx);\n                    goto cleanup;\n                }\n            }\n\n            controller->model = autodetectedModels[0];\n        }\n\n        if (controller->model != -1 &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068 &&\n            controller->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML attribute 'model' of entry \"\n                             \"'controller' to be 'buslogic' or 'lsilogic' or \"\n                             \"'lsisas1068' or 'vmpvscsi' but found '%s'\"),\n                           virDomainControllerModelSCSITypeToString(controller->model));\n            goto cleanup;\n        }\n\n        present[controller->idx] = true;\n        virtualDev[controller->idx] = controller->model;\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(autodetectedModels);\n\n    return result;\n}"
  },
  {
    "function_name": "virVMXHandleLegacySCSIDiskDriverName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "1079-1134",
    "snippet": "static int\nvirVMXHandleLegacySCSIDiskDriverName(virDomainDefPtr def,\n                                     virDomainDiskDefPtr disk)\n{\n    char *tmp;\n    int model;\n    size_t i;\n    virDomainControllerDefPtr controller = NULL;\n    const char *driver = virDomainDiskGetDriver(disk);\n    char *copy;\n\n    if (disk->bus != VIR_DOMAIN_DISK_BUS_SCSI || !driver)\n        return 0;\n\n    copy = g_strdup(driver);\n    tmp = copy;\n\n    for (; *tmp != '\\0'; ++tmp)\n        *tmp = g_ascii_tolower(*tmp);\n\n    model = virDomainControllerModelSCSITypeFromString(copy);\n    VIR_FREE(copy);\n\n    if (model < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown driver name '%s'\"), driver);\n        return -1;\n    }\n\n    for (i = 0; i < def->ncontrollers; ++i) {\n        if (def->controllers[i]->idx == disk->info.addr.drive.controller) {\n            controller = def->controllers[i];\n            break;\n        }\n    }\n\n    if (controller == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing SCSI controller for index %d\"),\n                       disk->info.addr.drive.controller);\n        return -1;\n    }\n\n    if (controller->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT) {\n        controller->model = model;\n    } else if (controller->model != model) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Inconsistent SCSI controller model ('%s' is not '%s') \"\n                         \"for SCSI controller index %d\"), driver,\n                       virDomainControllerModelSCSITypeToString(controller->model),\n                       controller->idx);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Inconsistent SCSI controller model ('%s' is not '%s') \"\n                         \"for SCSI controller index %d\")",
            "driver",
            "virDomainControllerModelSCSITypeToString(controller->model)",
            "controller->idx"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainControllerModelSCSITypeToString",
          "args": [
            "controller->model"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Inconsistent SCSI controller model ('%s' is not '%s') \"\n                         \"for SCSI controller index %d\""
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing SCSI controller for index %d\")",
            "disk->info.addr.drive.controller"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown driver name '%s'\")",
            "driver"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "copy"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainControllerModelSCSITypeFromString",
          "args": [
            "copy"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_tolower",
          "args": [
            "*tmp"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetDriver",
          "args": [
            "disk"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2185-2189",
          "snippet": "const char *\nvirDomainDiskGetDriver(const virDomainDiskDef *def)\n{\n    return def->driverName;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetDriver(const virDomainDiskDef *def)\n{\n    return def->driverName;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXHandleLegacySCSIDiskDriverName(virDomainDefPtr def,\n                                     virDomainDiskDefPtr disk)\n{\n    char *tmp;\n    int model;\n    size_t i;\n    virDomainControllerDefPtr controller = NULL;\n    const char *driver = virDomainDiskGetDriver(disk);\n    char *copy;\n\n    if (disk->bus != VIR_DOMAIN_DISK_BUS_SCSI || !driver)\n        return 0;\n\n    copy = g_strdup(driver);\n    tmp = copy;\n\n    for (; *tmp != '\\0'; ++tmp)\n        *tmp = g_ascii_tolower(*tmp);\n\n    model = virDomainControllerModelSCSITypeFromString(copy);\n    VIR_FREE(copy);\n\n    if (model < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown driver name '%s'\"), driver);\n        return -1;\n    }\n\n    for (i = 0; i < def->ncontrollers; ++i) {\n        if (def->controllers[i]->idx == disk->info.addr.drive.controller) {\n            controller = def->controllers[i];\n            break;\n        }\n    }\n\n    if (controller == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing SCSI controller for index %d\"),\n                       disk->info.addr.drive.controller);\n        return -1;\n    }\n\n    if (controller->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT) {\n        controller->model = model;\n    } else if (controller->model != model) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Inconsistent SCSI controller model ('%s' is not '%s') \"\n                         \"for SCSI controller index %d\"), driver,\n                       virDomainControllerModelSCSITypeToString(controller->model),\n                       controller->idx);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXVerifyDiskAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "966-1075",
    "snippet": "static int\nvirVMXVerifyDiskAddress(virDomainXMLOptionPtr xmlopt,\n                        virDomainDiskDefPtr disk,\n                        virDomainDefPtr vmdef)\n{\n    virDomainDiskDef def;\n    virDomainDeviceDriveAddressPtr drive;\n\n    memset(&def, 0, sizeof(def));\n\n    if (disk->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported disk address type '%s'\"),\n                       virDomainDeviceAddressTypeToString(disk->info.type));\n        return -1;\n    }\n\n    drive = &disk->info.addr.drive;\n\n    def.dst = disk->dst;\n    def.bus = disk->bus;\n\n    if (virDomainDiskDefAssignAddress(xmlopt, &def, vmdef) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not verify disk address\"));\n        return -1;\n    }\n\n    if (def.info.addr.drive.controller != drive->controller ||\n        def.info.addr.drive.bus != drive->bus ||\n        def.info.addr.drive.unit != drive->unit) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Disk address %d:%d:%d doesn't match target device '%s'\"),\n                       drive->controller, drive->bus, drive->unit, disk->dst);\n        return -1;\n    }\n\n    /* drive->{controller|bus|unit} is unsigned, no >= 0 checks are necessary */\n    if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (drive->controller > 3) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"SCSI controller index %d out of [0..3] range\"),\n                           drive->controller);\n            return -1;\n        }\n\n        if (drive->bus != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"SCSI bus index %d out of [0] range\"),\n                           drive->bus);\n            return -1;\n        }\n\n        if (drive->unit > 15 || drive->unit == 7) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"SCSI unit index %d out of [0..6,8..15] range\"),\n                           drive->unit);\n            return -1;\n        }\n    } else if (disk->bus == VIR_DOMAIN_DISK_BUS_IDE) {\n        if (drive->controller != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"IDE controller index %d out of [0] range\"),\n                           drive->controller);\n            return -1;\n        }\n\n        if (drive->bus > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"IDE bus index %d out of [0..1] range\"),\n                           drive->bus);\n            return -1;\n        }\n\n        if (drive->unit > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"IDE unit index %d out of [0..1] range\"),\n                           drive->unit);\n            return -1;\n        }\n    } else if (disk->bus == VIR_DOMAIN_DISK_BUS_FDC) {\n        if (drive->controller != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"FDC controller index %d out of [0] range\"),\n                           drive->controller);\n            return -1;\n        }\n\n        if (drive->bus != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"FDC bus index %d out of [0] range\"),\n                           drive->bus);\n            return -1;\n        }\n\n        if (drive->unit > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"FDC unit index %d out of [0..1] range\"),\n                           drive->unit);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported bus type '%s'\"),\n                       virDomainDiskBusTypeToString(disk->bus));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported bus type '%s'\")",
            "virDomainDiskBusTypeToString(disk->bus)"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskBusTypeToString",
          "args": [
            "disk->bus"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported bus type '%s'\""
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"FDC unit index %d out of [0..1] range\")",
            "drive->unit"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"FDC bus index %d out of [0] range\")",
            "drive->bus"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"FDC controller index %d out of [0] range\")",
            "drive->controller"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"IDE unit index %d out of [0..1] range\")",
            "drive->unit"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"IDE bus index %d out of [0..1] range\")",
            "drive->bus"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"IDE controller index %d out of [0] range\")",
            "drive->controller"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"SCSI unit index %d out of [0..6,8..15] range\")",
            "drive->unit"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"SCSI bus index %d out of [0] range\")",
            "drive->bus"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"SCSI controller index %d out of [0..3] range\")",
            "drive->controller"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Disk address %d:%d:%d doesn't match target device '%s'\")",
            "drive->controller",
            "drive->bus",
            "drive->unit",
            "disk->dst"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not verify disk address\")"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDefAssignAddress",
          "args": [
            "xmlopt",
            "&def",
            "vmdef"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskDefAssignAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "8831-8922",
          "snippet": "int\nvirDomainDiskDefAssignAddress(virDomainXMLOptionPtr xmlopt,\n                              virDomainDiskDefPtr def,\n                              const virDomainDef *vmdef)\n{\n    int idx = virDiskNameToIndex(def->dst);\n    if (idx < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unknown disk name '%s' and no address specified\"),\n                       def->dst);\n        return -1;\n    }\n\n    switch (def->bus) {\n    case VIR_DOMAIN_DISK_BUS_SCSI: {\n        virDomainDeviceDriveAddress addr = {0, 0, 0, 0};\n        unsigned int controller;\n        unsigned int unit;\n\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n\n        if (xmlopt->config.features & VIR_DOMAIN_DEF_FEATURE_WIDE_SCSI) {\n            /* For a wide SCSI bus we define the default mapping to be\n             * 16 units per bus, 1 bus per controller, many controllers.\n             * Unit 7 is the SCSI controller itself. Therefore unit 7\n             * cannot be assigned to disks and is skipped.\n             */\n            controller = idx / 15;\n            unit = idx % 15;\n\n            /* Skip the SCSI controller at unit 7 */\n            if (unit >= 7)\n                ++unit;\n        } else {\n            /* For a narrow SCSI bus we define the default mapping to be\n             * 7 units per bus, 1 bus per controller, many controllers */\n            controller = idx / 7;\n            unit = idx % 7;\n        }\n\n        addr.controller = controller;\n        addr.unit = unit;\n\n        if (virDomainDriveAddressIsUsedByHostdev(vmdef,\n                                                 VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI,\n                                                 &addr)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"using disk target name '%s' conflicts with \"\n                             \"SCSI host device address controller='%u' \"\n                             \"bus='%u' target='%u' unit='%u\"),\n                           def->dst, controller, 0, 0, unit);\n            return -1;\n        }\n\n        memcpy(&def->info.addr.drive, &addr, sizeof(addr));\n        break;\n    }\n\n    case VIR_DOMAIN_DISK_BUS_IDE:\n        /* For IDE we define the default mapping to be 2 units\n         * per bus, 2 bus per controller, many controllers */\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        def->info.addr.drive.controller = idx / 4;\n        def->info.addr.drive.bus = (idx % 4) / 2;\n        def->info.addr.drive.unit = (idx % 2);\n        break;\n\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        /* For SATA we define the default mapping to be 6 units\n         * per bus, 1 bus per controller, many controllers */\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        def->info.addr.drive.controller = idx / 6;\n        def->info.addr.drive.bus = 0;\n        def->info.addr.drive.unit = idx % 6;\n        break;\n\n    case VIR_DOMAIN_DISK_BUS_FDC:\n        /* For FDC we define the default mapping to be 2 units\n         * per bus, 1 bus per controller, many controllers */\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        def->info.addr.drive.controller = idx / 2;\n        def->info.addr.drive.bus = 0;\n        def->info.addr.drive.unit = idx % 2;\n        break;\n\n    default:\n        /* Other disk bus's aren't controller based */\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskDefAssignAddress(virDomainXMLOptionPtr xmlopt,\n                              virDomainDiskDefPtr def,\n                              const virDomainDef *vmdef)\n{\n    int idx = virDiskNameToIndex(def->dst);\n    if (idx < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unknown disk name '%s' and no address specified\"),\n                       def->dst);\n        return -1;\n    }\n\n    switch (def->bus) {\n    case VIR_DOMAIN_DISK_BUS_SCSI: {\n        virDomainDeviceDriveAddress addr = {0, 0, 0, 0};\n        unsigned int controller;\n        unsigned int unit;\n\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n\n        if (xmlopt->config.features & VIR_DOMAIN_DEF_FEATURE_WIDE_SCSI) {\n            /* For a wide SCSI bus we define the default mapping to be\n             * 16 units per bus, 1 bus per controller, many controllers.\n             * Unit 7 is the SCSI controller itself. Therefore unit 7\n             * cannot be assigned to disks and is skipped.\n             */\n            controller = idx / 15;\n            unit = idx % 15;\n\n            /* Skip the SCSI controller at unit 7 */\n            if (unit >= 7)\n                ++unit;\n        } else {\n            /* For a narrow SCSI bus we define the default mapping to be\n             * 7 units per bus, 1 bus per controller, many controllers */\n            controller = idx / 7;\n            unit = idx % 7;\n        }\n\n        addr.controller = controller;\n        addr.unit = unit;\n\n        if (virDomainDriveAddressIsUsedByHostdev(vmdef,\n                                                 VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI,\n                                                 &addr)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"using disk target name '%s' conflicts with \"\n                             \"SCSI host device address controller='%u' \"\n                             \"bus='%u' target='%u' unit='%u\"),\n                           def->dst, controller, 0, 0, unit);\n            return -1;\n        }\n\n        memcpy(&def->info.addr.drive, &addr, sizeof(addr));\n        break;\n    }\n\n    case VIR_DOMAIN_DISK_BUS_IDE:\n        /* For IDE we define the default mapping to be 2 units\n         * per bus, 2 bus per controller, many controllers */\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        def->info.addr.drive.controller = idx / 4;\n        def->info.addr.drive.bus = (idx % 4) / 2;\n        def->info.addr.drive.unit = (idx % 2);\n        break;\n\n    case VIR_DOMAIN_DISK_BUS_SATA:\n        /* For SATA we define the default mapping to be 6 units\n         * per bus, 1 bus per controller, many controllers */\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        def->info.addr.drive.controller = idx / 6;\n        def->info.addr.drive.bus = 0;\n        def->info.addr.drive.unit = idx % 6;\n        break;\n\n    case VIR_DOMAIN_DISK_BUS_FDC:\n        /* For FDC we define the default mapping to be 2 units\n         * per bus, 1 bus per controller, many controllers */\n        def->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        def->info.addr.drive.controller = idx / 2;\n        def->info.addr.drive.bus = 0;\n        def->info.addr.drive.unit = idx % 2;\n        break;\n\n    default:\n        /* Other disk bus's aren't controller based */\n        break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported disk address type '%s'\")",
            "virDomainDeviceAddressTypeToString(disk->info.type)"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDeviceAddressTypeToString",
          "args": [
            "disk->info.type"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&def",
            "0",
            "sizeof(def)"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXVerifyDiskAddress(virDomainXMLOptionPtr xmlopt,\n                        virDomainDiskDefPtr disk,\n                        virDomainDefPtr vmdef)\n{\n    virDomainDiskDef def;\n    virDomainDeviceDriveAddressPtr drive;\n\n    memset(&def, 0, sizeof(def));\n\n    if (disk->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported disk address type '%s'\"),\n                       virDomainDeviceAddressTypeToString(disk->info.type));\n        return -1;\n    }\n\n    drive = &disk->info.addr.drive;\n\n    def.dst = disk->dst;\n    def.bus = disk->bus;\n\n    if (virDomainDiskDefAssignAddress(xmlopt, &def, vmdef) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not verify disk address\"));\n        return -1;\n    }\n\n    if (def.info.addr.drive.controller != drive->controller ||\n        def.info.addr.drive.bus != drive->bus ||\n        def.info.addr.drive.unit != drive->unit) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Disk address %d:%d:%d doesn't match target device '%s'\"),\n                       drive->controller, drive->bus, drive->unit, disk->dst);\n        return -1;\n    }\n\n    /* drive->{controller|bus|unit} is unsigned, no >= 0 checks are necessary */\n    if (disk->bus == VIR_DOMAIN_DISK_BUS_SCSI) {\n        if (drive->controller > 3) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"SCSI controller index %d out of [0..3] range\"),\n                           drive->controller);\n            return -1;\n        }\n\n        if (drive->bus != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"SCSI bus index %d out of [0] range\"),\n                           drive->bus);\n            return -1;\n        }\n\n        if (drive->unit > 15 || drive->unit == 7) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"SCSI unit index %d out of [0..6,8..15] range\"),\n                           drive->unit);\n            return -1;\n        }\n    } else if (disk->bus == VIR_DOMAIN_DISK_BUS_IDE) {\n        if (drive->controller != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"IDE controller index %d out of [0] range\"),\n                           drive->controller);\n            return -1;\n        }\n\n        if (drive->bus > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"IDE bus index %d out of [0..1] range\"),\n                           drive->bus);\n            return -1;\n        }\n\n        if (drive->unit > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"IDE unit index %d out of [0..1] range\"),\n                           drive->unit);\n            return -1;\n        }\n    } else if (disk->bus == VIR_DOMAIN_DISK_BUS_FDC) {\n        if (drive->controller != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"FDC controller index %d out of [0] range\"),\n                           drive->controller);\n            return -1;\n        }\n\n        if (drive->bus != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"FDC bus index %d out of [0] range\"),\n                           drive->bus);\n            return -1;\n        }\n\n        if (drive->unit > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"FDC unit index %d out of [0..1] range\"),\n                           drive->unit);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported bus type '%s'\"),\n                       virDomainDiskBusTypeToString(disk->bus));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXFloppyDiskNameToUnit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "932-962",
    "snippet": "static int\nvirVMXFloppyDiskNameToUnit(const char *name, int *unit)\n{\n    int idx;\n\n    if (! STRPREFIX(name, \"fd\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'fd'\"));\n        return -1;\n    }\n\n    idx = virDiskNameToIndex(name);\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse valid disk index from '%s'\"), name);\n        return -1;\n    }\n\n    /* The FDC controller has 1 bus with 2 units for devices */\n    if (idx >= 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Floppy disk index (parsed from '%s') is too large\"), name);\n        return -1;\n    }\n\n    *unit = idx;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Floppy disk index (parsed from '%s') is too large\")",
            "name"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Floppy disk index (parsed from '%s') is too large\""
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse valid disk index from '%s'\")",
            "name"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDiskNameToIndex",
          "args": [
            "name"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "virDiskNameToIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "426-434",
          "snippet": "int virDiskNameToIndex(const char *name)\n{\n    int idx;\n\n    if (virDiskNameParse(name, &idx, NULL) < 0)\n        idx = -1;\n\n    return idx;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virDiskNameToIndex(const char *name)\n{\n    int idx;\n\n    if (virDiskNameParse(name, &idx, NULL) < 0)\n        idx = -1;\n\n    return idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'fd'\")"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "name",
            "\"fd\""
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXFloppyDiskNameToUnit(const char *name, int *unit)\n{\n    int idx;\n\n    if (! STRPREFIX(name, \"fd\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'fd'\"));\n        return -1;\n    }\n\n    idx = virDiskNameToIndex(name);\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse valid disk index from '%s'\"), name);\n        return -1;\n    }\n\n    /* The FDC controller has 1 bus with 2 units for devices */\n    if (idx >= 2) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Floppy disk index (parsed from '%s') is too large\"), name);\n        return -1;\n    }\n\n    *unit = idx;\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXIDEDiskNameToBusAndUnit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "897-928",
    "snippet": "static int\nvirVMXIDEDiskNameToBusAndUnit(const char *name, int *bus, int *unit)\n{\n    int idx;\n\n    if (! STRPREFIX(name, \"hd\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'hd'\"));\n        return -1;\n    }\n\n    idx = virDiskNameToIndex(name);\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse valid disk index from '%s'\"), name);\n        return -1;\n    }\n\n    /* The IDE controller has 2 buses with 2 units each for devices */\n    if (idx >= (2 * 2)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"IDE disk index (parsed from '%s') is too large\"), name);\n        return -1;\n    }\n\n    *bus = idx / 2;\n    *unit = idx % 2;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"IDE disk index (parsed from '%s') is too large\")",
            "name"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"IDE disk index (parsed from '%s') is too large\""
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse valid disk index from '%s'\")",
            "name"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDiskNameToIndex",
          "args": [
            "name"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "virDiskNameToIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "426-434",
          "snippet": "int virDiskNameToIndex(const char *name)\n{\n    int idx;\n\n    if (virDiskNameParse(name, &idx, NULL) < 0)\n        idx = -1;\n\n    return idx;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virDiskNameToIndex(const char *name)\n{\n    int idx;\n\n    if (virDiskNameParse(name, &idx, NULL) < 0)\n        idx = -1;\n\n    return idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'hd'\")"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "name",
            "\"hd\""
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXIDEDiskNameToBusAndUnit(const char *name, int *bus, int *unit)\n{\n    int idx;\n\n    if (! STRPREFIX(name, \"hd\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'hd'\"));\n        return -1;\n    }\n\n    idx = virDiskNameToIndex(name);\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse valid disk index from '%s'\"), name);\n        return -1;\n    }\n\n    /* The IDE controller has 2 buses with 2 units each for devices */\n    if (idx >= (2 * 2)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"IDE disk index (parsed from '%s') is too large\"), name);\n        return -1;\n    }\n\n    *bus = idx / 2;\n    *unit = idx % 2;\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXSCSIDiskNameToControllerAndUnit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "858-893",
    "snippet": "static int\nvirVMXSCSIDiskNameToControllerAndUnit(const char *name, int *controller, int *unit)\n{\n    int idx;\n\n    if (! STRPREFIX(name, \"sd\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'sd'\"));\n        return -1;\n    }\n\n    idx = virDiskNameToIndex(name);\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse valid disk index from '%s'\"), name);\n        return -1;\n    }\n\n    /* Each of the 4 SCSI controllers has 1 bus with 15 units each for devices */\n    if (idx >= (4 * 15)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SCSI disk index (parsed from '%s') is too large\"), name);\n        return -1;\n    }\n\n    *controller = idx / 15;\n    *unit = idx % 15;\n\n    /* Skip the controller ifself at unit 7 */\n    if (*unit >= 7)\n        ++(*unit);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"SCSI disk index (parsed from '%s') is too large\")",
            "name"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"SCSI disk index (parsed from '%s') is too large\""
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse valid disk index from '%s'\")",
            "name"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDiskNameToIndex",
          "args": [
            "name"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "virDiskNameToIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "426-434",
          "snippet": "int virDiskNameToIndex(const char *name)\n{\n    int idx;\n\n    if (virDiskNameParse(name, &idx, NULL) < 0)\n        idx = -1;\n\n    return idx;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virDiskNameToIndex(const char *name)\n{\n    int idx;\n\n    if (virDiskNameParse(name, &idx, NULL) < 0)\n        idx = -1;\n\n    return idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'sd'\")"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "name",
            "\"sd\""
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXSCSIDiskNameToControllerAndUnit(const char *name, int *controller, int *unit)\n{\n    int idx;\n\n    if (! STRPREFIX(name, \"sd\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML attribute 'dev' of entry \"\n                         \"'devices/disk/target' to start with 'sd'\"));\n        return -1;\n    }\n\n    idx = virDiskNameToIndex(name);\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse valid disk index from '%s'\"), name);\n        return -1;\n    }\n\n    /* Each of the 4 SCSI controllers has 1 bus with 15 units each for devices */\n    if (idx >= (4 * 15)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"SCSI disk index (parsed from '%s') is too large\"), name);\n        return -1;\n    }\n\n    *controller = idx / 15;\n    *unit = idx % 15;\n\n    /* Skip the controller ifself at unit 7 */\n    if (*unit >= 7)\n        ++(*unit);\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXGetConfigBoolean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "824-854",
    "snippet": "static int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "string"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\")",
            "name"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\""
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "string",
            "\"false\""
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "string",
            "\"true\""
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigStringHelper",
          "args": [
            "conf",
            "name",
            "&string",
            "optional"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigStringHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "729-746",
          "snippet": "static int\nvirVMXGetConfigStringHelper(virConfPtr conf, const char *name, char **string,\n                            bool optional)\n{\n    int rc;\n    *string = NULL;\n\n    rc = virConfGetValueString(conf, name, string);\n    if (rc == 1 && *string != NULL)\n        return 1;\n\n    if (optional)\n        return 0;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing essential config entry '%s'\"), name);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigStringHelper(virConfPtr conf, const char *name, char **string,\n                            bool optional)\n{\n    int rc;\n    *string = NULL;\n\n    rc = virConfGetValueString(conf, name, string);\n    if (rc == 1 && *string != NULL)\n        return 1;\n\n    if (optional)\n        return 0;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing essential config entry '%s'\"), name);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigBoolean(virConfPtr conf, const char *name, bool *boolean_,\n                       bool default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *boolean_ = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"true\")) {\n        *boolean_ = 1;\n    } else if (STRCASEEQ(string, \"false\")) {\n        *boolean_ = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Config entry '%s' must represent a boolean value \"\n                         \"(true|false)\"), name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
  },
  {
    "function_name": "virVMXGetConfigLong",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "792-820",
    "snippet": "static int\nvirVMXGetConfigLong(virConfPtr conf, const char *name, long long *number,\n                    long long default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *number = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"unlimited\")) {\n        *number = -1;\n    } else if (virStrToLong_ll(string, NULL, 10, number) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Config entry '%s' must represent an integer value\"),\n                name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "string"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Config entry '%s' must represent an integer value\")",
            "name"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Config entry '%s' must represent an integer value\""
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ll",
          "args": [
            "string",
            "NULL",
            "10",
            "number"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "526-542",
          "snippet": "int\nvirStrToLong_ll(char const *s, char **end_ptr, int base, long long *result)\n{\n    long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoll(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ll(char const *s, char **end_ptr, int base, long long *result)\n{\n    long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoll(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "string",
            "\"unlimited\""
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigStringHelper",
          "args": [
            "conf",
            "name",
            "&string",
            "optional"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigStringHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "729-746",
          "snippet": "static int\nvirVMXGetConfigStringHelper(virConfPtr conf, const char *name, char **string,\n                            bool optional)\n{\n    int rc;\n    *string = NULL;\n\n    rc = virConfGetValueString(conf, name, string);\n    if (rc == 1 && *string != NULL)\n        return 1;\n\n    if (optional)\n        return 0;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing essential config entry '%s'\"), name);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigStringHelper(virConfPtr conf, const char *name, char **string,\n                            bool optional)\n{\n    int rc;\n    *string = NULL;\n\n    rc = virConfGetValueString(conf, name, string);\n    if (rc == 1 && *string != NULL)\n        return 1;\n\n    if (optional)\n        return 0;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing essential config entry '%s'\"), name);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigLong(virConfPtr conf, const char *name, long long *number,\n                    long long default_, bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    *number = default_;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    if (STRCASEEQ(string, \"unlimited\")) {\n        *number = -1;\n    } else if (virStrToLong_ll(string, NULL, 10, number) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                _(\"Config entry '%s' must represent an integer value\"),\n                name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
  },
  {
    "function_name": "virVMXGetConfigUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "764-788",
    "snippet": "static int\nvirVMXGetConfigUUID(virConfPtr conf, const char *name, unsigned char *uuid,\n                    bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    rc = virUUIDParse(string, uuid);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"), string);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "string"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse UUID from string '%s'\")",
            "string"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not parse UUID from string '%s'\""
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "string",
            "uuid"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXGetConfigStringHelper",
          "args": [
            "conf",
            "name",
            "&string",
            "optional"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigStringHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "729-746",
          "snippet": "static int\nvirVMXGetConfigStringHelper(virConfPtr conf, const char *name, char **string,\n                            bool optional)\n{\n    int rc;\n    *string = NULL;\n\n    rc = virConfGetValueString(conf, name, string);\n    if (rc == 1 && *string != NULL)\n        return 1;\n\n    if (optional)\n        return 0;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing essential config entry '%s'\"), name);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigStringHelper(virConfPtr conf, const char *name, char **string,\n                            bool optional)\n{\n    int rc;\n    *string = NULL;\n\n    rc = virConfGetValueString(conf, name, string);\n    if (rc == 1 && *string != NULL)\n        return 1;\n\n    if (optional)\n        return 0;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing essential config entry '%s'\"), name);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigUUID(virConfPtr conf, const char *name, unsigned char *uuid,\n                    bool optional)\n{\n    char *string = NULL;\n    int ret = -1;\n    int rc;\n\n    rc = virVMXGetConfigStringHelper(conf, name, &string, optional);\n    if (rc <= 0)\n        return rc;\n\n    rc = virUUIDParse(string, uuid);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"), string);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(string);\n    return ret;\n}"
  },
  {
    "function_name": "virVMXGetConfigString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "750-760",
    "snippet": "static int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virVMXGetConfigStringHelper",
          "args": [
            "conf",
            "name",
            "string",
            "optional"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXGetConfigStringHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "729-746",
          "snippet": "static int\nvirVMXGetConfigStringHelper(virConfPtr conf, const char *name, char **string,\n                            bool optional)\n{\n    int rc;\n    *string = NULL;\n\n    rc = virConfGetValueString(conf, name, string);\n    if (rc == 1 && *string != NULL)\n        return 1;\n\n    if (optional)\n        return 0;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing essential config entry '%s'\"), name);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigStringHelper(virConfPtr conf, const char *name, char **string,\n                            bool optional)\n{\n    int rc;\n    *string = NULL;\n\n    rc = virConfGetValueString(conf, name, string);\n    if (rc == 1 && *string != NULL)\n        return 1;\n\n    if (optional)\n        return 0;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing essential config entry '%s'\"), name);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigString(virConfPtr conf, const char *name, char **string,\n                      bool optional)\n{\n    *string = NULL;\n\n    if (virVMXGetConfigStringHelper(conf, name, string, optional) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXGetConfigStringHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "729-746",
    "snippet": "static int\nvirVMXGetConfigStringHelper(virConfPtr conf, const char *name, char **string,\n                            bool optional)\n{\n    int rc;\n    *string = NULL;\n\n    rc = virConfGetValueString(conf, name, string);\n    if (rc == 1 && *string != NULL)\n        return 1;\n\n    if (optional)\n        return 0;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing essential config entry '%s'\"), name);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing essential config entry '%s'\")",
            "name"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing essential config entry '%s'\""
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueString",
          "args": [
            "conf",
            "name",
            "string"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "875-898",
          "snippet": "int virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXGetConfigStringHelper(virConfPtr conf, const char *name, char **string,\n                            bool optional)\n{\n    int rc;\n    *string = NULL;\n\n    rc = virConfGetValueString(conf, name, string);\n    if (rc == 1 && *string != NULL)\n        return 1;\n\n    if (optional)\n        return 0;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing essential config entry '%s'\"), name);\n    return -1;\n}"
  },
  {
    "function_name": "virVMXConvertToUTF8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "691-725",
    "snippet": "char *\nvirVMXConvertToUTF8(const char *encoding, const char *string)\n{\n    char *result = NULL;\n    xmlCharEncodingHandlerPtr handler;\n    xmlBufferPtr input;\n    xmlBufferPtr utf8;\n\n    handler = xmlFindCharEncodingHandler(encoding);\n\n    if (handler == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"libxml2 doesn't handle %s encoding\"), encoding);\n        return NULL;\n    }\n\n    input = xmlBufferCreateStatic((char *)string, strlen(string));\n    utf8 = xmlBufferCreate();\n\n    if (xmlCharEncInFunc(handler, utf8, input) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not convert from %s to UTF-8 encoding\"), encoding);\n        goto cleanup;\n    }\n\n    result = (char *)utf8->content;\n    utf8->content = NULL;\n\n cleanup:\n    xmlCharEncCloseFunc(handler);\n    xmlBufferFree(input);\n    xmlBufferFree(utf8);\n\n    return result;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlBufferFree",
          "args": [
            "utf8"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBufferFree",
          "args": [
            "input"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlCharEncCloseFunc",
          "args": [
            "handler"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not convert from %s to UTF-8 encoding\")",
            "encoding"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not convert from %s to UTF-8 encoding\""
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlCharEncInFunc",
          "args": [
            "handler",
            "utf8",
            "input"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBufferCreate",
          "args": [],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlBufferCreateStatic",
          "args": [
            "(char *)string",
            "strlen(string)"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "string"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"libxml2 doesn't handle %s encoding\")",
            "encoding"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFindCharEncodingHandler",
          "args": [
            "encoding"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirVMXConvertToUTF8(const char *encoding, const char *string)\n{\n    char *result = NULL;\n    xmlCharEncodingHandlerPtr handler;\n    xmlBufferPtr input;\n    xmlBufferPtr utf8;\n\n    handler = xmlFindCharEncodingHandler(encoding);\n\n    if (handler == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"libxml2 doesn't handle %s encoding\"), encoding);\n        return NULL;\n    }\n\n    input = xmlBufferCreateStatic((char *)string, strlen(string));\n    utf8 = xmlBufferCreate();\n\n    if (xmlCharEncInFunc(handler, utf8, input) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not convert from %s to UTF-8 encoding\"), encoding);\n        goto cleanup;\n    }\n\n    result = (char *)utf8->content;\n    utf8->content = NULL;\n\n cleanup:\n    xmlCharEncCloseFunc(handler);\n    xmlBufferFree(input);\n    xmlBufferFree(utf8);\n\n    return result;\n}"
  },
  {
    "function_name": "virVMXUnescapeHex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "664-687",
    "snippet": "int\nvirVMXUnescapeHex(char *string, char escape)\n{\n    char *tmp1 = string; /* reading from this one */\n    char *tmp2 = string; /* writing to this one */\n\n    /* Unescape from 'cXX' where c is the escape char and X is a hex digit */\n    while (*tmp1 != '\\0') {\n        if (*tmp1 == escape) {\n            if (!g_ascii_isxdigit(tmp1[1]) || !g_ascii_isxdigit(tmp1[2]))\n                return -1;\n\n            *tmp2++ = g_ascii_xdigit_value(tmp1[1]) * 16 +\n                g_ascii_xdigit_value(tmp1[2]);\n            tmp1 += 3;\n        } else {\n            *tmp2++ = *tmp1++;\n        }\n    }\n\n    *tmp2 = '\\0';\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_ascii_xdigit_value",
          "args": [
            "tmp1[2]"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_xdigit_value",
          "args": [
            "tmp1[1]"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_isxdigit",
          "args": [
            "tmp1[2]"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_isxdigit",
          "args": [
            "tmp1[1]"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirVMXUnescapeHex(char *string, char escape)\n{\n    char *tmp1 = string; /* reading from this one */\n    char *tmp2 = string; /* writing to this one */\n\n    /* Unescape from 'cXX' where c is the escape char and X is a hex digit */\n    while (*tmp1 != '\\0') {\n        if (*tmp1 == escape) {\n            if (!g_ascii_isxdigit(tmp1[1]) || !g_ascii_isxdigit(tmp1[2]))\n                return -1;\n\n            *tmp2++ = g_ascii_xdigit_value(tmp1[1]) * 16 +\n                g_ascii_xdigit_value(tmp1[2]);\n            tmp1 += 3;\n        } else {\n            *tmp2++ = *tmp1++;\n        }\n    }\n\n    *tmp2 = '\\0';\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXEscapeHex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "619-660",
    "snippet": "char *\nvirVMXEscapeHex(const char *string, char escape, const char *special)\n{\n    char *escaped = NULL;\n    size_t length = 1; /* 1 byte for termination */\n    const char *tmp1 = string;\n    char *tmp2;\n\n    /* Calculate length of escaped string */\n    while (*tmp1 != '\\0') {\n        if (*tmp1 == escape || strspn(tmp1, special) > 0)\n            length += 2;\n\n        ++tmp1;\n        ++length;\n    }\n\n    if (VIR_ALLOC_N(escaped, length) < 0)\n        return NULL;\n\n    tmp1 = string; /* reading from this one */\n    tmp2 = escaped; /* writing to this one */\n\n    /* Escape to 'cXX' where c is the escape char and X is a hex digit */\n    while (*tmp1 != '\\0') {\n        if (*tmp1 == escape || strspn(tmp1, special) > 0) {\n            *tmp2++ = escape;\n\n            g_snprintf(tmp2, 3, \"%02x\", (unsigned int)*tmp1);\n\n            tmp2 += 2;\n        } else {\n            *tmp2++ = *tmp1;\n        }\n\n        ++tmp1;\n    }\n\n    *tmp2 = '\\0';\n\n    return escaped;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "tmp2",
            "3",
            "\"%02x\"",
            "(unsigned int)*tmp1"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "tmp1",
            "special"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "escaped",
            "length"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "tmp1",
            "special"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirVMXEscapeHex(const char *string, char escape, const char *special)\n{\n    char *escaped = NULL;\n    size_t length = 1; /* 1 byte for termination */\n    const char *tmp1 = string;\n    char *tmp2;\n\n    /* Calculate length of escaped string */\n    while (*tmp1 != '\\0') {\n        if (*tmp1 == escape || strspn(tmp1, special) > 0)\n            length += 2;\n\n        ++tmp1;\n        ++length;\n    }\n\n    if (VIR_ALLOC_N(escaped, length) < 0)\n        return NULL;\n\n    tmp1 = string; /* reading from this one */\n    tmp2 = escaped; /* writing to this one */\n\n    /* Escape to 'cXX' where c is the escape char and X is a hex digit */\n    while (*tmp1 != '\\0') {\n        if (*tmp1 == escape || strspn(tmp1, special) > 0) {\n            *tmp2++ = escape;\n\n            g_snprintf(tmp2, 3, \"%02x\", (unsigned int)*tmp1);\n\n            tmp2 += 2;\n        } else {\n            *tmp2++ = *tmp1;\n        }\n\n        ++tmp1;\n    }\n\n    *tmp2 = '\\0';\n\n    return escaped;\n}"
  },
  {
    "function_name": "virVMXDomainXMLConfInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "611-617",
    "snippet": "virDomainXMLOptionPtr\nvirVMXDomainXMLConfInit(virCapsPtr caps)\n{\n    virVMXDomainDefParserConfig.priv = caps;\n    return virDomainXMLOptionNew(&virVMXDomainDefParserConfig, NULL,\n                                 &virVMXDomainXMLNamespace, NULL, NULL);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virDomainDefParserConfig virVMXDomainDefParserConfig = {\n    .macPrefix = {0x00, 0x0c, 0x29},\n    .devicesPostParseCallback = virVMXDomainDevicesDefPostParse,\n    .domainPostParseCallback = virVMXDomainDefPostParse,\n    .features = (VIR_DOMAIN_DEF_FEATURE_WIDE_SCSI |\n                 VIR_DOMAIN_DEF_FEATURE_NAME_SLASH |\n                 VIR_DOMAIN_DEF_FEATURE_NO_BOOT_ORDER),\n    .defArch = VIR_ARCH_I686,\n};",
      "static virXMLNamespace virVMXDomainXMLNamespace = {\n    .parse = NULL,\n    .free = virVMXDomainDefNamespaceFree,\n    .format = virVMXDomainDefNamespaceFormatXML,\n    .prefix = \"vmware\",\n    .uri = \"http://libvirt.org/schemas/domain/vmware/1.0\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainXMLOptionNew",
          "args": [
            "&virVMXDomainDefParserConfig",
            "NULL",
            "&virVMXDomainXMLNamespace",
            "NULL",
            "NULL"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainXMLOptionNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1415-1458",
          "snippet": "virDomainXMLOptionPtr\nvirDomainXMLOptionNew(virDomainDefParserConfigPtr config,\n                      virDomainXMLPrivateDataCallbacksPtr priv,\n                      virXMLNamespacePtr xmlns,\n                      virDomainABIStabilityPtr abi,\n                      virSaveCookieCallbacksPtr saveCookie)\n{\n    virDomainXMLOptionPtr xmlopt;\n\n    if (virDomainObjInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virDomainXMLOptionClass)))\n        return NULL;\n\n    if (priv)\n        xmlopt->privateData = *priv;\n\n    if (config)\n        xmlopt->config = *config;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    if (abi)\n        xmlopt->abi = *abi;\n\n    if (saveCookie)\n        xmlopt->saveCookie = *saveCookie;\n\n    /* Technically this forbids to use one of Xerox's MAC address prefixes in\n     * our hypervisor drivers. This shouldn't ever be a problem.\n     *\n     * Use the KVM prefix as default as it's in the privately administered\n     * range */\n    if (xmlopt->config.macPrefix[0] == 0 &&\n        xmlopt->config.macPrefix[1] == 0 &&\n        xmlopt->config.macPrefix[2] == 0) {\n        xmlopt->config.macPrefix[0] = 0x52;\n        xmlopt->config.macPrefix[1] = 0x54;\n    }\n\n    return xmlopt;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virDomainXMLOptionClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virClassPtr virDomainXMLOptionClass;\n\nvirDomainXMLOptionPtr\nvirDomainXMLOptionNew(virDomainDefParserConfigPtr config,\n                      virDomainXMLPrivateDataCallbacksPtr priv,\n                      virXMLNamespacePtr xmlns,\n                      virDomainABIStabilityPtr abi,\n                      virSaveCookieCallbacksPtr saveCookie)\n{\n    virDomainXMLOptionPtr xmlopt;\n\n    if (virDomainObjInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virDomainXMLOptionClass)))\n        return NULL;\n\n    if (priv)\n        xmlopt->privateData = *priv;\n\n    if (config)\n        xmlopt->config = *config;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    if (abi)\n        xmlopt->abi = *abi;\n\n    if (saveCookie)\n        xmlopt->saveCookie = *saveCookie;\n\n    /* Technically this forbids to use one of Xerox's MAC address prefixes in\n     * our hypervisor drivers. This shouldn't ever be a problem.\n     *\n     * Use the KVM prefix as default as it's in the privately administered\n     * range */\n    if (xmlopt->config.macPrefix[0] == 0 &&\n        xmlopt->config.macPrefix[1] == 0 &&\n        xmlopt->config.macPrefix[2] == 0) {\n        xmlopt->config.macPrefix[0] = 0x52;\n        xmlopt->config.macPrefix[1] = 0x54;\n    }\n\n    return xmlopt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainDefParserConfig virVMXDomainDefParserConfig = {\n    .macPrefix = {0x00, 0x0c, 0x29},\n    .devicesPostParseCallback = virVMXDomainDevicesDefPostParse,\n    .domainPostParseCallback = virVMXDomainDefPostParse,\n    .features = (VIR_DOMAIN_DEF_FEATURE_WIDE_SCSI |\n                 VIR_DOMAIN_DEF_FEATURE_NAME_SLASH |\n                 VIR_DOMAIN_DEF_FEATURE_NO_BOOT_ORDER),\n    .defArch = VIR_ARCH_I686,\n};\nstatic virXMLNamespace virVMXDomainXMLNamespace = {\n    .parse = NULL,\n    .free = virVMXDomainDefNamespaceFree,\n    .format = virVMXDomainDefNamespaceFormatXML,\n    .prefix = \"vmware\",\n    .uri = \"http://libvirt.org/schemas/domain/vmware/1.0\",\n};\n\nvirDomainXMLOptionPtr\nvirVMXDomainXMLConfInit(virCapsPtr caps)\n{\n    virVMXDomainDefParserConfig.priv = caps;\n    return virDomainXMLOptionNew(&virVMXDomainDefParserConfig, NULL,\n                                 &virVMXDomainXMLNamespace, NULL, NULL);\n}"
  },
  {
    "function_name": "virVMXDomainDefNamespaceFormatXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "581-601",
    "snippet": "static int\nvirVMXDomainDefNamespaceFormatXML(virBufferPtr buf, void *nsdata)\n{\n    struct virVMXDomainDefNamespaceData *data = nsdata;\n\n    if (!data)\n        return 0;\n\n    if (data->datacenterPath) {\n        virBufferAddLit(buf, \"<vmware:datacenterpath>\");\n        virBufferEscapeString(buf, \"%s\", data->datacenterPath);\n        virBufferAddLit(buf, \"</vmware:datacenterpath>\\n\");\n    }\n    if (data->moref) {\n        virBufferAddLit(buf, \"<vmware:moref>\");\n        virBufferEscapeString(buf, \"%s\", data->moref);\n        virBufferAddLit(buf, \"</vmware:moref>\\n\");\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</vmware:moref>\\n\""
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"%s\"",
            "data->moref"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<vmware:moref>\""
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</vmware:datacenterpath>\\n\""
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<vmware:datacenterpath>\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXDomainDefNamespaceFormatXML(virBufferPtr buf, void *nsdata)\n{\n    struct virVMXDomainDefNamespaceData *data = nsdata;\n\n    if (!data)\n        return 0;\n\n    if (data->datacenterPath) {\n        virBufferAddLit(buf, \"<vmware:datacenterpath>\");\n        virBufferEscapeString(buf, \"%s\", data->datacenterPath);\n        virBufferAddLit(buf, \"</vmware:datacenterpath>\\n\");\n    }\n    if (data->moref) {\n        virBufferAddLit(buf, \"<vmware:moref>\");\n        virBufferEscapeString(buf, \"%s\", data->moref);\n        virBufferAddLit(buf, \"</vmware:moref>\\n\");\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virVMXDomainDefNamespaceFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "569-579",
    "snippet": "static void\nvirVMXDomainDefNamespaceFree(void *nsdata)\n{\n    struct virVMXDomainDefNamespaceData *data = nsdata;\n\n    if (data) {\n        VIR_FREE(data->datacenterPath);\n        VIR_FREE(data->moref);\n    }\n    VIR_FREE(data);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->moref"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->datacenterPath"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nvirVMXDomainDefNamespaceFree(void *nsdata)\n{\n    struct virVMXDomainDefNamespaceData *data = nsdata;\n\n    if (data) {\n        VIR_FREE(data->datacenterPath);\n        VIR_FREE(data->moref);\n    }\n    VIR_FREE(data);\n}"
  },
  {
    "function_name": "virVMXDomainDevicesDefPostParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "544-552",
    "snippet": "static int\nvirVMXDomainDevicesDefPostParse(virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                                const virDomainDef *def G_GNUC_UNUSED,\n                                unsigned int parseFlags G_GNUC_UNUSED,\n                                void *opaque G_GNUC_UNUSED,\n                                void *parseOpaque G_GNUC_UNUSED)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXDomainDevicesDefPostParse(virDomainDeviceDefPtr dev G_GNUC_UNUSED,\n                                const virDomainDef *def G_GNUC_UNUSED,\n                                unsigned int parseFlags G_GNUC_UNUSED,\n                                void *opaque G_GNUC_UNUSED,\n                                void *parseOpaque G_GNUC_UNUSED)\n{\n    return 0;\n}"
  },
  {
    "function_name": "virVMXDomainDefPostParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
    "lines": "529-542",
    "snippet": "static int\nvirVMXDomainDefPostParse(virDomainDefPtr def,\n                         unsigned int parseFlags G_GNUC_UNUSED,\n                         void *opaque,\n                         void *parseOpaque G_GNUC_UNUSED)\n{\n    virCapsPtr caps = opaque;\n    if (!virCapabilitiesDomainSupported(caps, def->os.type,\n                                        def->os.arch,\n                                        def->virtType))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"viruri.h\"",
      "#include \"vmx.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesDomainSupported",
          "args": [
            "caps",
            "def->os.type",
            "def->os.arch",
            "def->virtType"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesDomainSupported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "787-801",
          "snippet": "bool\nvirCapabilitiesDomainSupported(virCapsPtr caps,\n                               int ostype,\n                               virArch arch,\n                               int virttype)\n{\n    g_autofree virCapsDomainDataPtr capsdata = NULL;\n\n    capsdata = virCapabilitiesDomainDataLookup(caps, ostype,\n                                               arch,\n                                               virttype,\n                                               NULL, NULL);\n\n    return capsdata != NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirCapabilitiesDomainSupported(virCapsPtr caps,\n                               int ostype,\n                               virArch arch,\n                               int virttype)\n{\n    g_autofree virCapsDomainDataPtr capsdata = NULL;\n\n    capsdata = virCapabilitiesDomainDataLookup(caps, ostype,\n                                               arch,\n                                               virttype,\n                                               NULL, NULL);\n\n    return capsdata != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvirVMXDomainDefPostParse(virDomainDefPtr def,\n                         unsigned int parseFlags G_GNUC_UNUSED,\n                         void *opaque,\n                         void *parseOpaque G_GNUC_UNUSED)\n{\n    virCapsPtr caps = opaque;\n    if (!virCapabilitiesDomainSupported(caps, def->os.type,\n                                        def->os.arch,\n                                        def->virtType))\n        return -1;\n\n    return 0;\n}"
  }
]